
_build/debug/NRF51_BOARD/FruityMesh.out:     file format elf32-littlearm


Disassembly of section .text:

0001b408 <_init>:
   1b408:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1b40a:	46c0      	nop			; (mov r8, r8)
   1b40c:	bcf8      	pop	{r3, r4, r5, r6, r7}
   1b40e:	bc08      	pop	{r3}
   1b410:	469e      	mov	lr, r3
   1b412:	4770      	bx	lr

0001b414 <_fini>:
   1b414:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1b416:	46c0      	nop			; (mov r8, r8)
   1b418:	bcf8      	pop	{r3, r4, r5, r6, r7}
   1b41a:	bc08      	pop	{r3}
   1b41c:	469e      	mov	lr, r3
   1b41e:	4770      	bx	lr

0001b420 <__do_global_dtors_aux>:
   1b420:	b510      	push	{r4, lr}
   1b422:	4c06      	ldr	r4, [pc, #24]	; (1b43c <__do_global_dtors_aux+0x1c>)
   1b424:	7823      	ldrb	r3, [r4, #0]
   1b426:	2b00      	cmp	r3, #0
   1b428:	d107      	bne.n	1b43a <__do_global_dtors_aux+0x1a>
   1b42a:	4b05      	ldr	r3, [pc, #20]	; (1b440 <__do_global_dtors_aux+0x20>)
   1b42c:	2b00      	cmp	r3, #0
   1b42e:	d002      	beq.n	1b436 <__do_global_dtors_aux+0x16>
   1b430:	4804      	ldr	r0, [pc, #16]	; (1b444 <__do_global_dtors_aux+0x24>)
   1b432:	e000      	b.n	1b436 <__do_global_dtors_aux+0x16>
   1b434:	bf00      	nop
   1b436:	2301      	movs	r3, #1
   1b438:	7023      	strb	r3, [r4, #0]
   1b43a:	bd10      	pop	{r4, pc}
   1b43c:	20002ef8 	.word	0x20002ef8
   1b440:	00000000 	.word	0x00000000
   1b444:	00022f68 	.word	0x00022f68

0001b448 <frame_dummy>:
   1b448:	b508      	push	{r3, lr}
   1b44a:	4b08      	ldr	r3, [pc, #32]	; (1b46c <frame_dummy+0x24>)
   1b44c:	2b00      	cmp	r3, #0
   1b44e:	d003      	beq.n	1b458 <frame_dummy+0x10>
   1b450:	4807      	ldr	r0, [pc, #28]	; (1b470 <frame_dummy+0x28>)
   1b452:	4908      	ldr	r1, [pc, #32]	; (1b474 <frame_dummy+0x2c>)
   1b454:	e000      	b.n	1b458 <frame_dummy+0x10>
   1b456:	bf00      	nop
   1b458:	4807      	ldr	r0, [pc, #28]	; (1b478 <frame_dummy+0x30>)
   1b45a:	6803      	ldr	r3, [r0, #0]
   1b45c:	2b00      	cmp	r3, #0
   1b45e:	d100      	bne.n	1b462 <frame_dummy+0x1a>
   1b460:	bd08      	pop	{r3, pc}
   1b462:	4b06      	ldr	r3, [pc, #24]	; (1b47c <frame_dummy+0x34>)
   1b464:	2b00      	cmp	r3, #0
   1b466:	d0fb      	beq.n	1b460 <frame_dummy+0x18>
   1b468:	4798      	blx	r3
   1b46a:	e7f9      	b.n	1b460 <frame_dummy+0x18>
   1b46c:	00000000 	.word	0x00000000
   1b470:	00022f68 	.word	0x00022f68
   1b474:	20002efc 	.word	0x20002efc
   1b478:	20002ef8 	.word	0x20002ef8
   1b47c:	00000000 	.word	0x00000000

0001b480 <_mainCRTStartup>:
   1b480:	4b16      	ldr	r3, [pc, #88]	; (1b4dc <_mainCRTStartup+0x5c>)
   1b482:	2b00      	cmp	r3, #0
   1b484:	d100      	bne.n	1b488 <_mainCRTStartup+0x8>
   1b486:	4b14      	ldr	r3, [pc, #80]	; (1b4d8 <_mainCRTStartup+0x58>)
   1b488:	469d      	mov	sp, r3
   1b48a:	2240      	movs	r2, #64	; 0x40
   1b48c:	0292      	lsls	r2, r2, #10
   1b48e:	1a9a      	subs	r2, r3, r2
   1b490:	4692      	mov	sl, r2
   1b492:	2100      	movs	r1, #0
   1b494:	468b      	mov	fp, r1
   1b496:	460f      	mov	r7, r1
   1b498:	4813      	ldr	r0, [pc, #76]	; (1b4e8 <_mainCRTStartup+0x68>)
   1b49a:	4a14      	ldr	r2, [pc, #80]	; (1b4ec <_mainCRTStartup+0x6c>)
   1b49c:	1a12      	subs	r2, r2, r0
   1b49e:	f006 f8d6 	bl	2164e <memset>
   1b4a2:	4b0f      	ldr	r3, [pc, #60]	; (1b4e0 <_mainCRTStartup+0x60>)
   1b4a4:	2b00      	cmp	r3, #0
   1b4a6:	d000      	beq.n	1b4aa <_mainCRTStartup+0x2a>
   1b4a8:	4798      	blx	r3
   1b4aa:	4b0e      	ldr	r3, [pc, #56]	; (1b4e4 <_mainCRTStartup+0x64>)
   1b4ac:	2b00      	cmp	r3, #0
   1b4ae:	d000      	beq.n	1b4b2 <_mainCRTStartup+0x32>
   1b4b0:	4798      	blx	r3
   1b4b2:	2000      	movs	r0, #0
   1b4b4:	2100      	movs	r1, #0
   1b4b6:	0004      	movs	r4, r0
   1b4b8:	000d      	movs	r5, r1
   1b4ba:	480d      	ldr	r0, [pc, #52]	; (1b4f0 <_mainCRTStartup+0x70>)
   1b4bc:	2800      	cmp	r0, #0
   1b4be:	d002      	beq.n	1b4c6 <_mainCRTStartup+0x46>
   1b4c0:	480c      	ldr	r0, [pc, #48]	; (1b4f4 <_mainCRTStartup+0x74>)
   1b4c2:	f006 f834 	bl	2152e <atexit>
   1b4c6:	f006 f851 	bl	2156c <__libc_init_array>
   1b4ca:	0020      	movs	r0, r4
   1b4cc:	0029      	movs	r1, r5
   1b4ce:	f000 f813 	bl	1b4f8 <main>
   1b4d2:	f006 f835 	bl	21540 <exit>
   1b4d6:	46c0      	nop			; (mov r8, r8)
   1b4d8:	00080000 	.word	0x00080000
   1b4dc:	20004000 	.word	0x20004000
	...
   1b4e8:	20002ef8 	.word	0x20002ef8
   1b4ec:	200037dc 	.word	0x200037dc
   1b4f0:	0002152f 	.word	0x0002152f
   1b4f4:	00000000 	.word	0x00000000

0001b4f8 <main>:
	nrf_clock_lf_cfg_t clock_lf_cfg;

	clock_lf_cfg.source = NRF_CLOCK_LF_SRC_XTAL;
	clock_lf_cfg.rc_ctiv = 0;
	clock_lf_cfg.rc_temp_ctiv = 0;
	clock_lf_cfg.xtal_accuracy = NRF_CLOCK_LF_XTAL_ACCURACY_100_PPM;
   1b4f8:	2203      	movs	r2, #3
    // Initialize the SoftDevice handler with the low frequency clock source
	//And a reference to the previously allocated buffer
	//No event handler is given because the event handling is done in the main loop
	nrf_clock_lf_cfg_t clock_lf_cfg;

	clock_lf_cfg.source = NRF_CLOCK_LF_SRC_XTAL;
   1b4fa:	2301      	movs	r3, #1

//Put the firmware version in a special section right after the initialization vector
uint32_t app_version __attribute__((section(".Version"), used)) = FM_VERSION;

int main(void)
{
   1b4fc:	b5f0      	push	{r4, r5, r6, r7, lr}
   1b4fe:	b091      	sub	sp, #68	; 0x44
    // Initialize the SoftDevice handler with the low frequency clock source
	//And a reference to the previously allocated buffer
	//No event handler is given because the event handling is done in the main loop
	nrf_clock_lf_cfg_t clock_lf_cfg;

	clock_lf_cfg.source = NRF_CLOCK_LF_SRC_XTAL;
   1b500:	a809      	add	r0, sp, #36	; 0x24
    if (!is_word_aligned(p_ble_evt_buffer))
    {
        return NRF_ERROR_INVALID_PARAM;
    }

    mp_ble_evt_buffer     = (uint8_t *)p_ble_evt_buffer;
   1b502:	49d7      	ldr	r1, [pc, #860]	; (1b860 <main+0x368>)
	clock_lf_cfg.rc_ctiv = 0;
	clock_lf_cfg.rc_temp_ctiv = 0;
	clock_lf_cfg.xtal_accuracy = NRF_CLOCK_LF_XTAL_ACCURACY_100_PPM;
   1b504:	70c2      	strb	r2, [r0, #3]
   1b506:	4ad7      	ldr	r2, [pc, #860]	; (1b864 <main+0x36c>)
    // Initialize the SoftDevice handler with the low frequency clock source
	//And a reference to the previously allocated buffer
	//No event handler is given because the event handling is done in the main loop
	nrf_clock_lf_cfg_t clock_lf_cfg;

	clock_lf_cfg.source = NRF_CLOCK_LF_SRC_XTAL;
   1b508:	7003      	strb	r3, [r0, #0]
   1b50a:	6011      	str	r1, [r2, #0]
    m_ble_evt_buffer_size = ble_evt_buffer_size;
   1b50c:	2148      	movs	r1, #72	; 0x48
	clock_lf_cfg.rc_ctiv = 0;
   1b50e:	2300      	movs	r3, #0
   1b510:	4ad5      	ldr	r2, [pc, #852]	; (1b868 <main+0x370>)
   1b512:	7043      	strb	r3, [r0, #1]
   1b514:	8011      	strh	r1, [r2, #0]
    // is not required.
    UNUSED_PARAMETER(p_ble_evt_buffer);
    UNUSED_PARAMETER(ble_evt_buffer_size);
#endif

    m_evt_schedule_func = evt_schedule_func;
   1b516:	4ad5      	ldr	r2, [pc, #852]	; (1b86c <main+0x374>)

    // Initialize SoftDevice.
#if defined(S212) || defined(S332)
    err_code = sd_softdevice_enable(p_clock_lf_cfg, softdevice_fault_handler, ANT_LICENSE_KEY);
#else
    err_code = sd_softdevice_enable(p_clock_lf_cfg, softdevice_fault_handler);
   1b518:	49d5      	ldr	r1, [pc, #852]	; (1b870 <main+0x378>)
	clock_lf_cfg.rc_temp_ctiv = 0;
   1b51a:	7083      	strb	r3, [r0, #2]
    // is not required.
    UNUSED_PARAMETER(p_ble_evt_buffer);
    UNUSED_PARAMETER(ble_evt_buffer_size);
#endif

    m_evt_schedule_func = evt_schedule_func;
   1b51c:	6013      	str	r3, [r2, #0]

    // Initialize SoftDevice.
#if defined(S212) || defined(S332)
    err_code = sd_softdevice_enable(p_clock_lf_cfg, softdevice_fault_handler, ANT_LICENSE_KEY);
#else
    err_code = sd_softdevice_enable(p_clock_lf_cfg, softdevice_fault_handler);
   1b51e:	f000 fde1 	bl	1c0e4 <sd_softdevice_enable.lto_priv.124>
   1b522:	1e04      	subs	r4, r0, #0
#endif
    if (err_code != NRF_SUCCESS)
   1b524:	d001      	beq.n	1b52a <main+0x32>
   1b526:	f000 fcd6 	bl	1bed6 <main+0x9de>
    {
        return err_code;
    }

    m_softdevice_enabled = true;
   1b52a:	2201      	movs	r2, #1
   1b52c:	4bd1      	ldr	r3, [pc, #836]	; (1b874 <main+0x37c>)
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   1b52e:	4dd2      	ldr	r5, [pc, #840]	; (1b878 <main+0x380>)
   1b530:	701a      	strb	r2, [r3, #0]
   1b532:	2380      	movs	r3, #128	; 0x80
   1b534:	03db      	lsls	r3, r3, #15
   1b536:	602b      	str	r3, [r5, #0]

uint32_t softdevice_sys_evt_handler_set(sys_evt_handler_t sys_evt_handler)
{
    VERIFY_PARAM_NOT_NULL(sys_evt_handler);

    m_sys_evt_handler = sys_evt_handler;
   1b538:	4ad0      	ldr	r2, [pc, #832]	; (1b87c <main+0x384>)
   1b53a:	4bd1      	ldr	r3, [pc, #836]	; (1b880 <main+0x388>)
    err = softdevice_sys_evt_handler_set(sys_evt_dispatch);
    APP_ERROR_CHECK(err);

    //Now we will enable the Softdevice. RAM usage depends on the values chosen
    ble_enable_params_t params;
    memset(&params, 0x00, sizeof(params));
   1b53c:	ae0b      	add	r6, sp, #44	; 0x2c
   1b53e:	1c21      	adds	r1, r4, #0
   1b540:	601a      	str	r2, [r3, #0]
   1b542:	1c30      	adds	r0, r6, #0
   1b544:	2214      	movs	r2, #20
   1b546:	f006 f882 	bl	2164e <memset>

    params.common_enable_params.vs_uuid_count = 5; //set the number of Vendor Specific UUIDs to 5
   1b54a:	2305      	movs	r3, #5
   1b54c:	8033      	strh	r3, [r6, #0]

    //TODO: configure Bandwidth
    //params.common_enable_params.p_conn_bw_counts->

    params.gap_enable_params.periph_conn_count = Config->meshMaxInConnections; //Number of connections as Peripheral
   1b54e:	f005 fc6b 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1b552:	3033      	adds	r0, #51	; 0x33
   1b554:	7803      	ldrb	r3, [r0, #0]
   1b556:	7233      	strb	r3, [r6, #8]
    params.gap_enable_params.central_conn_count = Config->meshMaxOutConnections; //Number of connections as Central
   1b558:	f005 fc66 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1b55c:	3034      	adds	r0, #52	; 0x34
   1b55e:	7803      	ldrb	r3, [r0, #0]
    params.gap_enable_params.central_sec_count = 1; //this application only needs to be able to pair in one central link at a time

    params.gatts_enable_params.service_changed = IS_SRVC_CHANGED_CHARACT_PRESENT; //we require the Service Changed characteristic
   1b560:	2201      	movs	r2, #1

    //TODO: configure Bandwidth
    //params.common_enable_params.p_conn_bw_counts->

    params.gap_enable_params.periph_conn_count = Config->meshMaxInConnections; //Number of connections as Peripheral
    params.gap_enable_params.central_conn_count = Config->meshMaxOutConnections; //Number of connections as Central
   1b562:	7273      	strb	r3, [r6, #9]
    params.gap_enable_params.central_sec_count = 1; //this application only needs to be able to pair in one central link at a time
   1b564:	2301      	movs	r3, #1
   1b566:	72b3      	strb	r3, [r6, #10]

    params.gatts_enable_params.service_changed = IS_SRVC_CHANGED_CHARACT_PRESENT; //we require the Service Changed characteristic
   1b568:	7b33      	ldrb	r3, [r6, #12]

    //The base ram address is gathered from the linker
    u32 app_ram_base = (u32)__application_ram_start_address;
    /* enable the BLE Stack */
//    logt("ERROR", "Ram base at 0x%x", app_ram_base);
    err = sd_ble_enable(&params, &app_ram_base);
   1b56a:	a90a      	add	r1, sp, #40	; 0x28

    params.gap_enable_params.periph_conn_count = Config->meshMaxInConnections; //Number of connections as Peripheral
    params.gap_enable_params.central_conn_count = Config->meshMaxOutConnections; //Number of connections as Central
    params.gap_enable_params.central_sec_count = 1; //this application only needs to be able to pair in one central link at a time

    params.gatts_enable_params.service_changed = IS_SRVC_CHANGED_CHARACT_PRESENT; //we require the Service Changed characteristic
   1b56c:	4313      	orrs	r3, r2
   1b56e:	7333      	strb	r3, [r6, #12]
    params.gatts_enable_params.attr_tab_size = BLE_GATTS_ATTR_TAB_SIZE_DEFAULT; //the default Attribute Table size is appropriate for our application

    //The base ram address is gathered from the linker
    u32 app_ram_base = (u32)__application_ram_start_address;
   1b570:	4bc4      	ldr	r3, [pc, #784]	; (1b884 <main+0x38c>)
    /* enable the BLE Stack */
//    logt("ERROR", "Ram base at 0x%x", app_ram_base);
    err = sd_ble_enable(&params, &app_ram_base);
   1b572:	1c30      	adds	r0, r6, #0

    params.gatts_enable_params.service_changed = IS_SRVC_CHANGED_CHARACT_PRESENT; //we require the Service Changed characteristic
    params.gatts_enable_params.attr_tab_size = BLE_GATTS_ATTR_TAB_SIZE_DEFAULT; //the default Attribute Table size is appropriate for our application

    //The base ram address is gathered from the linker
    u32 app_ram_base = (u32)__application_ram_start_address;
   1b574:	930a      	str	r3, [sp, #40]	; 0x28
    params.gap_enable_params.periph_conn_count = Config->meshMaxInConnections; //Number of connections as Peripheral
    params.gap_enable_params.central_conn_count = Config->meshMaxOutConnections; //Number of connections as Central
    params.gap_enable_params.central_sec_count = 1; //this application only needs to be able to pair in one central link at a time

    params.gatts_enable_params.service_changed = IS_SRVC_CHANGED_CHARACT_PRESENT; //we require the Service Changed characteristic
    params.gatts_enable_params.attr_tab_size = BLE_GATTS_ATTR_TAB_SIZE_DEFAULT; //the default Attribute Table size is appropriate for our application
   1b576:	6134      	str	r4, [r6, #16]

    //The base ram address is gathered from the linker
    u32 app_ram_base = (u32)__application_ram_start_address;
    /* enable the BLE Stack */
//    logt("ERROR", "Ram base at 0x%x", app_ram_base);
    err = sd_ble_enable(&params, &app_ram_base);
   1b578:	f005 fc44 	bl	20e04 <sd_ble_enable.lto_priv.123>
    if(err == NRF_SUCCESS){
   1b57c:	2204      	movs	r2, #4
   1b57e:	1c03      	adds	r3, r0, #0
   1b580:	9503      	str	r5, [sp, #12]
   1b582:	4393      	bics	r3, r2
		}
	} else if(err == NRF_ERROR_NO_MEM) {
		/* Not enough memory for the SoftDevice. Use output value in linker script */
//		logt("ERROR", "Fatal: Not enough memory for the selected configuration. Required:0x%x", app_ram_base);
    } else {
    	APP_ERROR_CHECK(err); //OK
   1b584:	2116      	movs	r1, #22
    //The base ram address is gathered from the linker
    u32 app_ram_base = (u32)__application_ram_start_address;
    /* enable the BLE Stack */
//    logt("ERROR", "Ram base at 0x%x", app_ram_base);
    err = sd_ble_enable(&params, &app_ram_base);
    if(err == NRF_SUCCESS){
   1b586:	2b00      	cmp	r3, #0
   1b588:	d001      	beq.n	1b58e <main+0x96>
   1b58a:	f000 fcab 	bl	1bee4 <main+0x9ec>
    } else {
    	APP_ERROR_CHECK(err); //OK
    }

    //Enable DC/DC (needs external LC filter, cmp. nrf51 reference manual page 43)
	err = sd_power_dcdc_mode_set(NRF_POWER_DCDC_ENABLE);
   1b58e:	2001      	movs	r0, #1
   1b590:	f005 fc32 	bl	20df8 <sd_power_dcdc_mode_set.lto_priv.122>
	APP_ERROR_CHECK(err); //OK
   1b594:	2800      	cmp	r0, #0
   1b596:	d004      	beq.n	1b5a2 <main+0xaa>
   1b598:	218d      	movs	r1, #141	; 0x8d
   1b59a:	0049      	lsls	r1, r1, #1
   1b59c:	4aba      	ldr	r2, [pc, #744]	; (1b888 <main+0x390>)
   1b59e:	f001 ff31 	bl	1d404 <app_error_handler>

	//Set power mode
	err = sd_power_mode_set(NRF_POWER_MODE_LOWPWR);
   1b5a2:	2001      	movs	r0, #1
   1b5a4:	f005 fc2a 	bl	20dfc <sd_power_mode_set.lto_priv.121>
	APP_ERROR_CHECK(err); //OK
   1b5a8:	218f      	movs	r1, #143	; 0x8f
   1b5aa:	2800      	cmp	r0, #0
   1b5ac:	d1f5      	bne.n	1b59a <main+0xa2>

	//Set preferred TX power
	err = sd_ble_gap_tx_power_set(Config->radioTransmitPower);
   1b5ae:	f005 fc3b 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1b5b2:	3080      	adds	r0, #128	; 0x80
   1b5b4:	7800      	ldrb	r0, [r0, #0]
   1b5b6:	b240      	sxtb	r0, r0
   1b5b8:	f005 fc26 	bl	20e08 <sd_ble_gap_tx_power_set.lto_priv.120>
   1b5bc:	1e05      	subs	r5, r0, #0
	APP_ERROR_CHECK(err); //OK
   1b5be:	d001      	beq.n	1b5c4 <main+0xcc>
   1b5c0:	2191      	movs	r1, #145	; 0x91
   1b5c2:	e7ea      	b.n	1b59a <main+0xa2>

	//Initialialize the SoftDevice and the BLE stack
	bleInit();

	//Initialize the storage class
	Storage::getInstance();
   1b5c4:	f005 fb4e 	bl	20c64 <_ZN7Storage11getInstanceEv>
bool NewStorage::dataBufferInUse = false;


void NewStorage::Init()
{
	Logger::getInstance().enableTag("NEWSTORAGE");
   1b5c8:	f001 fe66 	bl	1d298 <_ZN6Logger11getInstanceEv>
   1b5cc:	49af      	ldr	r1, [pc, #700]	; (1b88c <main+0x394>)
   1b5ce:	aa0a      	add	r2, sp, #40	; 0x28
   1b5d0:	1c30      	adds	r0, r6, #0
   1b5d2:	f005 fecb 	bl	2136c <_ZNSsC1EPKcRKSaIcE>
   1b5d6:	1c30      	adds	r0, r6, #0
   1b5d8:	f005 fe98 	bl	2130c <_ZNSsD1Ev>

	//Initialize queue for queueing store and load tasks
	taskQueue = new SimpleQueue(taskBuffer, NEW_STORAGE_TASK_QUEUE_LENGTH*sizeof(NewStorageTaskItem));
   1b5dc:	2018      	movs	r0, #24
   1b5de:	f005 fe1f 	bl	21220 <_Znwj>
//TODO: This queue might hardfault because of unaligned memory access, must be fixed

SimpleQueue::SimpleQueue(u8* buffer, u32 bufferLength)
{
    this->_numElements = 0;
    this->bufferStart = buffer;
   1b5e2:	4bab      	ldr	r3, [pc, #684]	; (1b890 <main+0x398>)

	//TODO: Could implement dataBuffer as circular buffer to support multiple queued writes at once
	memset(dataBuffer, 0, NEW_STORAGE_DATA_BUFFER_SIZE);
   1b5e4:	1c29      	adds	r1, r5, #0
    this->bufferEnd = buffer + bufferLength;
   1b5e6:	1c1a      	adds	r2, r3, #0
   1b5e8:	32be      	adds	r2, #190	; 0xbe
   1b5ea:	6042      	str	r2, [r0, #4]
    this->bufferLength = bufferLength;
   1b5ec:	22be      	movs	r2, #190	; 0xbe
//TODO: This queue might hardfault because of unaligned memory access, must be fixed

SimpleQueue::SimpleQueue(u8* buffer, u32 bufferLength)
{
    this->_numElements = 0;
    this->bufferStart = buffer;
   1b5ee:	6003      	str	r3, [r0, #0]
    this->bufferEnd = buffer + bufferLength;
    this->bufferLength = bufferLength;

    this->readPointer = this->bufferStart;
   1b5f0:	60c3      	str	r3, [r0, #12]
    this->writePointer = this->bufferStart;
   1b5f2:	6103      	str	r3, [r0, #16]


    ((u32*)writePointer)[0] = 0;
   1b5f4:	701d      	strb	r5, [r3, #0]
   1b5f6:	705d      	strb	r5, [r3, #1]
   1b5f8:	709d      	strb	r5, [r3, #2]
   1b5fa:	70dd      	strb	r5, [r3, #3]
void NewStorage::Init()
{
	Logger::getInstance().enableTag("NEWSTORAGE");

	//Initialize queue for queueing store and load tasks
	taskQueue = new SimpleQueue(taskBuffer, NEW_STORAGE_TASK_QUEUE_LENGTH*sizeof(NewStorageTaskItem));
   1b5fc:	4ba5      	ldr	r3, [pc, #660]	; (1b894 <main+0x39c>)
SimpleQueue::SimpleQueue(u8* buffer, u32 bufferLength)
{
    this->_numElements = 0;
    this->bufferStart = buffer;
    this->bufferEnd = buffer + bufferLength;
    this->bufferLength = bufferLength;
   1b5fe:	8102      	strh	r2, [r0, #8]
   1b600:	6018      	str	r0, [r3, #0]

//TODO: This queue might hardfault because of unaligned memory access, must be fixed

SimpleQueue::SimpleQueue(u8* buffer, u32 bufferLength)
{
    this->_numElements = 0;
   1b602:	8285      	strh	r5, [r0, #20]

	//TODO: Could implement dataBuffer as circular buffer to support multiple queued writes at once
	memset(dataBuffer, 0, NEW_STORAGE_DATA_BUFFER_SIZE);
   1b604:	3a7e      	subs	r2, #126	; 0x7e
   1b606:	48a4      	ldr	r0, [pc, #656]	; (1b898 <main+0x3a0>)
   1b608:	f006 f821 	bl	2164e <memset>

	retryCount = NEW_STORAGE_RETRY_COUNT;
   1b60c:	2203      	movs	r2, #3
   1b60e:	4ba3      	ldr	r3, [pc, #652]	; (1b89c <main+0x3a4>)
   1b610:	701a      	strb	r2, [r3, #0]

	//Initialize the new storage
	NewStorage::Init();

	//Init the magic
	node = new Node(Config->meshNetworkIdentifier);
   1b612:	f005 fc09 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1b616:	2088      	movs	r0, #136	; 0x88
   1b618:	f005 fe02 	bl	21220 <_Znwj>
   1b61c:	1c04      	adds	r4, r0, #0
#define MAX_JOIN_ME_PACKET_AGE_DS (15 * 10)

Node* Node::instance;
ConnectionManager* Node::cm;

Node::Node(networkID networkId)
   1b61e:	4ba0      	ldr	r3, [pc, #640]	; (1b8a0 <main+0x3a8>)
   1b620:	1c29      	adds	r1, r5, #0
   1b622:	6003      	str	r3, [r0, #0]
   1b624:	4b9f      	ldr	r3, [pc, #636]	; (1b8a4 <main+0x3ac>)
   1b626:	7305      	strb	r5, [r0, #12]
   1b628:	6043      	str	r3, [r0, #4]
   1b62a:	4b9f      	ldr	r3, [pc, #636]	; (1b8a8 <main+0x3b0>)
   1b62c:	2214      	movs	r2, #20
   1b62e:	6083      	str	r3, [r0, #8]
   1b630:	3040      	adds	r0, #64	; 0x40
   1b632:	f006 f80c 	bl	2164e <memset>
{
	//Initialize variables
	instance = this;
   1b636:	4b9d      	ldr	r3, [pc, #628]	; (1b8ac <main+0x3b4>)

	this->clusterId = 0;
	this->clusterSize = 1;
   1b638:	2201      	movs	r2, #1
ConnectionManager* Node::cm;

Node::Node(networkID networkId)
{
	//Initialize variables
	instance = this;
   1b63a:	601c      	str	r4, [r3, #0]

	this->clusterId = 0;
	this->clusterSize = 1;
   1b63c:	1c23      	adds	r3, r4, #0
   1b63e:	3378      	adds	r3, #120	; 0x78
Node::Node(networkID networkId)
{
	//Initialize variables
	instance = this;

	this->clusterId = 0;
   1b640:	67e5      	str	r5, [r4, #124]	; 0x7c
	this->clusterSize = 1;

	this->currentAckId = 0;

	this->noNodesFoundCounter = 0;
   1b642:	3b02      	subs	r3, #2
{
	//Initialize variables
	instance = this;

	this->clusterId = 0;
	this->clusterSize = 1;
   1b644:	805a      	strh	r2, [r3, #2]

	this->currentAckId = 0;
   1b646:	6165      	str	r5, [r4, #20]

	this->noNodesFoundCounter = 0;
	this->passsedTimeSinceLastTimerHandlerDs = 0;
   1b648:	3b0a      	subs	r3, #10
	this->clusterId = 0;
	this->clusterSize = 1;

	this->currentAckId = 0;

	this->noNodesFoundCounter = 0;
   1b64a:	729d      	strb	r5, [r3, #10]
	this->passsedTimeSinceLastTimerHandlerDs = 0;

	this->outputRawData = false;
   1b64c:	761d      	strb	r5, [r3, #24]
	this->clusterSize = 1;

	this->currentAckId = 0;

	this->noNodesFoundCounter = 0;
	this->passsedTimeSinceLastTimerHandlerDs = 0;
   1b64e:	801d      	strh	r5, [r3, #0]

	this->outputRawData = false;
   1b650:	1d27      	adds	r7, r4, #4

	this->radioActiveCount = 0;

	globalTimeSec = 0;
	globalTimeRemainderTicks = 0;
   1b652:	3b0c      	subs	r3, #12
	this->noNodesFoundCounter = 0;
	this->passsedTimeSinceLastTimerHandlerDs = 0;

	this->outputRawData = false;

	this->radioActiveCount = 0;
   1b654:	67fd      	str	r5, [r7, #124]	; 0x7c
	globalTimeRemainderTicks = 0;
	previousRtcTicks = 0;

	//Set the current state and its timeout
	currentStateTimeoutDs = 0;
	currentDiscoveryState = discoveryState::BOOTUP;
   1b656:	3b0c      	subs	r3, #12

	this->outputRawData = false;

	this->radioActiveCount = 0;

	globalTimeSec = 0;
   1b658:	65a5      	str	r5, [r4, #88]	; 0x58
	globalTimeRemainderTicks = 0;
   1b65a:	819d      	strh	r5, [r3, #12]
	previousRtcTicks = 0;
   1b65c:	65e5      	str	r5, [r4, #92]	; 0x5c

	//Set the current state and its timeout
	currentStateTimeoutDs = 0;
   1b65e:	66a5      	str	r5, [r4, #104]	; 0x68
	currentDiscoveryState = discoveryState::BOOTUP;
   1b660:	701a      	strb	r2, [r3, #0]
	nextDiscoveryState = discoveryState::INVALID_STATE;
   1b662:	705d      	strb	r5, [r3, #1]
	this->appTimerDs = 0;
	this->lastDecisionTimeDs = 0;
	this->appTimerRandomOffsetDs = 0;
   1b664:	3320      	adds	r3, #32

	//Set the current state and its timeout
	currentStateTimeoutDs = 0;
	currentDiscoveryState = discoveryState::BOOTUP;
	nextDiscoveryState = discoveryState::INVALID_STATE;
	this->appTimerDs = 0;
   1b666:	6665      	str	r5, [r4, #100]	; 0x64
	this->lastDecisionTimeDs = 0;
   1b668:	6725      	str	r5, [r4, #112]	; 0x70
	this->appTimerRandomOffsetDs = 0;
   1b66a:	801d      	strh	r5, [r3, #0]

	initializedByGateway = false;
   1b66c:	745d      	strb	r5, [r3, #17]
	//Register terminal listener
	Terminal::AddTerminalCommandListener(this);


	//Receive ConnectionManager events
	cm = ConnectionManager::getInstance();
   1b66e:	f002 f82f 	bl	1d6d0 <_ZN17ConnectionManager11getInstanceEv>
   1b672:	4b8f      	ldr	r3, [pc, #572]	; (1b8b0 <main+0x3b8>)

}

void ConnectionManager::setConnectionManagerCallback(ConnectionManagerCallback* cb)
{
	connectionManagerCallback = cb;
   1b674:	6087      	str	r7, [r0, #8]
   1b676:	6018      	str	r0, [r3, #0]
#endif
#ifdef ACTIVATE_DFU_MODULE
	activeModules[1] = new DFUModule(moduleID::DFU_MODULE_ID, this, cm, "dfu", 2);
#endif
#ifdef ACTIVATE_STATUS_REPORTER_MODULE
	activeModules[2] = new StatusReporterModule(moduleID::STATUS_REPORTER_MODULE_ID, this, cm, "status", 3);
   1b678:	20dc      	movs	r0, #220	; 0xdc
   1b67a:	f005 fdd1 	bl	21220 <_Znwj>
#include <app_error.h>
#include <stdlib.h>
}

StatusReporterModule::StatusReporterModule(u8 moduleId, Node* node, ConnectionManager* cm, const char* name, u16 storageSlot)
	: Module(moduleId, node, cm, name, storageSlot)
   1b67e:	4b8d      	ldr	r3, [pc, #564]	; (1b8b4 <main+0x3bc>)
   1b680:	1c07      	adds	r7, r0, #0
   1b682:	9300      	str	r3, [sp, #0]
   1b684:	2303      	movs	r3, #3
   1b686:	1c19      	adds	r1, r3, #0
   1b688:	9301      	str	r3, [sp, #4]
   1b68a:	4b89      	ldr	r3, [pc, #548]	; (1b8b0 <main+0x3b8>)
   1b68c:	1c22      	adds	r2, r4, #0
   1b68e:	681b      	ldr	r3, [r3, #0]
   1b690:	f005 fa98 	bl	20bc4 <_ZN6ModuleC2EhP4NodeP17ConnectionManagerPKct>
   1b694:	4b88      	ldr	r3, [pc, #544]	; (1b8b8 <main+0x3c0>)
   1b696:	603b      	str	r3, [r7, #0]
   1b698:	4b88      	ldr	r3, [pc, #544]	; (1b8bc <main+0x3c4>)
   1b69a:	607b      	str	r3, [r7, #4]
{
	//Register callbacks n' stuff
	Logger::getInstance().enableTag("STATUSMOD");
   1b69c:	f001 fdfc 	bl	1d298 <_ZN6Logger11getInstanceEv>
   1b6a0:	4987      	ldr	r1, [pc, #540]	; (1b8c0 <main+0x3c8>)
   1b6a2:	aa0a      	add	r2, sp, #40	; 0x28
   1b6a4:	1c30      	adds	r0, r6, #0
   1b6a6:	f005 fe61 	bl	2136c <_ZNSsC1EPKcRKSaIcE>
   1b6aa:	1c30      	adds	r0, r6, #0
   1b6ac:	f005 fe2e 	bl	2130c <_ZNSsD1Ev>

	//Save configuration to base class variables
	//sizeof configuration must be a multiple of 4 bytes
	configurationPointer = &configuration;
   1b6b0:	1c3b      	adds	r3, r7, #0
   1b6b2:	3328      	adds	r3, #40	; 0x28
   1b6b4:	623b      	str	r3, [r7, #32]
	configurationLength = sizeof(StatusReporterModuleConfiguration);
   1b6b6:	2312      	movs	r3, #18

	//Start module configuration loading
	LoadModuleConfiguration();
   1b6b8:	1c38      	adds	r0, r7, #0
	Logger::getInstance().enableTag("STATUSMOD");

	//Save configuration to base class variables
	//sizeof configuration must be a multiple of 4 bytes
	configurationPointer = &configuration;
	configurationLength = sizeof(StatusReporterModuleConfiguration);
   1b6ba:	84bb      	strh	r3, [r7, #36]	; 0x24

	//Start module configuration loading
	LoadModuleConfiguration();
   1b6bc:	f005 f896 	bl	207ec <_ZN6Module23LoadModuleConfigurationEv>
   1b6c0:	64a7      	str	r7, [r4, #72]	; 0x48
#endif
#ifdef ACTIVATE_ADVERTISING_MODULE
	activeModules[3] = new AdvertisingModule(moduleID::ADVERTISING_MODULE_ID, this, cm, "adv", 4);
   1b6c2:	2060      	movs	r0, #96	; 0x60
   1b6c4:	f005 fdac 	bl	21220 <_Znwj>
TODO: Who's responsible for restoring the mesh-advertising packet? This module or the Node?
 * */


AdvertisingModule::AdvertisingModule(u8 moduleId, Node* node, ConnectionManager* cm, const char* name, u16 storageSlot)
	: Module(moduleId, node, cm, name, storageSlot)
   1b6c8:	4b7e      	ldr	r3, [pc, #504]	; (1b8c4 <main+0x3cc>)
   1b6ca:	1c07      	adds	r7, r0, #0
   1b6cc:	9300      	str	r3, [sp, #0]
   1b6ce:	2304      	movs	r3, #4
   1b6d0:	9301      	str	r3, [sp, #4]
   1b6d2:	4b77      	ldr	r3, [pc, #476]	; (1b8b0 <main+0x3b8>)
   1b6d4:	2101      	movs	r1, #1
   1b6d6:	1c22      	adds	r2, r4, #0
   1b6d8:	681b      	ldr	r3, [r3, #0]
   1b6da:	f005 fa73 	bl	20bc4 <_ZN6ModuleC2EhP4NodeP17ConnectionManagerPKct>
   1b6de:	4b7a      	ldr	r3, [pc, #488]	; (1b8c8 <main+0x3d0>)
   1b6e0:	2201      	movs	r2, #1
   1b6e2:	603b      	str	r3, [r7, #0]
   1b6e4:	4b79      	ldr	r3, [pc, #484]	; (1b8cc <main+0x3d4>)
   1b6e6:	62bd      	str	r5, [r7, #40]	; 0x28
   1b6e8:	607b      	str	r3, [r7, #4]
   1b6ea:	1c3b      	adds	r3, r7, #0
   1b6ec:	335c      	adds	r3, #92	; 0x5c
   1b6ee:	801a      	strh	r2, [r3, #0]
{
	//Register callbacks n' stuff

	//Save configuration to base class variables
	//sizeof configuration must be a multiple of 4 bytes
	configurationPointer = &configuration;
   1b6f0:	3b30      	subs	r3, #48	; 0x30
   1b6f2:	623b      	str	r3, [r7, #32]
	configurationLength = sizeof(AdvertisingModuleConfiguration);
   1b6f4:	232d      	movs	r3, #45	; 0x2d

	//Start module configuration loading
	LoadModuleConfiguration();
   1b6f6:	1c38      	adds	r0, r7, #0
	//Register callbacks n' stuff

	//Save configuration to base class variables
	//sizeof configuration must be a multiple of 4 bytes
	configurationPointer = &configuration;
	configurationLength = sizeof(AdvertisingModuleConfiguration);
   1b6f8:	84bb      	strh	r3, [r7, #36]	; 0x24

	//Start module configuration loading
	LoadModuleConfiguration();
   1b6fa:	f005 f877 	bl	207ec <_ZN6Module23LoadModuleConfigurationEv>
   1b6fe:	64e7      	str	r7, [r4, #76]	; 0x4c
#endif
#ifdef ACTIVATE_SCANNING_MODULE
	activeModules[4] = new ScanningModule(moduleID::SCANNING_MODULE_ID, this, cm, "scan", 5);
   1b700:	4873      	ldr	r0, [pc, #460]	; (1b8d0 <main+0x3d8>)
   1b702:	f005 fd8d 	bl	21220 <_Znwj>
//This module scans for specific messages and reports them back
//This implementation is currently very basic and should just illustrate how
//such functionality could be implemented

ScanningModule::ScanningModule(u8 moduleId, Node* node, ConnectionManager* cm, const char* name, u16 storageSlot) :
		Module(moduleId, node, cm, name, storageSlot)
   1b706:	4b73      	ldr	r3, [pc, #460]	; (1b8d4 <main+0x3dc>)
   1b708:	1c07      	adds	r7, r0, #0
   1b70a:	9300      	str	r3, [sp, #0]
   1b70c:	2305      	movs	r3, #5
   1b70e:	9301      	str	r3, [sp, #4]
   1b710:	4b67      	ldr	r3, [pc, #412]	; (1b8b0 <main+0x3b8>)
   1b712:	2102      	movs	r1, #2
   1b714:	1c22      	adds	r2, r4, #0
   1b716:	681b      	ldr	r3, [r3, #0]
   1b718:	f005 fa54 	bl	20bc4 <_ZN6ModuleC2EhP4NodeP17ConnectionManagerPKct>
   1b71c:	4b6e      	ldr	r3, [pc, #440]	; (1b8d8 <main+0x3e0>)
   1b71e:	603b      	str	r3, [r7, #0]
   1b720:	4b6e      	ldr	r3, [pc, #440]	; (1b8dc <main+0x3e4>)
   1b722:	607b      	str	r3, [r7, #4]
{
	//Register callbacks n' stuff
	Logger::getInstance().enableTag("SCANMOD");
   1b724:	f001 fdb8 	bl	1d298 <_ZN6Logger11getInstanceEv>
   1b728:	496d      	ldr	r1, [pc, #436]	; (1b8e0 <main+0x3e8>)
   1b72a:	aa0a      	add	r2, sp, #40	; 0x28
   1b72c:	1c30      	adds	r0, r6, #0
   1b72e:	f005 fe1d 	bl	2136c <_ZNSsC1EPKcRKSaIcE>
   1b732:	1c30      	adds	r0, r6, #0
   1b734:	f005 fdea 	bl	2130c <_ZNSsD1Ev>

	//Save configuration to base class variables
	//sizeof configuration must be a multiple of 4 bytes
	configurationPointer = &configuration;
   1b738:	1c3b      	adds	r3, r7, #0
   1b73a:	3328      	adds	r3, #40	; 0x28
   1b73c:	623b      	str	r3, [r7, #32]
	configurationLength = sizeof(ScanningModuleConfiguration);
   1b73e:	230d      	movs	r3, #13
		return false;
	}
}

void ScanningModule::resetAssetTrackingTable(){
	memset(assetPackets, 0x00, sizeof(assetPackets));
   1b740:	1c38      	adds	r0, r7, #0
	Logger::getInstance().enableTag("SCANMOD");

	//Save configuration to base class variables
	//sizeof configuration must be a multiple of 4 bytes
	configurationPointer = &configuration;
	configurationLength = sizeof(ScanningModuleConfiguration);
   1b742:	84bb      	strh	r3, [r7, #36]	; 0x24

	//Initialize scanFilters as empty
	for (int i = 0; i < SCAN_FILTER_NUMBER; i++)
	{
		scanFilters[i].active = 0;
   1b744:	1c3b      	adds	r3, r7, #0
		return false;
	}
}

void ScanningModule::resetAssetTrackingTable(){
	memset(assetPackets, 0x00, sizeof(assetPackets));
   1b746:	3025      	adds	r0, #37	; 0x25
	configurationLength = sizeof(ScanningModuleConfiguration);

	//Initialize scanFilters as empty
	for (int i = 0; i < SCAN_FILTER_NUMBER; i++)
	{
		scanFilters[i].active = 0;
   1b748:	3338      	adds	r3, #56	; 0x38
   1b74a:	701d      	strb	r5, [r3, #0]
		return false;
	}
}

void ScanningModule::resetAssetTrackingTable(){
	memset(assetPackets, 0x00, sizeof(assetPackets));
   1b74c:	1c29      	adds	r1, r5, #0
   1b74e:	2278      	movs	r2, #120	; 0x78
   1b750:	30ff      	adds	r0, #255	; 0xff
   1b752:	f005 ff7c 	bl	2164e <memset>
	}

	resetAssetTrackingTable();

	//Start module configuration loading
	LoadModuleConfiguration();
   1b756:	1c38      	adds	r0, r7, #0
   1b758:	f005 f848 	bl	207ec <_ZN6Module23LoadModuleConfigurationEv>
   1b75c:	6527      	str	r7, [r4, #80]	; 0x50
#endif
#ifdef ACTIVATE_ENROLLMENT_MODULE
	activeModules[5] = new EnrollmentModule(moduleID::ENROLLMENT_MODULE_ID, this, cm, "enroll", 6);
   1b75e:	2038      	movs	r0, #56	; 0x38
   1b760:	f005 fd5e 	bl	21220 <_Znwj>
This module should allow configuration of network id, network key, nodeID and other necessary parameters
 */


EnrollmentModule::EnrollmentModule(u8 moduleId, Node* node, ConnectionManager* cm, const char* name, u16 storageSlot)
	: Module(moduleId, node, cm, name, storageSlot)
   1b764:	4b5f      	ldr	r3, [pc, #380]	; (1b8e4 <main+0x3ec>)
   1b766:	1c07      	adds	r7, r0, #0
   1b768:	9300      	str	r3, [sp, #0]
   1b76a:	2306      	movs	r3, #6
   1b76c:	9301      	str	r3, [sp, #4]
   1b76e:	4b50      	ldr	r3, [pc, #320]	; (1b8b0 <main+0x3b8>)
   1b770:	2105      	movs	r1, #5
   1b772:	1c22      	adds	r2, r4, #0
   1b774:	681b      	ldr	r3, [r3, #0]
   1b776:	f005 fa25 	bl	20bc4 <_ZN6ModuleC2EhP4NodeP17ConnectionManagerPKct>
   1b77a:	4b5b      	ldr	r3, [pc, #364]	; (1b8e8 <main+0x3f0>)
   1b77c:	603b      	str	r3, [r7, #0]
   1b77e:	4b5b      	ldr	r3, [pc, #364]	; (1b8ec <main+0x3f4>)
   1b780:	607b      	str	r3, [r7, #4]
{
	//Register callbacks n' stuff
	Logger::getInstance().enableTag("ENROLLMOD");
   1b782:	f001 fd89 	bl	1d298 <_ZN6Logger11getInstanceEv>
   1b786:	aa0a      	add	r2, sp, #40	; 0x28
   1b788:	4959      	ldr	r1, [pc, #356]	; (1b8f0 <main+0x3f8>)
   1b78a:	1c30      	adds	r0, r6, #0
   1b78c:	f005 fdee 	bl	2136c <_ZNSsC1EPKcRKSaIcE>
   1b790:	1c30      	adds	r0, r6, #0
   1b792:	f005 fdbb 	bl	2130c <_ZNSsD1Ev>

	rebootTimeDs = 0;

	//Save configuration to base class variables
	//sizeof configuration must be a multiple of 4 bytes
	configurationPointer = &configuration;
   1b796:	1c3b      	adds	r3, r7, #0
   1b798:	3328      	adds	r3, #40	; 0x28
   1b79a:	623b      	str	r3, [r7, #32]
	configurationLength = sizeof(EnrollmentModuleConfiguration);
   1b79c:	2309      	movs	r3, #9

	//Start module configuration loading
	LoadModuleConfiguration();
   1b79e:	1c38      	adds	r0, r7, #0
	rebootTimeDs = 0;

	//Save configuration to base class variables
	//sizeof configuration must be a multiple of 4 bytes
	configurationPointer = &configuration;
	configurationLength = sizeof(EnrollmentModuleConfiguration);
   1b7a0:	84bb      	strh	r3, [r7, #36]	; 0x24
	: Module(moduleId, node, cm, name, storageSlot)
{
	//Register callbacks n' stuff
	Logger::getInstance().enableTag("ENROLLMOD");

	rebootTimeDs = 0;
   1b7a2:	637d      	str	r5, [r7, #52]	; 0x34
	//sizeof configuration must be a multiple of 4 bytes
	configurationPointer = &configuration;
	configurationLength = sizeof(EnrollmentModuleConfiguration);

	//Start module configuration loading
	LoadModuleConfiguration();
   1b7a4:	f005 f822 	bl	207ec <_ZN6Module23LoadModuleConfigurationEv>
   1b7a8:	6567      	str	r7, [r4, #84]	; 0x54
	activeModules[6] = new IoModule(moduleID::IO_MODULE_ID, this, cm, "io", 7);
#endif


	//Register a pre/post transmit hook for radio events
	if(Config->enableRadioNotificationHandler){
   1b7aa:	f005 fb3d 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1b7ae:	3036      	adds	r0, #54	; 0x36
   1b7b0:	7803      	ldrb	r3, [r0, #0]
   1b7b2:	4a3e      	ldr	r2, [pc, #248]	; (1b8ac <main+0x3b4>)
   1b7b4:	9207      	str	r2, [sp, #28]
   1b7b6:	2b00      	cmp	r3, #0
   1b7b8:	d023      	beq.n	1b802 <main+0x30a>
                                     uint8_t    distance,
                                     ble_radio_notification_evt_handler_t evt_handler)
{
    uint32_t err_code;

    m_evt_handler = evt_handler;
   1b7ba:	4a4e      	ldr	r2, [pc, #312]	; (1b8f4 <main+0x3fc>)
   1b7bc:	4b4e      	ldr	r3, [pc, #312]	; (1b8f8 <main+0x400>)
  \details Clears the pending bit of an external interrupt.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   1b7be:	9903      	ldr	r1, [sp, #12]
   1b7c0:	601a      	str	r2, [r3, #0]
   1b7c2:	2280      	movs	r2, #128	; 0x80
   1b7c4:	23c0      	movs	r3, #192	; 0xc0
   1b7c6:	0392      	lsls	r2, r2, #14
   1b7c8:	005b      	lsls	r3, r3, #1
   1b7ca:	50ca      	str	r2, [r1, r3]
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
   1b7cc:	21c5      	movs	r1, #197	; 0xc5
   1b7ce:	9b03      	ldr	r3, [sp, #12]
   1b7d0:	0089      	lsls	r1, r1, #2
   1b7d2:	5858      	ldr	r0, [r3, r1]
   1b7d4:	4b49      	ldr	r3, [pc, #292]	; (1b8fc <main+0x404>)
   1b7d6:	4003      	ands	r3, r0
   1b7d8:	20c0      	movs	r0, #192	; 0xc0
   1b7da:	0200      	lsls	r0, r0, #8
   1b7dc:	4303      	orrs	r3, r0
   1b7de:	9803      	ldr	r0, [sp, #12]
   1b7e0:	5043      	str	r3, [r0, r1]
  {
    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
  }
  else
  {
    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
   1b7e2:	9b03      	ldr	r3, [sp, #12]
   1b7e4:	585b      	ldr	r3, [r3, r1]
  if(priority >= (1 << __NVIC_PRIO_BITS))
  {
    return 0;
  }
#ifdef NRF51
  if(   priority == 0
   1b7e6:	045b      	lsls	r3, r3, #17
   1b7e8:	d50b      	bpl.n	1b802 <main+0x30a>
  if (!__sd_nvic_is_app_accessible_priority(NVIC_GetPriority(IRQn)))
  {
    return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
  }

  if (nrf_nvic_state.__cr_flag)
   1b7ea:	4b45      	ldr	r3, [pc, #276]	; (1b900 <main+0x408>)
   1b7ec:	6859      	ldr	r1, [r3, #4]
   1b7ee:	2900      	cmp	r1, #0
   1b7f0:	d100      	bne.n	1b7f4 <main+0x2fc>
   1b7f2:	e373      	b.n	1bedc <main+0x9e4>
  {
    nrf_nvic_state.__irq_masks[(uint32_t)((int32_t)IRQn) >> 5] |= (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F));
   1b7f4:	6819      	ldr	r1, [r3, #0]
   1b7f6:	430a      	orrs	r2, r1
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   1b7f8:	601a      	str	r2, [r3, #0]
    {
        return err_code;
    }

    // Configure the event
    return sd_radio_notification_cfg_set(NRF_RADIO_NOTIFICATION_TYPE_INT_ON_BOTH, distance);
   1b7fa:	2003      	movs	r0, #3
   1b7fc:	2101      	movs	r1, #1
   1b7fe:	f001 faa1 	bl	1cd44 <sd_radio_notification_cfg_set.lto_priv.119>
		ble_radio_notification_init(3, NRF_RADIO_NOTIFICATION_DISTANCE_800US, RadioEventHandler);
	}
	joinMePacketBuffer = new SimpleBuffer((u8*) raw_joinMePacketBuffer, sizeof(joinMeBufferPacket) * JOIN_ME_PACKET_BUFFER_MAX_ELEMENTS, sizeof(joinMeBufferPacket));
   1b802:	2014      	movs	r0, #20
   1b804:	f005 fd0c 	bl	21220 <_Znwj>
#include <cstring>
}

SimpleBuffer::SimpleBuffer(u8* buffer, u16 bufferLength, u16 itemLength)
{
	this->_numElements = 0;
   1b808:	2100      	movs	r1, #0
   1b80a:	1c05      	adds	r5, r0, #0
	this->buffer = buffer;
	this->bufferLength = bufferLength;
   1b80c:	22b4      	movs	r2, #180	; 0xb4
	this->itemLength = itemLength;
   1b80e:	2324      	movs	r3, #36	; 0x24
//Reserves a specific amount of space in the queue if available and returns the pointer to that space
u8* SimpleBuffer::Reserve(void)
{
	if(buffer + bufferLength - writePointer < itemLength) return NULL;
	else {
		this->writePointer += itemLength;
   1b810:	2605      	movs	r6, #5
#include <cstring>
}

SimpleBuffer::SimpleBuffer(u8* buffer, u16 bufferLength, u16 itemLength)
{
	this->_numElements = 0;
   1b812:	8201      	strh	r1, [r0, #16]
	this->buffer = buffer;
   1b814:	483b      	ldr	r0, [pc, #236]	; (1b904 <main+0x40c>)
	this->bufferLength = bufferLength;
   1b816:	80aa      	strh	r2, [r5, #4]
	this->itemLength = itemLength;
   1b818:	80eb      	strh	r3, [r5, #6]
}

SimpleBuffer::SimpleBuffer(u8* buffer, u16 bufferLength, u16 itemLength)
{
	this->_numElements = 0;
	this->buffer = buffer;
   1b81a:	6028      	str	r0, [r5, #0]
	this->bufferLength = bufferLength;
	this->itemLength = itemLength;
	
	this->readPointer = this->buffer;
   1b81c:	60a8      	str	r0, [r5, #8]
	this->writePointer = this->buffer;
   1b81e:	60e8      	str	r0, [r5, #12]

	memset(buffer, 0x00, bufferLength);
   1b820:	f005 ff15 	bl	2164e <memset>
   1b824:	6125      	str	r5, [r4, #16]
}

//Reserves a specific amount of space in the queue if available and returns the pointer to that space
u8* SimpleBuffer::Reserve(void)
{
	if(buffer + bufferLength - writePointer < itemLength) return NULL;
   1b826:	88aa      	ldrh	r2, [r5, #4]
   1b828:	682b      	ldr	r3, [r5, #0]
   1b82a:	88e9      	ldrh	r1, [r5, #6]
   1b82c:	189a      	adds	r2, r3, r2
   1b82e:	68eb      	ldr	r3, [r5, #12]
   1b830:	1ad0      	subs	r0, r2, r3
   1b832:	4288      	cmp	r0, r1
   1b834:	db04      	blt.n	1b840 <main+0x348>
	else {
		this->writePointer += itemLength;
   1b836:	185b      	adds	r3, r3, r1
   1b838:	60eb      	str	r3, [r5, #12]
		
		_numElements++;
   1b83a:	8a2b      	ldrh	r3, [r5, #16]
   1b83c:	3301      	adds	r3, #1
   1b83e:	822b      	strh	r3, [r5, #16]
   1b840:	3e01      	subs	r6, #1

	//Fills buffer with empty packets
	for(int i=0; i<JOIN_ME_PACKET_BUFFER_MAX_ELEMENTS; i++){
   1b842:	2e00      	cmp	r6, #0
   1b844:	d1f3      	bne.n	1b82e <main+0x336>
		joinMePacketBuffer->Reserve();
	}


	//Load Node configuration from slot 0
	if(Config->ignorePersistentNodeConfigurationOnBoot){
   1b846:	f005 faef 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1b84a:	7803      	ldrb	r3, [r0, #0]
   1b84c:	2b00      	cmp	r3, #0
   1b84e:	d05b      	beq.n	1b908 <main+0x410>
//		logt("NODE", "ignoring persistent config!");
		persistentConfig.version = 0xFFFFFFFF;
   1b850:	2301      	movs	r3, #1
   1b852:	425b      	negs	r3, r3
   1b854:	61a3      	str	r3, [r4, #24]
		ConfigurationLoadedHandler();
   1b856:	1c20      	adds	r0, r4, #0
   1b858:	f001 fac6 	bl	1cde8 <_ZN4Node26ConfigurationLoadedHandlerEv>
   1b85c:	e06a      	b.n	1b934 <main+0x43c>
   1b85e:	46c0      	nop			; (mov r8, r8)
   1b860:	200032bc 	.word	0x200032bc
   1b864:	200032b8 	.word	0x200032b8
   1b868:	20002fd6 	.word	0x20002fd6
   1b86c:	20003308 	.word	0x20003308
   1b870:	0001c095 	.word	0x0001c095
   1b874:	2000330c 	.word	0x2000330c
   1b878:	e000e100 	.word	0xe000e100
   1b87c:	0001cd85 	.word	0x0001cd85
   1b880:	20003310 	.word	0x20003310
   1b884:	20002e80 	.word	0x20002e80
   1b888:	00022858 	.word	0x00022858
   1b88c:	00022865 	.word	0x00022865
   1b890:	20002f18 	.word	0x20002f18
   1b894:	20003584 	.word	0x20003584
   1b898:	200030d0 	.word	0x200030d0
   1b89c:	2000357d 	.word	0x2000357d
   1b8a0:	00022990 	.word	0x00022990
   1b8a4:	000229b4 	.word	0x000229b4
   1b8a8:	000229d4 	.word	0x000229d4
   1b8ac:	200033d8 	.word	0x200033d8
   1b8b0:	200033d0 	.word	0x200033d0
   1b8b4:	00022870 	.word	0x00022870
   1b8b8:	00022a38 	.word	0x00022a38
   1b8bc:	00022a78 	.word	0x00022a78
   1b8c0:	00022877 	.word	0x00022877
   1b8c4:	00022881 	.word	0x00022881
   1b8c8:	00022c30 	.word	0x00022c30
   1b8cc:	00022c70 	.word	0x00022c70
   1b8d0:	00000464 	.word	0x00000464
   1b8d4:	00022885 	.word	0x00022885
   1b8d8:	000229e8 	.word	0x000229e8
   1b8dc:	00022a28 	.word	0x00022a28
   1b8e0:	0002288a 	.word	0x0002288a
   1b8e4:	00022892 	.word	0x00022892
   1b8e8:	00022af0 	.word	0x00022af0
   1b8ec:	00022b30 	.word	0x00022b30
   1b8f0:	00022899 	.word	0x00022899
   1b8f4:	0001da15 	.word	0x0001da15
   1b8f8:	20002f14 	.word	0x20002f14
   1b8fc:	ffff00ff 	.word	0xffff00ff
   1b900:	200031f8 	.word	0x200031f8
   1b904:	20003200 	.word	0x20003200
	} else {
		Storage::getInstance().QueuedRead((u8*) &persistentConfig, sizeof(NodeConfiguration), 0, this);
   1b908:	f005 f9ac 	bl	20c64 <_ZN7Storage11getInstanceEv>
   1b90c:	1c23      	adds	r3, r4, #0
}

void Storage::QueuedRead(u8* data, u16 dataLength, u32 blockId, StorageEventListener* callback)
{
	taskitem task;
	task.data = data;
   1b90e:	a90b      	add	r1, sp, #44	; 0x2c
   1b910:	3318      	adds	r3, #24
   1b912:	608b      	str	r3, [r1, #8]
	task.dataLength = dataLength;
   1b914:	2328      	movs	r3, #40	; 0x28
   1b916:	804b      	strh	r3, [r1, #2]
   1b918:	1c23      	adds	r3, r4, #0
   1b91a:	3308      	adds	r3, #8
	task.storageBlock = blockId;
	task.callback = callback;
   1b91c:	60cb      	str	r3, [r1, #12]
	task.operation = operation::OPERATION_READ;

	taskQueue->Put((u8*)&task, sizeof(taskitem));
   1b91e:	1c03      	adds	r3, r0, #0
   1b920:	1c05      	adds	r5, r0, #0
   1b922:	33a4      	adds	r3, #164	; 0xa4
   1b924:	6818      	ldr	r0, [r3, #0]
void Storage::QueuedRead(u8* data, u16 dataLength, u32 blockId, StorageEventListener* callback)
{
	taskitem task;
	task.data = data;
	task.dataLength = dataLength;
	task.storageBlock = blockId;
   1b926:	604e      	str	r6, [r1, #4]
	task.callback = callback;
	task.operation = operation::OPERATION_READ;
   1b928:	800e      	strh	r6, [r1, #0]

	taskQueue->Put((u8*)&task, sizeof(taskitem));
   1b92a:	f003 fbdd 	bl	1f0e8 <_ZN11SimpleQueue3PutEPhm.constprop.15>

	ProcessQueue();
   1b92e:	1c28      	adds	r0, r5, #0
   1b930:	f003 fdee 	bl	1f510 <_ZN7Storage12ProcessQueueEv>
   1b934:	4bc1      	ldr	r3, [pc, #772]	; (1bc3c <main+0x744>)
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
   1b936:	25ff      	movs	r5, #255	; 0xff
   1b938:	601c      	str	r4, [r3, #0]
        mp_users = NULL;
        return NRF_ERROR_INVALID_PARAM;
    }
    
    // Stop RTC to prevent any running timers from expiring (in case of reinitialization)
    rtc1_stop();
   1b93a:	f000 fc37 	bl	1c1ac <rtc1_stop.lto_priv.118>
    
    m_evt_schedule_func = evt_schedule_func;
   1b93e:	2200      	movs	r2, #0
    
    // Initialize users array
    m_user_array_size = APP_TIMER_INT_LEVELS;
   1b940:	2103      	movs	r1, #3
    }
    
    // Stop RTC to prevent any running timers from expiring (in case of reinitialization)
    rtc1_stop();
    
    m_evt_schedule_func = evt_schedule_func;
   1b942:	4bbf      	ldr	r3, [pc, #764]	; (1bc40 <main+0x748>)
    
    // Initialize users array
    m_user_array_size = APP_TIMER_INT_LEVELS;
    mp_users          = p_buffer;
   1b944:	4cbf      	ldr	r4, [pc, #764]	; (1bc44 <main+0x74c>)
    }
    
    // Stop RTC to prevent any running timers from expiring (in case of reinitialization)
    rtc1_stop();
    
    m_evt_schedule_func = evt_schedule_func;
   1b946:	601a      	str	r2, [r3, #0]
    
    // Initialize users array
    m_user_array_size = APP_TIMER_INT_LEVELS;
   1b948:	4bbf      	ldr	r3, [pc, #764]	; (1bc48 <main+0x750>)
   1b94a:	7019      	strb	r1, [r3, #0]
    mp_users          = p_buffer;
   1b94c:	4bbf      	ldr	r3, [pc, #764]	; (1bc4c <main+0x754>)
    {
        timer_user_t * p_user = &mp_users[i];
        
        p_user->first              = 0;
        p_user->last               = 0;
        p_user->user_op_queue_size = op_queues_size;
   1b94e:	3901      	subs	r1, #1
        p_user->p_user_op_queue    = p_buffer;
   1b950:	1c18      	adds	r0, r3, #0
   1b952:	3018      	adds	r0, #24
    {
        timer_user_t * p_user = &mp_users[i];
        
        p_user->first              = 0;
        p_user->last               = 0;
        p_user->user_op_queue_size = op_queues_size;
   1b954:	7099      	strb	r1, [r3, #2]
   1b956:	7299      	strb	r1, [r3, #10]
   1b958:	7499      	strb	r1, [r3, #18]
        p_user->p_user_op_queue    = p_buffer;
   1b95a:	6058      	str	r0, [r3, #4]
   1b95c:	1c19      	adds	r1, r3, #0
   1b95e:	1c18      	adds	r0, r3, #0
   1b960:	3178      	adds	r1, #120	; 0x78
   1b962:	3048      	adds	r0, #72	; 0x48
    // Initialize operation queues
    for (i = 0; i < APP_TIMER_INT_LEVELS; i++)
    {
        timer_user_t * p_user = &mp_users[i];
        
        p_user->first              = 0;
   1b964:	701a      	strb	r2, [r3, #0]
        p_user->last               = 0;
   1b966:	705a      	strb	r2, [r3, #1]
    // Initialize operation queues
    for (i = 0; i < APP_TIMER_INT_LEVELS; i++)
    {
        timer_user_t * p_user = &mp_users[i];
        
        p_user->first              = 0;
   1b968:	721a      	strb	r2, [r3, #8]
        p_user->last               = 0;
   1b96a:	725a      	strb	r2, [r3, #9]
    // Initialize operation queues
    for (i = 0; i < APP_TIMER_INT_LEVELS; i++)
    {
        timer_user_t * p_user = &mp_users[i];
        
        p_user->first              = 0;
   1b96c:	741a      	strb	r2, [r3, #16]
        p_user->last               = 0;
   1b96e:	745a      	strb	r2, [r3, #17]
    
    m_evt_schedule_func = evt_schedule_func;
    
    // Initialize users array
    m_user_array_size = APP_TIMER_INT_LEVELS;
    mp_users          = p_buffer;
   1b970:	6023      	str	r3, [r4, #0]
        timer_user_t * p_user = &mp_users[i];
        
        p_user->first              = 0;
        p_user->last               = 0;
        p_user->user_op_queue_size = op_queues_size;
        p_user->p_user_op_queue    = p_buffer;
   1b972:	60d8      	str	r0, [r3, #12]
   1b974:	6159      	str	r1, [r3, #20]
    
        // Skip operation queue
        p_buffer = &((uint8_t *)p_buffer)[op_queues_size * sizeof(timer_user_op_t)];
    }

    mp_timer_id_head             = NULL;
   1b976:	4bb6      	ldr	r3, [pc, #728]	; (1bc50 <main+0x758>)
  \details Clears the pending bit of an external interrupt.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   1b978:	2180      	movs	r1, #128	; 0x80
   1b97a:	601a      	str	r2, [r3, #0]
    m_ticks_elapsed_q_read_ind  = 0;
   1b97c:	4bb5      	ldr	r3, [pc, #724]	; (1bc54 <main+0x75c>)
   1b97e:	9803      	ldr	r0, [sp, #12]
   1b980:	701a      	strb	r2, [r3, #0]
    m_ticks_elapsed_q_write_ind = 0;
   1b982:	4bb5      	ldr	r3, [pc, #724]	; (1bc58 <main+0x760>)
   1b984:	0349      	lsls	r1, r1, #13
   1b986:	701a      	strb	r2, [r3, #0]
   1b988:	23c0      	movs	r3, #192	; 0xc0
   1b98a:	005b      	lsls	r3, r3, #1
   1b98c:	50c1      	str	r1, [r0, r3]
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
   1b98e:	20c5      	movs	r0, #197	; 0xc5
   1b990:	9b03      	ldr	r3, [sp, #12]
   1b992:	0080      	lsls	r0, r0, #2
   1b994:	581b      	ldr	r3, [r3, r0]
   1b996:	43ab      	bics	r3, r5
   1b998:	3d3f      	subs	r5, #63	; 0x3f
   1b99a:	432b      	orrs	r3, r5
   1b99c:	9d03      	ldr	r5, [sp, #12]
   1b99e:	502b      	str	r3, [r5, r0]
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   1b9a0:	9b03      	ldr	r3, [sp, #12]
   1b9a2:	6019      	str	r1, [r3, #0]
 *
 * @param[in] prescaler   Value of the RTC1 PRESCALER register. Set to 0 for no prescaling.
 */
static void rtc1_init(uint32_t prescaler)
{
    NRF_RTC1->PRESCALER = prescaler;
   1b9a4:	23a1      	movs	r3, #161	; 0xa1
   1b9a6:	49ad      	ldr	r1, [pc, #692]	; (1bc5c <main+0x764>)
   1b9a8:	00db      	lsls	r3, r3, #3
   1b9aa:	50ca      	str	r2, [r1, r3]
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
   1b9ac:	22c4      	movs	r2, #196	; 0xc4
   1b9ae:	9b03      	ldr	r3, [sp, #12]
   1b9b0:	0092      	lsls	r2, r2, #2
   1b9b2:	5898      	ldr	r0, [r3, r2]
   1b9b4:	4baa      	ldr	r3, [pc, #680]	; (1bc60 <main+0x768>)
   1b9b6:	4003      	ands	r3, r0
   1b9b8:	20c0      	movs	r0, #192	; 0xc0
   1b9ba:	0200      	lsls	r0, r0, #8
   1b9bc:	4303      	orrs	r3, r0
   1b9be:	9803      	ldr	r0, [sp, #12]
   1b9c0:	5083      	str	r3, [r0, r2]
 *
 * @return     Current value of the RTC1 counter.
 */
static __INLINE uint32_t rtc1_counter_get(void)
{
    return NRF_RTC1->COUNTER;
   1b9c2:	48a8      	ldr	r0, [pc, #672]	; (1bc64 <main+0x76c>)
    NVIC_SetPriority(SWI_IRQn, SWI_IRQ_PRI);
    NVIC_EnableIRQ(SWI_IRQn);

    rtc1_init(prescaler);

    m_ticks_latest = rtc1_counter_get();
   1b9c4:	4ba8      	ldr	r3, [pc, #672]	; (1bc68 <main+0x770>)
 *
 * @return     Current value of the RTC1 counter.
 */
static __INLINE uint32_t rtc1_counter_get(void)
{
    return NRF_RTC1->COUNTER;
   1b9c6:	580a      	ldr	r2, [r1, r0]
    NVIC_SetPriority(SWI_IRQn, SWI_IRQ_PRI);
    NVIC_EnableIRQ(SWI_IRQn);

    rtc1_init(prescaler);

    m_ticks_latest = rtc1_counter_get();
   1b9c8:	601a      	str	r2, [r3, #0]
    }
    if (p_timer_id == NULL)
    {
        return NRF_ERROR_INVALID_PARAM;
    }
    if (((timer_node_t*)*p_timer_id)->is_running)
   1b9ca:	4ba8      	ldr	r3, [pc, #672]	; (1bc6c <main+0x774>)
   1b9cc:	7c1a      	ldrb	r2, [r3, #16]
   1b9ce:	1c1d      	adds	r5, r3, #0
   1b9d0:	9104      	str	r1, [sp, #16]
   1b9d2:	9005      	str	r0, [sp, #20]
   1b9d4:	2a00      	cmp	r2, #0
   1b9d6:	d000      	beq.n	1b9da <main+0x4e2>
   1b9d8:	e282      	b.n	1bee0 <main+0x9e8>
    {
        return NRF_ERROR_INVALID_STATE;
    }
    
    timer_node_t * p_node     = (timer_node_t *)*p_timer_id;
    p_node->is_running        = false;
   1b9da:	741a      	strb	r2, [r3, #16]
    p_node->mode              = mode;
   1b9dc:	3201      	adds	r2, #1
   1b9de:	745a      	strb	r2, [r3, #17]
    p_node->p_timeout_handler = timeout_handler;
   1b9e0:	4aa3      	ldr	r2, [pc, #652]	; (1bc70 <main+0x778>)
   1b9e2:	615a      	str	r2, [r3, #20]
	APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_OP_QUEUE_SIZE, NULL);

	err = app_timer_create(&mainTimerMsId, APP_TIMER_MODE_REPEATED, ble_timer_dispatch);
    APP_ERROR_CHECK(err);

	err = app_timer_start(mainTimerMsId, APP_TIMER_TICKS(Config->mainTimerTickDs * 100, APP_TIMER_PRESCALER), NULL);
   1b9e4:	f005 fa20 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1b9e8:	2364      	movs	r3, #100	; 0x64
   1b9ea:	88c2      	ldrh	r2, [r0, #6]
   1b9ec:	4353      	muls	r3, r2
   1b9ee:	17de      	asrs	r6, r3, #31
   1b9f0:	0c5a      	lsrs	r2, r3, #17
   1b9f2:	03f1      	lsls	r1, r6, #15
   1b9f4:	4311      	orrs	r1, r2
   1b9f6:	22fa      	movs	r2, #250	; 0xfa
   1b9f8:	03d8      	lsls	r0, r3, #15
   1b9fa:	2300      	movs	r3, #0
   1b9fc:	0052      	lsls	r2, r2, #1
   1b9fe:	1880      	adds	r0, r0, r2
   1ba00:	4159      	adcs	r1, r3
   1ba02:	22fa      	movs	r2, #250	; 0xfa
   1ba04:	2300      	movs	r3, #0
   1ba06:	0092      	lsls	r2, r2, #2
   1ba08:	f006 fcb8 	bl	2237c <__aeabi_uldivmod>
{
    uint32_t timeout_periodic;
    timer_node_t * p_node = (timer_node_t*)timer_id;
    
    // Check state and parameters
    VERIFY_MODULE_INITIALIZED();
   1ba0c:	6824      	ldr	r4, [r4, #0]
   1ba0e:	2c00      	cmp	r4, #0
   1ba10:	d100      	bne.n	1ba14 <main+0x51c>
   1ba12:	e26c      	b.n	1beee <main+0x9f6>

    if (timer_id == 0)
    {
        return NRF_ERROR_INVALID_STATE;
    }
    if (timeout_ticks < APP_TIMER_MIN_TIMEOUT_TICKS)
   1ba14:	2900      	cmp	r1, #0
   1ba16:	d102      	bne.n	1ba1e <main+0x526>
   1ba18:	2804      	cmp	r0, #4
   1ba1a:	d800      	bhi.n	1ba1e <main+0x526>
   1ba1c:	e265      	b.n	1beea <main+0x9f2>
    {
        return NRF_ERROR_INVALID_PARAM;
    }
    if (p_node->p_timeout_handler == NULL)
   1ba1e:	696b      	ldr	r3, [r5, #20]
   1ba20:	2b00      	cmp	r3, #0
   1ba22:	d100      	bne.n	1ba26 <main+0x52e>
   1ba24:	e263      	b.n	1beee <main+0x9f6>
    {
        return NRF_ERROR_INVALID_STATE;
    }
    
    // Schedule timer start operation
    timeout_periodic = (p_node->mode == APP_TIMER_MODE_REPEATED) ? timeout_ticks : 0;
   1ba26:	7c6b      	ldrb	r3, [r5, #17]
   1ba28:	2600      	movs	r6, #0
   1ba2a:	2b01      	cmp	r3, #1
   1ba2c:	d100      	bne.n	1ba30 <main+0x538>
   1ba2e:	1c06      	adds	r6, r0, #0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   1ba30:	f3ef 8105 	mrs	r1, IPSR
 * @retval   APP_IRQ_PRIORITY_LOW     We are running in Application Low interrupt level.
 * @retval   APP_IRQ_PRIORITY_THREAD  We are running in Thread Mode.
 */
static __INLINE uint8_t current_int_priority_get(void)
{
    uint32_t isr_vector_num = __get_IPSR() & IPSR_ISR_Msk ;
   1ba34:	05c9      	lsls	r1, r1, #23
   1ba36:	0dc9      	lsrs	r1, r1, #23
        case APP_IRQ_PRIORITY_LOW:
            ret = APP_LOW_USER_ID;
            break;
            
        default:
            ret = THREAD_MODE_USER_ID;
   1ba38:	2302      	movs	r3, #2
    if (isr_vector_num > 0)
   1ba3a:	2900      	cmp	r1, #0
   1ba3c:	d025      	beq.n	1ba8a <main+0x592>
    {
        int32_t irq_type = ((int32_t)isr_vector_num - EXTERNAL_INT_VECTOR_OFFSET);
   1ba3e:	3910      	subs	r1, #16
        return (NVIC_GetPriority((IRQn_Type)irq_type) & 0xFF);
   1ba40:	b2cb      	uxtb	r3, r1
                      Value is aligned automatically to the implemented priority bits of the microcontroller.
 */
__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
{

  if ((int32_t)(IRQn) < 0)
   1ba42:	b25a      	sxtb	r2, r3
   1ba44:	2a00      	cmp	r2, #0
   1ba46:	da0c      	bge.n	1ba62 <main+0x56a>
  {
    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
   1ba48:	220f      	movs	r2, #15
   1ba4a:	401a      	ands	r2, r3
   1ba4c:	3a08      	subs	r2, #8
   1ba4e:	4989      	ldr	r1, [pc, #548]	; (1bc74 <main+0x77c>)
   1ba50:	0892      	lsrs	r2, r2, #2
   1ba52:	0092      	lsls	r2, r2, #2
   1ba54:	1852      	adds	r2, r2, r1
   1ba56:	2103      	movs	r1, #3
   1ba58:	400b      	ands	r3, r1
   1ba5a:	408b      	lsls	r3, r1
   1ba5c:	6852      	ldr	r2, [r2, #4]
   1ba5e:	40da      	lsrs	r2, r3
   1ba60:	e008      	b.n	1ba74 <main+0x57c>
  }
  else
  {
    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
   1ba62:	0892      	lsrs	r2, r2, #2
   1ba64:	9b03      	ldr	r3, [sp, #12]
   1ba66:	32c0      	adds	r2, #192	; 0xc0
   1ba68:	0092      	lsls	r2, r2, #2
   1ba6a:	589a      	ldr	r2, [r3, r2]
   1ba6c:	2303      	movs	r3, #3
   1ba6e:	4019      	ands	r1, r3
   1ba70:	4099      	lsls	r1, r3
   1ba72:	40ca      	lsrs	r2, r1
   1ba74:	b2d2      	uxtb	r2, r2
   1ba76:	0992      	lsrs	r2, r2, #6
{
    timer_user_id_t ret;

    STATIC_ASSERT(APP_TIMER_INT_LEVELS == 3);
    
    switch (current_int_priority_get())
   1ba78:	b2d2      	uxtb	r2, r2
    {
        case APP_IRQ_PRIORITY_HIGH:
            ret = APP_HIGH_USER_ID;
   1ba7a:	2300      	movs	r3, #0
{
    timer_user_id_t ret;

    STATIC_ASSERT(APP_TIMER_INT_LEVELS == 3);
    
    switch (current_int_priority_get())
   1ba7c:	2a01      	cmp	r2, #1
   1ba7e:	d004      	beq.n	1ba8a <main+0x592>
        case APP_IRQ_PRIORITY_LOW:
            ret = APP_LOW_USER_ID;
            break;
            
        default:
            ret = THREAD_MODE_USER_ID;
   1ba80:	3a03      	subs	r2, #3
   1ba82:	4257      	negs	r7, r2
   1ba84:	4157      	adcs	r7, r2
   1ba86:	3302      	adds	r3, #2
   1ba88:	1bdb      	subs	r3, r3, r7
                                        uint32_t        timeout_periodic,
                                        void *          p_context)
{
    uint8_t last_index;
    
    timer_user_op_t * p_user_op = user_op_alloc(&mp_users[user_id], &last_index);
   1ba8a:	00db      	lsls	r3, r3, #3
   1ba8c:	18e3      	adds	r3, r4, r3
static timer_user_op_t * user_op_alloc(timer_user_t * p_user, uint8_t * p_last_index)
{        
    uint8_t           last;
    timer_user_op_t * p_user_op;
    
    last = p_user->last + 1;
   1ba8e:	785f      	ldrb	r7, [r3, #1]
    if (last == p_user->user_op_queue_size)
   1ba90:	789c      	ldrb	r4, [r3, #2]
static timer_user_op_t * user_op_alloc(timer_user_t * p_user, uint8_t * p_last_index)
{        
    uint8_t           last;
    timer_user_op_t * p_user_op;
    
    last = p_user->last + 1;
   1ba92:	1c7a      	adds	r2, r7, #1
   1ba94:	b2d2      	uxtb	r2, r2
    if (last == p_user->user_op_queue_size)
    {
        // Overflow case.
        last = 0;
   1ba96:	1aa4      	subs	r4, r4, r2
   1ba98:	1e61      	subs	r1, r4, #1
   1ba9a:	418c      	sbcs	r4, r1
    }
    if (last == p_user->first)
   1ba9c:	7819      	ldrb	r1, [r3, #0]
    
    last = p_user->last + 1;
    if (last == p_user->user_op_queue_size)
    {
        // Overflow case.
        last = 0;
   1ba9e:	4264      	negs	r4, r4
   1baa0:	4022      	ands	r2, r4
    }
    if (last == p_user->first)
   1baa2:	4291      	cmp	r1, r2
   1baa4:	d018      	beq.n	1bad8 <main+0x5e0>
        // Queue is full.
        return NULL;
    }
    
    *p_last_index = last;    
    p_user_op     = &p_user->p_user_op_queue[p_user->last];
   1baa6:	2118      	movs	r1, #24
   1baa8:	434f      	muls	r7, r1
   1baaa:	6859      	ldr	r1, [r3, #4]
   1baac:	19cf      	adds	r7, r1, r7
                                        void *          p_context)
{
    uint8_t last_index;
    
    timer_user_op_t * p_user_op = user_op_alloc(&mp_users[user_id], &last_index);
    if (p_user_op == NULL)
   1baae:	2f00      	cmp	r7, #0
   1bab0:	d012      	beq.n	1bad8 <main+0x5e0>
    {
        return NRF_ERROR_NO_MEM;
    }
    
    p_user_op->op_type                              = TIMER_USER_OP_TYPE_START;
   1bab2:	2101      	movs	r1, #1
 *
 * @return     Current value of the RTC1 counter.
 */
static __INLINE uint32_t rtc1_counter_get(void)
{
    return NRF_RTC1->COUNTER;
   1bab4:	9c05      	ldr	r4, [sp, #20]
    if (p_user_op == NULL)
    {
        return NRF_ERROR_NO_MEM;
    }
    
    p_user_op->op_type                              = TIMER_USER_OP_TYPE_START;
   1bab6:	7039      	strb	r1, [r7, #0]
 *
 * @return     Current value of the RTC1 counter.
 */
static __INLINE uint32_t rtc1_counter_get(void)
{
    return NRF_RTC1->COUNTER;
   1bab8:	9904      	ldr	r1, [sp, #16]
    {
        return NRF_ERROR_NO_MEM;
    }
    
    p_user_op->op_type                              = TIMER_USER_OP_TYPE_START;
    p_user_op->p_node                               = p_node;
   1baba:	607d      	str	r5, [r7, #4]
 *
 * @return     Current value of the RTC1 counter.
 */
static __INLINE uint32_t rtc1_counter_get(void)
{
    return NRF_RTC1->COUNTER;
   1babc:	5909      	ldr	r1, [r1, r4]
    }
    
    p_user_op->op_type                              = TIMER_USER_OP_TYPE_START;
    p_user_op->p_node                               = p_node;
    p_user_op->params.start.ticks_at_start          = rtc1_counter_get();
    p_user_op->params.start.ticks_first_interval    = timeout_initial;
   1babe:	60f8      	str	r0, [r7, #12]
        return NRF_ERROR_NO_MEM;
    }
    
    p_user_op->op_type                              = TIMER_USER_OP_TYPE_START;
    p_user_op->p_node                               = p_node;
    p_user_op->params.start.ticks_at_start          = rtc1_counter_get();
   1bac0:	60b9      	str	r1, [r7, #8]
    p_user_op->params.start.ticks_first_interval    = timeout_initial;
    p_user_op->params.start.ticks_periodic_interval = timeout_periodic;
    p_user_op->params.start.p_context               = p_context;
   1bac2:	2100      	movs	r1, #0
    
    p_user_op->op_type                              = TIMER_USER_OP_TYPE_START;
    p_user_op->p_node                               = p_node;
    p_user_op->params.start.ticks_at_start          = rtc1_counter_get();
    p_user_op->params.start.ticks_first_interval    = timeout_initial;
    p_user_op->params.start.ticks_periodic_interval = timeout_periodic;
   1bac4:	613e      	str	r6, [r7, #16]
    p_user_op->params.start.p_context               = p_context;
   1bac6:	6179      	str	r1, [r7, #20]
 * @param[in]  p_user     User that the entry is to be enqueued for.
 * @param[in]  last_index Index of the next last index to be enqueued.
 */
static void user_op_enque(timer_user_t * p_user, uint8_t last_index)
{
    p_user->last = last_index;
   1bac8:	705a      	strb	r2, [r3, #1]
  \details Sets the pending bit of an external interrupt.
  \param [in]      IRQn  Interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   1baca:	2280      	movs	r2, #128	; 0x80
   1bacc:	4b6a      	ldr	r3, [pc, #424]	; (1bc78 <main+0x780>)
   1bace:	0352      	lsls	r2, r2, #13
   1bad0:	605a      	str	r2, [r3, #4]
	//new Testing();

	//Start Timers
	initTimers();

	pendingSysEvent = 0;
   1bad2:	4b6a      	ldr	r3, [pc, #424]	; (1bc7c <main+0x784>)
   1bad4:	6019      	str	r1, [r3, #0]
   1bad6:	e028      	b.n	1bb2a <main+0x632>
    uint8_t last_index;
    
    timer_user_op_t * p_user_op = user_op_alloc(&mp_users[user_id], &last_index);
    if (p_user_op == NULL)
    {
        return NRF_ERROR_NO_MEM;
   1bad8:	2004      	movs	r0, #4

	err = app_timer_create(&mainTimerMsId, APP_TIMER_MODE_REPEATED, ble_timer_dispatch);
    APP_ERROR_CHECK(err);

	err = app_timer_start(mainTimerMsId, APP_TIMER_TICKS(Config->mainTimerTickDs * 100, APP_TIMER_PRESCALER), NULL);
    APP_ERROR_CHECK(err);
   1bada:	21e7      	movs	r1, #231	; 0xe7
   1badc:	e55d      	b.n	1b59a <main+0xa2>
{
	u32 err = 0;

	//Depending on the type of the BLE event, we have to do different stuff
	//Further Events: http://developer.nordicsemi.com/nRF51_SDK/doc/7.1.0/s120/html/a00746.html#gada486dd3c0cce897b23a887bed284fef
	switch (bleEvent->header.evt_id)
   1bade:	8820      	ldrh	r0, [r4, #0]
   1bae0:	3810      	subs	r0, #16
   1bae2:	280b      	cmp	r0, #11
   1bae4:	d92b      	bls.n	1bb3e <main+0x646>
bool ScanController::ScanEventHandler(ble_evt_t * bleEvent)
{
	//u32 err = 0;

	//Depending on the type of the BLE event, we have to do different stuff
	switch (bleEvent->header.evt_id)
   1bae6:	8823      	ldrh	r3, [r4, #0]
   1bae8:	2b10      	cmp	r3, #16
   1baea:	d100      	bne.n	1baee <main+0x5f6>
   1baec:	e082      	b.n	1bbf4 <main+0x6fc>
   1baee:	2b1d      	cmp	r3, #29
   1baf0:	d06b      	beq.n	1bbca <main+0x6d2>

bool GATTController::bleMeshServiceEventHandler(ble_evt_t* bleEvent)
{
	u32 err = 0;

	switch (bleEvent->header.evt_id)
   1baf2:	4d63      	ldr	r5, [pc, #396]	; (1bc80 <main+0x788>)
   1baf4:	882b      	ldrh	r3, [r5, #0]
   1baf6:	1c2c      	adds	r4, r5, #0
   1baf8:	2b32      	cmp	r3, #50	; 0x32
   1bafa:	d100      	bne.n	1bafe <main+0x606>
   1bafc:	e0f7      	b.n	1bcee <main+0x7f6>
   1bafe:	d900      	bls.n	1bb02 <main+0x60a>
   1bb00:	e082      	b.n	1bc08 <main+0x710>
   1bb02:	2b10      	cmp	r3, #16
   1bb04:	d100      	bne.n	1bb08 <main+0x610>
   1bb06:	e08c      	b.n	1bc22 <main+0x72a>
   1bb08:	d879      	bhi.n	1bbfe <main+0x706>
   1bb0a:	2b01      	cmp	r3, #1
   1bb0c:	d100      	bne.n	1bb10 <main+0x618>
   1bb0e:	e103      	b.n	1bd18 <main+0x820>
	GAPController::bleConnectionEventHandler(bleEvent);
	AdvertisingController::AdvertiseEventHandler(bleEvent);
	ScanController::ScanEventHandler(bleEvent);
	GATTController::bleMeshServiceEventHandler(bleEvent);

	if(node != NULL){
   1bb10:	4d4a      	ldr	r5, [pc, #296]	; (1bc3c <main+0x744>)
   1bb12:	682b      	ldr	r3, [r5, #0]
   1bb14:	2b00      	cmp	r3, #0
   1bb16:	d000      	beq.n	1bb1a <main+0x622>
   1bb18:	e10f      	b.n	1bd3a <main+0x842>

void ConnectionManager::BleEventHandler(ble_evt_t* bleEvent)
{
	ConnectionManager* cm = ConnectionManager::getInstance();

	for(int i=0; i<Config->meshMaxConnections; i++){
   1bb1a:	2600      	movs	r6, #0
		node->cm->BleEventHandler(bleEvent);
	}

	//Dispatch ble events to all modules
	for(int i=0; i<MAX_MODULE_COUNT; i++){
		if(node != NULL && node->activeModules[i] != 0  && node->activeModules[i]->configurationPointer->moduleActive){
   1bb1c:	682a      	ldr	r2, [r5, #0]
   1bb1e:	2a00      	cmp	r2, #0
   1bb20:	d000      	beq.n	1bb24 <main+0x62c>
   1bb22:	e12e      	b.n	1bd82 <main+0x88a>
	if(node != NULL){
		node->cm->BleEventHandler(bleEvent);
	}

	//Dispatch ble events to all modules
	for(int i=0; i<MAX_MODULE_COUNT; i++){
   1bb24:	3601      	adds	r6, #1
   1bb26:	2e05      	cmp	r6, #5
   1bb28:	d1f8      	bne.n	1bb1c <main+0x624>
		Terminal::CheckAndProcessLine();

		do
		{
			//Fetch the event
			sizeOfCurrentEvent = sizeOfEvent;
   1bb2a:	2348      	movs	r3, #72	; 0x48
			err = sd_ble_evt_get((u8*)currentEventBuffer, &sizeOfCurrentEvent);
   1bb2c:	4c54      	ldr	r4, [pc, #336]	; (1bc80 <main+0x788>)
		Terminal::CheckAndProcessLine();

		do
		{
			//Fetch the event
			sizeOfCurrentEvent = sizeOfEvent;
   1bb2e:	4955      	ldr	r1, [pc, #340]	; (1bc84 <main+0x78c>)
			err = sd_ble_evt_get((u8*)currentEventBuffer, &sizeOfCurrentEvent);
   1bb30:	1c20      	adds	r0, r4, #0
		Terminal::CheckAndProcessLine();

		do
		{
			//Fetch the event
			sizeOfCurrentEvent = sizeOfEvent;
   1bb32:	800b      	strh	r3, [r1, #0]
			err = sd_ble_evt_get((u8*)currentEventBuffer, &sizeOfCurrentEvent);
   1bb34:	f005 f964 	bl	20e00 <sd_ble_evt_get.lto_priv.110>

			//Handle ble event event
			if (err == NRF_SUCCESS)
   1bb38:	2800      	cmp	r0, #0
   1bb3a:	d0d0      	beq.n	1bade <main+0x5e6>
   1bb3c:	e132      	b.n	1bda4 <main+0x8ac>
   1bb3e:	f005 fb3f 	bl	211c0 <__gnu_thumb1_case_sqi>
   1bb42:	1306      	.short	0x1306
   1bb44:	d21ed2d2 	.word	0xd21ed2d2
   1bb48:	d2d2d2d2 	.word	0xd2d2d2d2
   1bb4c:	153d      	.short	0x153d
	{
	//************************** GAP *****************************
	//########## Connection with other device
	case BLE_GAP_EVT_CONNECTED:
	{
		currentlyConnecting = false;
   1bb4e:	2300      	movs	r3, #0
   1bb50:	4a4d      	ldr	r2, [pc, #308]	; (1bc88 <main+0x790>)
   1bb52:	7013      	strb	r3, [r2, #0]

		// Our advertisement stopped because we received a connection on this packet (we are peripheral)
		if (bleEvent->evt.gap_evt.params.connected.role == BLE_GAP_ROLE_PERIPH){
   1bb54:	7da2      	ldrb	r2, [r4, #22]
   1bb56:	2a01      	cmp	r2, #1
   1bb58:	d104      	bne.n	1bb64 <main+0x66c>

//If Advertising was interrupted, restart in previous state
void AdvertisingController::AdvertisingInterruptedBecauseOfIncomingConnectionHandler(void)
{
	logt("ADV", "advertising interrupted");
	advertisingState = ADV_STATE_OFF;
   1bb5a:	4a4c      	ldr	r2, [pc, #304]	; (1bc8c <main+0x794>)
   1bb5c:	8013      	strh	r3, [r2, #0]
	currentAdvertisingParams.type = BLE_GAP_ADV_TYPE_ADV_SCAN_IND;
   1bb5e:	2202      	movs	r2, #2
   1bb60:	4b4b      	ldr	r3, [pc, #300]	; (1bc90 <main+0x798>)
   1bb62:	701a      	strb	r2, [r3, #0]
		}

		logt("C", "Connected device");

		//Connection stops advertising
		connectionSuccessCallback(bleEvent);
   1bb64:	4b4b      	ldr	r3, [pc, #300]	; (1bc94 <main+0x79c>)
   1bb66:	e008      	b.n	1bb7a <main+0x682>
	}
		//########## Another Device disconnected
	case BLE_GAP_EVT_DISCONNECTED:
	{
		logt("C", "Disconnected device %d", bleEvent->evt.gap_evt.params.disconnected.reason);
		disconnectionCallback(bleEvent);
   1bb68:	4b4b      	ldr	r3, [pc, #300]	; (1bc98 <main+0x7a0>)
   1bb6a:	e006      	b.n	1bb7a <main+0x682>
	}
		break;

	case BLE_GAP_EVT_TIMEOUT:
	{
		if (bleEvent->evt.gap_evt.params.timeout.src == BLE_GAP_TIMEOUT_SRC_CONN)
   1bb6c:	7a23      	ldrb	r3, [r4, #8]
   1bb6e:	2b03      	cmp	r3, #3
   1bb70:	d1b9      	bne.n	1bae6 <main+0x5ee>
		{
			currentlyConnecting = false;
   1bb72:	2200      	movs	r2, #0
   1bb74:	4b44      	ldr	r3, [pc, #272]	; (1bc88 <main+0x790>)
   1bb76:	701a      	strb	r2, [r3, #0]

			connectingTimeoutCallback(bleEvent);
   1bb78:	4b48      	ldr	r3, [pc, #288]	; (1bc9c <main+0x7a4>)
   1bb7a:	681b      	ldr	r3, [r3, #0]
   1bb7c:	e022      	b.n	1bbc4 <main+0x6cc>
		//TODO: If we want multiple keys, we need to implement some more logic to select the key
		ble_gap_evt_sec_info_request_t securityRequest = bleEvent->evt.gap_evt.params.sec_info_request;

		//This is our security key
		ble_gap_enc_info_t key;
		key.auth = 1; //This key is authenticated
   1bb7e:	2202      	movs	r2, #2
   1bb80:	ad0b      	add	r5, sp, #44	; 0x2c
   1bb82:	7c2b      	ldrb	r3, [r5, #16]
		memcpy(&key.ltk, Node::getInstance()->persistentConfig.networkKey, 16); //Copy our mesh network key
   1bb84:	1c28      	adds	r0, r5, #0
		//TODO: If we want multiple keys, we need to implement some more logic to select the key
		ble_gap_evt_sec_info_request_t securityRequest = bleEvent->evt.gap_evt.params.sec_info_request;

		//This is our security key
		ble_gap_enc_info_t key;
		key.auth = 1; //This key is authenticated
   1bb86:	4313      	orrs	r3, r2
   1bb88:	742b      	strb	r3, [r5, #16]
		memcpy(&key.ltk, Node::getInstance()->persistentConfig.networkKey, 16); //Copy our mesh network key
   1bb8a:	9b07      	ldr	r3, [sp, #28]
   1bb8c:	320e      	adds	r2, #14
   1bb8e:	681b      	ldr	r3, [r3, #0]
   1bb90:	1c19      	adds	r1, r3, #0
   1bb92:	3128      	adds	r1, #40	; 0x28
   1bb94:	9304      	str	r3, [sp, #16]
   1bb96:	f005 fd3d 	bl	21614 <memcpy>
		key.ltk_len = 16;
   1bb9a:	2303      	movs	r3, #3
   1bb9c:	7c2a      	ldrb	r2, [r5, #16]
		err = sd_ble_gap_sec_info_reply(
			bleEvent->evt.gap_evt.conn_handle,
			&key, //This is our stored long term key
			NULL, //We do not have an identity resolving key
			NULL //We do not have signing info
		);
   1bb9e:	1c29      	adds	r1, r5, #0

		//This is our security key
		ble_gap_enc_info_t key;
		key.auth = 1; //This key is authenticated
		memcpy(&key.ltk, Node::getInstance()->persistentConfig.networkKey, 16); //Copy our mesh network key
		key.ltk_len = 16;
   1bba0:	4013      	ands	r3, r2
   1bba2:	2240      	movs	r2, #64	; 0x40
   1bba4:	4313      	orrs	r3, r2
		err = sd_ble_gap_sec_info_reply(
			bleEvent->evt.gap_evt.conn_handle,
			&key, //This is our stored long term key
			NULL, //We do not have an identity resolving key
			NULL //We do not have signing info
		);
   1bba6:	2200      	movs	r2, #0

		//This is our security key
		ble_gap_enc_info_t key;
		key.auth = 1; //This key is authenticated
		memcpy(&key.ltk, Node::getInstance()->persistentConfig.networkKey, 16); //Copy our mesh network key
		key.ltk_len = 16;
   1bba8:	742b      	strb	r3, [r5, #16]
		err = sd_ble_gap_sec_info_reply(
			bleEvent->evt.gap_evt.conn_handle,
			&key, //This is our stored long term key
			NULL, //We do not have an identity resolving key
			NULL //We do not have signing info
		);
   1bbaa:	88a0      	ldrh	r0, [r4, #4]
   1bbac:	1c13      	adds	r3, r2, #0
   1bbae:	f001 fbd5 	bl	1d35c <sd_ble_gap_sec_info_reply.lto_priv.117>
		APP_ERROR_CHECK(err); //TODO: Error handling
   1bbb2:	2800      	cmp	r0, #0
   1bbb4:	d097      	beq.n	1bae6 <main+0x5ee>
   1bbb6:	21d5      	movs	r1, #213	; 0xd5
   1bbb8:	4a39      	ldr	r2, [pc, #228]	; (1bca0 <main+0x7a8>)
   1bbba:	e4f0      	b.n	1b59e <main+0xa6>
		u8 level = bleEvent->evt.gap_evt.params.conn_sec_update.conn_sec.sec_mode.lv;
		u8 securityMode = bleEvent->evt.gap_evt.params.conn_sec_update.conn_sec.sec_mode.sm;

		logt("SEC", "Connection key is now %u bytes, level %u, securityMode %u", keySize, level, securityMode);

		if(connectionEncryptedCallback) connectionEncryptedCallback(bleEvent);
   1bbbc:	4b39      	ldr	r3, [pc, #228]	; (1bca4 <main+0x7ac>)
   1bbbe:	681b      	ldr	r3, [r3, #0]
   1bbc0:	2b00      	cmp	r3, #0
   1bbc2:	d090      	beq.n	1bae6 <main+0x5ee>
   1bbc4:	482e      	ldr	r0, [pc, #184]	; (1bc80 <main+0x788>)
   1bbc6:	4798      	blx	r3
   1bbc8:	e78d      	b.n	1bae6 <main+0x5ee>
		{
			//Check if packet is a valid mesh advertising packet
			advPacketHeader* packetHeader = (advPacketHeader*) bleEvent->evt.gap_evt.params.adv_report.data;

			if (
					bleEvent->evt.gap_evt.params.adv_report.dlen >= SIZEOF_ADV_PACKET_HEADER
   1bbca:	7c22      	ldrb	r2, [r4, #16]
   1bbcc:	08d2      	lsrs	r2, r2, #3
					&& packetHeader->manufacturer.companyIdentifier == COMPANY_IDENTIFIER
					&& packetHeader->meshIdentifier == MESH_IDENTIFIER
					&& packetHeader->networkId == Node::getInstance()->persistentConfig.networkId
   1bbce:	2a0a      	cmp	r2, #10
   1bbd0:	dd8f      	ble.n	1baf2 <main+0x5fa>
			//Check if packet is a valid mesh advertising packet
			advPacketHeader* packetHeader = (advPacketHeader*) bleEvent->evt.gap_evt.params.adv_report.data;

			if (
					bleEvent->evt.gap_evt.params.adv_report.dlen >= SIZEOF_ADV_PACKET_HEADER
					&& packetHeader->manufacturer.companyIdentifier == COMPANY_IDENTIFIER
   1bbd2:	8ae1      	ldrh	r1, [r4, #22]
   1bbd4:	4b34      	ldr	r3, [pc, #208]	; (1bca8 <main+0x7b0>)
   1bbd6:	4299      	cmp	r1, r3
   1bbd8:	d18b      	bne.n	1baf2 <main+0x5fa>
					&& packetHeader->meshIdentifier == MESH_IDENTIFIER
   1bbda:	7e23      	ldrb	r3, [r4, #24]
   1bbdc:	2bf0      	cmp	r3, #240	; 0xf0
   1bbde:	d188      	bne.n	1baf2 <main+0x5fa>


	public:
		static Node* getInstance()
		{
			return instance;
   1bbe0:	9b07      	ldr	r3, [sp, #28]
   1bbe2:	681e      	ldr	r6, [r3, #0]
					&& packetHeader->networkId == Node::getInstance()->persistentConfig.networkId
   1bbe4:	69a3      	ldr	r3, [r4, #24]
   1bbe6:	8cb1      	ldrh	r1, [r6, #36]	; 0x24
   1bbe8:	021b      	lsls	r3, r3, #8
   1bbea:	0c1b      	lsrs	r3, r3, #16
   1bbec:	428b      	cmp	r3, r1
   1bbee:	d000      	beq.n	1bbf2 <main+0x6fa>
   1bbf0:	e77f      	b.n	1baf2 <main+0x5fa>
   1bbf2:	e17e      	b.n	1bef2 <main+0x9fa>
		}

		case BLE_GAP_EVT_CONNECTED:
		{
			//In case, a connection comes in, scanning might have been stopped before (valid for outgoing connections)
			SetScanState(SCAN_STATE_HIGH);
   1bbf4:	2080      	movs	r0, #128	; 0x80
   1bbf6:	00c0      	lsls	r0, r0, #3
   1bbf8:	f001 fbb6 	bl	1d368 <_ZN14ScanController12SetScanStateE9scanState>
   1bbfc:	e779      	b.n	1baf2 <main+0x5fa>
   1bbfe:	2b11      	cmp	r3, #17
   1bc00:	d011      	beq.n	1bc26 <main+0x72e>
   1bc02:	2b30      	cmp	r3, #48	; 0x30
   1bc04:	d061      	beq.n	1bcca <main+0x7d2>
   1bc06:	e783      	b.n	1bb10 <main+0x618>
   1bc08:	2b3a      	cmp	r3, #58	; 0x3a
   1bc0a:	d100      	bne.n	1bc0e <main+0x716>
   1bc0c:	e089      	b.n	1bd22 <main+0x82a>
   1bc0e:	d803      	bhi.n	1bc18 <main+0x720>
   1bc10:	2b38      	cmp	r3, #56	; 0x38
   1bc12:	d100      	bne.n	1bc16 <main+0x71e>
   1bc14:	e080      	b.n	1bd18 <main+0x820>
   1bc16:	e77b      	b.n	1bb10 <main+0x618>
   1bc18:	2b50      	cmp	r3, #80	; 0x50
   1bc1a:	d009      	beq.n	1bc30 <main+0x738>
   1bc1c:	2b52      	cmp	r3, #82	; 0x52
   1bc1e:	d049      	beq.n	1bcb4 <main+0x7bc>
   1bc20:	e776      	b.n	1bb10 <main+0x618>
 * @param[in]   p_lbs       LEDButton Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
void GATTController::meshServiceConnectHandler(ble_evt_t* bleEvent)
{
	meshService.connectionHandle = bleEvent->evt.gap_evt.conn_handle;
   1bc22:	88aa      	ldrh	r2, [r5, #4]
   1bc24:	e001      	b.n	1bc2a <main+0x732>
 * @param[in]   p_lbs       LEDButton Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
void GATTController::meshServiceDisconnectHandler(ble_evt_t* bleEvent)
{
	meshService.connectionHandle = BLE_CONN_HANDLE_INVALID;
   1bc26:	2201      	movs	r2, #1
   1bc28:	4252      	negs	r2, r2
   1bc2a:	4b20      	ldr	r3, [pc, #128]	; (1bcac <main+0x7b4>)
   1bc2c:	831a      	strh	r2, [r3, #24]
   1bc2e:	e76f      	b.n	1bb10 <main+0x618>
 *	reveices a BLE_GATTS_EVT_WRITE
 */
void GATTController::meshServiceWriteHandler(ble_evt_t* bleEvent)
{
	//Send packet to Node which is responsible for sanity checking the packet
	if(bleEvent->evt.gatts_evt.params.write.handle == 14){
   1bc30:	88eb      	ldrh	r3, [r5, #6]
   1bc32:	2b0e      	cmp	r3, #14
   1bc34:	d000      	beq.n	1bc38 <main+0x740>
   1bc36:	e76b      	b.n	1bb10 <main+0x618>
		messageReceivedCallback(bleEvent);
   1bc38:	4b1d      	ldr	r3, [pc, #116]	; (1bcb0 <main+0x7b8>)
   1bc3a:	e06e      	b.n	1bd1a <main+0x822>
   1bc3c:	200033b4 	.word	0x200033b4
   1bc40:	200032b4 	.word	0x200032b4
   1bc44:	20002fd8 	.word	0x20002fd8
   1bc48:	2000330d 	.word	0x2000330d
   1bc4c:	20002fe0 	.word	0x20002fe0
   1bc50:	20002fdc 	.word	0x20002fdc
   1bc54:	20003314 	.word	0x20003314
   1bc58:	200031f4 	.word	0x200031f4
   1bc5c:	40011000 	.word	0x40011000
   1bc60:	ffff00ff 	.word	0xffff00ff
   1bc64:	00000504 	.word	0x00000504
   1bc68:	20003304 	.word	0x20003304
   1bc6c:	200031d4 	.word	0x200031d4
   1bc70:	0001cd95 	.word	0x0001cd95
   1bc74:	e000ed18 	.word	0xe000ed18
   1bc78:	e000e1fc 	.word	0xe000e1fc
   1bc7c:	20003390 	.word	0x20003390
   1bc80:	200032bc 	.word	0x200032bc
   1bc84:	20002e90 	.word	0x20002e90
   1bc88:	200033d4 	.word	0x200033d4
   1bc8c:	20003588 	.word	0x20003588
   1bc90:	20003524 	.word	0x20003524
   1bc94:	200033bc 	.word	0x200033bc
   1bc98:	20003398 	.word	0x20003398
   1bc9c:	200033b8 	.word	0x200033b8
   1bca0:	000228a3 	.word	0x000228a3
   1bca4:	2000338c 	.word	0x2000338c
   1bca8:	0000024d 	.word	0x0000024d
   1bcac:	2000358a 	.word	0x2000358a
   1bcb0:	200033a8 	.word	0x200033a8

void GATTController::attributeMissingHandler(ble_evt_t* bleEvent)
{
	u32 err = 0;
	//Handles missing Attributes, don't know why it is needed
	err = sd_ble_gatts_sys_attr_set(bleEvent->evt.gatts_evt.conn_handle, NULL, 0, 0);
   1bcb4:	2100      	movs	r1, #0
   1bcb6:	88a8      	ldrh	r0, [r5, #4]
   1bcb8:	1c0a      	adds	r2, r1, #0
   1bcba:	1c0b      	adds	r3, r1, #0
   1bcbc:	f001 fb14 	bl	1d2e8 <sd_ble_gatts_sys_attr_set.lto_priv.116>
	APP_ERROR_CHECK(err); //Unhandeled
   1bcc0:	2800      	cmp	r0, #0
   1bcc2:	d100      	bne.n	1bcc6 <main+0x7ce>
   1bcc4:	e724      	b.n	1bb10 <main+0x618>
   1bcc6:	21b6      	movs	r1, #182	; 0xb6
   1bcc8:	e00f      	b.n	1bcea <main+0x7f2>
void GATTController::_bleServiceDiscoveryFinishedHandler(ble_evt_t* bleEvent)
{
	u32 err = 0;

	//Service has been found
	if (bleEvent->evt.gattc_evt.params.prim_srvc_disc_rsp.count > 0)
   1bcca:	89ab      	ldrh	r3, [r5, #12]
   1bccc:	2b00      	cmp	r3, #0
   1bcce:	d100      	bne.n	1bcd2 <main+0x7da>
   1bcd0:	e71e      	b.n	1bb10 <main+0x618>
	{
		logt("C", "Found service");

		//Service handle range has been found, now start discovery on characteristics
		ble_gattc_handle_range_t handleRange;
		handleRange.start_handle = bleEvent->evt.gattc_evt.params.prim_srvc_disc_rsp.services[0].handle_range.start_handle;
   1bcd2:	8a6b      	ldrh	r3, [r5, #18]
   1bcd4:	a90b      	add	r1, sp, #44	; 0x2c
   1bcd6:	800b      	strh	r3, [r1, #0]
		handleRange.end_handle = bleEvent->evt.gattc_evt.params.prim_srvc_disc_rsp.services[0].handle_range.end_handle;
   1bcd8:	8aab      	ldrh	r3, [r5, #20]
   1bcda:	804b      	strh	r3, [r1, #2]

		err = sd_ble_gattc_characteristics_discover(bleEvent->evt.gattc_evt.conn_handle, &handleRange);
   1bcdc:	88a8      	ldrh	r0, [r5, #4]
   1bcde:	f001 fb01 	bl	1d2e4 <sd_ble_gattc_characteristics_discover.lto_priv.115>
		APP_ERROR_CHECK(err); //Currently Unhandeled
   1bce2:	2800      	cmp	r0, #0
   1bce4:	d100      	bne.n	1bce8 <main+0x7f0>
   1bce6:	e713      	b.n	1bb10 <main+0x618>
   1bce8:	21d6      	movs	r1, #214	; 0xd6
   1bcea:	4aaf      	ldr	r2, [pc, #700]	; (1bfa8 <main+0xab0>)
   1bcec:	e457      	b.n	1b59e <main+0xa6>
void GATTController::_bleCharacteristicDiscoveryFinishedHandler(ble_evt_t* bleEvent)
{
	u32 err = 0;

	//Service has been found
	if (bleEvent->evt.gattc_evt.params.char_disc_rsp.count > 0)
   1bcee:	89ab      	ldrh	r3, [r5, #12]
   1bcf0:	2b00      	cmp	r3, #0
   1bcf2:	d100      	bne.n	1bcf6 <main+0x7fe>
   1bcf4:	e70c      	b.n	1bb10 <main+0x618>
	{
		//Characteristics have been found (FIXME: more could be requested by calling discovery again see:https://devzone.nordicsemi.com/documentation/nrf51/4.3.0/html/group___b_l_e___g_a_t_t_c___c_h_a_r___d_i_s_c___m_s_c.html)
		if (bleEvent->evt.gattc_evt.params.char_disc_rsp.chars[0].uuid.uuid == MESH_SERVICE_CHARACTERISTIC_UUID && bleEvent->evt.gattc_evt.params.char_disc_rsp.chars[0].uuid.type == meshService.serviceUuid.type)
   1bcf6:	89ea      	ldrh	r2, [r5, #14]
   1bcf8:	4bac      	ldr	r3, [pc, #688]	; (1bfac <main+0xab4>)
   1bcfa:	429a      	cmp	r2, r3
   1bcfc:	d000      	beq.n	1bd00 <main+0x808>
   1bcfe:	e707      	b.n	1bb10 <main+0x618>
   1bd00:	4bab      	ldr	r3, [pc, #684]	; (1bfb0 <main+0xab8>)
   1bd02:	7c2a      	ldrb	r2, [r5, #16]
   1bd04:	7d9b      	ldrb	r3, [r3, #22]
   1bd06:	429a      	cmp	r2, r3
   1bd08:	d000      	beq.n	1bd0c <main+0x814>
   1bd0a:	e701      	b.n	1bb10 <main+0x618>
		{
			u16 characteristicHandle = bleEvent->evt.gattc_evt.params.char_disc_rsp.chars[0].handle_value;
			logt("C", "Found characteristic");
			handleDiscoveredCallback(bleEvent->evt.gattc_evt.conn_handle, characteristicHandle);
   1bd0c:	4ba9      	ldr	r3, [pc, #676]	; (1bfb4 <main+0xabc>)
   1bd0e:	88a8      	ldrh	r0, [r5, #4]
   1bd10:	8ae9      	ldrh	r1, [r5, #22]
   1bd12:	681b      	ldr	r3, [r3, #0]
   1bd14:	4798      	blx	r3
   1bd16:	e6fb      	b.n	1bb10 <main+0x618>
		}

			//Is called when a write has completed
		case BLE_GATTC_EVT_WRITE_RSP:
			//Send next packet after first has been received
			dataTransmittedCallback(bleEvent);
   1bd18:	4ba7      	ldr	r3, [pc, #668]	; (1bfb8 <main+0xac0>)
   1bd1a:	681b      	ldr	r3, [r3, #0]
   1bd1c:	1c20      	adds	r0, r4, #0
   1bd1e:	4798      	blx	r3
   1bd20:	e6f6      	b.n	1bb10 <main+0x618>

		case BLE_GATTC_EVT_TIMEOUT:
			//A GATTC Timeout occurs if a WRITE_RSP is not received within 30s
			//This essentially marks the end of a connection, we'll have to disconnect
			logt("ERROR", "BLE_GATTC_EVT_TIMEOUT");
			Logger::getInstance().logError(Logger::errorTypes::CUSTOM, Logger::customErrorTypes::BLE_GATTC_EVT_TIMEOUT_FORCED_US, 0);
   1bd22:	f001 fab9 	bl	1d298 <_ZN6Logger11getInstanceEv>
   1bd26:	2102      	movs	r1, #2
   1bd28:	2201      	movs	r2, #1
   1bd2a:	2300      	movs	r3, #0
   1bd2c:	f003 fe7c 	bl	1fa28 <_ZN6Logger8logErrorENS_10errorTypesEmt>
//Disconnect from paired peripheral
void GAPController::disconnectFromPartner(u16 connectionHandle)
{
	u32 err = 0;

	err = sd_ble_gap_disconnect(connectionHandle, BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION);
   1bd30:	88a8      	ldrh	r0, [r5, #4]
   1bd32:	2113      	movs	r1, #19
   1bd34:	f001 fb16 	bl	1d364 <sd_ble_gap_disconnect.lto_priv.67>
   1bd38:	e6ea      	b.n	1bb10 <main+0x618>
//
//

void ConnectionManager::BleEventHandler(ble_evt_t* bleEvent)
{
	ConnectionManager* cm = ConnectionManager::getInstance();
   1bd3a:	f001 fcc9 	bl	1d6d0 <_ZN17ConnectionManager11getInstanceEv>

	for(int i=0; i<Config->meshMaxConnections; i++){
   1bd3e:	2600      	movs	r6, #0
//
//

void ConnectionManager::BleEventHandler(ble_evt_t* bleEvent)
{
	ConnectionManager* cm = ConnectionManager::getInstance();
   1bd40:	1c07      	adds	r7, r0, #0

	for(int i=0; i<Config->meshMaxConnections; i++){
   1bd42:	f005 f871 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1bd46:	3035      	adds	r0, #53	; 0x35
   1bd48:	7803      	ldrb	r3, [r0, #0]
   1bd4a:	429e      	cmp	r6, r3
   1bd4c:	db00      	blt.n	1bd50 <main+0x858>
   1bd4e:	e6e4      	b.n	1bb1a <main+0x622>
   1bd50:	00b3      	lsls	r3, r6, #2
   1bd52:	18fb      	adds	r3, r7, r3
		cm->connections[i]->BleEventHandler(bleEvent);
   1bd54:	6a1b      	ldr	r3, [r3, #32]
}

//Handling general events
void Connection::BleEventHandler(ble_evt_t* bleEvent)
{
	if(connectionState == ConnectionState::DISCONNECTED) return;
   1bd56:	7a1a      	ldrb	r2, [r3, #8]
   1bd58:	2a00      	cmp	r2, #0
   1bd5a:	d010      	beq.n	1bd7e <main+0x886>

	if(bleEvent->header.evt_id >= BLE_GAP_EVT_BASE && bleEvent->header.evt_id < BLE_GAP_EVT_LAST){
   1bd5c:	8822      	ldrh	r2, [r4, #0]
   1bd5e:	1c11      	adds	r1, r2, #0
   1bd60:	3910      	subs	r1, #16
   1bd62:	291e      	cmp	r1, #30
   1bd64:	d80b      	bhi.n	1bd7e <main+0x886>
		if(bleEvent->evt.gap_evt.conn_handle != connectionHandle) return;
   1bd66:	21e9      	movs	r1, #233	; 0xe9
   1bd68:	0049      	lsls	r1, r1, #1
   1bd6a:	88a0      	ldrh	r0, [r4, #4]
   1bd6c:	5a59      	ldrh	r1, [r3, r1]
   1bd6e:	4288      	cmp	r0, r1
   1bd70:	d105      	bne.n	1bd7e <main+0x886>

		switch(bleEvent->header.evt_id){
   1bd72:	2a12      	cmp	r2, #18
   1bd74:	d103      	bne.n	1bd7e <main+0x886>
			case BLE_GAP_EVT_CONN_PARAM_UPDATE:
			{
				logt("CONN", "new connection params set");
				currentConnectionIntervalMs = bleEvent->evt.gap_evt.params.conn_param_update.conn_params.max_conn_interval;
   1bd76:	8961      	ldrh	r1, [r4, #10]
   1bd78:	32cd      	adds	r2, #205	; 0xcd
   1bd7a:	32ff      	adds	r2, #255	; 0xff
   1bd7c:	5299      	strh	r1, [r3, r2]

void ConnectionManager::BleEventHandler(ble_evt_t* bleEvent)
{
	ConnectionManager* cm = ConnectionManager::getInstance();

	for(int i=0; i<Config->meshMaxConnections; i++){
   1bd7e:	3601      	adds	r6, #1
   1bd80:	e7df      	b.n	1bd42 <main+0x84a>
		node->cm->BleEventHandler(bleEvent);
	}

	//Dispatch ble events to all modules
	for(int i=0; i<MAX_MODULE_COUNT; i++){
		if(node != NULL && node->activeModules[i] != 0  && node->activeModules[i]->configurationPointer->moduleActive){
   1bd82:	1c33      	adds	r3, r6, #0
   1bd84:	3310      	adds	r3, #16
   1bd86:	009b      	lsls	r3, r3, #2
   1bd88:	5898      	ldr	r0, [r3, r2]
   1bd8a:	2800      	cmp	r0, #0
   1bd8c:	d100      	bne.n	1bd90 <main+0x898>
   1bd8e:	e6c9      	b.n	1bb24 <main+0x62c>
   1bd90:	6a03      	ldr	r3, [r0, #32]
   1bd92:	789b      	ldrb	r3, [r3, #2]
   1bd94:	2b00      	cmp	r3, #0
   1bd96:	d100      	bne.n	1bd9a <main+0x8a2>
   1bd98:	e6c4      	b.n	1bb24 <main+0x62c>
			node->activeModules[i]->BleEventHandler(bleEvent);
   1bd9a:	6803      	ldr	r3, [r0, #0]
   1bd9c:	1c21      	adds	r1, r4, #0
   1bd9e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1bda0:	4798      	blx	r3
   1bda2:	e6bf      	b.n	1bb24 <main+0x62c>
			{
				//logt("EVENT", "--- EVENT_HANDLER %d -----", currentEvent->header.evt_id);
				bleDispatchEventHandler(currentEvent);
			}
			//No more events available
			else if (err == NRF_ERROR_NOT_FOUND)
   1bda4:	2805      	cmp	r0, #5
   1bda6:	d000      	beq.n	1bdaa <main+0x8b2>
   1bda8:	e092      	b.n	1bed0 <main+0x9d8>
			{
				//Handle Timer event that was waiting
				if (node && node->passsedTimeSinceLastTimerHandlerDs > 0)
   1bdaa:	4d84      	ldr	r5, [pc, #528]	; (1bfbc <main+0xac4>)
   1bdac:	682e      	ldr	r6, [r5, #0]
   1bdae:	1c2f      	adds	r7, r5, #0
   1bdb0:	2e00      	cmp	r6, #0
   1bdb2:	d036      	beq.n	1be22 <main+0x92a>
   1bdb4:	1c33      	adds	r3, r6, #0
   1bdb6:	336c      	adds	r3, #108	; 0x6c
   1bdb8:	881c      	ldrh	r4, [r3, #0]
   1bdba:	2c00      	cmp	r4, #0
   1bdbc:	d031      	beq.n	1be22 <main+0x92a>
}

void Node::TimerTickHandler(u16 timerDs) {
    //Update the app timer (The app timer has a drift when comparing it to the
    //config value in deciseconds because these do not convert nicely into ticks)
    appTimerDs += timerDs;
   1bdbe:	6e73      	ldr	r3, [r6, #100]	; 0x64
    currentStateTimeoutDs -= timerDs;

    UpdateGlobalTime();
   1bdc0:	1c30      	adds	r0, r6, #0
}

void Node::TimerTickHandler(u16 timerDs) {
    //Update the app timer (The app timer has a drift when comparing it to the
    //config value in deciseconds because these do not convert nicely into ticks)
    appTimerDs += timerDs;
   1bdc2:	191b      	adds	r3, r3, r4
   1bdc4:	6673      	str	r3, [r6, #100]	; 0x64
    currentStateTimeoutDs -= timerDs;
   1bdc6:	6eb3      	ldr	r3, [r6, #104]	; 0x68
   1bdc8:	1b1b      	subs	r3, r3, r4
   1bdca:	66b3      	str	r3, [r6, #104]	; 0x68

    UpdateGlobalTime();
   1bdcc:	f001 ffb6 	bl	1dd3c <_ZN4Node16UpdateGlobalTimeEv>

    //Check if we should switch states because of timeouts
    if (nextDiscoveryState != INVALID_STATE && currentStateTimeoutDs <= 0) {
   1bdd0:	1c33      	adds	r3, r6, #0
   1bdd2:	3355      	adds	r3, #85	; 0x55
   1bdd4:	7819      	ldrb	r1, [r3, #0]
   1bdd6:	2900      	cmp	r1, #0
   1bdd8:	d005      	beq.n	1bde6 <main+0x8ee>
   1bdda:	6eb3      	ldr	r3, [r6, #104]	; 0x68
   1bddc:	2b00      	cmp	r3, #0
   1bdde:	dc02      	bgt.n	1bde6 <main+0x8ee>
        //Go to the next state
        ChangeState(nextDiscoveryState);
   1bde0:	1c30      	adds	r0, r6, #0
   1bde2:	f002 f82f 	bl	1de44 <_ZN4Node11ChangeStateE14discoveryState>
}

//This function is called from the main event handling
void timerEventDispatch(u16 passedTime, u32 appTimer){
	//Dispatch event to all modules
	for(int i=0; i<MAX_MODULE_COUNT; i++){
   1bde6:	2600      	movs	r6, #0

					//Call the timer handler from the node
					node->TimerTickHandler(timerDs);

					//Dispatch timer to all other modules
					timerEventDispatch(timerDs, node->appTimerDs);
   1bde8:	682b      	ldr	r3, [r5, #0]
   1bdea:	6e5b      	ldr	r3, [r3, #100]	; 0x64
   1bdec:	9304      	str	r3, [sp, #16]

//This function is called from the main event handling
void timerEventDispatch(u16 passedTime, u32 appTimer){
	//Dispatch event to all modules
	for(int i=0; i<MAX_MODULE_COUNT; i++){
		if(node != NULL && node->activeModules[i] != 0  && node->activeModules[i]->configurationPointer->moduleActive){
   1bdee:	683a      	ldr	r2, [r7, #0]
   1bdf0:	2a00      	cmp	r2, #0
   1bdf2:	d00e      	beq.n	1be12 <main+0x91a>
   1bdf4:	1c33      	adds	r3, r6, #0
   1bdf6:	3310      	adds	r3, #16
   1bdf8:	009b      	lsls	r3, r3, #2
   1bdfa:	5898      	ldr	r0, [r3, r2]
   1bdfc:	2800      	cmp	r0, #0
   1bdfe:	d008      	beq.n	1be12 <main+0x91a>
   1be00:	6a03      	ldr	r3, [r0, #32]
   1be02:	789b      	ldrb	r3, [r3, #2]
   1be04:	2b00      	cmp	r3, #0
   1be06:	d004      	beq.n	1be12 <main+0x91a>
			node->activeModules[i]->TimerEventHandler(passedTime, appTimer);
   1be08:	6803      	ldr	r3, [r0, #0]
   1be0a:	1c21      	adds	r1, r4, #0
   1be0c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1be0e:	9a04      	ldr	r2, [sp, #16]
   1be10:	4798      	blx	r3
}

//This function is called from the main event handling
void timerEventDispatch(u16 passedTime, u32 appTimer){
	//Dispatch event to all modules
	for(int i=0; i<MAX_MODULE_COUNT; i++){
   1be12:	3601      	adds	r6, #1
   1be14:	2e05      	cmp	r6, #5
   1be16:	d1ea      	bne.n	1bdee <main+0x8f6>
					//Dispatch timer to all other modules
					timerEventDispatch(timerDs, node->appTimerDs);

					//FIXME: Should protect this with a semaphore
					//because the timerInterrupt works asynchronously
					node->passsedTimeSinceLastTimerHandlerDs -= timerDs;
   1be18:	682b      	ldr	r3, [r5, #0]
   1be1a:	336c      	adds	r3, #108	; 0x6c
   1be1c:	881a      	ldrh	r2, [r3, #0]
   1be1e:	1b14      	subs	r4, r2, r4
   1be20:	801c      	strh	r4, [r3, #0]
				}

				//If a pending system event is waiting, call the handler
				if(pendingSysEvent != 0){
   1be22:	4b67      	ldr	r3, [pc, #412]	; (1bfc0 <main+0xac8>)
   1be24:	681c      	ldr	r4, [r3, #0]
   1be26:	2c00      	cmp	r4, #0
   1be28:	d106      	bne.n	1be38 <main+0x940>
					u32 copy = pendingSysEvent;
					pendingSysEvent = 0;
					sysDispatchEventHandler(copy);
				}

				err = sd_app_evt_wait();
   1be2a:	f004 ffe3 	bl	20df4 <sd_app_evt_wait.lto_priv.109>
				APP_ERROR_CHECK(err); // OK
   1be2e:	2800      	cmp	r0, #0
   1be30:	d047      	beq.n	1bec2 <main+0x9ca>
   1be32:	21c6      	movs	r1, #198	; 0xc6
   1be34:	f7ff fbb2 	bl	1b59c <main+0xa4>
				}

				//If a pending system event is waiting, call the handler
				if(pendingSysEvent != 0){
					u32 copy = pendingSysEvent;
					pendingSysEvent = 0;
   1be38:	2200      	movs	r2, #0
}

void sysDispatchEventHandler(u32 sys_evt)
{
	//Hand system events to new storage class
	NewStorage::SystemEventHandler(sys_evt);
   1be3a:	1c20      	adds	r0, r4, #0
				}

				//If a pending system event is waiting, call the handler
				if(pendingSysEvent != 0){
					u32 copy = pendingSysEvent;
					pendingSysEvent = 0;
   1be3c:	601a      	str	r2, [r3, #0]
}

void sysDispatchEventHandler(u32 sys_evt)
{
	//Hand system events to new storage class
	NewStorage::SystemEventHandler(sys_evt);
   1be3e:	f003 fc9b 	bl	1f778 <_ZN10NewStorage18SystemEventHandlerEm>
 *
 * @param[in] sys_evt System event to be handled.
 */
void pstorage_sys_event_handler(uint32_t sys_evt)
{  
    if (m_state != STATE_IDLE && m_state != STATE_ERROR)
   1be42:	4d60      	ldr	r5, [pc, #384]	; (1bfc4 <main+0xacc>)
   1be44:	2604      	movs	r6, #4
   1be46:	782a      	ldrb	r2, [r5, #0]
   1be48:	1c13      	adds	r3, r2, #0
   1be4a:	43b3      	bics	r3, r6
   1be4c:	d01e      	beq.n	1be8c <main+0x994>
    {        
        switch (sys_evt)
   1be4e:	2c02      	cmp	r4, #2
   1be50:	d01e      	beq.n	1be90 <main+0x998>
   1be52:	2c03      	cmp	r4, #3
   1be54:	d11a      	bne.n	1be8c <main+0x994>
            case NRF_EVT_FLASH_OPERATION_SUCCESS:
                flash_operation_success_run();
                break;
            
            case NRF_EVT_FLASH_OPERATION_ERROR:            
                if (!(m_flags & MASK_FLASH_API_ERR_BUSY))
   1be56:	4b5c      	ldr	r3, [pc, #368]	; (1bfc8 <main+0xad0>)
   1be58:	681b      	ldr	r3, [r3, #0]
   1be5a:	071b      	lsls	r3, r3, #28
   1be5c:	d418      	bmi.n	1be90 <main+0x998>
 *          the system by issuing @ref pstorage_init which will also result to flushing of the 
 *          command queue.
 */
static void flash_operation_failure_run(void)
{   
    if (++m_num_of_command_retries != SD_CMD_MAX_TRIES)
   1be5e:	495b      	ldr	r1, [pc, #364]	; (1bfcc <main+0xad4>)
   1be60:	680b      	ldr	r3, [r1, #0]
   1be62:	3301      	adds	r3, #1
   1be64:	600b      	str	r3, [r1, #0]
   1be66:	2b03      	cmp	r3, #3
   1be68:	d004      	beq.n	1be74 <main+0x97c>
    {
        // Retry the last operation by doing a self transition to the current state.
            
        if (m_state != STATE_DATA_ERASE_WITH_SWAP)
   1be6a:	2a02      	cmp	r2, #2
   1be6c:	d10c      	bne.n	1be88 <main+0x990>
 * @param[in] new_state New swap sub state to transit to.
 */   
static void swap_sub_state_state_change(flash_swap_sub_state_t new_state)
{
    m_swap_sub_state = new_state;
    swap_sub_state_entry_action_run();    
   1be6e:	f000 fbef 	bl	1c650 <swap_sub_state_entry_action_run.lto_priv.112>
   1be72:	e00b      	b.n	1be8c <main+0x994>
 *
 * @param[in] result Result code of the operation for the application.
 */
static void app_notify_error_state_transit(uint32_t result)
{
    app_notify(result, &m_cmd_queue.cmd[m_cmd_queue.rp]);
   1be74:	2214      	movs	r2, #20
   1be76:	4b56      	ldr	r3, [pc, #344]	; (1bfd0 <main+0xad8>)
   1be78:	200d      	movs	r0, #13
   1be7a:	7819      	ldrb	r1, [r3, #0]
   1be7c:	4351      	muls	r1, r2
   1be7e:	18c9      	adds	r1, r1, r3
   1be80:	3104      	adds	r1, #4
   1be82:	f000 fbcf 	bl	1c624 <app_notify.lto_priv.114>
 *
 * @param[in] new_state New application main state to transit to.
 */
static void sm_state_change(pstorage_state_t new_state)
{
    m_state = new_state;
   1be86:	702e      	strb	r6, [r5, #0]
    state_entry_action_run();
   1be88:	f000 fc24 	bl	1c6d4 <state_entry_action_run.lto_priv.113>
}

//This function is called from the main event handling
void timerEventDispatch(u16 passedTime, u32 appTimer){
	//Dispatch event to all modules
	for(int i=0; i<MAX_MODULE_COUNT; i++){
   1be8c:	2500      	movs	r5, #0
   1be8e:	e00b      	b.n	1bea8 <main+0x9b0>
                else
                {
                    // As our last flash operation request was rejected by the flash API reissue the 
                    // request by doing same code execution path as for flash operation sucess 
                    // event. This will promote code reuse in the implementation.                    
                    flash_operation_success_run();
   1be90:	f000 fdf6 	bl	1ca80 <flash_operation_success_run.lto_priv.111>
   1be94:	e7fa      	b.n	1be8c <main+0x994>
	//Hand system events to the pstorage library
	pstorage_sys_event_handler(sys_evt);

	//Dispatch system events to all modules
	for(int i=0; i<MAX_MODULE_COUNT; i++){
		if(node != NULL && node->activeModules[i] != NULL && node->activeModules[i]->configurationPointer->moduleActive){
   1be96:	1c2b      	adds	r3, r5, #0
   1be98:	3310      	adds	r3, #16
   1be9a:	009b      	lsls	r3, r3, #2
   1be9c:	5898      	ldr	r0, [r3, r2]
   1be9e:	2800      	cmp	r0, #0
   1bea0:	d106      	bne.n	1beb0 <main+0x9b8>

	//Hand system events to the pstorage library
	pstorage_sys_event_handler(sys_evt);

	//Dispatch system events to all modules
	for(int i=0; i<MAX_MODULE_COUNT; i++){
   1bea2:	3501      	adds	r5, #1
   1bea4:	2d05      	cmp	r5, #5
   1bea6:	d0c0      	beq.n	1be2a <main+0x932>
		if(node != NULL && node->activeModules[i] != NULL && node->activeModules[i]->configurationPointer->moduleActive){
   1bea8:	683a      	ldr	r2, [r7, #0]
   1beaa:	2a00      	cmp	r2, #0
   1beac:	d1f3      	bne.n	1be96 <main+0x99e>
   1beae:	e7f8      	b.n	1bea2 <main+0x9aa>
   1beb0:	6a03      	ldr	r3, [r0, #32]
   1beb2:	789b      	ldrb	r3, [r3, #2]
   1beb4:	2b00      	cmp	r3, #0
   1beb6:	d0f4      	beq.n	1bea2 <main+0x9aa>
			node->activeModules[i]->SystemEventHandler(sys_evt);
   1beb8:	6803      	ldr	r3, [r0, #0]
   1beba:	1c21      	adds	r1, r4, #0
   1bebc:	6a1b      	ldr	r3, [r3, #32]
   1bebe:	4798      	blx	r3
   1bec0:	e7ef      	b.n	1bea2 <main+0x9aa>
  \details Clears the pending bit of an external interrupt.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   1bec2:	2280      	movs	r2, #128	; 0x80
   1bec4:	23c0      	movs	r3, #192	; 0xc0
   1bec6:	9903      	ldr	r1, [sp, #12]
   1bec8:	03d2      	lsls	r2, r2, #15
   1beca:	005b      	lsls	r3, r3, #1
   1becc:	50ca      	str	r2, [r1, r3]
   1bece:	e62c      	b.n	1bb2a <main+0x632>
				APP_ERROR_CHECK(err);  // OK
				break;
			}
			else
			{
				APP_ERROR_CHECK(err); //FIXME: NRF_ERROR_DATA_SIZE not handeled
   1bed0:	21cd      	movs	r1, #205	; 0xcd
   1bed2:	f7ff fb63 	bl	1b59c <main+0xa4>
	clock_lf_cfg.rc_temp_ctiv = 0;
	clock_lf_cfg.xtal_accuracy = NRF_CLOCK_LF_XTAL_ACCURACY_100_PPM;

	//SOFTDEVICE_HANDLER_INIT(&clock_lf_cfg, NULL);
    err = softdevice_handler_init(&clock_lf_cfg, currentEventBuffer, sizeOfEvent, NULL);
    APP_ERROR_CHECK(err);
   1bed6:	21ef      	movs	r1, #239	; 0xef
   1bed8:	f7ff fb60 	bl	1b59c <main+0xa4>
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   1bedc:	9b03      	ldr	r3, [sp, #12]
   1bede:	e48b      	b.n	1b7f8 <main+0x300>
	u32 err = 0;

	APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_OP_QUEUE_SIZE, NULL);

	err = app_timer_create(&mainTimerMsId, APP_TIMER_MODE_REPEATED, ble_timer_dispatch);
    APP_ERROR_CHECK(err);
   1bee0:	2008      	movs	r0, #8
   1bee2:	21cc      	movs	r1, #204	; 0xcc
   1bee4:	31ff      	adds	r1, #255	; 0xff
   1bee6:	f7ff fb59 	bl	1b59c <main+0xa4>
    {
        return NRF_ERROR_INVALID_STATE;
    }
    if (timeout_ticks < APP_TIMER_MIN_TIMEOUT_TICKS)
    {
        return NRF_ERROR_INVALID_PARAM;
   1beea:	2007      	movs	r0, #7
   1beec:	e5f5      	b.n	1bada <main+0x5e2>
{
    uint32_t timeout_periodic;
    timer_node_t * p_node = (timer_node_t*)timer_id;
    
    // Check state and parameters
    VERIFY_MODULE_INITIALIZED();
   1beee:	2008      	movs	r0, #8
   1bef0:	e5f3      	b.n	1bada <main+0x5e2>
	/*char stringBuffer[100];
	 convertBufferToHexString(data, dataLength, stringBuffer);
	 tracel(stringBuffer);
	 tracelf("type %d length %d, JOIN ME LENGTH %d", packetHeader->messageType, dataLength, SIZEOF_ADV_PACKET_JOIN_ME);*/

	switch (packetHeader->messageType)
   1bef2:	7ee3      	ldrb	r3, [r4, #27]
   1bef4:	2b01      	cmp	r3, #1
   1bef6:	d000      	beq.n	1befa <main+0xa02>
   1bef8:	e5fb      	b.n	1baf2 <main+0x5fa>
	{
		case MESSAGE_TYPE_JOIN_ME_V0:
			if (dataLength == SIZEOF_ADV_PACKET_JOIN_ME)
   1befa:	2a1f      	cmp	r2, #31
   1befc:	d000      	beq.n	1bf00 <main+0xa08>
   1befe:	e5f8      	b.n	1baf2 <main+0x5fa>
	//First, look if a packet from this node is already in the buffer, if yes, we use this space
	for (int i = 0; i < joinMePacketBuffer->_numElements; i++)
	{
		targetBuffer = (joinMeBufferPacket*) joinMePacketBuffer->PeekItemAt(i);

		if (packet->payload.sender == targetBuffer->payload.sender)
   1bf00:	2500      	movs	r5, #0
   1bf02:	1c2f      	adds	r7, r5, #0
joinMeBufferPacket* Node::findTargetBuffer(advPacketJoinMeV0* packet)
{
	joinMeBufferPacket* targetBuffer = NULL;

	//First, look if a packet from this node is already in the buffer, if yes, we use this space
	for (int i = 0; i < joinMePacketBuffer->_numElements; i++)
   1bf04:	6933      	ldr	r3, [r6, #16]
   1bf06:	9304      	str	r3, [sp, #16]
   1bf08:	8a1b      	ldrh	r3, [r3, #16]
   1bf0a:	9305      	str	r3, [sp, #20]
	{
		targetBuffer = (joinMeBufferPacket*) joinMePacketBuffer->PeekItemAt(i);

		if (packet->payload.sender == targetBuffer->payload.sender)
   1bf0c:	8ba3      	ldrh	r3, [r4, #28]
   1bf0e:	9306      	str	r3, [sp, #24]
joinMeBufferPacket* Node::findTargetBuffer(advPacketJoinMeV0* packet)
{
	joinMeBufferPacket* targetBuffer = NULL;

	//First, look if a packet from this node is already in the buffer, if yes, we use this space
	for (int i = 0; i < joinMePacketBuffer->_numElements; i++)
   1bf10:	9b05      	ldr	r3, [sp, #20]
   1bf12:	429d      	cmp	r5, r3
   1bf14:	da0a      	bge.n	1bf2c <main+0xa34>
	{
		targetBuffer = (joinMeBufferPacket*) joinMePacketBuffer->PeekItemAt(i);
   1bf16:	b2a9      	uxth	r1, r5
   1bf18:	9804      	ldr	r0, [sp, #16]
   1bf1a:	f003 fdb1 	bl	1fa80 <_ZN12SimpleBuffer10PeekItemAtEt>

		if (packet->payload.sender == targetBuffer->payload.sender)
   1bf1e:	9a06      	ldr	r2, [sp, #24]
   1bf20:	8a03      	ldrh	r3, [r0, #16]
	joinMeBufferPacket* targetBuffer = NULL;

	//First, look if a packet from this node is already in the buffer, if yes, we use this space
	for (int i = 0; i < joinMePacketBuffer->_numElements; i++)
	{
		targetBuffer = (joinMeBufferPacket*) joinMePacketBuffer->PeekItemAt(i);
   1bf22:	1c07      	adds	r7, r0, #0

		if (packet->payload.sender == targetBuffer->payload.sender)
   1bf24:	4293      	cmp	r3, r2
   1bf26:	d058      	beq.n	1bfda <main+0xae2>
joinMeBufferPacket* Node::findTargetBuffer(advPacketJoinMeV0* packet)
{
	joinMeBufferPacket* targetBuffer = NULL;

	//First, look if a packet from this node is already in the buffer, if yes, we use this space
	for (int i = 0; i < joinMePacketBuffer->_numElements; i++)
   1bf28:	3501      	adds	r5, #1
   1bf2a:	e7f1      	b.n	1bf10 <main+0xa18>
   1bf2c:	1c3d      	adds	r5, r7, #0
   1bf2e:	2700      	movs	r7, #0
			return targetBuffer;
		}
	}

	//Next, we look if there's an empty space
	for (int i = 0; i < joinMePacketBuffer->_numElements; i++)
   1bf30:	9b05      	ldr	r3, [sp, #20]
   1bf32:	429f      	cmp	r7, r3
   1bf34:	d009      	beq.n	1bf4a <main+0xa52>
	{
		if(((joinMeBufferPacket*) joinMePacketBuffer->PeekItemAt(i))->payload.sender == 0){
   1bf36:	b2b9      	uxth	r1, r7
   1bf38:	9804      	ldr	r0, [sp, #16]
   1bf3a:	f003 fda1 	bl	1fa80 <_ZN12SimpleBuffer10PeekItemAtEt>
   1bf3e:	8a03      	ldrh	r3, [r0, #16]
   1bf40:	2b00      	cmp	r3, #0
   1bf42:	d100      	bne.n	1bf46 <main+0xa4e>
   1bf44:	1c05      	adds	r5, r0, #0
			return targetBuffer;
		}
	}

	//Next, we look if there's an empty space
	for (int i = 0; i < joinMePacketBuffer->_numElements; i++)
   1bf46:	3701      	adds	r7, #1
   1bf48:	e7f2      	b.n	1bf30 <main+0xa38>
   1bf4a:	1e2f      	subs	r7, r5, #0
		if(((joinMeBufferPacket*) joinMePacketBuffer->PeekItemAt(i))->payload.sender == 0){
			targetBuffer = (joinMeBufferPacket*) joinMePacketBuffer->PeekItemAt(i);
		}
	}

	if(targetBuffer != NULL){
   1bf4c:	d145      	bne.n	1bfda <main+0xae2>
   1bf4e:	2301      	movs	r3, #1
   1bf50:	425b      	negs	r3, r3
   1bf52:	9306      	str	r3, [sp, #24]
		return targetBuffer;
	}

	//Next, we can overwrite the oldest packet that we saved from our own cluster
	u32 oldestTimestamp = UINT32_MAX;
	for (int i = 0; i < joinMePacketBuffer->_numElements; i++)
   1bf54:	9b05      	ldr	r3, [sp, #20]
   1bf56:	429f      	cmp	r7, r3
   1bf58:	d012      	beq.n	1bf80 <main+0xa88>
	{
		joinMeBufferPacket* tmpPacket = (joinMeBufferPacket*) joinMePacketBuffer->PeekItemAt(i);
   1bf5a:	b2b9      	uxth	r1, r7
   1bf5c:	9804      	ldr	r0, [sp, #16]
   1bf5e:	f003 fd8f 	bl	1fa80 <_ZN12SimpleBuffer10PeekItemAtEt>

		if(tmpPacket->payload.clusterId == clusterId && tmpPacket->receivedTimeDs < oldestTimestamp){
   1bf62:	8a83      	ldrh	r3, [r0, #20]
   1bf64:	8a42      	ldrh	r2, [r0, #18]
   1bf66:	041b      	lsls	r3, r3, #16
   1bf68:	4313      	orrs	r3, r2
   1bf6a:	6ff2      	ldr	r2, [r6, #124]	; 0x7c
   1bf6c:	4293      	cmp	r3, r2
   1bf6e:	d105      	bne.n	1bf7c <main+0xa84>
   1bf70:	68c3      	ldr	r3, [r0, #12]
   1bf72:	9a06      	ldr	r2, [sp, #24]
   1bf74:	4293      	cmp	r3, r2
   1bf76:	d201      	bcs.n	1bf7c <main+0xa84>
   1bf78:	1c05      	adds	r5, r0, #0
   1bf7a:	9306      	str	r3, [sp, #24]
		return targetBuffer;
	}

	//Next, we can overwrite the oldest packet that we saved from our own cluster
	u32 oldestTimestamp = UINT32_MAX;
	for (int i = 0; i < joinMePacketBuffer->_numElements; i++)
   1bf7c:	3701      	adds	r7, #1
   1bf7e:	e7e9      	b.n	1bf54 <main+0xa5c>
   1bf80:	1e2f      	subs	r7, r5, #0
			oldestTimestamp = tmpPacket->receivedTimeDs;
			targetBuffer = tmpPacket;
		}
	}

	if(targetBuffer != NULL){
   1bf82:	d12a      	bne.n	1bfda <main+0xae2>
   1bf84:	2301      	movs	r3, #1
   1bf86:	425b      	negs	r3, r3
   1bf88:	9306      	str	r3, [sp, #24]
	}

	//If there's still no space, we overwrite the oldest packet that we received, this will not fail
	//TODO: maybe do not use oldest one but worst candidate?? Use clusterScore on all packets to find the least interesting
	oldestTimestamp = UINT32_MAX;
	for (int i = 0; i < joinMePacketBuffer->_numElements; i++)
   1bf8a:	9b05      	ldr	r3, [sp, #20]
   1bf8c:	429f      	cmp	r7, r3
   1bf8e:	d021      	beq.n	1bfd4 <main+0xadc>
	{
		joinMeBufferPacket* tmpPacket = (joinMeBufferPacket*) joinMePacketBuffer->PeekItemAt(i);
   1bf90:	b2b9      	uxth	r1, r7
   1bf92:	9804      	ldr	r0, [sp, #16]
   1bf94:	f003 fd74 	bl	1fa80 <_ZN12SimpleBuffer10PeekItemAtEt>

		if(tmpPacket->receivedTimeDs < oldestTimestamp){
   1bf98:	9a06      	ldr	r2, [sp, #24]
   1bf9a:	68c3      	ldr	r3, [r0, #12]
   1bf9c:	4293      	cmp	r3, r2
   1bf9e:	d201      	bcs.n	1bfa4 <main+0xaac>
   1bfa0:	1c05      	adds	r5, r0, #0
   1bfa2:	9306      	str	r3, [sp, #24]
	}

	//If there's still no space, we overwrite the oldest packet that we received, this will not fail
	//TODO: maybe do not use oldest one but worst candidate?? Use clusterScore on all packets to find the least interesting
	oldestTimestamp = UINT32_MAX;
	for (int i = 0; i < joinMePacketBuffer->_numElements; i++)
   1bfa4:	3701      	adds	r7, #1
   1bfa6:	e7f0      	b.n	1bf8a <main+0xa92>
   1bfa8:	000228be 	.word	0x000228be
   1bfac:	00001524 	.word	0x00001524
   1bfb0:	2000358a 	.word	0x2000358a
   1bfb4:	200033b0 	.word	0x200033b0
   1bfb8:	200033a4 	.word	0x200033a4
   1bfbc:	200033b4 	.word	0x200033b4
   1bfc0:	20003390 	.word	0x20003390
   1bfc4:	2000357e 	.word	0x2000357e
   1bfc8:	2000353c 	.word	0x2000353c
   1bfcc:	200031d0 	.word	0x200031d0
   1bfd0:	200033e0 	.word	0x200033e0
   1bfd4:	1e2f      	subs	r7, r5, #0

				//Look through the buffer and determine a space where we can put the packet in
				joinMeBufferPacket* targetBuffer = findTargetBuffer(packet);

				//Now, we have the space for our packet and we fill it with the latest information
				if (targetBuffer != NULL)
   1bfd6:	d100      	bne.n	1bfda <main+0xae2>
   1bfd8:	e58b      	b.n	1baf2 <main+0x5fa>
				{
					memcpy(targetBuffer->bleAddress, bleEvent->evt.gap_evt.params.connected.peer_addr.addr, BLE_GAP_ADDR_LEN);
   1bfda:	4917      	ldr	r1, [pc, #92]	; (1c038 <main+0xb40>)
   1bfdc:	2206      	movs	r2, #6
   1bfde:	3109      	adds	r1, #9
   1bfe0:	1c78      	adds	r0, r7, #1
   1bfe2:	f005 fb17 	bl	21614 <memcpy>
					targetBuffer->bleAddressType = bleEvent->evt.gap_evt.params.connected.peer_addr.addr_type;
   1bfe6:	7a23      	ldrb	r3, [r4, #8]
   1bfe8:	703b      	strb	r3, [r7, #0]

					targetBuffer->payload.clusterId = packet->payload.clusterId;
   1bfea:	8c23      	ldrh	r3, [r4, #32]
   1bfec:	8be2      	ldrh	r2, [r4, #30]
   1bfee:	041b      	lsls	r3, r3, #16
   1bff0:	4313      	orrs	r3, r2
   1bff2:	827b      	strh	r3, [r7, #18]
   1bff4:	0c1b      	lsrs	r3, r3, #16
   1bff6:	82bb      	strh	r3, [r7, #20]
					targetBuffer->payload.clusterSize = packet->payload.clusterSize;
   1bff8:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   1bffa:	82fb      	strh	r3, [r7, #22]
					targetBuffer->payload.freeInConnections = packet->payload.freeInConnections;
   1bffc:	4b0e      	ldr	r3, [pc, #56]	; (1c038 <main+0xb40>)
   1bffe:	1d5a      	adds	r2, r3, #5
   1c000:	2307      	movs	r3, #7
   1c002:	7fd1      	ldrb	r1, [r2, #31]
					targetBuffer->payload.freeOutConnections = packet->payload.freeOutConnections;
   1c004:	7fd2      	ldrb	r2, [r2, #31]
					memcpy(targetBuffer->bleAddress, bleEvent->evt.gap_evt.params.connected.peer_addr.addr, BLE_GAP_ADDR_LEN);
					targetBuffer->bleAddressType = bleEvent->evt.gap_evt.params.connected.peer_addr.addr_type;

					targetBuffer->payload.clusterId = packet->payload.clusterId;
					targetBuffer->payload.clusterSize = packet->payload.clusterSize;
					targetBuffer->payload.freeInConnections = packet->payload.freeInConnections;
   1c006:	4019      	ands	r1, r3
   1c008:	1c08      	adds	r0, r1, #0
   1c00a:	7e39      	ldrb	r1, [r7, #24]
					targetBuffer->payload.freeOutConnections = packet->payload.freeOutConnections;
   1c00c:	08d2      	lsrs	r2, r2, #3
					memcpy(targetBuffer->bleAddress, bleEvent->evt.gap_evt.params.connected.peer_addr.addr, BLE_GAP_ADDR_LEN);
					targetBuffer->bleAddressType = bleEvent->evt.gap_evt.params.connected.peer_addr.addr_type;

					targetBuffer->payload.clusterId = packet->payload.clusterId;
					targetBuffer->payload.clusterSize = packet->payload.clusterSize;
					targetBuffer->payload.freeInConnections = packet->payload.freeInConnections;
   1c00e:	4399      	bics	r1, r3
					targetBuffer->payload.freeOutConnections = packet->payload.freeOutConnections;
   1c010:	4301      	orrs	r1, r0
   1c012:	00d2      	lsls	r2, r2, #3
   1c014:	400b      	ands	r3, r1
   1c016:	4313      	orrs	r3, r2
   1c018:	763b      	strb	r3, [r7, #24]
					targetBuffer->payload.sender = packet->payload.sender;
   1c01a:	8ba3      	ldrh	r3, [r4, #28]
   1c01c:	823b      	strh	r3, [r7, #16]
					targetBuffer->payload.meshWriteHandle = packet->payload.meshWriteHandle;
   1c01e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
   1c020:	83fb      	strh	r3, [r7, #30]
					targetBuffer->payload.ackField = packet->payload.ackField;
   1c022:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   1c024:	623b      	str	r3, [r7, #32]
					targetBuffer->connectable = bleEvent->evt.gap_evt.params.adv_report.type;
   1c026:	7c23      	ldrb	r3, [r4, #16]
   1c028:	075b      	lsls	r3, r3, #29
   1c02a:	0f9b      	lsrs	r3, r3, #30
   1c02c:	71fb      	strb	r3, [r7, #7]
					targetBuffer->rssi = bleEvent->evt.gap_evt.params.adv_report.rssi;
   1c02e:	7be3      	ldrb	r3, [r4, #15]
   1c030:	723b      	strb	r3, [r7, #8]
					targetBuffer->receivedTimeDs = appTimerDs;
   1c032:	6e73      	ldr	r3, [r6, #100]	; 0x64
   1c034:	60fb      	str	r3, [r7, #12]
   1c036:	e55c      	b.n	1baf2 <main+0x5fa>
   1c038:	200032bc 	.word	0x200032bc

0001c03c <is_page_erase_required>:
#include <stdint.h>
#include "nrf.h"

static __INLINE uint16_t pstorage_flash_page_size()
{
  return (uint16_t)NRF_FICR->CODEPAGESIZE;
   1c03c:	2280      	movs	r2, #128	; 0x80
   1c03e:	0552      	lsls	r2, r2, #21
   1c040:	6911      	ldr	r1, [r2, #16]
static bool is_page_erase_required(void)
{
    bool ret;
    
    const cmd_queue_element_t * p_cmd                      = &m_cmd_queue.cmd[m_cmd_queue.rp];
    const pstorage_block_t      cmd_block_id               = p_cmd->storage_addr.block_id;        
   1c042:	2214      	movs	r2, #20
 *
 * @retval true  If page erase is required.
 * @retval false If page erase is not required. 
 */
static bool is_page_erase_required(void)
{
   1c044:	b508      	push	{r3, lr}
    bool ret;
    
    const cmd_queue_element_t * p_cmd                      = &m_cmd_queue.cmd[m_cmd_queue.rp];
   1c046:	480e      	ldr	r0, [pc, #56]	; (1c080 <is_page_erase_required+0x44>)
    const pstorage_block_t      cmd_block_id               = p_cmd->storage_addr.block_id;        
    const uint32_t              id_last_page_to_be_cleared = (cmd_block_id + p_cmd->size + 
                                                             p_cmd->offset - 1u) / 
   1c048:	b289      	uxth	r1, r1
 */
static bool is_page_erase_required(void)
{
    bool ret;
    
    const cmd_queue_element_t * p_cmd                      = &m_cmd_queue.cmd[m_cmd_queue.rp];
   1c04a:	7803      	ldrb	r3, [r0, #0]
    const pstorage_block_t      cmd_block_id               = p_cmd->storage_addr.block_id;        
   1c04c:	4353      	muls	r3, r2
   1c04e:	18c3      	adds	r3, r0, r3
   1c050:	691a      	ldr	r2, [r3, #16]
   1c052:	1e50      	subs	r0, r2, #1
    const uint32_t              id_last_page_to_be_cleared = (cmd_block_id + p_cmd->size + 
   1c054:	88da      	ldrh	r2, [r3, #6]
   1c056:	891b      	ldrh	r3, [r3, #8]
   1c058:	1880      	adds	r0, r0, r2
                                                             p_cmd->offset - 1u) / 
   1c05a:	18c0      	adds	r0, r0, r3
{
    bool ret;
    
    const cmd_queue_element_t * p_cmd                      = &m_cmd_queue.cmd[m_cmd_queue.rp];
    const pstorage_block_t      cmd_block_id               = p_cmd->storage_addr.block_id;        
    const uint32_t              id_last_page_to_be_cleared = (cmd_block_id + p_cmd->size + 
   1c05c:	f006 f80c 	bl	22078 <__aeabi_uidiv>
                                                             PSTORAGE_FLASH_PAGE_SIZE;

    // True if:
    // - current page is not the last page OR
    // - current page is the last page AND no tail exists
    if ((m_current_page_id < id_last_page_to_be_cleared) ||
   1c060:	4a08      	ldr	r2, [pc, #32]	; (1c084 <is_page_erase_required+0x48>)
{
    bool ret;
    
    const cmd_queue_element_t * p_cmd                      = &m_cmd_queue.cmd[m_cmd_queue.rp];
    const pstorage_block_t      cmd_block_id               = p_cmd->storage_addr.block_id;        
    const uint32_t              id_last_page_to_be_cleared = (cmd_block_id + p_cmd->size + 
   1c062:	1c03      	adds	r3, r0, #0
                                                             PSTORAGE_FLASH_PAGE_SIZE;

    // True if:
    // - current page is not the last page OR
    // - current page is the last page AND no tail exists
    if ((m_current_page_id < id_last_page_to_be_cleared) ||
   1c064:	6812      	ldr	r2, [r2, #0]
        ((m_current_page_id == id_last_page_to_be_cleared) && (m_tail_word_size == 0)))         
    {
        ret = true;
   1c066:	2001      	movs	r0, #1
                                                             PSTORAGE_FLASH_PAGE_SIZE;

    // True if:
    // - current page is not the last page OR
    // - current page is the last page AND no tail exists
    if ((m_current_page_id < id_last_page_to_be_cleared) ||
   1c068:	429a      	cmp	r2, r3
   1c06a:	d307      	bcc.n	1c07c <is_page_erase_required+0x40>
    {
        ret = true;
    }
    else
    {
        ret = false;
   1c06c:	2000      	movs	r0, #0
                                                             PSTORAGE_FLASH_PAGE_SIZE;

    // True if:
    // - current page is not the last page OR
    // - current page is the last page AND no tail exists
    if ((m_current_page_id < id_last_page_to_be_cleared) ||
   1c06e:	429a      	cmp	r2, r3
   1c070:	d104      	bne.n	1c07c <is_page_erase_required+0x40>
        ((m_current_page_id == id_last_page_to_be_cleared) && (m_tail_word_size == 0)))         
   1c072:	4b05      	ldr	r3, [pc, #20]	; (1c088 <is_page_erase_required+0x4c>)
   1c074:	681b      	ldr	r3, [r3, #0]
   1c076:	4258      	negs	r0, r3
   1c078:	4158      	adcs	r0, r3
   1c07a:	b2c0      	uxtb	r0, r0
    {
        ret = false;
    }
    
    return ret;
}
   1c07c:	bd08      	pop	{r3, pc}
   1c07e:	46c0      	nop			; (mov r8, r8)
   1c080:	200033e0 	.word	0x200033e0
   1c084:	200035ac 	.word	0x200035ac
   1c088:	20003318 	.word	0x20003318

0001c08c <sd_flash_page_erase>:
* @retval ::NRF_ERROR_INVALID_ADDR  Tried to erase to a non existing flash page.
* @retval ::NRF_ERROR_BUSY          The previous command has not yet completed.
* @retval ::NRF_ERROR_FORBIDDEN     Tried to erase a protected page.
* @retval ::NRF_SUCCESS             The command was accepted.
*/
SVCALL(SD_FLASH_PAGE_ERASE, uint32_t, sd_flash_page_erase(uint32_t page_number));
   1c08c:	df28      	svc	40	; 0x28
   1c08e:	4770      	bx	lr

0001c090 <sd_flash_write>:
* @retval ::NRF_ERROR_BUSY           The previous command has not yet completed.
* @retval ::NRF_ERROR_INVALID_LENGTH Size was 0, or higher than the maximum allowed size.
* @retval ::NRF_ERROR_FORBIDDEN      Tried to write to or read from protected location.
* @retval ::NRF_SUCCESS              The command was accepted.
*/
SVCALL(SD_FLASH_WRITE, uint32_t, sd_flash_write(uint32_t * const p_dst, uint32_t const * const p_src, uint32_t size));
   1c090:	df29      	svc	41	; 0x29
   1c092:	4770      	bx	lr

0001c094 <softdevice_fault_handler>:
 * @param[in] pc    The program counter of the instruction that triggered the fault.
 * @param[in] info  Optional additional information regarding the fault. Refer to each fault
 *                  identifier for details.
 */
void softdevice_fault_handler(uint32_t id, uint32_t pc, uint32_t info)
{
   1c094:	b508      	push	{r3, lr}
	}

	//Called when the softdevice crashes
	void app_error_fault_handler(uint32_t id, uint32_t pc, uint32_t info)
	{
		keepId = id;
   1c096:	4b0e      	ldr	r3, [pc, #56]	; (1c0d0 <softdevice_fault_handler+0x3c>)
   1c098:	6018      	str	r0, [r3, #0]
		keepPc = pc;
   1c09a:	4b0e      	ldr	r3, [pc, #56]	; (1c0d4 <softdevice_fault_handler+0x40>)
   1c09c:	6019      	str	r1, [r3, #0]
		keepInfo = info;
   1c09e:	4b0e      	ldr	r3, [pc, #56]	; (1c0d8 <softdevice_fault_handler+0x44>)
   1c0a0:	601a      	str	r2, [r3, #0]

		if(Config->debugMode) while(1){
   1c0a2:	f004 fec1 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1c0a6:	78c3      	ldrb	r3, [r0, #3]
   1c0a8:	2b00      	cmp	r3, #0
   1c0aa:	d00f      	beq.n	1c0cc <softdevice_fault_handler+0x38>
#elif defined ( __GNUC__ )

static void __INLINE nrf_delay_us(uint32_t volatile number_of_us) __attribute__((always_inline));
static void __INLINE nrf_delay_us(uint32_t volatile number_of_us)
{
register uint32_t delay __ASM ("r0") = number_of_us;
   1c0ac:	480b      	ldr	r0, [pc, #44]	; (1c0dc <softdevice_fault_handler+0x48>)
#endif
    " BNE 1b\n"
#ifdef NRF51
    ".syntax divided\n"
#endif
    : "+r" (delay));
   1c0ae:	3801      	subs	r0, #1
   1c0b0:	46c0      	nop			; (mov r8, r8)
   1c0b2:	46c0      	nop			; (mov r8, r8)
   1c0b4:	46c0      	nop			; (mov r8, r8)
   1c0b6:	46c0      	nop			; (mov r8, r8)
   1c0b8:	46c0      	nop			; (mov r8, r8)
   1c0ba:	46c0      	nop			; (mov r8, r8)
   1c0bc:	46c0      	nop			; (mov r8, r8)
   1c0be:	46c0      	nop			; (mov r8, r8)
   1c0c0:	46c0      	nop			; (mov r8, r8)
   1c0c2:	46c0      	nop			; (mov r8, r8)
   1c0c4:	46c0      	nop			; (mov r8, r8)
   1c0c6:	46c0      	nop			; (mov r8, r8)
   1c0c8:	d1f1      	bne.n	1c0ae <softdevice_fault_handler+0x1a>
   1c0ca:	e7ef      	b.n	1c0ac <softdevice_fault_handler+0x18>
			nrf_delay_us(50000);
		}
		else NVIC_SystemReset();
   1c0cc:	f004 fe9e 	bl	20e0c <NVIC_SystemReset.lto_priv.72>
   1c0d0:	2000332c 	.word	0x2000332c
   1c0d4:	20003334 	.word	0x20003334
   1c0d8:	20003320 	.word	0x20003320
   1c0dc:	0000c350 	.word	0x0000c350

0001c0e0 <sd_ble_evt_get.lto_priv.135>:
 * @retval ::NRF_SUCCESS Event pulled and stored into the supplied buffer.
 * @retval ::NRF_ERROR_INVALID_ADDR Invalid or not sufficiently aligned pointer supplied.
 * @retval ::NRF_ERROR_NOT_FOUND No events ready to be pulled.
 * @retval ::NRF_ERROR_DATA_SIZE Event ready but could not fit into the supplied buffer.
 */
SVCALL(SD_BLE_EVT_GET, uint32_t, sd_ble_evt_get(uint8_t *p_dest, uint16_t *p_len));
   1c0e0:	df61      	svc	97	; 0x61
   1c0e2:	4770      	bx	lr

0001c0e4 <sd_softdevice_enable.lto_priv.124>:
 * @retval ::NRF_SUCCESS
 * @retval ::NRF_ERROR_INVALID_STATE SoftDevice is already enabled, and the clock source and fault handler cannot be updated.
 * @retval ::NRF_ERROR_SDM_INCORRECT_INTERRUPT_CONFIGURATION SoftDevice interrupt is already enabled, or an enabled interrupt has an illegal priority level.
 * @retval ::NRF_ERROR_SDM_LFCLK_SOURCE_UNKNOWN Unknown low frequency clock source selected.
 */
SVCALL(SD_SOFTDEVICE_ENABLE, uint32_t, sd_softdevice_enable(nrf_clock_lf_cfg_t const * p_clock_lf_cfg, nrf_fault_handler_t fault_handler));
   1c0e4:	df10      	svc	16
   1c0e6:	4770      	bx	lr

0001c0e8 <sd_evt_get.lto_priv.134>:
 * @param[out] p_evt_id Set to one of the values in @ref NRF_SOC_EVTS, if any events are pending.
 *
 * @retval ::NRF_SUCCESS An event was pending. The event id is written in the p_evt_id parameter.
 * @retval ::NRF_ERROR_NOT_FOUND No pending events. 
 */
SVCALL(SD_EVT_GET, uint32_t, sd_evt_get(uint32_t * p_evt_id));
   1c0e8:	df52      	svc	82	; 0x52
   1c0ea:	4770      	bx	lr

0001c0ec <RTC1_IRQHandler>:
/**@brief Function for handling the RTC1 interrupt.
 *
 * @details Checks for timeouts, and executes timeout handlers for expired timers.
 */
void RTC1_IRQHandler(void)
{
   1c0ec:	b570      	push	{r4, r5, r6, lr}
    // Clear all events (also unexpected ones)
    NRF_RTC1->EVENTS_COMPARE[0] = 0;
   1c0ee:	2400      	movs	r4, #0
   1c0f0:	4b23      	ldr	r3, [pc, #140]	; (1c180 <RTC1_IRQHandler+0x94>)
   1c0f2:	645c      	str	r4, [r3, #68]	; 0x44
    NRF_RTC1->EVENTS_COMPARE[1] = 0;
   1c0f4:	649c      	str	r4, [r3, #72]	; 0x48
    NRF_RTC1->EVENTS_COMPARE[2] = 0;
   1c0f6:	64dc      	str	r4, [r3, #76]	; 0x4c
    NRF_RTC1->EVENTS_COMPARE[3] = 0;
   1c0f8:	651c      	str	r4, [r3, #80]	; 0x50
    NRF_RTC1->EVENTS_TICK       = 0;
   1c0fa:	605c      	str	r4, [r3, #4]
    NRF_RTC1->EVENTS_OVRFLW     = 0;
   1c0fc:	609c      	str	r4, [r3, #8]
/**@brief Function for checking for expired timers.
 */
static void timer_timeouts_check(void)
{
    // Handle expired of timer 
    if (mp_timer_id_head != NULL)
   1c0fe:	4b21      	ldr	r3, [pc, #132]	; (1c184 <RTC1_IRQHandler+0x98>)
   1c100:	681b      	ldr	r3, [r3, #0]
   1c102:	42a3      	cmp	r3, r4
   1c104:	d03b      	beq.n	1c17e <RTC1_IRQHandler+0x92>
 *
 * @return     Current value of the RTC1 counter.
 */
static __INLINE uint32_t rtc1_counter_get(void)
{
    return NRF_RTC1->COUNTER;
   1c106:	4920      	ldr	r1, [pc, #128]	; (1c188 <RTC1_IRQHandler+0x9c>)
   1c108:	4a20      	ldr	r2, [pc, #128]	; (1c18c <RTC1_IRQHandler+0xa0>)
   1c10a:	588a      	ldr	r2, [r1, r2]

        // Initialize actual elapsed ticks being consumed to 0.
        ticks_expired = 0;

        // ticks_elapsed is collected here, job will use it.
        ticks_elapsed = ticks_diff_get(rtc1_counter_get(), m_ticks_latest);
   1c10c:	4920      	ldr	r1, [pc, #128]	; (1c190 <RTC1_IRQHandler+0xa4>)
 *
 * @return     Number of ticks elapsed from ticks_old to ticks_now.
 */
static __INLINE uint32_t ticks_diff_get(uint32_t ticks_now, uint32_t ticks_old)
{
    return ((ticks_now - ticks_old) & MAX_RTC_COUNTER_VAL);
   1c10e:	680d      	ldr	r5, [r1, #0]
   1c110:	1b55      	subs	r5, r2, r5
   1c112:	022d      	lsls	r5, r5, #8
   1c114:	0a2d      	lsrs	r5, r5, #8

        // Expire all timers within ticks_elapsed and collect ticks_expired.
        while (p_timer != NULL)
        {
            // Do nothing if timer did not expire.
            if (ticks_elapsed < p_timer->ticks_to_expire)
   1c116:	681a      	ldr	r2, [r3, #0]
   1c118:	4295      	cmp	r5, r2
   1c11a:	d31c      	bcc.n	1c156 <RTC1_IRQHandler+0x6a>
            {
                break;
            }

            // Decrement ticks_elapsed and collect expired ticks.
            ticks_elapsed -= p_timer->ticks_to_expire;
   1c11c:	1aad      	subs	r5, r5, r2
            ticks_expired += p_timer->ticks_to_expire;
   1c11e:	18a4      	adds	r4, r4, r2
            // Move to next timer.
            p_previous_timer = p_timer;
            p_timer = p_timer->next;

            // Execute Task.
            if (p_previous_timer->is_running)
   1c120:	7c1a      	ldrb	r2, [r3, #16]
            ticks_elapsed -= p_timer->ticks_to_expire;
            ticks_expired += p_timer->ticks_to_expire;

            // Move to next timer.
            p_previous_timer = p_timer;
            p_timer = p_timer->next;
   1c122:	69de      	ldr	r6, [r3, #28]

            // Execute Task.
            if (p_previous_timer->is_running)
   1c124:	2a00      	cmp	r2, #0
   1c126:	d012      	beq.n	1c14e <RTC1_IRQHandler+0x62>
            {
                p_previous_timer->is_running = false;
   1c128:	2200      	movs	r2, #0
   1c12a:	741a      	strb	r2, [r3, #16]
 *
 * @param[in]  p_timer   Pointer to expired timer.
 */
static void timeout_handler_exec(timer_node_t * p_timer)
{
    if (m_evt_schedule_func != NULL)
   1c12c:	4a19      	ldr	r2, [pc, #100]	; (1c194 <RTC1_IRQHandler+0xa8>)
   1c12e:	6812      	ldr	r2, [r2, #0]
   1c130:	2a00      	cmp	r2, #0
   1c132:	d009      	beq.n	1c148 <RTC1_IRQHandler+0x5c>
    {
        uint32_t err_code = m_evt_schedule_func(p_timer->p_timeout_handler, p_timer->p_context);
   1c134:	6958      	ldr	r0, [r3, #20]
   1c136:	6999      	ldr	r1, [r3, #24]
   1c138:	4790      	blx	r2
        APP_ERROR_CHECK(err_code);
   1c13a:	2800      	cmp	r0, #0
   1c13c:	d007      	beq.n	1c14e <RTC1_IRQHandler+0x62>
   1c13e:	2166      	movs	r1, #102	; 0x66
   1c140:	4a15      	ldr	r2, [pc, #84]	; (1c198 <RTC1_IRQHandler+0xac>)
   1c142:	31ff      	adds	r1, #255	; 0xff
   1c144:	f001 f95e 	bl	1d404 <app_error_handler>
    }
    else
    {
        p_timer->p_timeout_handler(p_timer->p_context);
   1c148:	695a      	ldr	r2, [r3, #20]
   1c14a:	6998      	ldr	r0, [r3, #24]
   1c14c:	4790      	blx	r2

        // Auto variable containing the head of timers expiring.
        p_timer = mp_timer_id_head;

        // Expire all timers within ticks_elapsed and collect ticks_expired.
        while (p_timer != NULL)
   1c14e:	2e00      	cmp	r6, #0
   1c150:	d001      	beq.n	1c156 <RTC1_IRQHandler+0x6a>
   1c152:	1c33      	adds	r3, r6, #0
   1c154:	e7df      	b.n	1c116 <RTC1_IRQHandler+0x2a>
                timeout_handler_exec(p_previous_timer);
            }
        }

        // Prepare to queue the ticks expired in the m_ticks_elapsed queue.
        if (m_ticks_elapsed_q_read_ind == m_ticks_elapsed_q_write_ind)
   1c156:	4b11      	ldr	r3, [pc, #68]	; (1c19c <RTC1_IRQHandler+0xb0>)
   1c158:	4a11      	ldr	r2, [pc, #68]	; (1c1a0 <RTC1_IRQHandler+0xb4>)
   1c15a:	7819      	ldrb	r1, [r3, #0]
   1c15c:	7813      	ldrb	r3, [r2, #0]
   1c15e:	428b      	cmp	r3, r1
   1c160:	d105      	bne.n	1c16e <RTC1_IRQHandler+0x82>
            // The read index of the queue is equal to the write index. This means the new
            // value of ticks_expired should be stored at a new location in the m_ticks_elapsed
            // queue (which is implemented as a double buffer).

            // Check if there will be a queue overflow.
            if (++m_ticks_elapsed_q_write_ind == CONTEXT_QUEUE_SIZE_MAX)
   1c162:	3301      	adds	r3, #1
   1c164:	b2db      	uxtb	r3, r3
   1c166:	2b02      	cmp	r3, #2
   1c168:	d100      	bne.n	1c16c <RTC1_IRQHandler+0x80>
            {
                // There will be a queue overflow. Hence the write index should point to the start
                // of the queue.
                m_ticks_elapsed_q_write_ind = 0;
   1c16a:	2300      	movs	r3, #0
   1c16c:	7013      	strb	r3, [r2, #0]
            }
        }

        // Queue the ticks expired.
        m_ticks_elapsed[m_ticks_elapsed_q_write_ind] = ticks_expired;
   1c16e:	7813      	ldrb	r3, [r2, #0]
   1c170:	4a0c      	ldr	r2, [pc, #48]	; (1c1a4 <RTC1_IRQHandler+0xb8>)
   1c172:	009b      	lsls	r3, r3, #2
   1c174:	509c      	str	r4, [r3, r2]
  \details Sets the pending bit of an external interrupt.
  \param [in]      IRQn  Interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   1c176:	2280      	movs	r2, #128	; 0x80
   1c178:	4b0b      	ldr	r3, [pc, #44]	; (1c1a8 <RTC1_IRQHandler+0xbc>)
   1c17a:	0352      	lsls	r2, r2, #13
   1c17c:	605a      	str	r2, [r3, #4]
    NRF_RTC1->EVENTS_TICK       = 0;
    NRF_RTC1->EVENTS_OVRFLW     = 0;

    // Check for expired timers
    timer_timeouts_check();
}
   1c17e:	bd70      	pop	{r4, r5, r6, pc}
   1c180:	400110fc 	.word	0x400110fc
   1c184:	20002fdc 	.word	0x20002fdc
   1c188:	40011000 	.word	0x40011000
   1c18c:	00000504 	.word	0x00000504
   1c190:	20003304 	.word	0x20003304
   1c194:	200032b4 	.word	0x200032b4
   1c198:	000228da 	.word	0x000228da
   1c19c:	20003314 	.word	0x20003314
   1c1a0:	200031f4 	.word	0x200031f4
   1c1a4:	20003338 	.word	0x20003338
   1c1a8:	e000e1fc 	.word	0xe000e1fc

0001c1ac <rtc1_stop.lto_priv.118>:
  \details Disables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   1c1ac:	2280      	movs	r2, #128	; 0x80
   1c1ae:	4b19      	ldr	r3, [pc, #100]	; (1c214 <rtc1_stop.lto_priv.118+0x68>)
   1c1b0:	0292      	lsls	r2, r2, #10
   1c1b2:	67da      	str	r2, [r3, #124]	; 0x7c
 */
static void rtc1_stop(void)
{
    NVIC_DisableIRQ(RTC1_IRQn);

    NRF_RTC1->EVTENCLR = RTC_EVTEN_COMPARE0_Msk;
   1c1b4:	21d2      	movs	r1, #210	; 0xd2
   1c1b6:	2280      	movs	r2, #128	; 0x80
   1c1b8:	4b17      	ldr	r3, [pc, #92]	; (1c218 <rtc1_stop.lto_priv.118+0x6c>)
   1c1ba:	0252      	lsls	r2, r2, #9
   1c1bc:	0089      	lsls	r1, r1, #2
   1c1be:	505a      	str	r2, [r3, r1]
    NRF_RTC1->INTENCLR = RTC_INTENSET_COMPARE0_Msk;
   1c1c0:	3940      	subs	r1, #64	; 0x40
   1c1c2:	505a      	str	r2, [r3, r1]

    NRF_RTC1->TASKS_STOP = 1;
   1c1c4:	2101      	movs	r1, #1
   1c1c6:	222f      	movs	r2, #47	; 0x2f
   1c1c8:	6059      	str	r1, [r3, #4]
#elif defined ( __GNUC__ )

static void __INLINE nrf_delay_us(uint32_t volatile number_of_us) __attribute__((always_inline));
static void __INLINE nrf_delay_us(uint32_t volatile number_of_us)
{
register uint32_t delay __ASM ("r0") = number_of_us;
   1c1ca:	1c10      	adds	r0, r2, #0
__ASM volatile (
   1c1cc:	3801      	subs	r0, #1
   1c1ce:	46c0      	nop			; (mov r8, r8)
   1c1d0:	46c0      	nop			; (mov r8, r8)
   1c1d2:	46c0      	nop			; (mov r8, r8)
   1c1d4:	46c0      	nop			; (mov r8, r8)
   1c1d6:	46c0      	nop			; (mov r8, r8)
   1c1d8:	46c0      	nop			; (mov r8, r8)
   1c1da:	46c0      	nop			; (mov r8, r8)
   1c1dc:	46c0      	nop			; (mov r8, r8)
   1c1de:	46c0      	nop			; (mov r8, r8)
   1c1e0:	46c0      	nop			; (mov r8, r8)
   1c1e2:	46c0      	nop			; (mov r8, r8)
   1c1e4:	46c0      	nop			; (mov r8, r8)
   1c1e6:	d1f1      	bne.n	1c1cc <rtc1_stop.lto_priv.118+0x20>
    nrf_delay_us(MAX_RTC_TASKS_DELAY);

    NRF_RTC1->TASKS_CLEAR = 1;
   1c1e8:	6099      	str	r1, [r3, #8]
    m_ticks_latest        = 0;
   1c1ea:	2300      	movs	r3, #0
   1c1ec:	490b      	ldr	r1, [pc, #44]	; (1c21c <rtc1_stop.lto_priv.118+0x70>)
#elif defined ( __GNUC__ )

static void __INLINE nrf_delay_us(uint32_t volatile number_of_us) __attribute__((always_inline));
static void __INLINE nrf_delay_us(uint32_t volatile number_of_us)
{
register uint32_t delay __ASM ("r0") = number_of_us;
   1c1ee:	1c10      	adds	r0, r2, #0
   1c1f0:	600b      	str	r3, [r1, #0]
__ASM volatile (
   1c1f2:	3801      	subs	r0, #1
   1c1f4:	46c0      	nop			; (mov r8, r8)
   1c1f6:	46c0      	nop			; (mov r8, r8)
   1c1f8:	46c0      	nop			; (mov r8, r8)
   1c1fa:	46c0      	nop			; (mov r8, r8)
   1c1fc:	46c0      	nop			; (mov r8, r8)
   1c1fe:	46c0      	nop			; (mov r8, r8)
   1c200:	46c0      	nop			; (mov r8, r8)
   1c202:	46c0      	nop			; (mov r8, r8)
   1c204:	46c0      	nop			; (mov r8, r8)
   1c206:	46c0      	nop			; (mov r8, r8)
   1c208:	46c0      	nop			; (mov r8, r8)
   1c20a:	46c0      	nop			; (mov r8, r8)
   1c20c:	d1f1      	bne.n	1c1f2 <rtc1_stop.lto_priv.118+0x46>
    nrf_delay_us(MAX_RTC_TASKS_DELAY);

    m_rtc1_running = false;
   1c20e:	4a04      	ldr	r2, [pc, #16]	; (1c220 <rtc1_stop.lto_priv.118+0x74>)
   1c210:	7013      	strb	r3, [r2, #0]
}
   1c212:	4770      	bx	lr
   1c214:	e000e104 	.word	0xe000e104
   1c218:	40011000 	.word	0x40011000
   1c21c:	20003304 	.word	0x20003304
   1c220:	20003340 	.word	0x20003340

0001c224 <SWI0_IRQHandler>:
/**@brief Function for handling the SWI interrupt.
 *
 * @details Performs all updates to the timer list.
 */
void SWI_IRQHandler(void)
{
   1c224:	b5f0      	push	{r4, r5, r6, r7, lr}
        }
    }
#endif

    // Back up the previous known tick and previous list head
    ticks_previous    = m_ticks_latest;
   1c226:	48bf      	ldr	r0, [pc, #764]	; (1c524 <SWI0_IRQHandler+0x300>)
 * @return     TRUE if elapsed ticks was read from queue, FALSE otherwise.
 */
static bool elapsed_ticks_acquire(uint32_t * p_ticks_elapsed)
{
    // Pick the elapsed value from queue.
    if (m_ticks_elapsed_q_read_ind != m_ticks_elapsed_q_write_ind)
   1c228:	4abf      	ldr	r2, [pc, #764]	; (1c528 <SWI0_IRQHandler+0x304>)
        }
    }
#endif

    // Back up the previous known tick and previous list head
    ticks_previous    = m_ticks_latest;
   1c22a:	6803      	ldr	r3, [r0, #0]
 * @return     TRUE if elapsed ticks was read from queue, FALSE otherwise.
 */
static bool elapsed_ticks_acquire(uint32_t * p_ticks_elapsed)
{
    // Pick the elapsed value from queue.
    if (m_ticks_elapsed_q_read_ind != m_ticks_elapsed_q_write_ind)
   1c22c:	49bf      	ldr	r1, [pc, #764]	; (1c52c <SWI0_IRQHandler+0x308>)
/**@brief Function for handling the SWI interrupt.
 *
 * @details Performs all updates to the timer list.
 */
void SWI_IRQHandler(void)
{
   1c22e:	b089      	sub	sp, #36	; 0x24
        }
    }
#endif

    // Back up the previous known tick and previous list head
    ticks_previous    = m_ticks_latest;
   1c230:	9304      	str	r3, [sp, #16]
 * @return     TRUE if elapsed ticks was read from queue, FALSE otherwise.
 */
static bool elapsed_ticks_acquire(uint32_t * p_ticks_elapsed)
{
    // Pick the elapsed value from queue.
    if (m_ticks_elapsed_q_read_ind != m_ticks_elapsed_q_write_ind)
   1c232:	7809      	ldrb	r1, [r1, #0]
   1c234:	7813      	ldrb	r3, [r2, #0]
   1c236:	4299      	cmp	r1, r3
   1c238:	d011      	beq.n	1c25e <SWI0_IRQHandler+0x3a>
    {
        // Dequeue elapsed value.
        m_ticks_elapsed_q_read_ind++;
   1c23a:	3301      	adds	r3, #1
   1c23c:	b2db      	uxtb	r3, r3
        if (m_ticks_elapsed_q_read_ind == CONTEXT_QUEUE_SIZE_MAX)
   1c23e:	2b02      	cmp	r3, #2
   1c240:	d100      	bne.n	1c244 <SWI0_IRQHandler+0x20>
        {
            m_ticks_elapsed_q_read_ind = 0;
   1c242:	2300      	movs	r3, #0
   1c244:	7013      	strb	r3, [r2, #0]
        }

        *p_ticks_elapsed = m_ticks_elapsed[m_ticks_elapsed_q_read_ind];
   1c246:	7813      	ldrb	r3, [r2, #0]
   1c248:	4ab9      	ldr	r2, [pc, #740]	; (1c530 <SWI0_IRQHandler+0x30c>)
   1c24a:	009b      	lsls	r3, r3, #2
   1c24c:	5899      	ldr	r1, [r3, r2]

        m_ticks_latest += *p_ticks_elapsed;
   1c24e:	9b04      	ldr	r3, [sp, #16]
   1c250:	18cb      	adds	r3, r1, r3
        m_ticks_latest &= MAX_RTC_COUNTER_VAL;
   1c252:	021b      	lsls	r3, r3, #8
   1c254:	0a1b      	lsrs	r3, r3, #8
   1c256:	6003      	str	r3, [r0, #0]

        return true;
   1c258:	2301      	movs	r3, #1
   1c25a:	9303      	str	r3, [sp, #12]
   1c25c:	e001      	b.n	1c262 <SWI0_IRQHandler+0x3e>
    }
    else
    {
        // No elapsed value in queue.
        *p_ticks_elapsed = 0;
   1c25e:	2100      	movs	r1, #0
        return false;
   1c260:	9103      	str	r1, [sp, #12]
{
    timer_node_t * p_timer_old_head;
    uint8_t        user_id;

    // Remember the old head, so as to decide if new compare needs to be set.
    p_timer_old_head = mp_timer_id_head;
   1c262:	4bb4      	ldr	r3, [pc, #720]	; (1c534 <SWI0_IRQHandler+0x310>)
   1c264:	681b      	ldr	r3, [r3, #0]
   1c266:	9306      	str	r3, [sp, #24]

    user_id = m_user_array_size;
   1c268:	4bb3      	ldr	r3, [pc, #716]	; (1c538 <SWI0_IRQHandler+0x314>)
   1c26a:	781b      	ldrb	r3, [r3, #0]
   1c26c:	9301      	str	r3, [sp, #4]
    while (user_id--)
    {
        timer_user_t * p_user         = &mp_users[user_id];
   1c26e:	4bb3      	ldr	r3, [pc, #716]	; (1c53c <SWI0_IRQHandler+0x318>)
    uint8_t        user_id;

    // Remember the old head, so as to decide if new compare needs to be set.
    p_timer_old_head = mp_timer_id_head;

    user_id = m_user_array_size;
   1c270:	9a01      	ldr	r2, [sp, #4]
    while (user_id--)
    {
        timer_user_t * p_user         = &mp_users[user_id];
   1c272:	681b      	ldr	r3, [r3, #0]
    uint8_t        user_id;

    // Remember the old head, so as to decide if new compare needs to be set.
    p_timer_old_head = mp_timer_id_head;

    user_id = m_user_array_size;
   1c274:	9202      	str	r2, [sp, #8]
    while (user_id--)
    {
        timer_user_t * p_user         = &mp_users[user_id];
   1c276:	9307      	str	r3, [sp, #28]
   1c278:	4baa      	ldr	r3, [pc, #680]	; (1c524 <SWI0_IRQHandler+0x300>)
   1c27a:	681e      	ldr	r6, [r3, #0]
   1c27c:	4bb0      	ldr	r3, [pc, #704]	; (1c540 <SWI0_IRQHandler+0x31c>)
   1c27e:	781b      	ldrb	r3, [r3, #0]
   1c280:	9305      	str	r3, [sp, #20]
   1c282:	9b06      	ldr	r3, [sp, #24]

    // Remember the old head, so as to decide if new compare needs to be set.
    p_timer_old_head = mp_timer_id_head;

    user_id = m_user_array_size;
    while (user_id--)
   1c284:	9802      	ldr	r0, [sp, #8]
   1c286:	3801      	subs	r0, #1
   1c288:	b2c2      	uxtb	r2, r0
   1c28a:	9202      	str	r2, [sp, #8]
   1c28c:	2aff      	cmp	r2, #255	; 0xff
   1c28e:	d02d      	beq.n	1c2ec <SWI0_IRQHandler+0xc8>
    {
        timer_user_t * p_user         = &mp_users[user_id];
   1c290:	9a02      	ldr	r2, [sp, #8]
   1c292:	00d4      	lsls	r4, r2, #3
   1c294:	9a07      	ldr	r2, [sp, #28]
   1c296:	1914      	adds	r4, r2, r4
        uint8_t        user_ops_first = p_user->first;
   1c298:	7822      	ldrb	r2, [r4, #0]
        
        while (user_ops_first != p_user->last)
   1c29a:	7865      	ldrb	r5, [r4, #1]
   1c29c:	4295      	cmp	r5, r2
   1c29e:	d0f1      	beq.n	1c284 <SWI0_IRQHandler+0x60>
        {
            timer_user_op_t * p_user_op = &p_user->p_user_op_queue[user_ops_first];
   1c2a0:	2518      	movs	r5, #24
   1c2a2:	4355      	muls	r5, r2

            // Traverse to next operation in queue.
            user_ops_first++;
            if (user_ops_first == p_user->user_op_queue_size)
   1c2a4:	78a7      	ldrb	r7, [r4, #2]
        while (user_ops_first != p_user->last)
        {
            timer_user_op_t * p_user_op = &p_user->p_user_op_queue[user_ops_first];

            // Traverse to next operation in queue.
            user_ops_first++;
   1c2a6:	3201      	adds	r2, #1
        timer_user_t * p_user         = &mp_users[user_id];
        uint8_t        user_ops_first = p_user->first;
        
        while (user_ops_first != p_user->last)
        {
            timer_user_op_t * p_user_op = &p_user->p_user_op_queue[user_ops_first];
   1c2a8:	6860      	ldr	r0, [r4, #4]

            // Traverse to next operation in queue.
            user_ops_first++;
   1c2aa:	b2d2      	uxtb	r2, r2
            if (user_ops_first == p_user->user_op_queue_size)
            {
                user_ops_first = 0;
   1c2ac:	1abf      	subs	r7, r7, r2
        timer_user_t * p_user         = &mp_users[user_id];
        uint8_t        user_ops_first = p_user->first;
        
        while (user_ops_first != p_user->last)
        {
            timer_user_op_t * p_user_op = &p_user->p_user_op_queue[user_ops_first];
   1c2ae:	1945      	adds	r5, r0, r5

            // Traverse to next operation in queue.
            user_ops_first++;
            if (user_ops_first == p_user->user_op_queue_size)
            {
                user_ops_first = 0;
   1c2b0:	1c38      	adds	r0, r7, #0
   1c2b2:	1e47      	subs	r7, r0, #1
   1c2b4:	41b8      	sbcs	r0, r7
   1c2b6:	4247      	negs	r7, r0
   1c2b8:	403a      	ands	r2, r7
            }

            switch (p_user_op->op_type)
   1c2ba:	782f      	ldrb	r7, [r5, #0]
   1c2bc:	2f02      	cmp	r7, #2
   1c2be:	d002      	beq.n	1c2c6 <SWI0_IRQHandler+0xa2>
   1c2c0:	2f03      	cmp	r7, #3
   1c2c2:	d1ea      	bne.n	1c29a <SWI0_IRQHandler+0x76>
   1c2c4:	e00c      	b.n	1c2e0 <SWI0_IRQHandler+0xbc>
            {
                case TIMER_USER_OP_TYPE_STOP:
                    // Delete node if timer is running.
                    timer_list_remove(p_user_op->p_node);
   1c2c6:	469c      	mov	ip, r3
   1c2c8:	1c1f      	adds	r7, r3, #0
   1c2ca:	686d      	ldr	r5, [r5, #4]

    // Find the timer's position in timer list.
    p_previous = mp_timer_id_head;
    p_current  = p_previous;
    
    while (p_current != NULL)
   1c2cc:	4660      	mov	r0, ip
   1c2ce:	2800      	cmp	r0, #0
   1c2d0:	d0e3      	beq.n	1c29a <SWI0_IRQHandler+0x76>
    {
        if (p_current == p_timer)
   1c2d2:	45ac      	cmp	ip, r5
   1c2d4:	d100      	bne.n	1c2d8 <SWI0_IRQHandler+0xb4>
   1c2d6:	e148      	b.n	1c56a <SWI0_IRQHandler+0x346>
        {
            break;
        }
        p_previous = p_current;
        p_current  = p_current->next;
   1c2d8:	4667      	mov	r7, ip
   1c2da:	69f8      	ldr	r0, [r7, #28]
   1c2dc:	4684      	mov	ip, r0
   1c2de:	e7f5      	b.n	1c2cc <SWI0_IRQHandler+0xa8>
                    timer_list_remove(p_user_op->p_node);
                    break;
                    
                case TIMER_USER_OP_TYPE_STOP_ALL:
                    // Delete list of running timers, and mark all timers as not running.
                    while (mp_timer_id_head != NULL)
   1c2e0:	2b00      	cmp	r3, #0
   1c2e2:	d0da      	beq.n	1c29a <SWI0_IRQHandler+0x76>
                    {
                        timer_node_t * p_head = mp_timer_id_head;

                        p_head->is_running = false;
   1c2e4:	2500      	movs	r5, #0
   1c2e6:	741d      	strb	r5, [r3, #16]
                        mp_timer_id_head    = p_head->next;
   1c2e8:	69db      	ldr	r3, [r3, #28]
   1c2ea:	e7f9      	b.n	1c2e0 <SWI0_IRQHandler+0xbc>
   1c2ec:	4668      	mov	r0, sp
   1c2ee:	4a94      	ldr	r2, [pc, #592]	; (1c540 <SWI0_IRQHandler+0x31c>)
   1c2f0:	7d00      	ldrb	r0, [r0, #20]
   1c2f2:	4d90      	ldr	r5, [pc, #576]	; (1c534 <SWI0_IRQHandler+0x310>)
   1c2f4:	4c8b      	ldr	r4, [pc, #556]	; (1c524 <SWI0_IRQHandler+0x300>)
   1c2f6:	7010      	strb	r0, [r2, #0]

    // Handle list deletions
    compare_update = list_deletions_handler();
    
    // Handle expired timers
    if (ticks_have_elapsed)
   1c2f8:	9a03      	ldr	r2, [sp, #12]
   1c2fa:	602b      	str	r3, [r5, #0]
   1c2fc:	6026      	str	r6, [r4, #0]
   1c2fe:	2a00      	cmp	r2, #0
   1c300:	d106      	bne.n	1c310 <SWI0_IRQHandler+0xec>
            }
        }
    }

    // Detect change in head of the list.
    return (mp_timer_id_head != p_timer_old_head);
   1c302:	9a06      	ldr	r2, [sp, #24]
   1c304:	1a9b      	subs	r3, r3, r2
   1c306:	1e5a      	subs	r2, r3, #1
   1c308:	4193      	sbcs	r3, r2

/**@brief Function for handling changes to the timer list.
 */
static void timer_list_handler(void)
{
    timer_node_t * p_restart_list_head = NULL;
   1c30a:	9a03      	ldr	r2, [sp, #12]
            }
        }
    }

    // Detect change in head of the list.
    return (mp_timer_id_head != p_timer_old_head);
   1c30c:	b2db      	uxtb	r3, r3
   1c30e:	e021      	b.n	1c354 <SWI0_IRQHandler+0x130>

    // Handle list deletions
    compare_update = list_deletions_handler();
    
    // Handle expired timers
    if (ticks_have_elapsed)
   1c310:	2200      	movs	r2, #0
   1c312:	1c16      	adds	r6, r2, #0
                                   uint32_t         ticks_previous,
                                   timer_node_t **  p_restart_list_head)
{
    uint32_t ticks_expired = 0;

    while (mp_timer_id_head != NULL)
   1c314:	2b00      	cmp	r3, #0
   1c316:	d01a      	beq.n	1c34e <SWI0_IRQHandler+0x12a>

        // Auto variable for current timer node.
        p_timer = mp_timer_id_head;

        // Do nothing if timer did not expire 
        if (ticks_elapsed < p_timer->ticks_to_expire)
   1c318:	6818      	ldr	r0, [r3, #0]
   1c31a:	4281      	cmp	r1, r0
   1c31c:	d204      	bcs.n	1c328 <SWI0_IRQHandler+0x104>
        {
            p_timer->ticks_to_expire -= ticks_elapsed;
   1c31e:	1a41      	subs	r1, r0, r1
   1c320:	602b      	str	r3, [r5, #0]
   1c322:	6019      	str	r1, [r3, #0]
    
    // Handle expired timers
    if (ticks_have_elapsed)
    {
        expired_timers_handler(ticks_elapsed, ticks_previous, &p_restart_list_head);
        compare_update = true;
   1c324:	2301      	movs	r3, #1
   1c326:	e015      	b.n	1c354 <SWI0_IRQHandler+0x130>
            p_timer->ticks_to_expire -= ticks_elapsed;
            break;
        }

        // Decrement ticks_elapsed and collect expired ticks.
        ticks_elapsed -= p_timer->ticks_to_expire;
   1c328:	1a09      	subs	r1, r1, r0
        ticks_expired += p_timer->ticks_to_expire;
   1c32a:	1836      	adds	r6, r6, r0

        // Timer expired, set ticks_to_expire zero.
        p_timer->ticks_to_expire = 0;
   1c32c:	2000      	movs	r0, #0
        // Remove the expired timer from head.
        p_timer_expired  = mp_timer_id_head;
        mp_timer_id_head = p_timer->next;

        // Timer will be restarted if periodic.
        if (p_timer->ticks_periodic_interval != 0)
   1c32e:	68df      	ldr	r7, [r3, #12]
        // Decrement ticks_elapsed and collect expired ticks.
        ticks_elapsed -= p_timer->ticks_to_expire;
        ticks_expired += p_timer->ticks_to_expire;

        // Timer expired, set ticks_to_expire zero.
        p_timer->ticks_to_expire = 0;
   1c330:	6018      	str	r0, [r3, #0]

        // Remove the expired timer from head.
        p_timer_expired  = mp_timer_id_head;
        mp_timer_id_head = p_timer->next;
   1c332:	69d8      	ldr	r0, [r3, #28]
   1c334:	4684      	mov	ip, r0

        // Timer will be restarted if periodic.
        if (p_timer->ticks_periodic_interval != 0)
   1c336:	2f00      	cmp	r7, #0
   1c338:	d007      	beq.n	1c34a <SWI0_IRQHandler+0x126>
        {
            p_timer->ticks_at_start       = (ticks_previous + ticks_expired) & MAX_RTC_COUNTER_VAL;
            p_timer->ticks_first_interval = p_timer->ticks_periodic_interval;
            p_timer->next                 = *p_restart_list_head;
   1c33a:	61da      	str	r2, [r3, #28]
   1c33c:	1c1a      	adds	r2, r3, #0
        mp_timer_id_head = p_timer->next;

        // Timer will be restarted if periodic.
        if (p_timer->ticks_periodic_interval != 0)
        {
            p_timer->ticks_at_start       = (ticks_previous + ticks_expired) & MAX_RTC_COUNTER_VAL;
   1c33e:	9804      	ldr	r0, [sp, #16]
            p_timer->ticks_first_interval = p_timer->ticks_periodic_interval;
   1c340:	609f      	str	r7, [r3, #8]
        mp_timer_id_head = p_timer->next;

        // Timer will be restarted if periodic.
        if (p_timer->ticks_periodic_interval != 0)
        {
            p_timer->ticks_at_start       = (ticks_previous + ticks_expired) & MAX_RTC_COUNTER_VAL;
   1c342:	1830      	adds	r0, r6, r0
   1c344:	0200      	lsls	r0, r0, #8
   1c346:	0a00      	lsrs	r0, r0, #8
   1c348:	6058      	str	r0, [r3, #4]
        // Timer expired, set ticks_to_expire zero.
        p_timer->ticks_to_expire = 0;

        // Remove the expired timer from head.
        p_timer_expired  = mp_timer_id_head;
        mp_timer_id_head = p_timer->next;
   1c34a:	4663      	mov	r3, ip
   1c34c:	e7e2      	b.n	1c314 <SWI0_IRQHandler+0xf0>
   1c34e:	4979      	ldr	r1, [pc, #484]	; (1c534 <SWI0_IRQHandler+0x310>)
   1c350:	600b      	str	r3, [r1, #0]
    
    // Handle expired timers
    if (ticks_have_elapsed)
    {
        expired_timers_handler(ticks_elapsed, ticks_previous, &p_restart_list_head);
        compare_update = true;
   1c352:	3301      	adds	r3, #1
{
    timer_node_t * p_timer_id_old_head;
    uint8_t        user_id;

    // Remember the old head, so as to decide if new compare needs to be set.
    p_timer_id_old_head = mp_timer_id_head;
   1c354:	4977      	ldr	r1, [pc, #476]	; (1c534 <SWI0_IRQHandler+0x310>)
   1c356:	6809      	ldr	r1, [r1, #0]
   1c358:	9102      	str	r1, [sp, #8]

    user_id = m_user_array_size;
    while (user_id--)
    {
        timer_user_t * p_user = &mp_users[user_id];
   1c35a:	4978      	ldr	r1, [pc, #480]	; (1c53c <SWI0_IRQHandler+0x318>)
                p_timer->ticks_at_start          = p_user_op->params.start.ticks_at_start;
                p_timer->ticks_first_interval    = p_user_op->params.start.ticks_first_interval;
                p_timer->ticks_periodic_interval = p_user_op->params.start.ticks_periodic_interval;
                p_timer->p_context               = p_user_op->params.start.p_context;

                if (m_rtc1_reset)
   1c35c:	9802      	ldr	r0, [sp, #8]
    p_timer_id_old_head = mp_timer_id_head;

    user_id = m_user_array_size;
    while (user_id--)
    {
        timer_user_t * p_user = &mp_users[user_id];
   1c35e:	6809      	ldr	r1, [r1, #0]
   1c360:	9105      	str	r1, [sp, #20]
                }
            }

            // Prepare the node to be inserted.
            if (
                 ((p_timer->ticks_at_start - m_ticks_latest) & MAX_RTC_COUNTER_VAL)
   1c362:	6821      	ldr	r1, [r4, #0]
   1c364:	9104      	str	r1, [sp, #16]
                p_timer->ticks_at_start          = p_user_op->params.start.ticks_at_start;
                p_timer->ticks_first_interval    = p_user_op->params.start.ticks_first_interval;
                p_timer->ticks_periodic_interval = p_user_op->params.start.ticks_periodic_interval;
                p_timer->p_context               = p_user_op->params.start.p_context;

                if (m_rtc1_reset)
   1c366:	4976      	ldr	r1, [pc, #472]	; (1c540 <SWI0_IRQHandler+0x31c>)
   1c368:	7809      	ldrb	r1, [r1, #0]
   1c36a:	9106      	str	r1, [sp, #24]

    // Remember the old head, so as to decide if new compare needs to be set.
    p_timer_id_old_head = mp_timer_id_head;

    user_id = m_user_array_size;
    while (user_id--)
   1c36c:	9901      	ldr	r1, [sp, #4]
   1c36e:	3901      	subs	r1, #1
   1c370:	b2c9      	uxtb	r1, r1
   1c372:	9101      	str	r1, [sp, #4]
   1c374:	29ff      	cmp	r1, #255	; 0xff
   1c376:	d06c      	beq.n	1c452 <SWI0_IRQHandler+0x22e>
    {
        timer_user_t * p_user = &mp_users[user_id];
   1c378:	9901      	ldr	r1, [sp, #4]
   1c37a:	00cd      	lsls	r5, r1, #3
   1c37c:	9905      	ldr	r1, [sp, #20]
   1c37e:	194d      	adds	r5, r1, r5

        // Handle insertions of timers.
        while ((p_restart_list_head != NULL) || (p_user->first != p_user->last))
   1c380:	2a00      	cmp	r2, #0
   1c382:	d002      	beq.n	1c38a <SWI0_IRQHandler+0x166>
            timer_node_t * p_timer;

            if (p_restart_list_head != NULL)
            {
                p_timer           = p_restart_list_head;
                p_restart_list_head = p_timer->next;
   1c384:	1c11      	adds	r1, r2, #0
   1c386:	69d2      	ldr	r2, [r2, #28]
   1c388:	e022      	b.n	1c3d0 <SWI0_IRQHandler+0x1ac>
    while (user_id--)
    {
        timer_user_t * p_user = &mp_users[user_id];

        // Handle insertions of timers.
        while ((p_restart_list_head != NULL) || (p_user->first != p_user->last))
   1c38a:	7829      	ldrb	r1, [r5, #0]
   1c38c:	786c      	ldrb	r4, [r5, #1]
   1c38e:	428c      	cmp	r4, r1
   1c390:	d0ec      	beq.n	1c36c <SWI0_IRQHandler+0x148>
                p_timer           = p_restart_list_head;
                p_restart_list_head = p_timer->next;
            }
            else
            {
                timer_user_op_t * p_user_op = &p_user->p_user_op_queue[p_user->first];
   1c392:	2418      	movs	r4, #24
   1c394:	434c      	muls	r4, r1
   1c396:	686e      	ldr	r6, [r5, #4]

                p_user->first++;
   1c398:	3101      	adds	r1, #1
                p_timer           = p_restart_list_head;
                p_restart_list_head = p_timer->next;
            }
            else
            {
                timer_user_op_t * p_user_op = &p_user->p_user_op_queue[p_user->first];
   1c39a:	1934      	adds	r4, r6, r4

                p_user->first++;
                if (p_user->first == p_user->user_op_queue_size)
   1c39c:	78ae      	ldrb	r6, [r5, #2]
            }
            else
            {
                timer_user_op_t * p_user_op = &p_user->p_user_op_queue[p_user->first];

                p_user->first++;
   1c39e:	b2c9      	uxtb	r1, r1
   1c3a0:	7029      	strb	r1, [r5, #0]
                if (p_user->first == p_user->user_op_queue_size)
   1c3a2:	428e      	cmp	r6, r1
   1c3a4:	d100      	bne.n	1c3a8 <SWI0_IRQHandler+0x184>
                {
                    p_user->first = 0;
   1c3a6:	702a      	strb	r2, [r5, #0]
                }

                p_timer = p_user_op->p_node;

                if ((p_user_op->op_type != TIMER_USER_OP_TYPE_START) || p_timer->is_running)
   1c3a8:	7827      	ldrb	r7, [r4, #0]
                if (p_user->first == p_user->user_op_queue_size)
                {
                    p_user->first = 0;
                }

                p_timer = p_user_op->p_node;
   1c3aa:	6861      	ldr	r1, [r4, #4]

                if ((p_user_op->op_type != TIMER_USER_OP_TYPE_START) || p_timer->is_running)
   1c3ac:	1c06      	adds	r6, r0, #0
   1c3ae:	2f01      	cmp	r7, #1
   1c3b0:	d14d      	bne.n	1c44e <SWI0_IRQHandler+0x22a>
   1c3b2:	7c0f      	ldrb	r7, [r1, #16]
   1c3b4:	2f00      	cmp	r7, #0
   1c3b6:	d14a      	bne.n	1c44e <SWI0_IRQHandler+0x22a>
                {
                    continue;
                }

                p_timer->ticks_at_start          = p_user_op->params.start.ticks_at_start;
   1c3b8:	68a6      	ldr	r6, [r4, #8]
   1c3ba:	604e      	str	r6, [r1, #4]
                p_timer->ticks_first_interval    = p_user_op->params.start.ticks_first_interval;
   1c3bc:	68e6      	ldr	r6, [r4, #12]
   1c3be:	608e      	str	r6, [r1, #8]
                p_timer->ticks_periodic_interval = p_user_op->params.start.ticks_periodic_interval;
   1c3c0:	6926      	ldr	r6, [r4, #16]
   1c3c2:	60ce      	str	r6, [r1, #12]
                p_timer->p_context               = p_user_op->params.start.p_context;
   1c3c4:	6964      	ldr	r4, [r4, #20]
   1c3c6:	618c      	str	r4, [r1, #24]

                if (m_rtc1_reset)
   1c3c8:	9c06      	ldr	r4, [sp, #24]
   1c3ca:	2c00      	cmp	r4, #0
   1c3cc:	d000      	beq.n	1c3d0 <SWI0_IRQHandler+0x1ac>
                {
                    p_timer->ticks_at_start = 0;
   1c3ce:	604f      	str	r7, [r1, #4]
                }
            }

            // Prepare the node to be inserted.
            if (
                 ((p_timer->ticks_at_start - m_ticks_latest) & MAX_RTC_COUNTER_VAL)
   1c3d0:	684c      	ldr	r4, [r1, #4]
   1c3d2:	9e04      	ldr	r6, [sp, #16]
   1c3d4:	9403      	str	r4, [sp, #12]
   1c3d6:	1ba6      	subs	r6, r4, r6
                    p_timer->ticks_at_start = 0;
                }
            }

            // Prepare the node to be inserted.
            if (
   1c3d8:	4c5a      	ldr	r4, [pc, #360]	; (1c544 <SWI0_IRQHandler+0x320>)
                 ((p_timer->ticks_at_start - m_ticks_latest) & MAX_RTC_COUNTER_VAL)
   1c3da:	0236      	lsls	r6, r6, #8
   1c3dc:	0a36      	lsrs	r6, r6, #8
   1c3de:	688f      	ldr	r7, [r1, #8]
                    p_timer->ticks_at_start = 0;
                }
            }

            // Prepare the node to be inserted.
            if (
   1c3e0:	42a6      	cmp	r6, r4
   1c3e2:	d802      	bhi.n	1c3ea <SWI0_IRQHandler+0x1c6>
                 ((p_timer->ticks_at_start - m_ticks_latest) & MAX_RTC_COUNTER_VAL)
                 <
                 (MAX_RTC_COUNTER_VAL / 2)
                )
            {
                p_timer->ticks_to_expire = ticks_diff_get(p_timer->ticks_at_start, m_ticks_latest) + 
   1c3e4:	19f6      	adds	r6, r6, r7
   1c3e6:	600e      	str	r6, [r1, #0]
   1c3e8:	e00b      	b.n	1c402 <SWI0_IRQHandler+0x1de>
 *
 * @return     Number of ticks elapsed from ticks_old to ticks_now.
 */
static __INLINE uint32_t ticks_diff_get(uint32_t ticks_now, uint32_t ticks_old)
{
    return ((ticks_now - ticks_old) & MAX_RTC_COUNTER_VAL);
   1c3ea:	9c04      	ldr	r4, [sp, #16]
   1c3ec:	9e03      	ldr	r6, [sp, #12]
   1c3ee:	1ba4      	subs	r4, r4, r6
   1c3f0:	0224      	lsls	r4, r4, #8
   1c3f2:	0a24      	lsrs	r4, r4, #8
            else
            {
                uint32_t delta_current_start;

                delta_current_start = ticks_diff_get(m_ticks_latest, p_timer->ticks_at_start);
                if (p_timer->ticks_first_interval > delta_current_start)
   1c3f4:	42a7      	cmp	r7, r4
   1c3f6:	d902      	bls.n	1c3fe <SWI0_IRQHandler+0x1da>
                {
                    p_timer->ticks_to_expire = p_timer->ticks_first_interval - delta_current_start;
   1c3f8:	1b3f      	subs	r7, r7, r4
   1c3fa:	600f      	str	r7, [r1, #0]
   1c3fc:	e001      	b.n	1c402 <SWI0_IRQHandler+0x1de>
                }
                else
                {
                    p_timer->ticks_to_expire = 0;
   1c3fe:	2400      	movs	r4, #0
   1c400:	600c      	str	r4, [r1, #0]
                }
            }

            p_timer->ticks_at_start       = 0;
   1c402:	2400      	movs	r4, #0
            p_timer->ticks_first_interval = 0;
            p_timer->is_running           = true;
   1c404:	2601      	movs	r6, #1
                {
                    p_timer->ticks_to_expire = 0;
                }
            }

            p_timer->ticks_at_start       = 0;
   1c406:	604c      	str	r4, [r1, #4]
            p_timer->ticks_first_interval = 0;
            p_timer->is_running           = true;
   1c408:	740e      	strb	r6, [r1, #16]
                    p_timer->ticks_to_expire = 0;
                }
            }

            p_timer->ticks_at_start       = 0;
            p_timer->ticks_first_interval = 0;
   1c40a:	608c      	str	r4, [r1, #8]
            p_timer->is_running           = true;
            p_timer->next                 = NULL;
   1c40c:	61cc      	str	r4, [r1, #28]
 *
 * @param[in]  timer_id   Id of timer to insert.
 */
static void timer_list_insert(timer_node_t * p_timer)
{
    if (mp_timer_id_head == NULL)
   1c40e:	1c0e      	adds	r6, r1, #0
   1c410:	42a0      	cmp	r0, r4
   1c412:	d01c      	beq.n	1c44e <SWI0_IRQHandler+0x22a>
    {
        mp_timer_id_head = p_timer;
    }
    else
    {
        if (p_timer->ticks_to_expire <= mp_timer_id_head->ticks_to_expire)
   1c414:	680e      	ldr	r6, [r1, #0]
   1c416:	6804      	ldr	r4, [r0, #0]
   1c418:	42a6      	cmp	r6, r4
   1c41a:	d804      	bhi.n	1c426 <SWI0_IRQHandler+0x202>
        {
            mp_timer_id_head->ticks_to_expire -= p_timer->ticks_to_expire;
   1c41c:	1ba6      	subs	r6, r4, r6
   1c41e:	6006      	str	r6, [r0, #0]
            
            p_timer->next   = mp_timer_id_head;
   1c420:	61c8      	str	r0, [r1, #28]
   1c422:	1c0e      	adds	r6, r1, #0
   1c424:	e013      	b.n	1c44e <SWI0_IRQHandler+0x22a>
    {
        mp_timer_id_head = p_timer;
    }
    else
    {
        if (p_timer->ticks_to_expire <= mp_timer_id_head->ticks_to_expire)
   1c426:	4684      	mov	ip, r0
   1c428:	1c04      	adds	r4, r0, #0

            ticks_to_expire   = p_timer->ticks_to_expire;
            p_previous        = mp_timer_id_head;
            p_current         = mp_timer_id_head;
            
            while ((p_current != NULL) && (ticks_to_expire > p_current->ticks_to_expire))
   1c42a:	6827      	ldr	r7, [r4, #0]
   1c42c:	42be      	cmp	r6, r7
   1c42e:	d906      	bls.n	1c43e <SWI0_IRQHandler+0x21a>
            {
                ticks_to_expire   -= p_current->ticks_to_expire;
   1c430:	1bf6      	subs	r6, r6, r7
                p_previous         = p_current;
                p_current          = p_current->next;
   1c432:	69e7      	ldr	r7, [r4, #28]
   1c434:	46a4      	mov	ip, r4

            ticks_to_expire   = p_timer->ticks_to_expire;
            p_previous        = mp_timer_id_head;
            p_current         = mp_timer_id_head;
            
            while ((p_current != NULL) && (ticks_to_expire > p_current->ticks_to_expire))
   1c436:	2f00      	cmp	r7, #0
   1c438:	d005      	beq.n	1c446 <SWI0_IRQHandler+0x222>
   1c43a:	1c3c      	adds	r4, r7, #0
   1c43c:	e7f5      	b.n	1c42a <SWI0_IRQHandler+0x206>
                p_current          = p_current->next;
            }

            if (p_current != NULL)
            {
                p_current->ticks_to_expire -= ticks_to_expire;
   1c43e:	1bbf      	subs	r7, r7, r6
   1c440:	6027      	str	r7, [r4, #0]
   1c442:	1c27      	adds	r7, r4, #0
   1c444:	4664      	mov	r4, ip
            }

            p_timer->ticks_to_expire = ticks_to_expire;
   1c446:	600e      	str	r6, [r1, #0]
            p_timer->next            = p_current;
            p_previous->next         = p_timer;
   1c448:	1c06      	adds	r6, r0, #0
            {
                p_current->ticks_to_expire -= ticks_to_expire;
            }

            p_timer->ticks_to_expire = ticks_to_expire;
            p_timer->next            = p_current;
   1c44a:	61cf      	str	r7, [r1, #28]
            p_previous->next         = p_timer;
   1c44c:	61e1      	str	r1, [r4, #28]
   1c44e:	1c30      	adds	r0, r6, #0
   1c450:	e796      	b.n	1c380 <SWI0_IRQHandler+0x15c>
   1c452:	4a38      	ldr	r2, [pc, #224]	; (1c534 <SWI0_IRQHandler+0x310>)
   1c454:	6010      	str	r0, [r2, #0]
        expired_timers_handler(ticks_elapsed, ticks_previous, &p_restart_list_head);
        compare_update = true;
    }
    
    // Handle list insertions
    if (list_insertions_handler(p_restart_list_head))
   1c456:	9a02      	ldr	r2, [sp, #8]
   1c458:	4290      	cmp	r0, r2
   1c45a:	d102      	bne.n	1c462 <SWI0_IRQHandler+0x23e>
    {
        compare_update = true;
    }

    // Update compare register if necessary
    if (compare_update)
   1c45c:	2b00      	cmp	r3, #0
   1c45e:	d100      	bne.n	1c462 <SWI0_IRQHandler+0x23e>
   1c460:	e07e      	b.n	1c560 <SWI0_IRQHandler+0x33c>
/**@brief Function for updating the Capture Compare register.
 */
static void compare_reg_update(timer_node_t * p_timer_id_head_old)
{
    // Setup the timeout for timers on the head of the list 
    if (mp_timer_id_head != NULL)
   1c462:	2800      	cmp	r0, #0
   1c464:	d100      	bne.n	1c468 <SWI0_IRQHandler+0x244>
   1c466:	e079      	b.n	1c55c <SWI0_IRQHandler+0x338>
    {
        uint32_t ticks_to_expire = mp_timer_id_head->ticks_to_expire;
   1c468:	6805      	ldr	r5, [r0, #0]
 *
 * @return     Current value of the RTC1 counter.
 */
static __INLINE uint32_t rtc1_counter_get(void)
{
    return NRF_RTC1->COUNTER;
   1c46a:	4937      	ldr	r1, [pc, #220]	; (1c548 <SWI0_IRQHandler+0x324>)
   1c46c:	4837      	ldr	r0, [pc, #220]	; (1c54c <SWI0_IRQHandler+0x328>)
    // Setup the timeout for timers on the head of the list 
    if (mp_timer_id_head != NULL)
    {
        uint32_t ticks_to_expire = mp_timer_id_head->ticks_to_expire;
        uint32_t pre_counter_val = rtc1_counter_get();
        uint32_t cc              = m_ticks_latest;
   1c46e:	4b2d      	ldr	r3, [pc, #180]	; (1c524 <SWI0_IRQHandler+0x300>)
 *
 * @return     Current value of the RTC1 counter.
 */
static __INLINE uint32_t rtc1_counter_get(void)
{
    return NRF_RTC1->COUNTER;
   1c470:	580c      	ldr	r4, [r1, r0]
    // Setup the timeout for timers on the head of the list 
    if (mp_timer_id_head != NULL)
    {
        uint32_t ticks_to_expire = mp_timer_id_head->ticks_to_expire;
        uint32_t pre_counter_val = rtc1_counter_get();
        uint32_t cc              = m_ticks_latest;
   1c472:	681b      	ldr	r3, [r3, #0]
        uint32_t ticks_elapsed   = ticks_diff_get(pre_counter_val, cc) + RTC_COMPARE_OFFSET_MIN;

        if (!m_rtc1_running)
   1c474:	4e36      	ldr	r6, [pc, #216]	; (1c550 <SWI0_IRQHandler+0x32c>)
 *
 * @return     Number of ticks elapsed from ticks_old to ticks_now.
 */
static __INLINE uint32_t ticks_diff_get(uint32_t ticks_now, uint32_t ticks_old)
{
    return ((ticks_now - ticks_old) & MAX_RTC_COUNTER_VAL);
   1c476:	1ae2      	subs	r2, r4, r3
   1c478:	0212      	lsls	r2, r2, #8
   1c47a:	0a12      	lsrs	r2, r2, #8
        uint32_t ticks_to_expire = mp_timer_id_head->ticks_to_expire;
        uint32_t pre_counter_val = rtc1_counter_get();
        uint32_t cc              = m_ticks_latest;
        uint32_t ticks_elapsed   = ticks_diff_get(pre_counter_val, cc) + RTC_COMPARE_OFFSET_MIN;

        if (!m_rtc1_running)
   1c47c:	7837      	ldrb	r7, [r6, #0]
    if (mp_timer_id_head != NULL)
    {
        uint32_t ticks_to_expire = mp_timer_id_head->ticks_to_expire;
        uint32_t pre_counter_val = rtc1_counter_get();
        uint32_t cc              = m_ticks_latest;
        uint32_t ticks_elapsed   = ticks_diff_get(pre_counter_val, cc) + RTC_COMPARE_OFFSET_MIN;
   1c47e:	3203      	adds	r2, #3
   1c480:	9201      	str	r2, [sp, #4]
   1c482:	9002      	str	r0, [sp, #8]

        if (!m_rtc1_running)
   1c484:	2f00      	cmp	r7, #0
   1c486:	d11f      	bne.n	1c4c8 <SWI0_IRQHandler+0x2a4>

/**@brief Function for starting the RTC1 timer.
 */
static void rtc1_start(void)
{
    NRF_RTC1->EVTENSET = RTC_EVTEN_COMPARE0_Msk;
   1c488:	2080      	movs	r0, #128	; 0x80
   1c48a:	27d1      	movs	r7, #209	; 0xd1
   1c48c:	0240      	lsls	r0, r0, #9
   1c48e:	00bf      	lsls	r7, r7, #2
   1c490:	51c8      	str	r0, [r1, r7]
    NRF_RTC1->INTENSET = RTC_INTENSET_COMPARE0_Msk;
   1c492:	3f40      	subs	r7, #64	; 0x40
   1c494:	51c8      	str	r0, [r1, r7]
  \details Clears the pending bit of an external interrupt.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   1c496:	22c0      	movs	r2, #192	; 0xc0
   1c498:	2780      	movs	r7, #128	; 0x80
   1c49a:	482e      	ldr	r0, [pc, #184]	; (1c554 <SWI0_IRQHandler+0x330>)
   1c49c:	02bf      	lsls	r7, r7, #10
   1c49e:	0052      	lsls	r2, r2, #1
   1c4a0:	5087      	str	r7, [r0, r2]
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   1c4a2:	6007      	str	r7, [r0, #0]

    NVIC_ClearPendingIRQ(RTC1_IRQn);
    NVIC_EnableIRQ(RTC1_IRQn);

    NRF_RTC1->TASKS_START = 1;
   1c4a4:	2701      	movs	r7, #1
#elif defined ( __GNUC__ )

static void __INLINE nrf_delay_us(uint32_t volatile number_of_us) __attribute__((always_inline));
static void __INLINE nrf_delay_us(uint32_t volatile number_of_us)
{
register uint32_t delay __ASM ("r0") = number_of_us;
   1c4a6:	202f      	movs	r0, #47	; 0x2f
   1c4a8:	600f      	str	r7, [r1, #0]
__ASM volatile (
   1c4aa:	3801      	subs	r0, #1
   1c4ac:	46c0      	nop			; (mov r8, r8)
   1c4ae:	46c0      	nop			; (mov r8, r8)
   1c4b0:	46c0      	nop			; (mov r8, r8)
   1c4b2:	46c0      	nop			; (mov r8, r8)
   1c4b4:	46c0      	nop			; (mov r8, r8)
   1c4b6:	46c0      	nop			; (mov r8, r8)
   1c4b8:	46c0      	nop			; (mov r8, r8)
   1c4ba:	46c0      	nop			; (mov r8, r8)
   1c4bc:	46c0      	nop			; (mov r8, r8)
   1c4be:	46c0      	nop			; (mov r8, r8)
   1c4c0:	46c0      	nop			; (mov r8, r8)
   1c4c2:	46c0      	nop			; (mov r8, r8)
   1c4c4:	d1f1      	bne.n	1c4aa <SWI0_IRQHandler+0x286>
    nrf_delay_us(MAX_RTC_TASKS_DELAY);

    m_rtc1_running = true;
   1c4c6:	7037      	strb	r7, [r6, #0]
        {
            // No timers were already running, start RTC
            rtc1_start();
        }

        cc += (ticks_elapsed < ticks_to_expire) ? ticks_to_expire : ticks_elapsed;
   1c4c8:	9a01      	ldr	r2, [sp, #4]
   1c4ca:	42aa      	cmp	r2, r5
   1c4cc:	d200      	bcs.n	1c4d0 <SWI0_IRQHandler+0x2ac>
   1c4ce:	1c2a      	adds	r2, r5, #0
 *
 * @param[in] value   New value of Capture Compare register 0.
 */
static __INLINE void rtc1_compare0_set(uint32_t value)
{
    NRF_RTC1->CC[0] = value;
   1c4d0:	20a8      	movs	r0, #168	; 0xa8
        {
            // No timers were already running, start RTC
            rtc1_start();
        }

        cc += (ticks_elapsed < ticks_to_expire) ? ticks_to_expire : ticks_elapsed;
   1c4d2:	18d3      	adds	r3, r2, r3
        cc &= MAX_RTC_COUNTER_VAL;
   1c4d4:	021b      	lsls	r3, r3, #8
   1c4d6:	0a1b      	lsrs	r3, r3, #8
 *
 * @param[in] value   New value of Capture Compare register 0.
 */
static __INLINE void rtc1_compare0_set(uint32_t value)
{
    NRF_RTC1->CC[0] = value;
   1c4d8:	00c0      	lsls	r0, r0, #3
 *
 * @return     Current value of the RTC1 counter.
 */
static __INLINE uint32_t rtc1_counter_get(void)
{
    return NRF_RTC1->COUNTER;
   1c4da:	9a02      	ldr	r2, [sp, #8]
 *
 * @param[in] value   New value of Capture Compare register 0.
 */
static __INLINE void rtc1_compare0_set(uint32_t value)
{
    NRF_RTC1->CC[0] = value;
   1c4dc:	500b      	str	r3, [r1, r0]
 *
 * @return     Current value of the RTC1 counter.
 */
static __INLINE uint32_t rtc1_counter_get(void)
{
    return NRF_RTC1->COUNTER;
   1c4de:	5889      	ldr	r1, [r1, r2]
 *
 * @param[in] value   New value of Capture Compare register 0.
 */
static __INLINE void rtc1_compare0_set(uint32_t value)
{
    NRF_RTC1->CC[0] = value;
   1c4e0:	4d19      	ldr	r5, [pc, #100]	; (1c548 <SWI0_IRQHandler+0x324>)
 *
 * @return     Number of ticks elapsed from ticks_old to ticks_now.
 */
static __INLINE uint32_t ticks_diff_get(uint32_t ticks_now, uint32_t ticks_old)
{
    return ((ticks_now - ticks_old) & MAX_RTC_COUNTER_VAL);
   1c4e2:	1b09      	subs	r1, r1, r4
   1c4e4:	0209      	lsls	r1, r1, #8
   1c4e6:	0a09      	lsrs	r1, r1, #8
   1c4e8:	1b1c      	subs	r4, r3, r4
   1c4ea:	0224      	lsls	r4, r4, #8
        rtc1_compare0_set(cc);

        uint32_t post_counter_val = rtc1_counter_get();

        if (
            (ticks_diff_get(post_counter_val, pre_counter_val) + RTC_COMPARE_OFFSET_MIN)
   1c4ec:	3103      	adds	r1, #3
 *
 * @return     Number of ticks elapsed from ticks_old to ticks_now.
 */
static __INLINE uint32_t ticks_diff_get(uint32_t ticks_now, uint32_t ticks_old)
{
    return ((ticks_now - ticks_old) & MAX_RTC_COUNTER_VAL);
   1c4ee:	0a24      	lsrs	r4, r4, #8
        
        rtc1_compare0_set(cc);

        uint32_t post_counter_val = rtc1_counter_get();

        if (
   1c4f0:	42a1      	cmp	r1, r4
   1c4f2:	d935      	bls.n	1c560 <SWI0_IRQHandler+0x33c>
 *
 * @return     Current value of the RTC1 counter.
 */
static __INLINE uint32_t rtc1_counter_get(void)
{
    return NRF_RTC1->COUNTER;
   1c4f4:	4b15      	ldr	r3, [pc, #84]	; (1c54c <SWI0_IRQHandler+0x328>)
   1c4f6:	58eb      	ldr	r3, [r5, r3]
 *
 * @param[in] value   New value of Capture Compare register 0.
 */
static __INLINE void rtc1_compare0_set(uint32_t value)
{
    NRF_RTC1->CC[0] = value;
   1c4f8:	502b      	str	r3, [r5, r0]
#elif defined ( __GNUC__ )

static void __INLINE nrf_delay_us(uint32_t volatile number_of_us) __attribute__((always_inline));
static void __INLINE nrf_delay_us(uint32_t volatile number_of_us)
{
register uint32_t delay __ASM ("r0") = number_of_us;
   1c4fa:	202f      	movs	r0, #47	; 0x2f
__ASM volatile (
   1c4fc:	3801      	subs	r0, #1
   1c4fe:	46c0      	nop			; (mov r8, r8)
   1c500:	46c0      	nop			; (mov r8, r8)
   1c502:	46c0      	nop			; (mov r8, r8)
   1c504:	46c0      	nop			; (mov r8, r8)
   1c506:	46c0      	nop			; (mov r8, r8)
   1c508:	46c0      	nop			; (mov r8, r8)
   1c50a:	46c0      	nop			; (mov r8, r8)
   1c50c:	46c0      	nop			; (mov r8, r8)
   1c50e:	46c0      	nop			; (mov r8, r8)
   1c510:	46c0      	nop			; (mov r8, r8)
   1c512:	46c0      	nop			; (mov r8, r8)
   1c514:	46c0      	nop			; (mov r8, r8)
   1c516:	d1f1      	bne.n	1c4fc <SWI0_IRQHandler+0x2d8>
  \details Sets the pending bit of an external interrupt.
  \param [in]      IRQn  Interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   1c518:	2280      	movs	r2, #128	; 0x80
   1c51a:	4b0f      	ldr	r3, [pc, #60]	; (1c558 <SWI0_IRQHandler+0x334>)
   1c51c:	0292      	lsls	r2, r2, #10
   1c51e:	605a      	str	r2, [r3, #4]
   1c520:	e01e      	b.n	1c560 <SWI0_IRQHandler+0x33c>
   1c522:	46c0      	nop			; (mov r8, r8)
   1c524:	20003304 	.word	0x20003304
   1c528:	20003314 	.word	0x20003314
   1c52c:	200031f4 	.word	0x200031f4
   1c530:	20003338 	.word	0x20003338
   1c534:	20002fdc 	.word	0x20002fdc
   1c538:	2000330d 	.word	0x2000330d
   1c53c:	20002fd8 	.word	0x20002fd8
   1c540:	2000331c 	.word	0x2000331c
   1c544:	007ffffe 	.word	0x007ffffe
   1c548:	40011000 	.word	0x40011000
   1c54c:	00000504 	.word	0x00000504
   1c550:	20003340 	.word	0x20003340
   1c554:	e000e100 	.word	0xe000e100
   1c558:	e000e1fc 	.word	0xe000e1fc
        }
    }
    else
    {
        // No timers are running, stop RTC
        rtc1_stop();
   1c55c:	f7ff fe26 	bl	1c1ac <rtc1_stop.lto_priv.118>
    // Update compare register if necessary
    if (compare_update)
    {
        compare_reg_update(p_timer_id_head_old);
    }
    m_rtc1_reset = false;
   1c560:	2200      	movs	r2, #0
   1c562:	4b0c      	ldr	r3, [pc, #48]	; (1c594 <SWI0_IRQHandler+0x370>)
   1c564:	701a      	strb	r2, [r3, #0]
 * @details Performs all updates to the timer list.
 */
void SWI_IRQHandler(void)
{
    timer_list_handler();
}
   1c566:	b009      	add	sp, #36	; 0x24
   1c568:	bdf0      	pop	{r4, r5, r6, r7, pc}
    {
        return;
    }

    // Timer is the first in the list
    if (p_previous == p_current)
   1c56a:	42af      	cmp	r7, r5
   1c56c:	d107      	bne.n	1c57e <SWI0_IRQHandler+0x35a>
    {
        mp_timer_id_head = mp_timer_id_head->next;
   1c56e:	69db      	ldr	r3, [r3, #28]

        // No more timers in the list. Reset RTC1 in case Start timer operations are present in the queue.
        if (mp_timer_id_head == NULL)
   1c570:	2b00      	cmp	r3, #0
   1c572:	d104      	bne.n	1c57e <SWI0_IRQHandler+0x35a>
        {
            NRF_RTC1->TASKS_CLEAR = 1;
   1c574:	2601      	movs	r6, #1
   1c576:	4808      	ldr	r0, [pc, #32]	; (1c598 <SWI0_IRQHandler+0x374>)
   1c578:	6086      	str	r6, [r0, #8]
            m_ticks_latest        = 0;
            m_rtc1_reset          = true;
   1c57a:	9605      	str	r6, [sp, #20]

        // No more timers in the list. Reset RTC1 in case Start timer operations are present in the queue.
        if (mp_timer_id_head == NULL)
        {
            NRF_RTC1->TASKS_CLEAR = 1;
            m_ticks_latest        = 0;
   1c57c:	1c1e      	adds	r6, r3, #0
            m_rtc1_reset          = true;
        }
    }

    // Remaining timeout between next timeout.
    timeout = p_current->ticks_to_expire;
   1c57e:	6828      	ldr	r0, [r5, #0]

    // Link previous timer with next of this timer, i.e. removing the timer from list.
    p_previous->next = p_current->next;
   1c580:	69ed      	ldr	r5, [r5, #28]
            m_rtc1_reset          = true;
        }
    }

    // Remaining timeout between next timeout.
    timeout = p_current->ticks_to_expire;
   1c582:	4684      	mov	ip, r0

    // Link previous timer with next of this timer, i.e. removing the timer from list.
    p_previous->next = p_current->next;
   1c584:	61fd      	str	r5, [r7, #28]

    // If this is not the last timer, increment the next timer by this timer timeout.
    p_current = p_previous->next;
    if (p_current != NULL)
   1c586:	2d00      	cmp	r5, #0
   1c588:	d100      	bne.n	1c58c <SWI0_IRQHandler+0x368>
   1c58a:	e686      	b.n	1c29a <SWI0_IRQHandler+0x76>
    {
        p_current->ticks_to_expire += timeout;
   1c58c:	6828      	ldr	r0, [r5, #0]
   1c58e:	4460      	add	r0, ip
   1c590:	6028      	str	r0, [r5, #0]
   1c592:	e682      	b.n	1c29a <SWI0_IRQHandler+0x76>
   1c594:	2000331c 	.word	0x2000331c
   1c598:	40011000 	.word	0x40011000

0001c59c <GPIOTE_IRQHandler>:
    nrf_gpiote_events_t event = TE_IDX_TO_EVENT_ADDR(channel_port_get(pin));
    return nrf_gpiote_event_addr_get(event);
}

void GPIOTE_IRQHandler(void)
{
   1c59c:	b570      	push	{r4, r5, r6, lr}
    uint32_t input = 0;

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    uint32_t i;
    nrf_gpiote_events_t event = NRF_GPIOTE_EVENTS_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
   1c59e:	2201      	movs	r2, #1
    return nrf_gpiote_event_addr_get(event);
}

void GPIOTE_IRQHandler(void)
{
    uint32_t status = 0;
   1c5a0:	2400      	movs	r4, #0
    nrf_gpiote_events_t event = TE_IDX_TO_EVENT_ADDR(channel_port_get(pin));
    return nrf_gpiote_event_addr_get(event);
}

void GPIOTE_IRQHandler(void)
{
   1c5a2:	4b1c      	ldr	r3, [pc, #112]	; (1c614 <GPIOTE_IRQHandler+0x78>)
    uint32_t i;
    nrf_gpiote_events_t event = NRF_GPIOTE_EVENTS_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
    for (i = 0; i < NUMBER_OF_GPIO_TE; i++)
    {
        if (nrf_gpiote_event_is_set(event) && nrf_gpiote_int_is_enabled(mask))
   1c5a4:	6819      	ldr	r1, [r3, #0]
   1c5a6:	2901      	cmp	r1, #1
   1c5a8:	d108      	bne.n	1c5bc <GPIOTE_IRQHandler+0x20>
    NRF_GPIOTE->INTENCLR = mask;
}

__STATIC_INLINE uint32_t nrf_gpiote_int_is_enabled(uint32_t mask)
{
    return (NRF_GPIOTE->INTENSET & mask);
   1c5aa:	21c1      	movs	r1, #193	; 0xc1
   1c5ac:	481a      	ldr	r0, [pc, #104]	; (1c618 <GPIOTE_IRQHandler+0x7c>)
   1c5ae:	0089      	lsls	r1, r1, #2
   1c5b0:	5841      	ldr	r1, [r0, r1]
   1c5b2:	4211      	tst	r1, r2
   1c5b4:	d002      	beq.n	1c5bc <GPIOTE_IRQHandler+0x20>
    return (*(uint32_t *)nrf_gpiote_event_addr_get(event) == 0x1UL) ? true : false;
}

__STATIC_INLINE void nrf_gpiote_event_clear(nrf_gpiote_events_t event)
{
    *(uint32_t *)nrf_gpiote_event_addr_get(event) = 0;
   1c5b6:	2100      	movs	r1, #0
        {
            nrf_gpiote_event_clear(event);
            status |= mask;
   1c5b8:	4314      	orrs	r4, r2
   1c5ba:	6019      	str	r1, [r3, #0]

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    uint32_t i;
    nrf_gpiote_events_t event = NRF_GPIOTE_EVENTS_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
    for (i = 0; i < NUMBER_OF_GPIO_TE; i++)
   1c5bc:	4917      	ldr	r1, [pc, #92]	; (1c61c <GPIOTE_IRQHandler+0x80>)
   1c5be:	3304      	adds	r3, #4
        if (nrf_gpiote_event_is_set(event) && nrf_gpiote_int_is_enabled(mask))
        {
            nrf_gpiote_event_clear(event);
            status |= mask;
        }
        mask <<= 1;
   1c5c0:	0052      	lsls	r2, r2, #1

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    uint32_t i;
    nrf_gpiote_events_t event = NRF_GPIOTE_EVENTS_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
    for (i = 0; i < NUMBER_OF_GPIO_TE; i++)
   1c5c2:	428b      	cmp	r3, r1
   1c5c4:	d1ee      	bne.n	1c5a4 <GPIOTE_IRQHandler+0x8>
    return ((uint32_t)NRF_GPIOTE + task);
}

__STATIC_INLINE bool nrf_gpiote_event_is_set(nrf_gpiote_events_t event)
{
    return (*(uint32_t *)nrf_gpiote_event_addr_get(event) == 0x1UL) ? true : false;
   1c5c6:	4b16      	ldr	r3, [pc, #88]	; (1c620 <GPIOTE_IRQHandler+0x84>)
        event = (nrf_gpiote_events_t)((uint32_t)event + sizeof(uint32_t));
    }

    /* collect PORT status event, if event is set read pins state. Processing is postponed to the
     * end of interrupt. */
    if (nrf_gpiote_event_is_set(NRF_GPIOTE_EVENTS_PORT))
   1c5c8:	681a      	ldr	r2, [r3, #0]
   1c5ca:	2a01      	cmp	r2, #1
   1c5cc:	d109      	bne.n	1c5e2 <GPIOTE_IRQHandler+0x46>
}

__STATIC_INLINE void nrf_gpiote_event_clear(nrf_gpiote_events_t event)
{
    *(uint32_t *)nrf_gpiote_event_addr_get(event) = 0;
   1c5ce:	2200      	movs	r2, #0
   1c5d0:	601a      	str	r2, [r3, #0]
    {
        nrf_gpiote_event_clear(NRF_GPIOTE_EVENTS_PORT);
        status |= (uint32_t)NRF_GPIOTE_INT_PORT_MASK;
   1c5d2:	2380      	movs	r3, #128	; 0x80
   1c5d4:	061b      	lsls	r3, r3, #24
   1c5d6:	431c      	orrs	r4, r3
    return  ((NRF_GPIO->IN >> pin_number) & 1UL);
}

__STATIC_INLINE uint32_t nrf_gpio_pins_read(void)
{
    return NRF_GPIO->IN;
   1c5d8:	22a0      	movs	r2, #160	; 0xa0
   1c5da:	23a2      	movs	r3, #162	; 0xa2
   1c5dc:	05d2      	lsls	r2, r2, #23
   1c5de:	00db      	lsls	r3, r3, #3
   1c5e0:	58d3      	ldr	r3, [r2, r3]
        input = nrf_gpio_pins_read();
    }

    /* Process pin events. */
    if (status & NRF_GPIOTE_INT_IN_MASK)
   1c5e2:	0723      	lsls	r3, r4, #28
   1c5e4:	d014      	beq.n	1c610 <GPIOTE_IRQHandler+0x74>
   1c5e6:	2601      	movs	r6, #1
   1c5e8:	2500      	movs	r5, #0
    {
        mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
        for (i = 0; i < NUMBER_OF_GPIO_TE; i++)
        {
            if (mask & status)
   1c5ea:	4234      	tst	r4, r6
   1c5ec:	d00c      	beq.n	1c608 <GPIOTE_IRQHandler+0x6c>
   1c5ee:	4a0a      	ldr	r2, [pc, #40]	; (1c618 <GPIOTE_IRQHandler+0x7c>)
   1c5f0:	00ab      	lsls	r3, r5, #2
   1c5f2:	189b      	adds	r3, r3, r2
                              ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

__STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(uint32_t idx)
{
    return ((NRF_GPIOTE->CONFIG[idx] & GPIOTE_CONFIG_PSEL_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   1c5f4:	22a2      	movs	r2, #162	; 0xa2
   1c5f6:	00d2      	lsls	r2, r2, #3
   1c5f8:	5898      	ldr	r0, [r3, r2]
}

__STATIC_INLINE nrf_gpiote_polarity_t nrf_gpiote_event_polarity_get(uint32_t idx)
{
    return (nrf_gpiote_polarity_t)((NRF_GPIOTE->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >> GPIOTE_CONFIG_POLARITY_Pos);
   1c5fa:	5899      	ldr	r1, [r3, r2]
                              ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

__STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(uint32_t idx)
{
    return ((NRF_GPIOTE->CONFIG[idx] & GPIOTE_CONFIG_PSEL_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   1c5fc:	04c0      	lsls	r0, r0, #19
}

__STATIC_INLINE nrf_gpiote_polarity_t nrf_gpiote_event_polarity_get(uint32_t idx)
{
    return (nrf_gpiote_polarity_t)((NRF_GPIOTE->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >> GPIOTE_CONFIG_POLARITY_Pos);
   1c5fe:	0389      	lsls	r1, r1, #14
                              ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

__STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(uint32_t idx)
{
    return ((NRF_GPIOTE->CONFIG[idx] & GPIOTE_CONFIG_PSEL_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   1c600:	0ec0      	lsrs	r0, r0, #27
            {
                nrf_drv_gpiote_pin_t pin = nrf_gpiote_event_pin_get(i);
                nrf_gpiote_polarity_t polarity = nrf_gpiote_event_polarity_get(i);
                nrf_drv_gpiote_evt_handler_t handler = channel_handler_get(i);
                handler(pin,polarity);
   1c602:	0f89      	lsrs	r1, r1, #30
   1c604:	2300      	movs	r3, #0
   1c606:	4798      	blx	r3

    /* Process pin events. */
    if (status & NRF_GPIOTE_INT_IN_MASK)
    {
        mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
        for (i = 0; i < NUMBER_OF_GPIO_TE; i++)
   1c608:	3501      	adds	r5, #1
                nrf_drv_gpiote_pin_t pin = nrf_gpiote_event_pin_get(i);
                nrf_gpiote_polarity_t polarity = nrf_gpiote_event_polarity_get(i);
                nrf_drv_gpiote_evt_handler_t handler = channel_handler_get(i);
                handler(pin,polarity);
            }
            mask <<= 1;
   1c60a:	0076      	lsls	r6, r6, #1

    /* Process pin events. */
    if (status & NRF_GPIOTE_INT_IN_MASK)
    {
        mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
        for (i = 0; i < NUMBER_OF_GPIO_TE; i++)
   1c60c:	2d04      	cmp	r5, #4
   1c60e:	d1ec      	bne.n	1c5ea <GPIOTE_IRQHandler+0x4e>
                }
            }
        }
        while (repeat);
    }
}
   1c610:	bd70      	pop	{r4, r5, r6, pc}
   1c612:	46c0      	nop			; (mov r8, r8)
   1c614:	40006100 	.word	0x40006100
   1c618:	40006000 	.word	0x40006000
   1c61c:	40006110 	.word	0x40006110
   1c620:	4000617c 	.word	0x4000617c

0001c624 <app_notify.lto_priv.114>:
 *
 * @param[in] result Result code of the operation for the application.
 * @param[in] p_elem Pointer to the command queue element for which this result was received. 
 */
static void app_notify(uint32_t result, cmd_queue_element_t * p_elem)
{
   1c624:	1c0b      	adds	r3, r1, #0
   1c626:	b537      	push	{r0, r1, r2, r4, r5, lr}
        ntf_cb = m_raw_app_table.cb;
    }
    else
#endif // PSTORAGE_RAW_MODE_ENABLE
    {
        ntf_cb = m_app_table[p_elem->storage_addr.module_id].cb;
   1c628:	240c      	movs	r4, #12
 *
 * @param[in] result Result code of the operation for the application.
 * @param[in] p_elem Pointer to the command queue element for which this result was received. 
 */
static void app_notify(uint32_t result, cmd_queue_element_t * p_elem)
{
   1c62a:	1c02      	adds	r2, r0, #0
#endif // PSTORAGE_RAW_MODE_ENABLE
    {
        ntf_cb = m_app_table[p_elem->storage_addr.module_id].cb;
    }

    ntf_cb(&p_elem->storage_addr, op_code, result, p_elem->p_data_addr, m_app_data_size);
   1c62c:	1c18      	adds	r0, r3, #0
        ntf_cb = m_raw_app_table.cb;
    }
    else
#endif // PSTORAGE_RAW_MODE_ENABLE
    {
        ntf_cb = m_app_table[p_elem->storage_addr.module_id].cb;
   1c62e:	6889      	ldr	r1, [r1, #8]
    }

    ntf_cb(&p_elem->storage_addr, op_code, result, p_elem->p_data_addr, m_app_data_size);
   1c630:	4d05      	ldr	r5, [pc, #20]	; (1c648 <app_notify.lto_priv.114+0x24>)
        ntf_cb = m_raw_app_table.cb;
    }
    else
#endif // PSTORAGE_RAW_MODE_ENABLE
    {
        ntf_cb = m_app_table[p_elem->storage_addr.module_id].cb;
   1c632:	434c      	muls	r4, r1
    }

    ntf_cb(&p_elem->storage_addr, op_code, result, p_elem->p_data_addr, m_app_data_size);
   1c634:	682d      	ldr	r5, [r5, #0]
   1c636:	7819      	ldrb	r1, [r3, #0]
   1c638:	9500      	str	r5, [sp, #0]
   1c63a:	4d04      	ldr	r5, [pc, #16]	; (1c64c <app_notify.lto_priv.114+0x28>)
   1c63c:	3008      	adds	r0, #8
   1c63e:	5964      	ldr	r4, [r4, r5]
   1c640:	691b      	ldr	r3, [r3, #16]
   1c642:	47a0      	blx	r4
}
   1c644:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
   1c646:	46c0      	nop			; (mov r8, r8)
   1c648:	20003328 	.word	0x20003328
   1c64c:	20003568 	.word	0x20003568

0001c650 <swap_sub_state_entry_action_run.lto_priv.112>:


/**@brief Function for dispatching the correct swap sub state entry action.
 */
static void swap_sub_state_entry_action_run(void)
{
   1c650:	b508      	push	{r3, lr}
        state_erase_data_page_entry_run,
        state_restore_tail_entry_run,
        state_restore_head_entry_run
    };
    
    swap_sub_state_sm_lut[m_swap_sub_state]();
   1c652:	4b03      	ldr	r3, [pc, #12]	; (1c660 <swap_sub_state_entry_action_run.lto_priv.112+0x10>)
   1c654:	4a03      	ldr	r2, [pc, #12]	; (1c664 <swap_sub_state_entry_action_run.lto_priv.112+0x14>)
   1c656:	781b      	ldrb	r3, [r3, #0]
   1c658:	009b      	lsls	r3, r3, #2
   1c65a:	589b      	ldr	r3, [r3, r2]
   1c65c:	4798      	blx	r3
}
   1c65e:	bd08      	pop	{r3, pc}
   1c660:	20003324 	.word	0x20003324
   1c664:	0002291c 	.word	0x0002291c

0001c668 <swap_sub_state_err_busy_process>:

/**@brief Function for reissuing the last flash operation request, which was rejected by the flash 
 *        API, in swap sub sate.
 */
static void swap_sub_state_err_busy_process(void)
{
   1c668:	b508      	push	{r3, lr}
    // Reissue the request by doing a self transition to the current state.    
    m_flags &= ~MASK_FLASH_API_ERR_BUSY;
   1c66a:	2308      	movs	r3, #8
   1c66c:	4a03      	ldr	r2, [pc, #12]	; (1c67c <swap_sub_state_err_busy_process+0x14>)
   1c66e:	6811      	ldr	r1, [r2, #0]
   1c670:	4399      	bics	r1, r3
   1c672:	6011      	str	r1, [r2, #0]
 * @param[in] new_state New swap sub state to transit to.
 */   
static void swap_sub_state_state_change(flash_swap_sub_state_t new_state)
{
    m_swap_sub_state = new_state;
    swap_sub_state_entry_action_run();    
   1c674:	f7ff ffec 	bl	1c650 <swap_sub_state_entry_action_run.lto_priv.112>
static void swap_sub_state_err_busy_process(void)
{
    // Reissue the request by doing a self transition to the current state.    
    m_flags &= ~MASK_FLASH_API_ERR_BUSY;
    swap_sub_state_state_change(m_swap_sub_state);        
}
   1c678:	bd08      	pop	{r3, pc}
   1c67a:	46c0      	nop			; (mov r8, r8)
   1c67c:	2000353c 	.word	0x2000353c

0001c680 <swap_erase_state_run>:


/**@brief Function for doing swap erase state action upon flash operation success event.
 */
static void swap_erase_state_run(void)
{
   1c680:	b508      	push	{r3, lr}
    if (!(m_flags & MASK_FLASH_API_ERR_BUSY))
   1c682:	4b06      	ldr	r3, [pc, #24]	; (1c69c <swap_erase_state_run+0x1c>)
   1c684:	681b      	ldr	r3, [r3, #0]
   1c686:	071b      	lsls	r3, r3, #28
   1c688:	d405      	bmi.n	1c696 <swap_erase_state_run+0x16>
 *
 * @param[in] new_state New swap sub state to transit to.
 */   
static void swap_sub_state_state_change(flash_swap_sub_state_t new_state)
{
    m_swap_sub_state = new_state;
   1c68a:	2201      	movs	r2, #1
   1c68c:	4b04      	ldr	r3, [pc, #16]	; (1c6a0 <swap_erase_state_run+0x20>)
   1c68e:	701a      	strb	r2, [r3, #0]
    swap_sub_state_entry_action_run();    
   1c690:	f7ff ffde 	bl	1c650 <swap_sub_state_entry_action_run.lto_priv.112>
   1c694:	e001      	b.n	1c69a <swap_erase_state_run+0x1a>
        swap_sub_state_state_change(STATE_WRITE_DATA_TO_SWAP);
    }
    else
    {
        // As operation request was rejected by the flash API reissue the request.
        swap_sub_state_err_busy_process();        
   1c696:	f7ff ffe7 	bl	1c668 <swap_sub_state_err_busy_process>
    }
}
   1c69a:	bd08      	pop	{r3, pc}
   1c69c:	2000353c 	.word	0x2000353c
   1c6a0:	20003324 	.word	0x20003324

0001c6a4 <data_to_swap_write_state_run>:

/**@brief Function for doing data to swap write state action upon flash operation success event.
 */
static void data_to_swap_write_state_run(void)
{        
    if (!(m_flags & MASK_FLASH_API_ERR_BUSY))
   1c6a4:	4a09      	ldr	r2, [pc, #36]	; (1c6cc <data_to_swap_write_state_run+0x28>)


/**@brief Function for doing data to swap write state action upon flash operation success event.
 */
static void data_to_swap_write_state_run(void)
{        
   1c6a6:	b508      	push	{r3, lr}
    if (!(m_flags & MASK_FLASH_API_ERR_BUSY))
   1c6a8:	6813      	ldr	r3, [r2, #0]
   1c6aa:	0719      	lsls	r1, r3, #28
   1c6ac:	d40a      	bmi.n	1c6c4 <data_to_swap_write_state_run+0x20>
    {
        // If the operation is executed only on 1 single flash page it automatically means that tail 
        // area is written to the swap, which we store to flags.     
        if (m_flags & MASK_SINGLE_PAGE_OPERATION)
   1c6ae:	0799      	lsls	r1, r3, #30
   1c6b0:	d502      	bpl.n	1c6b8 <data_to_swap_write_state_run+0x14>
        {
            m_flags |= MASK_TAIL_SWAP_DONE;        
   1c6b2:	2101      	movs	r1, #1
   1c6b4:	430b      	orrs	r3, r1
   1c6b6:	6013      	str	r3, [r2, #0]
 *
 * @param[in] new_state New swap sub state to transit to.
 */   
static void swap_sub_state_state_change(flash_swap_sub_state_t new_state)
{
    m_swap_sub_state = new_state;
   1c6b8:	2202      	movs	r2, #2
   1c6ba:	4b05      	ldr	r3, [pc, #20]	; (1c6d0 <data_to_swap_write_state_run+0x2c>)
   1c6bc:	701a      	strb	r2, [r3, #0]
    swap_sub_state_entry_action_run();    
   1c6be:	f7ff ffc7 	bl	1c650 <swap_sub_state_entry_action_run.lto_priv.112>
   1c6c2:	e001      	b.n	1c6c8 <data_to_swap_write_state_run+0x24>
        swap_sub_state_state_change(STATE_ERASE_DATA_PAGE);    
    }
    else
    {
        // As operation request was rejected by the flash API reissue the request.
        swap_sub_state_err_busy_process();        
   1c6c4:	f7ff ffd0 	bl	1c668 <swap_sub_state_err_busy_process>
    }        
}
   1c6c8:	bd08      	pop	{r3, pc}
   1c6ca:	46c0      	nop			; (mov r8, r8)
   1c6cc:	2000353c 	.word	0x2000353c
   1c6d0:	20003324 	.word	0x20003324

0001c6d4 <state_entry_action_run.lto_priv.113>:


/**@brief Function for dispatching the correct application main state entry action.
 */
static void state_entry_action_run(void)
{
   1c6d4:	b5f0      	push	{r4, r5, r6, r7, lr}
    switch (m_state)
   1c6d6:	4b2c      	ldr	r3, [pc, #176]	; (1c788 <state_entry_action_run.lto_priv.113+0xb4>)


/**@brief Function for dispatching the correct application main state entry action.
 */
static void state_entry_action_run(void)
{
   1c6d8:	b085      	sub	sp, #20
    switch (m_state)
   1c6da:	7818      	ldrb	r0, [r3, #0]
   1c6dc:	2803      	cmp	r0, #3
   1c6de:	d850      	bhi.n	1c782 <state_entry_action_run.lto_priv.113+0xae>
   1c6e0:	f005 fcc0 	bl	22064 <__gnu_thumb1_case_uqi>
   1c6e4:	4b110e02 	.word	0x4b110e02
 * @details Function for idle state entry actions, which include resetting relevant state data and 
 *          scheduling any possible queued flash access operation.
 */
static void state_idle_entry_run(void)
{
    m_num_of_command_retries = 0;
   1c6e8:	2300      	movs	r3, #0
   1c6ea:	4a28      	ldr	r2, [pc, #160]	; (1c78c <state_entry_action_run.lto_priv.113+0xb8>)
   1c6ec:	6013      	str	r3, [r2, #0]
    m_num_of_bytes_written   = 0;
   1c6ee:	4a28      	ldr	r2, [pc, #160]	; (1c790 <state_entry_action_run.lto_priv.113+0xbc>)
   1c6f0:	6013      	str	r3, [r2, #0]

/**@brief Function for dequeing a possible pending flash access operation.
 */
static void cmd_queue_dequeue(void)
{
    if ((m_cmd_queue.count != 0)) 
   1c6f2:	4b28      	ldr	r3, [pc, #160]	; (1c794 <state_entry_action_run.lto_priv.113+0xc0>)
   1c6f4:	785b      	ldrb	r3, [r3, #1]
   1c6f6:	2b00      	cmp	r3, #0
   1c6f8:	d043      	beq.n	1c782 <state_entry_action_run.lto_priv.113+0xae>
    {
        cmd_process();
   1c6fa:	f000 f901 	bl	1c900 <cmd_process.lto_priv.62>
   1c6fe:	e040      	b.n	1c782 <state_entry_action_run.lto_priv.113+0xae>
 *
 * @details Function for store state entry action, which includes writing data to a flash page.
 */
static void state_store_entry_run(void)
{
    store_cmd_flash_write_execute();    
   1c700:	f000 f950 	bl	1c9a4 <store_cmd_flash_write_execute>
   1c704:	e03d      	b.n	1c782 <state_entry_action_run.lto_priv.113+0xae>
 * @details Function for data erase with swap state entry actions. This includes adjusting relevant 
 *          state and data variables and transitioning to the correct sub state.
 */
static void state_data_erase_swap_entry_run(void)
{
    m_flags &= ~MASK_TAIL_SWAP_DONE;
   1c706:	4c24      	ldr	r4, [pc, #144]	; (1c798 <state_entry_action_run.lto_priv.113+0xc4>)
   1c708:	2780      	movs	r7, #128	; 0x80
   1c70a:	6823      	ldr	r3, [r4, #0]
   1c70c:	057f      	lsls	r7, r7, #21
   1c70e:	9301      	str	r3, [sp, #4]
   1c710:	2301      	movs	r3, #1
   1c712:	9a01      	ldr	r2, [sp, #4]
   1c714:	439a      	bics	r2, r3
    
    const cmd_queue_element_t * p_cmd        = &m_cmd_queue.cmd[m_cmd_queue.rp];
    const pstorage_block_t      cmd_block_id = p_cmd->storage_addr.block_id;
   1c716:	2314      	movs	r3, #20
 * @details Function for data erase with swap state entry actions. This includes adjusting relevant 
 *          state and data variables and transitioning to the correct sub state.
 */
static void state_data_erase_swap_entry_run(void)
{
    m_flags &= ~MASK_TAIL_SWAP_DONE;
   1c718:	6022      	str	r2, [r4, #0]
   1c71a:	9202      	str	r2, [sp, #8]
    
    const cmd_queue_element_t * p_cmd        = &m_cmd_queue.cmd[m_cmd_queue.rp];
   1c71c:	4a1d      	ldr	r2, [pc, #116]	; (1c794 <state_entry_action_run.lto_priv.113+0xc0>)
   1c71e:	6939      	ldr	r1, [r7, #16]
   1c720:	7815      	ldrb	r5, [r2, #0]
    const pstorage_block_t      cmd_block_id = p_cmd->storage_addr.block_id;
    
    const uint32_t clear_start_page_id = cmd_block_id / PSTORAGE_FLASH_PAGE_SIZE;
   1c722:	b289      	uxth	r1, r1
static void state_data_erase_swap_entry_run(void)
{
    m_flags &= ~MASK_TAIL_SWAP_DONE;
    
    const cmd_queue_element_t * p_cmd        = &m_cmd_queue.cmd[m_cmd_queue.rp];
    const pstorage_block_t      cmd_block_id = p_cmd->storage_addr.block_id;
   1c724:	435d      	muls	r5, r3
   1c726:	1955      	adds	r5, r2, r5
   1c728:	692b      	ldr	r3, [r5, #16]
    
    const uint32_t clear_start_page_id = cmd_block_id / PSTORAGE_FLASH_PAGE_SIZE;
   1c72a:	1c18      	adds	r0, r3, #0
static void state_data_erase_swap_entry_run(void)
{
    m_flags &= ~MASK_TAIL_SWAP_DONE;
    
    const cmd_queue_element_t * p_cmd        = &m_cmd_queue.cmd[m_cmd_queue.rp];
    const pstorage_block_t      cmd_block_id = p_cmd->storage_addr.block_id;
   1c72c:	9303      	str	r3, [sp, #12]
    
    const uint32_t clear_start_page_id = cmd_block_id / PSTORAGE_FLASH_PAGE_SIZE;
   1c72e:	f005 fca3 	bl	22078 <__aeabi_uidiv>
    m_current_page_id                  = clear_start_page_id;      
   1c732:	4b1a      	ldr	r3, [pc, #104]	; (1c79c <state_entry_action_run.lto_priv.113+0xc8>)
    m_flags &= ~MASK_TAIL_SWAP_DONE;
    
    const cmd_queue_element_t * p_cmd        = &m_cmd_queue.cmd[m_cmd_queue.rp];
    const pstorage_block_t      cmd_block_id = p_cmd->storage_addr.block_id;
    
    const uint32_t clear_start_page_id = cmd_block_id / PSTORAGE_FLASH_PAGE_SIZE;
   1c734:	1c06      	adds	r6, r0, #0
    m_current_page_id                  = clear_start_page_id;      
   1c736:	6018      	str	r0, [r3, #0]
   1c738:	9b03      	ldr	r3, [sp, #12]
   1c73a:	6939      	ldr	r1, [r7, #16]
   1c73c:	1e58      	subs	r0, r3, #1
    // @note: No need to include p_cmd->offset when calculating clear_end_page_id as:
    // - clear API does not include offset parameter
    // - update and store APIs are limited to operate on single block boundary thus the boolean 
    // clause ((m_head_word_size == 0) && is_more_than_one_page) below in this function  will never 
    // evaluate as true as if is_more_than_one_page == true m_head_word_size is always != 0        
    const uint32_t clear_end_page_id  = (cmd_block_id + p_cmd->size - 1u) / 
   1c73e:	88eb      	ldrh	r3, [r5, #6]
   1c740:	b289      	uxth	r1, r1
   1c742:	18c0      	adds	r0, r0, r3
   1c744:	f005 fc98 	bl	22078 <__aeabi_uidiv>
                                        PSTORAGE_FLASH_PAGE_SIZE;

    if (clear_start_page_id == clear_end_page_id)
   1c748:	4286      	cmp	r6, r0
   1c74a:	d103      	bne.n	1c754 <state_entry_action_run.lto_priv.113+0x80>
    {
        m_flags |= MASK_SINGLE_PAGE_OPERATION;
   1c74c:	2302      	movs	r3, #2
   1c74e:	9a02      	ldr	r2, [sp, #8]
   1c750:	4313      	orrs	r3, r2
   1c752:	e003      	b.n	1c75c <state_entry_action_run.lto_priv.113+0x88>
    }
    else
    {
        m_flags &= ~MASK_SINGLE_PAGE_OPERATION;
   1c754:	2303      	movs	r3, #3
   1c756:	9a01      	ldr	r2, [sp, #4]
   1c758:	439a      	bics	r2, r3
   1c75a:	1c13      	adds	r3, r2, #0
   1c75c:	6023      	str	r3, [r4, #0]
    }
                            
    if ((m_head_word_size == 0) && !(m_flags & MASK_SINGLE_PAGE_OPERATION))
   1c75e:	4b10      	ldr	r3, [pc, #64]	; (1c7a0 <state_entry_action_run.lto_priv.113+0xcc>)
   1c760:	681a      	ldr	r2, [r3, #0]
   1c762:	4b10      	ldr	r3, [pc, #64]	; (1c7a4 <state_entry_action_run.lto_priv.113+0xd0>)
   1c764:	2a00      	cmp	r2, #0
   1c766:	d103      	bne.n	1c770 <state_entry_action_run.lto_priv.113+0x9c>
   1c768:	6821      	ldr	r1, [r4, #0]
   1c76a:	3202      	adds	r2, #2
   1c76c:	4211      	tst	r1, r2
   1c76e:	d000      	beq.n	1c772 <state_entry_action_run.lto_priv.113+0x9e>
 *
 * @param[in] new_state New swap sub state to transit to.
 */   
static void swap_sub_state_state_change(flash_swap_sub_state_t new_state)
{
    m_swap_sub_state = new_state;
   1c770:	2200      	movs	r2, #0
   1c772:	701a      	strb	r2, [r3, #0]
    swap_sub_state_entry_action_run();    
   1c774:	f7ff ff6c 	bl	1c650 <swap_sub_state_entry_action_run.lto_priv.112>
   1c778:	e003      	b.n	1c782 <state_entry_action_run.lto_priv.113+0xae>
 *
 * @details Function for data erase state entry action, which includes erasing the data flash page.
 */
static void state_data_erase_entry_run(void)
{
    flash_page_erase(m_current_page_id);                          
   1c77a:	4b08      	ldr	r3, [pc, #32]	; (1c79c <state_entry_action_run.lto_priv.113+0xc8>)
   1c77c:	6818      	ldr	r0, [r3, #0]
   1c77e:	f000 f8fd 	bl	1c97c <flash_page_erase>
                        
        default:
            // No action needed.
            break;
    }
}
   1c782:	b005      	add	sp, #20
   1c784:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1c786:	46c0      	nop			; (mov r8, r8)
   1c788:	2000357e 	.word	0x2000357e
   1c78c:	200031d0 	.word	0x200031d0
   1c790:	200035a8 	.word	0x200035a8
   1c794:	200033e0 	.word	0x200033e0
   1c798:	2000353c 	.word	0x2000353c
   1c79c:	200035ac 	.word	0x200035ac
   1c7a0:	20003330 	.word	0x20003330
   1c7a4:	20003324 	.word	0x20003324

0001c7a8 <clear_operation_execute>:
/**@brief Function for executing the clear operation.
 */
static void clear_operation_execute(void)
{    
    const cmd_queue_element_t * p_cmd        = &m_cmd_queue.cmd[m_cmd_queue.rp];
    const pstorage_block_t      cmd_block_id = p_cmd->storage_addr.block_id;
   1c7a8:	2214      	movs	r2, #20


/**@brief Function for executing the clear operation.
 */
static void clear_operation_execute(void)
{    
   1c7aa:	b5f0      	push	{r4, r5, r6, r7, lr}
    const cmd_queue_element_t * p_cmd        = &m_cmd_queue.cmd[m_cmd_queue.rp];
   1c7ac:	494e      	ldr	r1, [pc, #312]	; (1c8e8 <clear_operation_execute+0x140>)


/**@brief Function for executing the clear operation.
 */
static void clear_operation_execute(void)
{    
   1c7ae:	b085      	sub	sp, #20
    const cmd_queue_element_t * p_cmd        = &m_cmd_queue.cmd[m_cmd_queue.rp];
   1c7b0:	780b      	ldrb	r3, [r1, #0]
   1c7b2:	2580      	movs	r5, #128	; 0x80
    const pstorage_block_t      cmd_block_id = p_cmd->storage_addr.block_id;
   1c7b4:	4353      	muls	r3, r2
   1c7b6:	18cb      	adds	r3, r1, r3
   1c7b8:	1c1a      	adds	r2, r3, #0
   1c7ba:	3208      	adds	r2, #8

    const pstorage_size_t  block_size    = m_app_table[p_cmd->storage_addr.module_id].block_size;
   1c7bc:	6852      	ldr	r2, [r2, #4]
   1c7be:	056d      	lsls	r5, r5, #21
   1c7c0:	9201      	str	r2, [sp, #4]
   1c7c2:	220c      	movs	r2, #12
   1c7c4:	9801      	ldr	r0, [sp, #4]
   1c7c6:	6929      	ldr	r1, [r5, #16]
   1c7c8:	4342      	muls	r2, r0
   1c7ca:	4848      	ldr	r0, [pc, #288]	; (1c8ec <clear_operation_execute+0x144>)
/**@brief Function for executing the clear operation.
 */
static void clear_operation_execute(void)
{    
    const cmd_queue_element_t * p_cmd        = &m_cmd_queue.cmd[m_cmd_queue.rp];
    const pstorage_block_t      cmd_block_id = p_cmd->storage_addr.block_id;
   1c7cc:	691c      	ldr	r4, [r3, #16]

    const pstorage_size_t  block_size    = m_app_table[p_cmd->storage_addr.module_id].block_size;
   1c7ce:	1882      	adds	r2, r0, r2
      
    const bool is_start_address_page_aligned = (cmd_block_id % PSTORAGE_FLASH_PAGE_SIZE) == 0;
    
    // Calculate the end (1 beyond allocated area) for complete storage area and to the area only 
    // within scope of this command.
    const pstorage_block_t end_of_storage_address     = block_base_id + (block_size * block_count); 
   1c7d0:	8950      	ldrh	r0, [r2, #10]
   1c7d2:	8916      	ldrh	r6, [r2, #8]
   1c7d4:	6852      	ldr	r2, [r2, #4]
   1c7d6:	4370      	muls	r0, r6
   1c7d8:	1882      	adds	r2, r0, r2
   1c7da:	9202      	str	r2, [sp, #8]
    const pstorage_block_t cmd_end_of_storage_address = cmd_block_id + p_cmd->size + p_cmd->offset;
   1c7dc:	88da      	ldrh	r2, [r3, #6]

    // Zero tail to make sure no extra erase is done erroneously.
    m_tail_word_size = 0;        
   1c7de:	4e44      	ldr	r6, [pc, #272]	; (1c8f0 <clear_operation_execute+0x148>)
    const bool is_start_address_page_aligned = (cmd_block_id % PSTORAGE_FLASH_PAGE_SIZE) == 0;
    
    // Calculate the end (1 beyond allocated area) for complete storage area and to the area only 
    // within scope of this command.
    const pstorage_block_t end_of_storage_address     = block_base_id + (block_size * block_count); 
    const pstorage_block_t cmd_end_of_storage_address = cmd_block_id + p_cmd->size + p_cmd->offset;
   1c7e0:	9203      	str	r2, [sp, #12]
   1c7e2:	891f      	ldrh	r7, [r3, #8]

    const pstorage_size_t  block_size    = m_app_table[p_cmd->storage_addr.module_id].block_size;
    const pstorage_size_t  block_count   = m_app_table[p_cmd->storage_addr.module_id].block_count;
    const pstorage_block_t block_base_id = m_app_table[p_cmd->storage_addr.module_id].base_id;  
      
    const bool is_start_address_page_aligned = (cmd_block_id % PSTORAGE_FLASH_PAGE_SIZE) == 0;
   1c7e4:	b289      	uxth	r1, r1
   1c7e6:	19d3      	adds	r3, r2, r7
    
    // Calculate the end (1 beyond allocated area) for complete storage area and to the area only 
    // within scope of this command.
    const pstorage_block_t end_of_storage_address     = block_base_id + (block_size * block_count); 
    const pstorage_block_t cmd_end_of_storage_address = cmd_block_id + p_cmd->size + p_cmd->offset;
   1c7e8:	191b      	adds	r3, r3, r4
   1c7ea:	9300      	str	r3, [sp, #0]

    // Zero tail to make sure no extra erase is done erroneously.
    m_tail_word_size = 0;        
   1c7ec:	2300      	movs	r3, #0

    const pstorage_size_t  block_size    = m_app_table[p_cmd->storage_addr.module_id].block_size;
    const pstorage_size_t  block_count   = m_app_table[p_cmd->storage_addr.module_id].block_count;
    const pstorage_block_t block_base_id = m_app_table[p_cmd->storage_addr.module_id].base_id;  
      
    const bool is_start_address_page_aligned = (cmd_block_id % PSTORAGE_FLASH_PAGE_SIZE) == 0;
   1c7ee:	1c20      	adds	r0, r4, #0
    // within scope of this command.
    const pstorage_block_t end_of_storage_address     = block_base_id + (block_size * block_count); 
    const pstorage_block_t cmd_end_of_storage_address = cmd_block_id + p_cmd->size + p_cmd->offset;

    // Zero tail to make sure no extra erase is done erroneously.
    m_tail_word_size = 0;        
   1c7f0:	6033      	str	r3, [r6, #0]

    const pstorage_size_t  block_size    = m_app_table[p_cmd->storage_addr.module_id].block_size;
    const pstorage_size_t  block_count   = m_app_table[p_cmd->storage_addr.module_id].block_count;
    const pstorage_block_t block_base_id = m_app_table[p_cmd->storage_addr.module_id].base_id;  
      
    const bool is_start_address_page_aligned = (cmd_block_id % PSTORAGE_FLASH_PAGE_SIZE) == 0;
   1c7f2:	f005 fcc7 	bl	22184 <__aeabi_uidivmod>
   1c7f6:	1c2a      	adds	r2, r5, #0
    // - 1st logical test covers the case of: clear/update 1 complete single page.
    // - 2nd logical test covers the case of: 
    //   1) Clear/update last allocated page and page is not full (page can't be shared between 
    //      multiple clients so the end of the page is unused area).
    //   2) Clear/update all allocated storage.
    if ((is_start_address_page_aligned && (p_cmd->size == PSTORAGE_FLASH_PAGE_SIZE)) ||
   1c7f8:	2900      	cmp	r1, #0
   1c7fa:	d10b      	bne.n	1c814 <clear_operation_execute+0x6c>
   1c7fc:	692b      	ldr	r3, [r5, #16]
   1c7fe:	9903      	ldr	r1, [sp, #12]
   1c800:	b29b      	uxth	r3, r3
   1c802:	4299      	cmp	r1, r3
   1c804:	d009      	beq.n	1c81a <clear_operation_execute+0x72>
        (is_start_address_page_aligned && (cmd_end_of_storage_address == end_of_storage_address) && 
   1c806:	9b00      	ldr	r3, [sp, #0]
   1c808:	9902      	ldr	r1, [sp, #8]
   1c80a:	428b      	cmp	r3, r1
   1c80c:	d151      	bne.n	1c8b2 <clear_operation_execute+0x10a>
   1c80e:	2f00      	cmp	r7, #0
   1c810:	d15c      	bne.n	1c8cc <clear_operation_execute+0x124>
   1c812:	e002      	b.n	1c81a <clear_operation_execute+0x72>
        (p_cmd->offset == 0)) || (p_cmd->storage_addr.module_id == RAW_MODE_APP_ID)) 
   1c814:	9b01      	ldr	r3, [sp, #4]
   1c816:	2b02      	cmp	r3, #2
   1c818:	d108      	bne.n	1c82c <clear_operation_execute+0x84>
   1c81a:	6911      	ldr	r1, [r2, #16]
    {
        // Nothing to put to the swap and we can just erase the pages(s).         
        
        m_current_page_id = cmd_block_id / PSTORAGE_FLASH_PAGE_SIZE;
   1c81c:	1c20      	adds	r0, r4, #0
   1c81e:	b289      	uxth	r1, r1
   1c820:	f005 fc2a 	bl	22078 <__aeabi_uidiv>
   1c824:	4b33      	ldr	r3, [pc, #204]	; (1c8f4 <clear_operation_execute+0x14c>)
   1c826:	6018      	str	r0, [r3, #0]
 *
 * @param[in] new_state New application main state to transit to.
 */
static void sm_state_change(pstorage_state_t new_state)
{
    m_state = new_state;
   1c828:	2303      	movs	r3, #3
   1c82a:	e03c      	b.n	1c8a6 <clear_operation_execute+0xfe>
   1c82c:	6929      	ldr	r1, [r5, #16]
    else
    {
        // Not all the blocks for the module can be cleared, we need to use swap page for storing 
        // data temporarily.                        
        
        m_head_word_size = ((cmd_block_id + p_cmd->offset) % PSTORAGE_FLASH_PAGE_SIZE) / 
   1c82e:	1938      	adds	r0, r7, r4
   1c830:	b289      	uxth	r1, r1
   1c832:	f005 fca7 	bl	22184 <__aeabi_uidivmod>
   1c836:	4b30      	ldr	r3, [pc, #192]	; (1c8f8 <clear_operation_execute+0x150>)
   1c838:	0889      	lsrs	r1, r1, #2
   1c83a:	6019      	str	r1, [r3, #0]
                           sizeof(uint32_t);
        
        const bool is_cmd_end_address_page_aligned = ((cmd_end_of_storage_address % 
                                                      PSTORAGE_FLASH_PAGE_SIZE) == 0);
        if ((cmd_end_of_storage_address != end_of_storage_address) && 
   1c83c:	9a02      	ldr	r2, [sp, #8]
   1c83e:	9b00      	ldr	r3, [sp, #0]
   1c840:	6929      	ldr	r1, [r5, #16]
   1c842:	4293      	cmp	r3, r2
   1c844:	d02e      	beq.n	1c8a4 <clear_operation_execute+0xfc>
        // data temporarily.                        
        
        m_head_word_size = ((cmd_block_id + p_cmd->offset) % PSTORAGE_FLASH_PAGE_SIZE) / 
                           sizeof(uint32_t);
        
        const bool is_cmd_end_address_page_aligned = ((cmd_end_of_storage_address % 
   1c846:	b289      	uxth	r1, r1
   1c848:	9800      	ldr	r0, [sp, #0]
   1c84a:	f005 fc9b 	bl	22184 <__aeabi_uidivmod>
                                                      PSTORAGE_FLASH_PAGE_SIZE) == 0);
        if ((cmd_end_of_storage_address != end_of_storage_address) && 
   1c84e:	2900      	cmp	r1, #0
   1c850:	d028      	beq.n	1c8a4 <clear_operation_execute+0xfc>
   1c852:	2480      	movs	r4, #128	; 0x80
            !is_cmd_end_address_page_aligned)
        {
            // When command area is not equal to end of the storage allocation area and not ending 
            // to page boundary there is a need to restore the tail area.
            tail_word_size_calculate(cmd_end_of_storage_address, end_of_storage_address);
   1c854:	466b      	mov	r3, sp
   1c856:	0564      	lsls	r4, r4, #21
   1c858:	6921      	ldr	r1, [r4, #16]
   1c85a:	881f      	ldrh	r7, [r3, #0]
   1c85c:	6923      	ldr	r3, [r4, #16]
{ 
    // Two different cases to resolve when calculating correct size for restore tail section:
    // 1) End of storage area and command end area are in the same page.
    // 2) End of storage area and command end area are not in the same page.
    
    const uint32_t end_of_storage_area_page         = end_of_storage_address     / 
   1c85e:	b289      	uxth	r1, r1
   1c860:	9301      	str	r3, [sp, #4]
   1c862:	466b      	mov	r3, sp
   1c864:	8918      	ldrh	r0, [r3, #8]
   1c866:	f005 fc07 	bl	22078 <__aeabi_uidiv>
                                                      PSTORAGE_FLASH_PAGE_SIZE;
    const uint32_t command_end_of_storage_area_page = cmd_end_of_storage_address / 
   1c86a:	466b      	mov	r3, sp
{ 
    // Two different cases to resolve when calculating correct size for restore tail section:
    // 1) End of storage area and command end area are in the same page.
    // 2) End of storage area and command end area are not in the same page.
    
    const uint32_t end_of_storage_area_page         = end_of_storage_address     / 
   1c86c:	1c05      	adds	r5, r0, #0
                                                      PSTORAGE_FLASH_PAGE_SIZE;
    const uint32_t command_end_of_storage_area_page = cmd_end_of_storage_address / 
   1c86e:	8899      	ldrh	r1, [r3, #4]
   1c870:	1c38      	adds	r0, r7, #0
   1c872:	f005 fc01 	bl	22078 <__aeabi_uidiv>
                                                      PSTORAGE_FLASH_PAGE_SIZE;

    if (end_of_storage_area_page == command_end_of_storage_area_page)
   1c876:	b2ad      	uxth	r5, r5
   1c878:	b280      	uxth	r0, r0
   1c87a:	4285      	cmp	r5, r0
   1c87c:	d107      	bne.n	1c88e <clear_operation_execute+0xe6>
   1c87e:	466b      	mov	r3, sp
   1c880:	466a      	mov	r2, sp
   1c882:	891b      	ldrh	r3, [r3, #8]
   1c884:	8812      	ldrh	r2, [r2, #0]
    {
        //lint -e{573} suppress "Signed-unsigned mix with divide".
        m_tail_word_size = (end_of_storage_address - cmd_end_of_storage_address) / sizeof(uint32_t);                                           
   1c886:	1a9b      	subs	r3, r3, r2
   1c888:	089b      	lsrs	r3, r3, #2
   1c88a:	6033      	str	r3, [r6, #0]
   1c88c:	e00a      	b.n	1c8a4 <clear_operation_execute+0xfc>
   1c88e:	6923      	ldr	r3, [r4, #16]
   1c890:	6921      	ldr	r1, [r4, #16]
    }
    else
    {
        //lint -e{573} suppress "Signed-unsigned mix with divide".    
        m_tail_word_size = (PSTORAGE_FLASH_PAGE_SIZE - 
                           (cmd_end_of_storage_address % PSTORAGE_FLASH_PAGE_SIZE)) / 
   1c892:	1c38      	adds	r0, r7, #0
   1c894:	b289      	uxth	r1, r1
   1c896:	b29c      	uxth	r4, r3
   1c898:	f005 fc74 	bl	22184 <__aeabi_uidivmod>
   1c89c:	b289      	uxth	r1, r1
        m_tail_word_size = (end_of_storage_address - cmd_end_of_storage_address) / sizeof(uint32_t);                                           
    }
    else
    {
        //lint -e{573} suppress "Signed-unsigned mix with divide".    
        m_tail_word_size = (PSTORAGE_FLASH_PAGE_SIZE - 
   1c89e:	1a64      	subs	r4, r4, r1
                           (cmd_end_of_storage_address % PSTORAGE_FLASH_PAGE_SIZE)) / 
   1c8a0:	08a4      	lsrs	r4, r4, #2
        m_tail_word_size = (end_of_storage_address - cmd_end_of_storage_address) / sizeof(uint32_t);                                           
    }
    else
    {
        //lint -e{573} suppress "Signed-unsigned mix with divide".    
        m_tail_word_size = (PSTORAGE_FLASH_PAGE_SIZE - 
   1c8a2:	6034      	str	r4, [r6, #0]
 *
 * @param[in] new_state New application main state to transit to.
 */
static void sm_state_change(pstorage_state_t new_state)
{
    m_state = new_state;
   1c8a4:	2302      	movs	r3, #2
   1c8a6:	4a15      	ldr	r2, [pc, #84]	; (1c8fc <clear_operation_execute+0x154>)
   1c8a8:	7013      	strb	r3, [r2, #0]
    state_entry_action_run();
   1c8aa:	f7ff ff13 	bl	1c6d4 <state_entry_action_run.lto_priv.113>
            tail_word_size_calculate(cmd_end_of_storage_address, end_of_storage_address);
        }

        sm_state_change(STATE_DATA_ERASE_WITH_SWAP);         
    }        
}
   1c8ae:	b005      	add	sp, #20
   1c8b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    //   1) Clear/update last allocated page and page is not full (page can't be shared between 
    //      multiple clients so the end of the page is unused area).
    //   2) Clear/update all allocated storage.
    if ((is_start_address_page_aligned && (p_cmd->size == PSTORAGE_FLASH_PAGE_SIZE)) ||
        (is_start_address_page_aligned && (cmd_end_of_storage_address == end_of_storage_address) && 
        (p_cmd->offset == 0)) || (p_cmd->storage_addr.module_id == RAW_MODE_APP_ID)) 
   1c8b2:	9b01      	ldr	r3, [sp, #4]
   1c8b4:	2b02      	cmp	r3, #2
   1c8b6:	d0b0      	beq.n	1c81a <clear_operation_execute+0x72>
   1c8b8:	6929      	ldr	r1, [r5, #16]
    else
    {
        // Not all the blocks for the module can be cleared, we need to use swap page for storing 
        // data temporarily.                        
        
        m_head_word_size = ((cmd_block_id + p_cmd->offset) % PSTORAGE_FLASH_PAGE_SIZE) / 
   1c8ba:	1938      	adds	r0, r7, r4
   1c8bc:	b289      	uxth	r1, r1
   1c8be:	f005 fc61 	bl	22184 <__aeabi_uidivmod>
   1c8c2:	4b0d      	ldr	r3, [pc, #52]	; (1c8f8 <clear_operation_execute+0x150>)
   1c8c4:	0889      	lsrs	r1, r1, #2
   1c8c6:	6019      	str	r1, [r3, #0]
   1c8c8:	6929      	ldr	r1, [r5, #16]
   1c8ca:	e7bc      	b.n	1c846 <clear_operation_execute+0x9e>
    //   1) Clear/update last allocated page and page is not full (page can't be shared between 
    //      multiple clients so the end of the page is unused area).
    //   2) Clear/update all allocated storage.
    if ((is_start_address_page_aligned && (p_cmd->size == PSTORAGE_FLASH_PAGE_SIZE)) ||
        (is_start_address_page_aligned && (cmd_end_of_storage_address == end_of_storage_address) && 
        (p_cmd->offset == 0)) || (p_cmd->storage_addr.module_id == RAW_MODE_APP_ID)) 
   1c8cc:	9b01      	ldr	r3, [sp, #4]
   1c8ce:	2b02      	cmp	r3, #2
   1c8d0:	d0a3      	beq.n	1c81a <clear_operation_execute+0x72>
   1c8d2:	6929      	ldr	r1, [r5, #16]
    else
    {
        // Not all the blocks for the module can be cleared, we need to use swap page for storing 
        // data temporarily.                        
        
        m_head_word_size = ((cmd_block_id + p_cmd->offset) % PSTORAGE_FLASH_PAGE_SIZE) / 
   1c8d4:	1938      	adds	r0, r7, r4
   1c8d6:	b289      	uxth	r1, r1
   1c8d8:	f005 fc54 	bl	22184 <__aeabi_uidivmod>
   1c8dc:	4b06      	ldr	r3, [pc, #24]	; (1c8f8 <clear_operation_execute+0x150>)
   1c8de:	0889      	lsrs	r1, r1, #2
   1c8e0:	6019      	str	r1, [r3, #0]
   1c8e2:	692b      	ldr	r3, [r5, #16]
   1c8e4:	e7de      	b.n	1c8a4 <clear_operation_execute+0xfc>
   1c8e6:	46c0      	nop			; (mov r8, r8)
   1c8e8:	200033e0 	.word	0x200033e0
   1c8ec:	20003568 	.word	0x20003568
   1c8f0:	20003318 	.word	0x20003318
   1c8f4:	200035ac 	.word	0x200035ac
   1c8f8:	20003330 	.word	0x20003330
   1c8fc:	2000357e 	.word	0x2000357e

0001c900 <cmd_process.lto_priv.62>:
/**@brief Function for dispatching the flash access operation.
 */  
static void cmd_process(void)
{
    const cmd_queue_element_t * p_cmd = &m_cmd_queue.cmd[m_cmd_queue.rp];
    m_app_data_size                   = p_cmd->size;
   1c900:	2214      	movs	r2, #20


/**@brief Function for dispatching the flash access operation.
 */  
static void cmd_process(void)
{
   1c902:	b508      	push	{r3, lr}
    const cmd_queue_element_t * p_cmd = &m_cmd_queue.cmd[m_cmd_queue.rp];
   1c904:	490a      	ldr	r1, [pc, #40]	; (1c930 <cmd_process.lto_priv.62+0x30>)
   1c906:	780b      	ldrb	r3, [r1, #0]
    m_app_data_size                   = p_cmd->size;
   1c908:	4353      	muls	r3, r2
   1c90a:	18cb      	adds	r3, r1, r3
   1c90c:	88d9      	ldrh	r1, [r3, #6]
   1c90e:	4a09      	ldr	r2, [pc, #36]	; (1c934 <cmd_process.lto_priv.62+0x34>)
   1c910:	6011      	str	r1, [r2, #0]

    switch (p_cmd->op_code)
   1c912:	791b      	ldrb	r3, [r3, #4]
   1c914:	2b03      	cmp	r3, #3
   1c916:	d008      	beq.n	1c92a <cmd_process.lto_priv.62+0x2a>
   1c918:	2b04      	cmp	r3, #4
   1c91a:	d006      	beq.n	1c92a <cmd_process.lto_priv.62+0x2a>
   1c91c:	2b01      	cmp	r3, #1
   1c91e:	d106      	bne.n	1c92e <cmd_process.lto_priv.62+0x2e>
 *
 * @param[in] new_state New application main state to transit to.
 */
static void sm_state_change(pstorage_state_t new_state)
{
    m_state = new_state;
   1c920:	4a05      	ldr	r2, [pc, #20]	; (1c938 <cmd_process.lto_priv.62+0x38>)
   1c922:	7013      	strb	r3, [r2, #0]
    state_entry_action_run();
   1c924:	f7ff fed6 	bl	1c6d4 <state_entry_action_run.lto_priv.113>
   1c928:	e001      	b.n	1c92e <cmd_process.lto_priv.62+0x2e>

/**@brief Function for executing the update operation.
 */ 
static void update_operation_execute(void)
{
    clear_operation_execute();
   1c92a:	f7ff ff3d 	bl	1c7a8 <clear_operation_execute>

        default:
            // No action required.
            break;
    }
}
   1c92e:	bd08      	pop	{r3, pc}
   1c930:	200033e0 	.word	0x200033e0
   1c934:	20003328 	.word	0x20003328
   1c938:	2000357e 	.word	0x2000357e

0001c93c <flash_api_err_code_process>:
/**@brief Function for processing flash API error code.
 *
 * @param[in] err_code Error code from the flash API.
 */
static void flash_api_err_code_process(uint32_t err_code)
{
   1c93c:	b508      	push	{r3, lr}
    switch (err_code)
   1c93e:	2800      	cmp	r0, #0
   1c940:	d014      	beq.n	1c96c <flash_api_err_code_process+0x30>
   1c942:	2811      	cmp	r0, #17
   1c944:	d105      	bne.n	1c952 <flash_api_err_code_process+0x16>
            break;
            
        case NRF_ERROR_BUSY:
            // Flash access operation was not accepted and must be reissued upon flash operation 
            // complete event.
            m_flags |= MASK_FLASH_API_ERR_BUSY;        
   1c946:	2308      	movs	r3, #8
   1c948:	4a09      	ldr	r2, [pc, #36]	; (1c970 <flash_api_err_code_process+0x34>)
   1c94a:	6811      	ldr	r1, [r2, #0]
   1c94c:	430b      	orrs	r3, r1
   1c94e:	6013      	str	r3, [r2, #0]
   1c950:	e00c      	b.n	1c96c <flash_api_err_code_process+0x30>
 *
 * @param[in] result Result code of the operation for the application.
 */
static void app_notify_error_state_transit(uint32_t result)
{
    app_notify(result, &m_cmd_queue.cmd[m_cmd_queue.rp]);
   1c952:	2214      	movs	r2, #20
   1c954:	4b07      	ldr	r3, [pc, #28]	; (1c974 <flash_api_err_code_process+0x38>)
   1c956:	7819      	ldrb	r1, [r3, #0]
   1c958:	4351      	muls	r1, r2
   1c95a:	18c9      	adds	r1, r1, r3
   1c95c:	3104      	adds	r1, #4
   1c95e:	f7ff fe61 	bl	1c624 <app_notify.lto_priv.114>
 *
 * @param[in] new_state New application main state to transit to.
 */
static void sm_state_change(pstorage_state_t new_state)
{
    m_state = new_state;
   1c962:	2204      	movs	r2, #4
   1c964:	4b04      	ldr	r3, [pc, #16]	; (1c978 <flash_api_err_code_process+0x3c>)
   1c966:	701a      	strb	r2, [r3, #0]
    state_entry_action_run();
   1c968:	f7ff feb4 	bl	1c6d4 <state_entry_action_run.lto_priv.113>
        default:
            // Complete the operation with appropriate result code and transit to an error state. 
            app_notify_error_state_transit(err_code);
            break;
    }
}
   1c96c:	bd08      	pop	{r3, pc}
   1c96e:	46c0      	nop			; (mov r8, r8)
   1c970:	2000353c 	.word	0x2000353c
   1c974:	200033e0 	.word	0x200033e0
   1c978:	2000357e 	.word	0x2000357e

0001c97c <flash_page_erase>:
/**@brief Function for erasing flash page.
 *
 * @param[in] page_number Page number of the page to be erased.
 */
static void flash_page_erase(uint32_t page_number)
{
   1c97c:	b508      	push	{r3, lr}
    flash_api_err_code_process(sd_flash_page_erase(page_number));
   1c97e:	f7ff fb85 	bl	1c08c <sd_flash_page_erase>
   1c982:	f7ff ffdb 	bl	1c93c <flash_api_err_code_process>
}
   1c986:	bd08      	pop	{r3, pc}

0001c988 <state_erase_data_page_entry_run>:
 *
 * @details Function for erase data page state entry action, which includes erasing the data flash 
 *          page.
 */
static void state_erase_data_page_entry_run(void)
{
   1c988:	b508      	push	{r3, lr}
    flash_page_erase(m_current_page_id);
   1c98a:	4b02      	ldr	r3, [pc, #8]	; (1c994 <state_erase_data_page_entry_run+0xc>)
   1c98c:	6818      	ldr	r0, [r3, #0]
   1c98e:	f7ff fff5 	bl	1c97c <flash_page_erase>
}
   1c992:	bd08      	pop	{r3, pc}
   1c994:	200035ac 	.word	0x200035ac

0001c998 <flash_write>:
 * @param[in] size_in_words Number of 32-bit words to write. 
 */
static void flash_write(uint32_t * const       p_dst, 
                        uint32_t const * const p_src, 
                        uint32_t               size_in_words)
{
   1c998:	b508      	push	{r3, lr}
    flash_api_err_code_process(sd_flash_write(p_dst, p_src, size_in_words));    
   1c99a:	f7ff fb79 	bl	1c090 <sd_flash_write>
   1c99e:	f7ff ffcd 	bl	1c93c <flash_api_err_code_process>
}
   1c9a2:	bd08      	pop	{r3, pc}

0001c9a4 <store_cmd_flash_write_execute>:
 * @details Function for writing data to flash upon executing store command. Data is written to 
 *          flash in reverse order, meaning starting at the end. If the data that is to be written 
 *          is greater than the flash page size, it will be fragmented to fit the flash page size.
 */
static void store_cmd_flash_write_execute(void)
{
   1c9a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    const cmd_queue_element_t * p_cmd = &m_cmd_queue.cmd[m_cmd_queue.rp];
    
    if (p_cmd->size > SOC_MAX_WRITE_SIZE)    
   1c9a6:	2314      	movs	r3, #20
 *          flash in reverse order, meaning starting at the end. If the data that is to be written 
 *          is greater than the flash page size, it will be fragmented to fit the flash page size.
 */
static void store_cmd_flash_write_execute(void)
{
    const cmd_queue_element_t * p_cmd = &m_cmd_queue.cmd[m_cmd_queue.rp];
   1c9a8:	4a14      	ldr	r2, [pc, #80]	; (1c9fc <store_cmd_flash_write_execute+0x58>)
   1c9aa:	2480      	movs	r4, #128	; 0x80
   1c9ac:	7816      	ldrb	r6, [r2, #0]
   1c9ae:	0564      	lsls	r4, r4, #21
    
    if (p_cmd->size > SOC_MAX_WRITE_SIZE)    
   1c9b0:	435e      	muls	r6, r3
   1c9b2:	1996      	adds	r6, r2, r6
   1c9b4:	1c37      	adds	r7, r6, #0
   1c9b6:	1c33      	adds	r3, r6, #0
   1c9b8:	6921      	ldr	r1, [r4, #16]
   1c9ba:	88f2      	ldrh	r2, [r6, #6]
   1c9bc:	b289      	uxth	r1, r1
   1c9be:	8930      	ldrh	r0, [r6, #8]
   1c9c0:	3708      	adds	r7, #8
   1c9c2:	3310      	adds	r3, #16
   1c9c4:	4d0e      	ldr	r5, [pc, #56]	; (1ca00 <store_cmd_flash_write_execute+0x5c>)
   1c9c6:	428a      	cmp	r2, r1
   1c9c8:	d90f      	bls.n	1c9ea <store_cmd_flash_write_execute+0x46>
   1c9ca:	6921      	ldr	r1, [r4, #16]
   1c9cc:	6926      	ldr	r6, [r4, #16]
   1c9ce:	b289      	uxth	r1, r1
    {
        const uint32_t offset = p_cmd->size - PSTORAGE_FLASH_PAGE_SIZE;
   1c9d0:	1a52      	subs	r2, r2, r1
        flash_write((uint32_t *)(p_cmd->storage_addr.block_id + p_cmd->offset + offset),
   1c9d2:	68b9      	ldr	r1, [r7, #8]
   1c9d4:	1840      	adds	r0, r0, r1
   1c9d6:	6859      	ldr	r1, [r3, #4]
   1c9d8:	1880      	adds	r0, r0, r2
   1c9da:	1889      	adds	r1, r1, r2
   1c9dc:	b2b2      	uxth	r2, r6
   1c9de:	0892      	lsrs	r2, r2, #2
   1c9e0:	f7ff ffda 	bl	1c998 <flash_write>
   1c9e4:	6923      	ldr	r3, [r4, #16]
                    (uint32_t *)(p_cmd->p_data_addr + offset), 
                    PSTORAGE_FLASH_PAGE_SIZE / sizeof(uint32_t));   

        m_num_of_bytes_written = PSTORAGE_FLASH_PAGE_SIZE;    
   1c9e6:	b29b      	uxth	r3, r3
   1c9e8:	e006      	b.n	1c9f8 <store_cmd_flash_write_execute+0x54>
    }
    else
    {
        flash_write((uint32_t *)(p_cmd->storage_addr.block_id + p_cmd->offset),
   1c9ea:	68b9      	ldr	r1, [r7, #8]
   1c9ec:	0892      	lsrs	r2, r2, #2
   1c9ee:	1840      	adds	r0, r0, r1
   1c9f0:	6859      	ldr	r1, [r3, #4]
   1c9f2:	f7ff ffd1 	bl	1c998 <flash_write>
                    (uint32_t *)(p_cmd->p_data_addr), 
                    p_cmd->size / sizeof(uint32_t));   

        m_num_of_bytes_written = p_cmd->size;        
   1c9f6:	88f3      	ldrh	r3, [r6, #6]
   1c9f8:	602b      	str	r3, [r5, #0]
    }    
}
   1c9fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1c9fc:	200033e0 	.word	0x200033e0
   1ca00:	200035a8 	.word	0x200035a8

0001ca04 <command_end_procedure_run>:
 * @details Function for executing the finalization procedure for command executed, which includes 
 *          notifying the application of command completion, consuming the command queue element, 
 *          and changing the internal state.
 */
static void command_end_procedure_run(void)
{    
   1ca04:	b538      	push	{r3, r4, r5, lr}
    app_notify(NRF_SUCCESS, &m_cmd_queue.cmd[m_cmd_queue.rp]);
   1ca06:	2414      	movs	r4, #20
   1ca08:	4d10      	ldr	r5, [pc, #64]	; (1ca4c <command_end_procedure_run+0x48>)
   1ca0a:	2000      	movs	r0, #0
   1ca0c:	7829      	ldrb	r1, [r5, #0]
   1ca0e:	4361      	muls	r1, r4
   1ca10:	1949      	adds	r1, r1, r5
   1ca12:	3104      	adds	r1, #4
   1ca14:	f7ff fe06 	bl	1c624 <app_notify.lto_priv.114>
 * @details Function for consuming a command queue element, which has been fully processed.
 */
static void command_queue_element_consume(void)
{
    // Initialize/free the element as it is now processed.    
    cmd_queue_element_init(m_cmd_queue.rp);
   1ca18:	7829      	ldrb	r1, [r5, #0]
 * @param[in] index Index of the element to be initialized.
 */
static void cmd_queue_element_init(uint32_t index)
{
    // Internal function and checks on range of index can be avoided.
    m_cmd_queue.cmd[index].op_code                = INVALID_OPCODE;
   1ca1a:	2200      	movs	r2, #0
   1ca1c:	434c      	muls	r4, r1
   1ca1e:	192b      	adds	r3, r5, r4
    m_cmd_queue.cmd[index].size                   = 0;
    m_cmd_queue.cmd[index].storage_addr.module_id = PSTORAGE_NUM_OF_PAGES;
   1ca20:	2401      	movs	r4, #1
 * @param[in] index Index of the element to be initialized.
 */
static void cmd_queue_element_init(uint32_t index)
{
    // Internal function and checks on range of index can be avoided.
    m_cmd_queue.cmd[index].op_code                = INVALID_OPCODE;
   1ca22:	711a      	strb	r2, [r3, #4]
    m_cmd_queue.cmd[index].size                   = 0;
   1ca24:	80da      	strh	r2, [r3, #6]
    m_cmd_queue.cmd[index].storage_addr.module_id = PSTORAGE_NUM_OF_PAGES;
   1ca26:	60dc      	str	r4, [r3, #12]
    m_cmd_queue.cmd[index].storage_addr.block_id  = 0;
   1ca28:	611a      	str	r2, [r3, #16]
    m_cmd_queue.cmd[index].p_data_addr            = NULL;
   1ca2a:	615a      	str	r2, [r3, #20]
    m_cmd_queue.cmd[index].offset                 = 0;
   1ca2c:	811a      	strh	r2, [r3, #8]
{
    // Initialize/free the element as it is now processed.    
    cmd_queue_element_init(m_cmd_queue.rp);

    // Adjust command queue state tracking variables.
    --(m_cmd_queue.count);   
   1ca2e:	786b      	ldrb	r3, [r5, #1]
    if (++(m_cmd_queue.rp) == PSTORAGE_CMD_QUEUE_SIZE)
   1ca30:	1909      	adds	r1, r1, r4
{
    // Initialize/free the element as it is now processed.    
    cmd_queue_element_init(m_cmd_queue.rp);

    // Adjust command queue state tracking variables.
    --(m_cmd_queue.count);   
   1ca32:	3b01      	subs	r3, #1
   1ca34:	706b      	strb	r3, [r5, #1]
    if (++(m_cmd_queue.rp) == PSTORAGE_CMD_QUEUE_SIZE)
   1ca36:	b2cb      	uxtb	r3, r1
   1ca38:	2b0a      	cmp	r3, #10
   1ca3a:	d001      	beq.n	1ca40 <command_end_procedure_run+0x3c>
   1ca3c:	702b      	strb	r3, [r5, #0]
   1ca3e:	e000      	b.n	1ca42 <command_end_procedure_run+0x3e>
    {
        m_cmd_queue.rp = 0;
   1ca40:	702a      	strb	r2, [r5, #0]
 *
 * @param[in] new_state New application main state to transit to.
 */
static void sm_state_change(pstorage_state_t new_state)
{
    m_state = new_state;
   1ca42:	4b03      	ldr	r3, [pc, #12]	; (1ca50 <command_end_procedure_run+0x4c>)
   1ca44:	701a      	strb	r2, [r3, #0]
    state_entry_action_run();
   1ca46:	f7ff fe45 	bl	1c6d4 <state_entry_action_run.lto_priv.113>
    app_notify(NRF_SUCCESS, &m_cmd_queue.cmd[m_cmd_queue.rp]);
    
    command_queue_element_consume();
    
    sm_state_change(STATE_IDLE);
}
   1ca4a:	bd38      	pop	{r3, r4, r5, pc}
   1ca4c:	200033e0 	.word	0x200033e0
   1ca50:	2000357e 	.word	0x2000357e

0001ca54 <clear_post_processing_run>:
 */
static void clear_post_processing_run(void)
{
    const cmd_queue_element_t * p_cmd = &m_cmd_queue.cmd[m_cmd_queue.rp]; 
    
    if (p_cmd->op_code != PSTORAGE_UPDATE_OP_CODE)
   1ca54:	2214      	movs	r2, #20
 *
 * @details Function for performing post processing for the update and clear commands, which implies 
 *          executing the correct execution path depending on the command. 
 */
static void clear_post_processing_run(void)
{
   1ca56:	b508      	push	{r3, lr}
    const cmd_queue_element_t * p_cmd = &m_cmd_queue.cmd[m_cmd_queue.rp]; 
    
    if (p_cmd->op_code != PSTORAGE_UPDATE_OP_CODE)
   1ca58:	4907      	ldr	r1, [pc, #28]	; (1ca78 <clear_post_processing_run+0x24>)
 * @details Function for performing post processing for the update and clear commands, which implies 
 *          executing the correct execution path depending on the command. 
 */
static void clear_post_processing_run(void)
{
    const cmd_queue_element_t * p_cmd = &m_cmd_queue.cmd[m_cmd_queue.rp]; 
   1ca5a:	780b      	ldrb	r3, [r1, #0]
    
    if (p_cmd->op_code != PSTORAGE_UPDATE_OP_CODE)
   1ca5c:	4353      	muls	r3, r2
   1ca5e:	18cb      	adds	r3, r1, r3
   1ca60:	791b      	ldrb	r3, [r3, #4]
   1ca62:	2b04      	cmp	r3, #4
   1ca64:	d002      	beq.n	1ca6c <clear_post_processing_run+0x18>
    {
        command_end_procedure_run();    
   1ca66:	f7ff ffcd 	bl	1ca04 <command_end_procedure_run>
   1ca6a:	e004      	b.n	1ca76 <clear_post_processing_run+0x22>
 *
 * @param[in] new_state New application main state to transit to.
 */
static void sm_state_change(pstorage_state_t new_state)
{
    m_state = new_state;
   1ca6c:	2201      	movs	r2, #1
   1ca6e:	4b03      	ldr	r3, [pc, #12]	; (1ca7c <clear_post_processing_run+0x28>)
   1ca70:	701a      	strb	r2, [r3, #0]
    state_entry_action_run();
   1ca72:	f7ff fe2f 	bl	1c6d4 <state_entry_action_run.lto_priv.113>
    }
    else
    {
        store_operation_execute();                    
    }
}
   1ca76:	bd08      	pop	{r3, pc}
   1ca78:	200033e0 	.word	0x200033e0
   1ca7c:	2000357e 	.word	0x2000357e

0001ca80 <flash_operation_success_run.lto_priv.111>:


/**@brief Function for doing action upon flash operation success event.
 */
static void flash_operation_success_run(void)
{    
   1ca80:	b508      	push	{r3, lr}
    switch (m_state)
   1ca82:	4b1e      	ldr	r3, [pc, #120]	; (1cafc <flash_operation_success_run.lto_priv.111+0x7c>)
   1ca84:	781b      	ldrb	r3, [r3, #0]
   1ca86:	2b02      	cmp	r3, #2
   1ca88:	d030      	beq.n	1caec <flash_operation_success_run.lto_priv.111+0x6c>
   1ca8a:	2b03      	cmp	r3, #3
   1ca8c:	d019      	beq.n	1cac2 <flash_operation_success_run.lto_priv.111+0x42>
   1ca8e:	2b01      	cmp	r3, #1
   1ca90:	d132      	bne.n	1caf8 <flash_operation_success_run.lto_priv.111+0x78>

/**@brief Function for doing store state action upon flash operation success event.
 */
static void store_sub_state_sm_run(void)
{
    if (!(m_flags & MASK_FLASH_API_ERR_BUSY))
   1ca92:	2108      	movs	r1, #8
   1ca94:	4a1a      	ldr	r2, [pc, #104]	; (1cb00 <flash_operation_success_run.lto_priv.111+0x80>)
   1ca96:	6813      	ldr	r3, [r2, #0]
   1ca98:	420b      	tst	r3, r1
   1ca9a:	d122      	bne.n	1cae2 <flash_operation_success_run.lto_priv.111+0x62>
    {        
        // As write operation request has succeeded, adjust the size tracking state information 
        // accordingly.
        cmd_queue_element_t * p_cmd = &m_cmd_queue.cmd[m_cmd_queue.rp];    
        p_cmd->size                -= m_num_of_bytes_written;
   1ca9c:	2314      	movs	r3, #20
{
    if (!(m_flags & MASK_FLASH_API_ERR_BUSY))
    {        
        // As write operation request has succeeded, adjust the size tracking state information 
        // accordingly.
        cmd_queue_element_t * p_cmd = &m_cmd_queue.cmd[m_cmd_queue.rp];    
   1ca9e:	4919      	ldr	r1, [pc, #100]	; (1cb04 <flash_operation_success_run.lto_priv.111+0x84>)
   1caa0:	780a      	ldrb	r2, [r1, #0]
        p_cmd->size                -= m_num_of_bytes_written;
   1caa2:	435a      	muls	r2, r3
   1caa4:	4b18      	ldr	r3, [pc, #96]	; (1cb08 <flash_operation_success_run.lto_priv.111+0x88>)
   1caa6:	188a      	adds	r2, r1, r2
   1caa8:	6819      	ldr	r1, [r3, #0]
   1caaa:	88d3      	ldrh	r3, [r2, #6]
   1caac:	1a5b      	subs	r3, r3, r1
   1caae:	b29b      	uxth	r3, r3
   1cab0:	80d3      	strh	r3, [r2, #6]

        if (p_cmd->size == 0)
   1cab2:	2b00      	cmp	r3, #0
   1cab4:	d102      	bne.n	1cabc <flash_operation_success_run.lto_priv.111+0x3c>
        {
            command_end_procedure_run();
   1cab6:	f7ff ffa5 	bl	1ca04 <command_end_procedure_run>
   1caba:	e01d      	b.n	1caf8 <flash_operation_success_run.lto_priv.111+0x78>
        }
        else
        {
            store_cmd_flash_write_execute();
   1cabc:	f7ff ff72 	bl	1c9a4 <store_cmd_flash_write_execute>
   1cac0:	e01a      	b.n	1caf8 <flash_operation_success_run.lto_priv.111+0x78>
 * @details Function for doing erase state action upon flash operation success event, which includes 
 *          making a state transition depending on the current state.
 */
static void erase_sub_state_sm_run(void)
{
    if (!(m_flags & MASK_FLASH_API_ERR_BUSY))
   1cac2:	2108      	movs	r1, #8
   1cac4:	4a0e      	ldr	r2, [pc, #56]	; (1cb00 <flash_operation_success_run.lto_priv.111+0x80>)
   1cac6:	6813      	ldr	r3, [r2, #0]
   1cac8:	420b      	tst	r3, r1
   1caca:	d10a      	bne.n	1cae2 <flash_operation_success_run.lto_priv.111+0x62>
    {        
        // Clear operation request has succeeded.
        ++m_current_page_id;                        
   1cacc:	4a0f      	ldr	r2, [pc, #60]	; (1cb0c <flash_operation_success_run.lto_priv.111+0x8c>)
   1cace:	6813      	ldr	r3, [r2, #0]
   1cad0:	3301      	adds	r3, #1
   1cad2:	6013      	str	r3, [r2, #0]
                
        if (!is_page_erase_required())
   1cad4:	f7ff fab2 	bl	1c03c <is_page_erase_required>
   1cad8:	2800      	cmp	r0, #0
   1cada:	d104      	bne.n	1cae6 <flash_operation_success_run.lto_priv.111+0x66>
        {
            clear_post_processing_run();
   1cadc:	f7ff ffba 	bl	1ca54 <clear_post_processing_run>
   1cae0:	e00a      	b.n	1caf8 <flash_operation_success_run.lto_priv.111+0x78>
 *        API, in main sate.
 */
static void main_state_err_busy_process(void)
{
    // Reissue the request by doing a self transition to the current state.    
    m_flags &= ~MASK_FLASH_API_ERR_BUSY;
   1cae2:	438b      	bics	r3, r1
   1cae4:	6013      	str	r3, [r2, #0]
 * @param[in] new_state New application main state to transit to.
 */
static void sm_state_change(pstorage_state_t new_state)
{
    m_state = new_state;
    state_entry_action_run();
   1cae6:	f7ff fdf5 	bl	1c6d4 <state_entry_action_run.lto_priv.113>
   1caea:	e005      	b.n	1caf8 <flash_operation_success_run.lto_priv.111+0x78>
        data_page_erase_state_run,
        tail_restore_state_run,
        head_restore_state_run
    };
    
    swap_sub_state_sm_lut[m_swap_sub_state]();    
   1caec:	4b08      	ldr	r3, [pc, #32]	; (1cb10 <flash_operation_success_run.lto_priv.111+0x90>)
   1caee:	4a09      	ldr	r2, [pc, #36]	; (1cb14 <flash_operation_success_run.lto_priv.111+0x94>)
   1caf0:	781b      	ldrb	r3, [r3, #0]
   1caf2:	009b      	lsls	r3, r3, #2
   1caf4:	589b      	ldr	r3, [r3, r2]
   1caf6:	4798      	blx	r3
            
        default:
            // No implementation needed.
            break;
    }                    
}
   1caf8:	bd08      	pop	{r3, pc}
   1cafa:	46c0      	nop			; (mov r8, r8)
   1cafc:	2000357e 	.word	0x2000357e
   1cb00:	2000353c 	.word	0x2000353c
   1cb04:	200033e0 	.word	0x200033e0
   1cb08:	200035a8 	.word	0x200035a8
   1cb0c:	200035ac 	.word	0x200035ac
   1cb10:	20003324 	.word	0x20003324
   1cb14:	00022930 	.word	0x00022930

0001cb18 <data_page_erase_state_run>:
 *
 * @details Function for doing data page erase state action upon a flash operation success event, 
 *          which includes making a state transit to a new state depending on the current state.
 */
static void data_page_erase_state_run(void)
{            
   1cb18:	b510      	push	{r4, lr}
    if (!(m_flags & MASK_FLASH_API_ERR_BUSY))
   1cb1a:	4c17      	ldr	r4, [pc, #92]	; (1cb78 <data_page_erase_state_run+0x60>)
   1cb1c:	6823      	ldr	r3, [r4, #0]
   1cb1e:	071b      	lsls	r3, r3, #28
   1cb20:	d426      	bmi.n	1cb70 <data_page_erase_state_run+0x58>
    {
        ++m_current_page_id;   
   1cb22:	4a16      	ldr	r2, [pc, #88]	; (1cb7c <data_page_erase_state_run+0x64>)
   1cb24:	6813      	ldr	r3, [r2, #0]
   1cb26:	3301      	adds	r3, #1
   1cb28:	6013      	str	r3, [r2, #0]
                    
        if (m_head_word_size != 0)
   1cb2a:	4b15      	ldr	r3, [pc, #84]	; (1cb80 <data_page_erase_state_run+0x68>)
 *
 * @param[in] new_state New swap sub state to transit to.
 */   
static void swap_sub_state_state_change(flash_swap_sub_state_t new_state)
{
    m_swap_sub_state = new_state;
   1cb2c:	2204      	movs	r2, #4
{            
    if (!(m_flags & MASK_FLASH_API_ERR_BUSY))
    {
        ++m_current_page_id;   
                    
        if (m_head_word_size != 0)
   1cb2e:	681b      	ldr	r3, [r3, #0]
   1cb30:	2b00      	cmp	r3, #0
   1cb32:	d104      	bne.n	1cb3e <data_page_erase_state_run+0x26>
        {            
            swap_sub_state_state_change(STATE_RESTORE_HEAD);
        }
        else if (is_page_erase_required())
   1cb34:	f7ff fa82 	bl	1c03c <is_page_erase_required>
   1cb38:	2800      	cmp	r0, #0
   1cb3a:	d003      	beq.n	1cb44 <data_page_erase_state_run+0x2c>
 *
 * @param[in] new_state New swap sub state to transit to.
 */   
static void swap_sub_state_state_change(flash_swap_sub_state_t new_state)
{
    m_swap_sub_state = new_state;
   1cb3c:	2202      	movs	r2, #2
   1cb3e:	4b11      	ldr	r3, [pc, #68]	; (1cb84 <data_page_erase_state_run+0x6c>)
   1cb40:	701a      	strb	r2, [r3, #0]
   1cb42:	e00f      	b.n	1cb64 <data_page_erase_state_run+0x4c>
        else if (is_page_erase_required())
        {
            // Additional page erase operation is required.    
            swap_sub_state_state_change(STATE_ERASE_DATA_PAGE);                
        }                
        else if (m_tail_word_size != 0)
   1cb44:	4b10      	ldr	r3, [pc, #64]	; (1cb88 <data_page_erase_state_run+0x70>)
   1cb46:	681b      	ldr	r3, [r3, #0]
   1cb48:	2b00      	cmp	r3, #0
   1cb4a:	d00e      	beq.n	1cb6a <data_page_erase_state_run+0x52>
        {                    
            if (!(m_flags & MASK_TAIL_SWAP_DONE)) 
   1cb4c:	6823      	ldr	r3, [r4, #0]
   1cb4e:	2001      	movs	r0, #1
   1cb50:	1c19      	adds	r1, r3, #0
   1cb52:	4a0c      	ldr	r2, [pc, #48]	; (1cb84 <data_page_erase_state_run+0x6c>)
   1cb54:	4001      	ands	r1, r0
   1cb56:	d103      	bne.n	1cb60 <data_page_erase_state_run+0x48>
            {
                // Tail area restore is required and we have not yet written the relevant data page 
                // to swap area. Start the process of writing the data page to swap.
                m_flags |= MASK_TAIL_SWAP_DONE;            
   1cb58:	4303      	orrs	r3, r0
   1cb5a:	6023      	str	r3, [r4, #0]
 *
 * @param[in] new_state New swap sub state to transit to.
 */   
static void swap_sub_state_state_change(flash_swap_sub_state_t new_state)
{
    m_swap_sub_state = new_state;
   1cb5c:	7011      	strb	r1, [r2, #0]
   1cb5e:	e001      	b.n	1cb64 <data_page_erase_state_run+0x4c>
   1cb60:	2303      	movs	r3, #3
   1cb62:	7013      	strb	r3, [r2, #0]
    swap_sub_state_entry_action_run();    
   1cb64:	f7ff fd74 	bl	1c650 <swap_sub_state_entry_action_run.lto_priv.112>
   1cb68:	e004      	b.n	1cb74 <data_page_erase_state_run+0x5c>

/**@brief Function for doing swap sub state exit action.
 */
static void swap_sub_sm_exit_action_run(void)
{
    clear_post_processing_run();
   1cb6a:	f7ff ff73 	bl	1ca54 <clear_post_processing_run>
   1cb6e:	e001      	b.n	1cb74 <data_page_erase_state_run+0x5c>
        }        
    }
    else
    {
        // As operation request was rejected by the flash API reissue the request.
        swap_sub_state_err_busy_process();        
   1cb70:	f7ff fd7a 	bl	1c668 <swap_sub_state_err_busy_process>
    }
}
   1cb74:	bd10      	pop	{r4, pc}
   1cb76:	46c0      	nop			; (mov r8, r8)
   1cb78:	2000353c 	.word	0x2000353c
   1cb7c:	200035ac 	.word	0x200035ac
   1cb80:	20003330 	.word	0x20003330
   1cb84:	20003324 	.word	0x20003324
   1cb88:	20003318 	.word	0x20003318

0001cb8c <tail_restore_state_run>:


/**@brief Function for doing restore tail state action upon flash operation success event.
 */
static void tail_restore_state_run(void)
{
   1cb8c:	b508      	push	{r3, lr}
    if (!(m_flags & MASK_FLASH_API_ERR_BUSY))
   1cb8e:	4b05      	ldr	r3, [pc, #20]	; (1cba4 <tail_restore_state_run+0x18>)
   1cb90:	681b      	ldr	r3, [r3, #0]
   1cb92:	071b      	lsls	r3, r3, #28
   1cb94:	d402      	bmi.n	1cb9c <tail_restore_state_run+0x10>

/**@brief Function for doing swap sub state exit action.
 */
static void swap_sub_sm_exit_action_run(void)
{
    clear_post_processing_run();
   1cb96:	f7ff ff5d 	bl	1ca54 <clear_post_processing_run>
   1cb9a:	e001      	b.n	1cba0 <tail_restore_state_run+0x14>
        swap_sub_sm_exit_action_run();        
    }
    else
    {
        // As operation request was rejected by the flash API reissue the request.
        swap_sub_state_err_busy_process();        
   1cb9c:	f7ff fd64 	bl	1c668 <swap_sub_state_err_busy_process>
    }    
}
   1cba0:	bd08      	pop	{r3, pc}
   1cba2:	46c0      	nop			; (mov r8, r8)
   1cba4:	2000353c 	.word	0x2000353c

0001cba8 <head_restore_state_run>:
 *
 * @details Function for doing restore head state action upon flash operation success event, which 
 *          includes making a state transition depending on the current state.
 */
static void head_restore_state_run(void)
{
   1cba8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (!(m_flags & MASK_FLASH_API_ERR_BUSY))
   1cbaa:	2408      	movs	r4, #8
   1cbac:	4e1d      	ldr	r6, [pc, #116]	; (1cc24 <head_restore_state_run+0x7c>)
   1cbae:	6835      	ldr	r5, [r6, #0]
   1cbb0:	402c      	ands	r4, r5
   1cbb2:	d122      	bne.n	1cbfa <head_restore_state_run+0x52>
{
    bool ret_value;

    // Extract id of the last page command is executed upon.
    const cmd_queue_element_t * p_cmd        = &m_cmd_queue.cmd[m_cmd_queue.rp];
    const pstorage_block_t      cmd_block_id = p_cmd->storage_addr.block_id;        
   1cbb4:	2214      	movs	r2, #20
static bool is_tail_data_page_swap_required(void)
{
    bool ret_value;

    // Extract id of the last page command is executed upon.
    const cmd_queue_element_t * p_cmd        = &m_cmd_queue.cmd[m_cmd_queue.rp];
   1cbb6:	491c      	ldr	r1, [pc, #112]	; (1cc28 <head_restore_state_run+0x80>)
    const uint32_t              last_page_id = (cmd_block_id + p_cmd->size + p_cmd->offset - 1u) / 
                                               PSTORAGE_FLASH_PAGE_SIZE;    
        
    // If tail section area exists and the current page is the last page then tail data page swap is 
    // required.    
    if ((m_tail_word_size != 0) && (m_current_page_id == last_page_id))
   1cbb8:	4f1c      	ldr	r7, [pc, #112]	; (1cc2c <head_restore_state_run+0x84>)
static bool is_tail_data_page_swap_required(void)
{
    bool ret_value;

    // Extract id of the last page command is executed upon.
    const cmd_queue_element_t * p_cmd        = &m_cmd_queue.cmd[m_cmd_queue.rp];
   1cbba:	780b      	ldrb	r3, [r1, #0]
    const uint32_t              last_page_id = (cmd_block_id + p_cmd->size + p_cmd->offset - 1u) / 
                                               PSTORAGE_FLASH_PAGE_SIZE;    
        
    // If tail section area exists and the current page is the last page then tail data page swap is 
    // required.    
    if ((m_tail_word_size != 0) && (m_current_page_id == last_page_id))
   1cbbc:	683f      	ldr	r7, [r7, #0]
{
    bool ret_value;

    // Extract id of the last page command is executed upon.
    const cmd_queue_element_t * p_cmd        = &m_cmd_queue.cmd[m_cmd_queue.rp];
    const pstorage_block_t      cmd_block_id = p_cmd->storage_addr.block_id;        
   1cbbe:	4353      	muls	r3, r2
   1cbc0:	18cb      	adds	r3, r1, r3
   1cbc2:	2180      	movs	r1, #128	; 0x80
   1cbc4:	0549      	lsls	r1, r1, #21
   1cbc6:	6918      	ldr	r0, [r3, #16]
    const uint32_t              last_page_id = (cmd_block_id + p_cmd->size + p_cmd->offset - 1u) / 
   1cbc8:	88da      	ldrh	r2, [r3, #6]
   1cbca:	6909      	ldr	r1, [r1, #16]
   1cbcc:	891b      	ldrh	r3, [r3, #8]
                                               PSTORAGE_FLASH_PAGE_SIZE;    
        
    // If tail section area exists and the current page is the last page then tail data page swap is 
    // required.    
    if ((m_tail_word_size != 0) && (m_current_page_id == last_page_id))
   1cbce:	2f00      	cmp	r7, #0
   1cbd0:	d016      	beq.n	1cc00 <head_restore_state_run+0x58>
   1cbd2:	3801      	subs	r0, #1
   1cbd4:	1880      	adds	r0, r0, r2
    bool ret_value;

    // Extract id of the last page command is executed upon.
    const cmd_queue_element_t * p_cmd        = &m_cmd_queue.cmd[m_cmd_queue.rp];
    const pstorage_block_t      cmd_block_id = p_cmd->storage_addr.block_id;        
    const uint32_t              last_page_id = (cmd_block_id + p_cmd->size + p_cmd->offset - 1u) / 
   1cbd6:	18c0      	adds	r0, r0, r3
   1cbd8:	b289      	uxth	r1, r1
   1cbda:	f005 fa4d 	bl	22078 <__aeabi_uidiv>
                                               PSTORAGE_FLASH_PAGE_SIZE;    
        
    // If tail section area exists and the current page is the last page then tail data page swap is 
    // required.    
    if ((m_tail_word_size != 0) && (m_current_page_id == last_page_id))
   1cbde:	4b14      	ldr	r3, [pc, #80]	; (1cc30 <head_restore_state_run+0x88>)
   1cbe0:	681b      	ldr	r3, [r3, #0]
   1cbe2:	4283      	cmp	r3, r0
   1cbe4:	d10c      	bne.n	1cc00 <head_restore_state_run+0x58>
            // Additional data page needs to be swapped for tail section as we are clearing a block, 
            // which is shared between 2 flash pages.
                    
            // Adjust variables to ensure correct state transition path is taken after the tail 
            // section swap has completed.
            m_head_word_size = 0;   
   1cbe6:	4b13      	ldr	r3, [pc, #76]	; (1cc34 <head_restore_state_run+0x8c>)
   1cbe8:	601c      	str	r4, [r3, #0]
            m_flags         |= MASK_TAIL_SWAP_DONE;        
   1cbea:	2301      	movs	r3, #1
   1cbec:	431d      	orrs	r5, r3
 *
 * @param[in] new_state New swap sub state to transit to.
 */   
static void swap_sub_state_state_change(flash_swap_sub_state_t new_state)
{
    m_swap_sub_state = new_state;
   1cbee:	4b12      	ldr	r3, [pc, #72]	; (1cc38 <head_restore_state_run+0x90>)
            // which is shared between 2 flash pages.
                    
            // Adjust variables to ensure correct state transition path is taken after the tail 
            // section swap has completed.
            m_head_word_size = 0;   
            m_flags         |= MASK_TAIL_SWAP_DONE;        
   1cbf0:	6035      	str	r5, [r6, #0]
 *
 * @param[in] new_state New swap sub state to transit to.
 */   
static void swap_sub_state_state_change(flash_swap_sub_state_t new_state)
{
    m_swap_sub_state = new_state;
   1cbf2:	701c      	strb	r4, [r3, #0]
    swap_sub_state_entry_action_run();    
   1cbf4:	f7ff fd2c 	bl	1c650 <swap_sub_state_entry_action_run.lto_priv.112>
   1cbf8:	e013      	b.n	1cc22 <head_restore_state_run+0x7a>
        }
    }
    else
    {
        // As operation request was rejected by the flash API reissue the request.
        swap_sub_state_err_busy_process();        
   1cbfa:	f7ff fd35 	bl	1c668 <swap_sub_state_err_busy_process>
   1cbfe:	e010      	b.n	1cc22 <head_restore_state_run+0x7a>
            m_head_word_size = 0;   
            m_flags         |= MASK_TAIL_SWAP_DONE;        
                  
            swap_sub_state_state_change(STATE_ERASE_SWAP);        
        }
        else if (is_page_erase_required())
   1cc00:	f7ff fa1c 	bl	1c03c <is_page_erase_required>
   1cc04:	2800      	cmp	r0, #0
   1cc06:	d004      	beq.n	1cc12 <head_restore_state_run+0x6a>
        {
            // Additional page erase operation is required.
                    
            // Adjust variable to ensure correct state transition path is taken after the additional 
            // page erase operation has completed.
            m_head_word_size = 0;
   1cc08:	2200      	movs	r2, #0
   1cc0a:	4b0a      	ldr	r3, [pc, #40]	; (1cc34 <head_restore_state_run+0x8c>)
   1cc0c:	601a      	str	r2, [r3, #0]
 *
 * @param[in] new_state New swap sub state to transit to.
 */   
static void swap_sub_state_state_change(flash_swap_sub_state_t new_state)
{
    m_swap_sub_state = new_state;
   1cc0e:	3202      	adds	r2, #2
   1cc10:	e002      	b.n	1cc18 <head_restore_state_run+0x70>
            // Adjust variable to ensure correct state transition path is taken after the additional 
            // page erase operation has completed.
            m_head_word_size = 0;
            swap_sub_state_state_change(STATE_ERASE_DATA_PAGE);        
        }            
        else if (m_tail_word_size != 0)
   1cc12:	2f00      	cmp	r7, #0
   1cc14:	d003      	beq.n	1cc1e <head_restore_state_run+0x76>
 *
 * @param[in] new_state New swap sub state to transit to.
 */   
static void swap_sub_state_state_change(flash_swap_sub_state_t new_state)
{
    m_swap_sub_state = new_state;
   1cc16:	2203      	movs	r2, #3
   1cc18:	4b07      	ldr	r3, [pc, #28]	; (1cc38 <head_restore_state_run+0x90>)
   1cc1a:	701a      	strb	r2, [r3, #0]
   1cc1c:	e7ea      	b.n	1cbf4 <head_restore_state_run+0x4c>

/**@brief Function for doing swap sub state exit action.
 */
static void swap_sub_sm_exit_action_run(void)
{
    clear_post_processing_run();
   1cc1e:	f7ff ff19 	bl	1ca54 <clear_post_processing_run>
    else
    {
        // As operation request was rejected by the flash API reissue the request.
        swap_sub_state_err_busy_process();        
    }
}
   1cc22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1cc24:	2000353c 	.word	0x2000353c
   1cc28:	200033e0 	.word	0x200033e0
   1cc2c:	20003318 	.word	0x20003318
   1cc30:	200035ac 	.word	0x200035ac
   1cc34:	20003330 	.word	0x20003330
   1cc38:	20003324 	.word	0x20003324

0001cc3c <pstorage_flash_page_end.lto_priv.133>:
#elif defined NRF52
#define BOOTLOADER_ADDRESS           (PSTORAGE_FLASH_EMPTY_MASK)
#endif

static __INLINE uint32_t pstorage_flash_page_end()
{
   1cc3c:	b508      	push	{r3, lr}
   uint32_t bootloader_addr = BOOTLOADER_ADDRESS;
   1cc3e:	4b06      	ldr	r3, [pc, #24]	; (1cc58 <pstorage_flash_page_end.lto_priv.133+0x1c>)
   1cc40:	6958      	ldr	r0, [r3, #20]
   1cc42:	2380      	movs	r3, #128	; 0x80
   1cc44:	055b      	lsls	r3, r3, #21

   return ((bootloader_addr != PSTORAGE_FLASH_EMPTY_MASK) ?
           (bootloader_addr/ PSTORAGE_FLASH_PAGE_SIZE) : NRF_FICR->CODESIZE);
   1cc46:	1c42      	adds	r2, r0, #1
   1cc48:	d004      	beq.n	1cc54 <pstorage_flash_page_end.lto_priv.133+0x18>
#include <stdint.h>
#include "nrf.h"

static __INLINE uint16_t pstorage_flash_page_size()
{
  return (uint16_t)NRF_FICR->CODEPAGESIZE;
   1cc4a:	6919      	ldr	r1, [r3, #16]
static __INLINE uint32_t pstorage_flash_page_end()
{
   uint32_t bootloader_addr = BOOTLOADER_ADDRESS;

   return ((bootloader_addr != PSTORAGE_FLASH_EMPTY_MASK) ?
           (bootloader_addr/ PSTORAGE_FLASH_PAGE_SIZE) : NRF_FICR->CODESIZE);
   1cc4c:	b289      	uxth	r1, r1
   1cc4e:	f005 fa13 	bl	22078 <__aeabi_uidiv>
   1cc52:	e000      	b.n	1cc56 <pstorage_flash_page_end.lto_priv.133+0x1a>
   1cc54:	6958      	ldr	r0, [r3, #20]
}
   1cc56:	bd08      	pop	{r3, pc}
   1cc58:	10001000 	.word	0x10001000

0001cc5c <state_restore_head_entry_run>:
 *
 * @details Function for restore head state entry action, which includes writing the head section 
 *          back from swap to the data page.
 */
static void state_restore_head_entry_run(void)
{
   1cc5c:	b538      	push	{r3, r4, r5, lr}
#include <stdint.h>
#include "nrf.h"

static __INLINE uint16_t pstorage_flash_page_size()
{
  return (uint16_t)NRF_FICR->CODEPAGESIZE;
   1cc5e:	2580      	movs	r5, #128	; 0x80
   1cc60:	056d      	lsls	r5, r5, #21
   1cc62:	692c      	ldr	r4, [r5, #16]
    flash_write((uint32_t *)((m_current_page_id - 1u) * PSTORAGE_FLASH_PAGE_SIZE),
   1cc64:	4a08      	ldr	r2, [pc, #32]	; (1cc88 <state_restore_head_entry_run+0x2c>)
   1cc66:	b2a3      	uxth	r3, r4
   1cc68:	6814      	ldr	r4, [r2, #0]
   1cc6a:	3c01      	subs	r4, #1
   1cc6c:	435c      	muls	r4, r3
                (uint32_t *)PSTORAGE_SWAP_ADDR,
   1cc6e:	f7ff ffe5 	bl	1cc3c <pstorage_flash_page_end.lto_priv.133>
   1cc72:	692b      	ldr	r3, [r5, #16]
   1cc74:	1e41      	subs	r1, r0, #1
   1cc76:	b29b      	uxth	r3, r3
   1cc78:	4359      	muls	r1, r3
 * @details Function for restore head state entry action, which includes writing the head section 
 *          back from swap to the data page.
 */
static void state_restore_head_entry_run(void)
{
    flash_write((uint32_t *)((m_current_page_id - 1u) * PSTORAGE_FLASH_PAGE_SIZE),
   1cc7a:	4b04      	ldr	r3, [pc, #16]	; (1cc8c <state_restore_head_entry_run+0x30>)
   1cc7c:	1c20      	adds	r0, r4, #0
   1cc7e:	681a      	ldr	r2, [r3, #0]
   1cc80:	f7ff fe8a 	bl	1c998 <flash_write>
                (uint32_t *)PSTORAGE_SWAP_ADDR,
                m_head_word_size);
}
   1cc84:	bd38      	pop	{r3, r4, r5, pc}
   1cc86:	46c0      	nop			; (mov r8, r8)
   1cc88:	200035ac 	.word	0x200035ac
   1cc8c:	20003330 	.word	0x20003330

0001cc90 <state_restore_tail_entry_run>:
static void state_restore_tail_entry_run(void)
{
    const cmd_queue_element_t * p_cmd        = &m_cmd_queue.cmd[m_cmd_queue.rp];    
    const pstorage_block_t      cmd_block_id = p_cmd->storage_addr.block_id;                            
    
    const uint32_t tail_offset = (cmd_block_id + p_cmd->size + p_cmd->offset) % 
   1cc90:	2214      	movs	r2, #20
 *
 * @details Function for restore tail state entry action, which includes writing the tail section 
 *          back from swap to the data page.
 */
static void state_restore_tail_entry_run(void)
{
   1cc92:	b570      	push	{r4, r5, r6, lr}
   1cc94:	2680      	movs	r6, #128	; 0x80
    const cmd_queue_element_t * p_cmd        = &m_cmd_queue.cmd[m_cmd_queue.rp];    
   1cc96:	490e      	ldr	r1, [pc, #56]	; (1ccd0 <state_restore_tail_entry_run+0x40>)
   1cc98:	0576      	lsls	r6, r6, #21
   1cc9a:	780b      	ldrb	r3, [r1, #0]
    const pstorage_block_t      cmd_block_id = p_cmd->storage_addr.block_id;                            
    
    const uint32_t tail_offset = (cmd_block_id + p_cmd->size + p_cmd->offset) % 
   1cc9c:	4353      	muls	r3, r2
   1cc9e:	18cb      	adds	r3, r1, r3
   1cca0:	891a      	ldrh	r2, [r3, #8]
   1cca2:	88dc      	ldrh	r4, [r3, #6]
   1cca4:	691b      	ldr	r3, [r3, #16]
   1cca6:	18a4      	adds	r4, r4, r2
   1cca8:	6931      	ldr	r1, [r6, #16]
   1ccaa:	18e4      	adds	r4, r4, r3
   1ccac:	1c20      	adds	r0, r4, #0
   1ccae:	b289      	uxth	r1, r1
   1ccb0:	f005 fa68 	bl	22184 <__aeabi_uidivmod>
   1ccb4:	1c0d      	adds	r5, r1, #0
                                 PSTORAGE_FLASH_PAGE_SIZE; 
                                 
    flash_write((uint32_t *)(cmd_block_id + p_cmd->size + p_cmd->offset),
                (uint32_t *)(PSTORAGE_SWAP_ADDR + tail_offset),
   1ccb6:	f7ff ffc1 	bl	1cc3c <pstorage_flash_page_end.lto_priv.133>
   1ccba:	6933      	ldr	r3, [r6, #16]
   1ccbc:	3801      	subs	r0, #1
   1ccbe:	b29b      	uxth	r3, r3
   1ccc0:	4358      	muls	r0, r3
    const pstorage_block_t      cmd_block_id = p_cmd->storage_addr.block_id;                            
    
    const uint32_t tail_offset = (cmd_block_id + p_cmd->size + p_cmd->offset) % 
                                 PSTORAGE_FLASH_PAGE_SIZE; 
                                 
    flash_write((uint32_t *)(cmd_block_id + p_cmd->size + p_cmd->offset),
   1ccc2:	4b04      	ldr	r3, [pc, #16]	; (1ccd4 <state_restore_tail_entry_run+0x44>)
                (uint32_t *)(PSTORAGE_SWAP_ADDR + tail_offset),
   1ccc4:	1941      	adds	r1, r0, r5
    const pstorage_block_t      cmd_block_id = p_cmd->storage_addr.block_id;                            
    
    const uint32_t tail_offset = (cmd_block_id + p_cmd->size + p_cmd->offset) % 
                                 PSTORAGE_FLASH_PAGE_SIZE; 
                                 
    flash_write((uint32_t *)(cmd_block_id + p_cmd->size + p_cmd->offset),
   1ccc6:	681a      	ldr	r2, [r3, #0]
   1ccc8:	1c20      	adds	r0, r4, #0
   1ccca:	f7ff fe65 	bl	1c998 <flash_write>
                (uint32_t *)(PSTORAGE_SWAP_ADDR + tail_offset),
                m_tail_word_size);
}
   1ccce:	bd70      	pop	{r4, r5, r6, pc}
   1ccd0:	200033e0 	.word	0x200033e0
   1ccd4:	20003318 	.word	0x20003318

0001ccd8 <state_write_data_swap_entry_run>:
 *
 * @details Function for write data to the swap state entry action, which includes writing the 
 *          current data page to the swap flash page.
 */
static void state_write_data_swap_entry_run(void)
{
   1ccd8:	b508      	push	{r3, lr}
    // @note: There is room for further optimization here as there is only need to write the
    // whole flash page to swap area if there is both head and tail area to be restored. In any 
    // other case we can omit some data from the head or end of the page as that is the clear area.
    flash_write((uint32_t *)(PSTORAGE_SWAP_ADDR), 
   1ccda:	f7ff ffaf 	bl	1cc3c <pstorage_flash_page_end.lto_priv.133>
   1ccde:	2280      	movs	r2, #128	; 0x80
   1cce0:	0552      	lsls	r2, r2, #21
   1cce2:	6913      	ldr	r3, [r2, #16]
   1cce4:	3801      	subs	r0, #1
   1cce6:	b29b      	uxth	r3, r3
   1cce8:	4358      	muls	r0, r3
                (uint32_t *)(m_current_page_id * PSTORAGE_FLASH_PAGE_SIZE), 
   1ccea:	4b05      	ldr	r3, [pc, #20]	; (1cd00 <state_write_data_swap_entry_run+0x28>)
   1ccec:	6911      	ldr	r1, [r2, #16]
   1ccee:	6912      	ldr	r2, [r2, #16]
   1ccf0:	681b      	ldr	r3, [r3, #0]
   1ccf2:	b289      	uxth	r1, r1
static void state_write_data_swap_entry_run(void)
{
    // @note: There is room for further optimization here as there is only need to write the
    // whole flash page to swap area if there is both head and tail area to be restored. In any 
    // other case we can omit some data from the head or end of the page as that is the clear area.
    flash_write((uint32_t *)(PSTORAGE_SWAP_ADDR), 
   1ccf4:	b292      	uxth	r2, r2
                (uint32_t *)(m_current_page_id * PSTORAGE_FLASH_PAGE_SIZE), 
   1ccf6:	4359      	muls	r1, r3
static void state_write_data_swap_entry_run(void)
{
    // @note: There is room for further optimization here as there is only need to write the
    // whole flash page to swap area if there is both head and tail area to be restored. In any 
    // other case we can omit some data from the head or end of the page as that is the clear area.
    flash_write((uint32_t *)(PSTORAGE_SWAP_ADDR), 
   1ccf8:	0892      	lsrs	r2, r2, #2
   1ccfa:	f7ff fe4d 	bl	1c998 <flash_write>
                (uint32_t *)(m_current_page_id * PSTORAGE_FLASH_PAGE_SIZE), 
                PSTORAGE_FLASH_PAGE_SIZE / sizeof(uint32_t));    
}
   1ccfe:	bd08      	pop	{r3, pc}
   1cd00:	200035ac 	.word	0x200035ac

0001cd04 <state_swap_erase_entry_run>:
 *
 * @details Function for swap erase state entry action, which includes erasing swap flash 
 *          page.
 */
static void state_swap_erase_entry_run(void)
{
   1cd04:	b508      	push	{r3, lr}
    flash_page_erase(PSTORAGE_SWAP_ADDR / PSTORAGE_FLASH_PAGE_SIZE);                
   1cd06:	f7ff ff99 	bl	1cc3c <pstorage_flash_page_end.lto_priv.133>
   1cd0a:	2280      	movs	r2, #128	; 0x80
   1cd0c:	0552      	lsls	r2, r2, #21
   1cd0e:	6913      	ldr	r3, [r2, #16]
   1cd10:	6911      	ldr	r1, [r2, #16]
   1cd12:	b29b      	uxth	r3, r3
   1cd14:	3801      	subs	r0, #1
   1cd16:	4358      	muls	r0, r3
   1cd18:	b289      	uxth	r1, r1
   1cd1a:	f005 f9ad 	bl	22078 <__aeabi_uidiv>
   1cd1e:	f7ff fe2d 	bl	1c97c <flash_page_erase>
}
   1cd22:	bd08      	pop	{r3, pc}

0001cd24 <SWI1_IRQHandler>:
static ble_radio_notification_evt_handler_t m_evt_handler  = NULL;   /**< Application event handler for handling Radio Notification events. */


void SWI1_IRQHandler(void)
{
    m_radio_active = !m_radio_active;
   1cd24:	2001      	movs	r0, #1
   1cd26:	4a05      	ldr	r2, [pc, #20]	; (1cd3c <SWI1_IRQHandler+0x18>)
static bool                                 m_radio_active = false;  /**< Current radio state. */
static ble_radio_notification_evt_handler_t m_evt_handler  = NULL;   /**< Application event handler for handling Radio Notification events. */


void SWI1_IRQHandler(void)
{
   1cd28:	b508      	push	{r3, lr}
    m_radio_active = !m_radio_active;
   1cd2a:	7813      	ldrb	r3, [r2, #0]
   1cd2c:	4058      	eors	r0, r3
    if (m_evt_handler != NULL)
   1cd2e:	4b04      	ldr	r3, [pc, #16]	; (1cd40 <SWI1_IRQHandler+0x1c>)
static ble_radio_notification_evt_handler_t m_evt_handler  = NULL;   /**< Application event handler for handling Radio Notification events. */


void SWI1_IRQHandler(void)
{
    m_radio_active = !m_radio_active;
   1cd30:	7010      	strb	r0, [r2, #0]
    if (m_evt_handler != NULL)
   1cd32:	681b      	ldr	r3, [r3, #0]
   1cd34:	2b00      	cmp	r3, #0
   1cd36:	d000      	beq.n	1cd3a <SWI1_IRQHandler+0x16>
    {
        m_evt_handler(m_radio_active);
   1cd38:	4798      	blx	r3
    }
}
   1cd3a:	bd08      	pop	{r3, pc}
   1cd3c:	20003315 	.word	0x20003315
   1cd40:	20002f14 	.word	0x20002f14

0001cd44 <sd_radio_notification_cfg_set.lto_priv.119>:
 *                       @ref NRF_RADIO_NOTIFICATION_TYPE_INT_ON_INACTIVE is used. 
 *
 * @retval ::NRF_ERROR_INVALID_PARAM The group number is invalid.
 * @retval ::NRF_SUCCESS
 */
SVCALL(SD_RADIO_NOTIFICATION_CFG_SET, uint32_t, sd_radio_notification_cfg_set(uint8_t type, uint8_t distance));
   1cd44:	df4c      	svc	76	; 0x4c
   1cd46:	4770      	bx	lr

0001cd48 <_ZN6Module23NodeStateChangedHandlerE14discoveryState>:

		//This handler receives all connection packets
		virtual void ConnectionPacketReceivedEventHandler(connectionPacket* inPacket, Connection* connection, connPacketHeader* packetHeader, u16 dataLength);

		//Changing the node state will affect some module's behaviour
		virtual void NodeStateChangedHandler(discoveryState newState){};
   1cd48:	4770      	bx	lr

0001cd4a <_ZN6Module28MeshConnectionChangedHandlerEP10Connection>:

		//This handler receives all ble events and can act on them
		virtual void BleEventHandler(ble_evt_t* bleEvent){};

		//When a mesh connection is connected with handshake and everything or if it is disconnected, the ConnectionManager will call this handler
		virtual void MeshConnectionChangedHandler(Connection* connection){};
   1cd4a:	4770      	bx	lr

0001cd4c <sd_ble_gap_address_set>:
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameters.
 * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address.
 * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
 * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
 */
SVCALL(SD_BLE_GAP_ADDRESS_SET, uint32_t, sd_ble_gap_address_set(uint8_t addr_cycle_mode, ble_gap_addr_t const *p_addr));
   1cd4c:	df70      	svc	112	; 0x70
   1cd4e:	4770      	bx	lr

0001cd50 <sd_ble_gap_adv_stop>:
 * @endmscs
 *
 * @retval ::NRF_SUCCESS The BLE stack has stopped advertising.
 * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation (most probably not in advertising state).
 */
SVCALL(SD_BLE_GAP_ADV_STOP, uint32_t, sd_ble_gap_adv_stop(void));
   1cd50:	df74      	svc	116	; 0x74
   1cd52:	4770      	bx	lr

0001cd54 <sd_ble_gap_adv_start>:
 * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
 * @retval ::BLE_ERROR_GAP_WHITELIST_IN_USE Unable to replace the whitelist while another operation is using it.
 * @retval ::NRF_ERROR_RESOURCES Not enough BLE role slots available.
 *                               Stop one or more currently active roles (Central, Peripheral or Observer) and try again
 */
SVCALL(SD_BLE_GAP_ADV_START, uint32_t, sd_ble_gap_adv_start(ble_gap_adv_params_t const *p_adv_params));
   1cd54:	df73      	svc	115	; 0x73
   1cd56:	4770      	bx	lr

0001cd58 <sd_ble_uuid_vs_add>:
 *
 * @retval ::NRF_SUCCESS Successfully added the Vendor Specific UUID.
 * @retval ::NRF_ERROR_INVALID_ADDR If p_vs_uuid or p_uuid_type is NULL or invalid.
 * @retval ::NRF_ERROR_NO_MEM If there are no more free slots for VS UUIDs.
 */
SVCALL(SD_BLE_UUID_VS_ADD, uint32_t, sd_ble_uuid_vs_add(ble_uuid128_t const *p_vs_uuid, uint8_t *p_uuid_type));
   1cd58:	df63      	svc	99	; 0x63
   1cd5a:	4770      	bx	lr

0001cd5c <sd_ble_gatts_characteristic_add>:
 * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation, a service context is required.
 * @retval ::NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.
 * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
 * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, attribute lengths are restricted by @ref BLE_GATTS_ATTR_LENS_MAX.
 */
SVCALL(SD_BLE_GATTS_CHARACTERISTIC_ADD, uint32_t, sd_ble_gatts_characteristic_add(uint16_t service_handle, ble_gatts_char_md_t const *p_char_md, ble_gatts_attr_t const *p_attr_char_value, ble_gatts_char_handles_t *p_handles));
   1cd5c:	dfa2      	svc	162	; 0xa2
   1cd5e:	4770      	bx	lr

0001cd60 <sd_ble_gatts_service_add>:
 * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, Vendor Specific UUIDs need to be present in the table.
 * @retval ::NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.
 * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
 */
SVCALL(SD_BLE_GATTS_SERVICE_ADD, uint32_t, sd_ble_gatts_service_add(uint8_t type, ble_uuid_t const *p_uuid, uint16_t *p_handle));
   1cd60:	dfa0      	svc	160	; 0xa0
   1cd62:	4770      	bx	lr

0001cd64 <sd_ble_gap_connect>:
 *                          wait for the corresponding @ref BLE_GAP_EVT_CONNECTED event before calling again.
 * @retval ::BLE_ERROR_GAP_WHITELIST_IN_USE Unable to replace the whitelist while another operation is using it.
 * @retval ::NRF_ERROR_RESOURCES Not enough BLE role slots available.
 *                               Stop one or more currently active roles (Central, Peripheral or Broadcaster) and try again
 */
SVCALL(SD_BLE_GAP_CONNECT, uint32_t, sd_ble_gap_connect(ble_gap_addr_t const *p_peer_addr, ble_gap_scan_params_t const *p_scan_params, ble_gap_conn_params_t const *p_conn_params));
   1cd64:	df8c      	svc	140	; 0x8c
   1cd66:	4770      	bx	lr

0001cd68 <sd_ble_gap_device_name_set>:
 * @retval ::NRF_SUCCESS GAP device name and permissions set successfully.
 * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
 * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
 */
SVCALL(SD_BLE_GAP_DEVICE_NAME_SET, uint32_t, sd_ble_gap_device_name_set(ble_gap_conn_sec_mode_t const *p_write_perm, uint8_t const *p_dev_name, uint16_t len));
   1cd68:	df7c      	svc	124	; 0x7c
   1cd6a:	4770      	bx	lr

0001cd6c <sd_ble_gap_ppcp_set>:
 *
 * @retval ::NRF_SUCCESS Peripheral Preferred Connection Parameters set successfully.
 * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
 */
SVCALL(SD_BLE_GAP_PPCP_SET, uint32_t, sd_ble_gap_ppcp_set(ble_gap_conn_params_t const *p_conn_params));
   1cd6c:	df7a      	svc	122	; 0x7a
   1cd6e:	4770      	bx	lr

0001cd70 <sd_ble_gap_appearance_set>:
 * @param[in] appearance Appearance (16-bit), see @ref BLE_APPEARANCES.
 *
 * @retval ::NRF_SUCCESS  Appearance value set successfully.
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
 */
SVCALL(SD_BLE_GAP_APPEARANCE_SET, uint32_t, sd_ble_gap_appearance_set(uint16_t appearance));
   1cd70:	df78      	svc	120	; 0x78
   1cd72:	4770      	bx	lr

0001cd74 <sd_ble_gap_conn_param_update>:
 * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
 * @retval ::NRF_ERROR_BUSY Procedure already in progress or not allowed at this time, process pending events and wait for pending procedures to complete and retry.
 * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
 * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
 */
SVCALL(SD_BLE_GAP_CONN_PARAM_UPDATE, uint32_t, sd_ble_gap_conn_param_update(uint16_t conn_handle, ble_gap_conn_params_t const *p_conn_params));
   1cd74:	df75      	svc	117	; 0x75
   1cd76:	4770      	bx	lr

0001cd78 <sd_ble_gap_scan_stop>:
 * @endmscs
 *
 * @retval ::NRF_SUCCESS Successfully stopped scanning procedure.
 * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation (most probably not in scanning state).
 */
SVCALL(SD_BLE_GAP_SCAN_STOP, uint32_t, sd_ble_gap_scan_stop(void));
   1cd78:	df8b      	svc	139	; 0x8b
   1cd7a:	4770      	bx	lr

0001cd7c <sd_ble_gap_scan_start>:
 * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
 * @retval ::BLE_ERROR_GAP_WHITELIST_IN_USE Unable to replace the whitelist while another operation is using it.
 * @retval ::NRF_ERROR_RESOURCES Not enough BLE role slots available.
 *                               Stop one or more currently active roles (Central, Peripheral or Broadcaster) and try again
 */
SVCALL(SD_BLE_GAP_SCAN_START, uint32_t, sd_ble_gap_scan_start(ble_gap_scan_params_t const *p_scan_params));
   1cd7c:	df8a      	svc	138	; 0x8a
   1cd7e:	4770      	bx	lr

0001cd80 <_ZN7StorageD1Ev.lto_priv.132>:
};

//The storage class has two different operation modes, a buffered read/write
//and a queued read/write that is used for storing and loading configurations

class Storage : public TerminalCommandListener
   1cd80:	4770      	bx	lr
	...

0001cd84 <sys_evt_dispatch>:
	void sys_evt_dispatch(uint32_t sys_evt)
	{
		//Because there can only be one flash event at a time before registering a new flash operation
		//We do not need an event queue to handle this. If we want other sys_events, we probably need a queue
		if(sys_evt == NRF_EVT_FLASH_OPERATION_ERROR
			|| sys_evt == NRF_EVT_FLASH_OPERATION_SUCCESS
   1cd84:	1e83      	subs	r3, r0, #2
	//Dispatches system events
	void sys_evt_dispatch(uint32_t sys_evt)
	{
		//Because there can only be one flash event at a time before registering a new flash operation
		//We do not need an event queue to handle this. If we want other sys_events, we probably need a queue
		if(sys_evt == NRF_EVT_FLASH_OPERATION_ERROR
   1cd86:	2b01      	cmp	r3, #1
   1cd88:	d801      	bhi.n	1cd8e <sys_evt_dispatch+0xa>
			|| sys_evt == NRF_EVT_FLASH_OPERATION_SUCCESS
		){
			pendingSysEvent = sys_evt;
   1cd8a:	4b01      	ldr	r3, [pc, #4]	; (1cd90 <sys_evt_dispatch+0xc>)
   1cd8c:	6018      	str	r0, [r3, #0]
		}
	}
   1cd8e:	4770      	bx	lr
   1cd90:	20003390 	.word	0x20003390

0001cd94 <_ZL18ble_timer_dispatchPv.lto_priv.83>:
//### TIMERS ##############################################################
APP_TIMER_DEF(mainTimerMsId);

//Called by the app_timer module
static void ble_timer_dispatch(void * p_context)
{
   1cd94:	b508      	push	{r3, lr}
    UNUSED_PARAMETER(p_context);

    //We just increase the time that has passed since the last handler
    //And call the timer from our main event handling queue
    node->passsedTimeSinceLastTimerHandlerDs += Config->mainTimerTickDs;
   1cd96:	f004 f847 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1cd9a:	4b04      	ldr	r3, [pc, #16]	; (1cdac <_ZL18ble_timer_dispatchPv.lto_priv.83+0x18>)
   1cd9c:	88c2      	ldrh	r2, [r0, #6]
   1cd9e:	681b      	ldr	r3, [r3, #0]
   1cda0:	336c      	adds	r3, #108	; 0x6c
   1cda2:	8819      	ldrh	r1, [r3, #0]
   1cda4:	188a      	adds	r2, r1, r2
   1cda6:	801a      	strh	r2, [r3, #0]

    //Timer handlers are called from the main event handling queue and from timerEventDispatch
}
   1cda8:	bd08      	pop	{r3, pc}
   1cdaa:	46c0      	nop			; (mov r8, r8)
   1cdac:	200033b4 	.word	0x200033b4

0001cdb0 <_ZN4Node24ConnectingTimeoutHandlerEP9ble_evt_t>:
}

//TODO: part of the connection manager
//If we wanted to connect but our connection timed out (only outgoing connections)
void Node::ConnectingTimeoutHandler(ble_evt_t* bleEvent)
{
   1cdb0:	b508      	push	{r3, lr}
//	logt("NODE", "Connecting Timeout");

	//We are leaving the discoveryState::CONNECTING state
	ChangeState(discoveryState::DISCOVERY);
   1cdb2:	2102      	movs	r1, #2
   1cdb4:	f001 f846 	bl	1de44 <_ZN4Node11ChangeStateE14discoveryState>
}
   1cdb8:	bd08      	pop	{r3, pc}
	...

0001cdbc <_ZThn4_N4Node24ConnectingTimeoutHandlerEP9ble_evt_t>:
		void ConfigurationLoadedHandler();

		//Methods of ConnectionManagerCallback
		void DisconnectionHandler(Connection* connection);
		void ConnectionSuccessfulHandler(ble_evt_t* bleEvent);
		void ConnectingTimeoutHandler(ble_evt_t* bleEvent);
   1cdbc:	b408      	push	{r3}
   1cdbe:	4b02      	ldr	r3, [pc, #8]	; (1cdc8 <_ZThn4_N4Node24ConnectingTimeoutHandlerEP9ble_evt_t+0xc>)
   1cdc0:	469c      	mov	ip, r3
   1cdc2:	3804      	subs	r0, #4
   1cdc4:	bc08      	pop	{r3}
   1cdc6:	4760      	bx	ip
   1cdc8:	0001cdb1 	.word	0x0001cdb1

0001cdcc <_ZN4Node27ConnectionSuccessfulHandlerEP9ble_evt_t>:
#define ________________CONNECTION___________________
#pragma region connections

//Is called as soon as a connection is connected, before the handshake
void Node::ConnectionSuccessfulHandler(ble_evt_t* bleEvent)
{
   1cdcc:	b508      	push	{r3, lr}
//	logt("NODE", "Connection initiated");

	//We are leaving the discoveryState::CONNECTING state
	ChangeState(discoveryState::HANDSHAKE);
   1cdce:	2106      	movs	r1, #6
   1cdd0:	f001 f838 	bl	1de44 <_ZN4Node11ChangeStateE14discoveryState>

	//FIXME: The handshake needs some kind of timeout
}
   1cdd4:	bd08      	pop	{r3, pc}
	...

0001cdd8 <_ZThn4_N4Node27ConnectionSuccessfulHandlerEP9ble_evt_t>:
		//Implements Storage Callback for loading the configuration
		void ConfigurationLoadedHandler();

		//Methods of ConnectionManagerCallback
		void DisconnectionHandler(Connection* connection);
		void ConnectionSuccessfulHandler(ble_evt_t* bleEvent);
   1cdd8:	b408      	push	{r3}
   1cdda:	4b02      	ldr	r3, [pc, #8]	; (1cde4 <_ZThn4_N4Node27ConnectionSuccessfulHandlerEP9ble_evt_t+0xc>)
   1cddc:	469c      	mov	ip, r3
   1cdde:	3804      	subs	r0, #4
   1cde0:	bc08      	pop	{r3}
   1cde2:	4760      	bx	ip
   1cde4:	0001cdcd 	.word	0x0001cdcd

0001cde8 <_ZN4Node26ConfigurationLoadedHandlerEv>:
void Node::ConfigurationLoadedHandler()
{
	u32 err;

	//If config is unset, set to default
	if (persistentConfig.version == 0xFFFFFFFF)
   1cde8:	6983      	ldr	r3, [r0, #24]
	}

}

void Node::ConfigurationLoadedHandler()
{
   1cdea:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1cdec:	1c04      	adds	r4, r0, #0
	u32 err;

	//If config is unset, set to default
	if (persistentConfig.version == 0xFFFFFFFF)
   1cdee:	3301      	adds	r3, #1
   1cdf0:	d12b      	bne.n	1ce4a <_ZN4Node26ConfigurationLoadedHandlerEv+0x62>
	{
//		logt("NODE", "Config was empty, default config set");
		persistentConfig.version = 0;
   1cdf2:	2300      	movs	r3, #0
   1cdf4:	6183      	str	r3, [r0, #24]
		persistentConfig.connectionLossCounter = 0;
   1cdf6:	8703      	strh	r3, [r0, #56]	; 0x38
		persistentConfig.networkId = Config->meshNetworkIdentifier;
   1cdf8:	f004 f816 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1cdfc:	3068      	adds	r0, #104	; 0x68
   1cdfe:	8803      	ldrh	r3, [r0, #0]
   1ce00:	84a3      	strh	r3, [r4, #36]	; 0x24
		memcpy(&persistentConfig.networkKey, &Config->meshNetworkKey, 16);
   1ce02:	f004 f811 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1ce06:	1c01      	adds	r1, r0, #0
   1ce08:	1c20      	adds	r0, r4, #0
   1ce0a:	3157      	adds	r1, #87	; 0x57
   1ce0c:	2210      	movs	r2, #16
   1ce0e:	3028      	adds	r0, #40	; 0x28
   1ce10:	f004 fc00 	bl	21614 <memcpy>
		persistentConfig.dBmRX = 10;
   1ce14:	1c23      	adds	r3, r4, #0
   1ce16:	220a      	movs	r2, #10
   1ce18:	333c      	adds	r3, #60	; 0x3c
   1ce1a:	701a      	strb	r2, [r3, #0]
		persistentConfig.dBmTX = 10;
   1ce1c:	3b01      	subs	r3, #1
   1ce1e:	701a      	strb	r2, [r3, #0]

		persistentConfig.deviceType = Config->deviceType;
   1ce20:	f004 f802 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1ce24:	1c23      	adds	r3, r4, #0
   1ce26:	306c      	adds	r0, #108	; 0x6c
   1ce28:	7802      	ldrb	r2, [r0, #0]
   1ce2a:	333a      	adds	r3, #58	; 0x3a
   1ce2c:	701a      	strb	r2, [r3, #0]
		persistentConfig.nodeId = Config->defaultNodeId;
   1ce2e:	f003 fffb 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1ce32:	306a      	adds	r0, #106	; 0x6a
   1ce34:	8803      	ldrh	r3, [r0, #0]
   1ce36:	84e3      	strh	r3, [r4, #38]	; 0x26

		memcpy(&persistentConfig.nodeAddress, &Config->staticAccessAddress, sizeof(ble_gap_addr_t));
   1ce38:	f003 fff6 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1ce3c:	1c01      	adds	r1, r0, #0
   1ce3e:	1c20      	adds	r0, r4, #0
   1ce40:	316d      	adds	r1, #109	; 0x6d
   1ce42:	301c      	adds	r0, #28
   1ce44:	2207      	movs	r2, #7
   1ce46:	f004 fbe5 	bl	21614 <memcpy>
	}

	//Random offset that can be used to disperse packets from different nodes over time
	this->appTimerRandomOffsetDs = (persistentConfig.nodeId % 100);
   1ce4a:	8ce0      	ldrh	r0, [r4, #38]	; 0x26
   1ce4c:	2164      	movs	r1, #100	; 0x64
   1ce4e:	f005 f999 	bl	22184 <__aeabi_uidivmod>
   1ce52:	1c23      	adds	r3, r4, #0
   1ce54:	3374      	adds	r3, #116	; 0x74
   1ce56:	8019      	strh	r1, [r3, #0]
	//Change window title of the Terminal
	SetTerminalTitle();
//	logt("NODE", "====> Node %u (%s) <====", persistentConfig.nodeId, Config->serialNumber);

	//Get a random number for the connection loss counter (hard on system start,...stat)
	persistentConfig.connectionLossCounter = Utility::GetRandomInteger();
   1ce58:	f002 fe00 	bl	1fa5c <_ZN7Utility16GetRandomIntegerEv>

//Generates a new clusterID by using connectionLoss and the unique id of the node
clusterID Node::GenerateClusterID(void)
{
	//Combine connection loss and nodeId to generate a unique cluster id
	clusterID newId = this->persistentConfig.nodeId + (this->persistentConfig.connectionLossCounter << 16);
   1ce5c:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
	//Change window title of the Terminal
	SetTerminalTitle();
//	logt("NODE", "====> Node %u (%s) <====", persistentConfig.nodeId, Config->serialNumber);

	//Get a random number for the connection loss counter (hard on system start,...stat)
	persistentConfig.connectionLossCounter = Utility::GetRandomInteger();
   1ce5e:	8720      	strh	r0, [r4, #56]	; 0x38

//Generates a new clusterID by using connectionLoss and the unique id of the node
clusterID Node::GenerateClusterID(void)
{
	//Combine connection loss and nodeId to generate a unique cluster id
	clusterID newId = this->persistentConfig.nodeId + (this->persistentConfig.connectionLossCounter << 16);
   1ce60:	0400      	lsls	r0, r0, #16
   1ce62:	1818      	adds	r0, r3, r0
	persistentConfig.connectionLossCounter = Utility::GetRandomInteger();

	clusterId = this->GenerateClusterID();

	//Set the BLE address so that we have the same on every startup, mostly for debugging
	if(persistentConfig.nodeAddress.addr_type != 0xFF){
   1ce64:	7f23      	ldrb	r3, [r4, #28]
//	logt("NODE", "====> Node %u (%s) <====", persistentConfig.nodeId, Config->serialNumber);

	//Get a random number for the connection loss counter (hard on system start,...stat)
	persistentConfig.connectionLossCounter = Utility::GetRandomInteger();

	clusterId = this->GenerateClusterID();
   1ce66:	67e0      	str	r0, [r4, #124]	; 0x7c

	//Set the BLE address so that we have the same on every startup, mostly for debugging
	if(persistentConfig.nodeAddress.addr_type != 0xFF){
   1ce68:	2bff      	cmp	r3, #255	; 0xff
   1ce6a:	d004      	beq.n	1ce76 <_ZN4Node26ConfigurationLoadedHandlerEv+0x8e>
		err = sd_ble_gap_address_set(BLE_GAP_ADDR_CYCLE_MODE_NONE, &persistentConfig.nodeAddress);
   1ce6c:	1c21      	adds	r1, r4, #0
   1ce6e:	2000      	movs	r0, #0
   1ce70:	311c      	adds	r1, #28
   1ce72:	f7ff ff6b 	bl	1cd4c <sd_ble_gap_address_set>
void ScanController::Initialize(void)
{

	//Define scanning Parameters
	currentScanParams.active = 0;					// Active scanning set.
	currentScanParams.selective = 0;				// Selective scanning not set.
   1ce76:	2201      	movs	r2, #1
   1ce78:	2702      	movs	r7, #2
	currentScanParams.p_whitelist = NULL;				// White-list not set.
   1ce7a:	2600      	movs	r6, #0

void ScanController::Initialize(void)
{

	//Define scanning Parameters
	currentScanParams.active = 0;					// Active scanning set.
   1ce7c:	4d37      	ldr	r5, [pc, #220]	; (1cf5c <_ZN4Node26ConfigurationLoadedHandlerEv+0x174>)
   1ce7e:	782b      	ldrb	r3, [r5, #0]
	currentScanParams.selective = 0;				// Selective scanning not set.
	currentScanParams.p_whitelist = NULL;				// White-list not set.
   1ce80:	606e      	str	r6, [r5, #4]
void ScanController::Initialize(void)
{

	//Define scanning Parameters
	currentScanParams.active = 0;					// Active scanning set.
	currentScanParams.selective = 0;				// Selective scanning not set.
   1ce82:	4393      	bics	r3, r2
   1ce84:	43bb      	bics	r3, r7
   1ce86:	702b      	strb	r3, [r5, #0]
	currentScanParams.p_whitelist = NULL;				// White-list not set.
	currentScanParams.interval = (u16) Config->meshScanIntervalHigh;				// Scan interval.
   1ce88:	f003 ffce 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1ce8c:	8a83      	ldrh	r3, [r0, #20]
   1ce8e:	812b      	strh	r3, [r5, #8]
	currentScanParams.window = (u16) Config->meshScanWindowHigh;	// Scan window.
   1ce90:	f003 ffca 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1ce94:	8ac3      	ldrh	r3, [r0, #22]
	currentScanParams.timeout = 0;					// Never stop scanning unless explicit asked to.
   1ce96:	81ae      	strh	r6, [r5, #12]
	//Define scanning Parameters
	currentScanParams.active = 0;					// Active scanning set.
	currentScanParams.selective = 0;				// Selective scanning not set.
	currentScanParams.p_whitelist = NULL;				// White-list not set.
	currentScanParams.interval = (u16) Config->meshScanIntervalHigh;				// Scan interval.
	currentScanParams.window = (u16) Config->meshScanWindowHigh;	// Scan window.
   1ce98:	816b      	strh	r3, [r5, #10]
	currentScanParams.timeout = 0;					// Never stop scanning unless explicit asked to.

	scanningState = SCAN_STATE_OFF;
   1ce9a:	4b31      	ldr	r3, [pc, #196]	; (1cf60 <_ZN4Node26ConfigurationLoadedHandlerEv+0x178>)

	advertisingPacketAwaitingUpdate = false;
	currentAdvertisementPacketLength = 0;

	//Define default Advertisement params
	currentAdvertisingParams.type = BLE_GAP_ADV_TYPE_ADV_SCAN_IND; //Connectable
   1ce9c:	4d31      	ldr	r5, [pc, #196]	; (1cf64 <_ZN4Node26ConfigurationLoadedHandlerEv+0x17c>)
   1ce9e:	801e      	strh	r6, [r3, #0]
		}
	}

	//Init softdevice and c libraries
	ScanController::Initialize();
	AdvertisingController::Initialize(persistentConfig.networkId);
   1cea0:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
   1cea2:	702f      	strb	r7, [r5, #0]
   1cea4:	9301      	str	r3, [sp, #4]

void AdvertisingController::Initialize(u16 networkIdentifier)
{
	u32 err = 0;

	advertisingPacketAwaitingUpdate = false;
   1cea6:	4b30      	ldr	r3, [pc, #192]	; (1cf68 <_ZN4Node26ConfigurationLoadedHandlerEv+0x180>)
	currentAdvertisementPacketLength = 0;

	//Define default Advertisement params
	currentAdvertisingParams.type = BLE_GAP_ADV_TYPE_ADV_SCAN_IND; //Connectable
	currentAdvertisingParams.p_peer_addr = NULL; //Unidirected, not directed
   1cea8:	606e      	str	r6, [r5, #4]

void AdvertisingController::Initialize(u16 networkIdentifier)
{
	u32 err = 0;

	advertisingPacketAwaitingUpdate = false;
   1ceaa:	701e      	strb	r6, [r3, #0]
	currentAdvertisementPacketLength = 0;
   1ceac:	4b2f      	ldr	r3, [pc, #188]	; (1cf6c <_ZN4Node26ConfigurationLoadedHandlerEv+0x184>)

	//Define default Advertisement params
	currentAdvertisingParams.type = BLE_GAP_ADV_TYPE_ADV_SCAN_IND; //Connectable
	currentAdvertisingParams.p_peer_addr = NULL; //Unidirected, not directed
	currentAdvertisingParams.fp = BLE_GAP_ADV_FP_ANY; //Filter policy
   1ceae:	722e      	strb	r6, [r5, #8]
void AdvertisingController::Initialize(u16 networkIdentifier)
{
	u32 err = 0;

	advertisingPacketAwaitingUpdate = false;
	currentAdvertisementPacketLength = 0;
   1ceb0:	701e      	strb	r6, [r3, #0]
	//Define default Advertisement params
	currentAdvertisingParams.type = BLE_GAP_ADV_TYPE_ADV_SCAN_IND; //Connectable
	currentAdvertisingParams.p_peer_addr = NULL; //Unidirected, not directed
	currentAdvertisingParams.fp = BLE_GAP_ADV_FP_ANY; //Filter policy
	currentAdvertisingParams.p_whitelist = NULL;
	currentAdvertisingParams.interval = 0x0200; // Advertising interval between 0x0020 and 0x4000 in 0.625 ms units (20ms to 10.24s), see @ref BLE_GAP_ADV_INTERVALS
   1ceb2:	2380      	movs	r3, #128	; 0x80
   1ceb4:	009b      	lsls	r3, r3, #2

	//Define default Advertisement params
	currentAdvertisingParams.type = BLE_GAP_ADV_TYPE_ADV_SCAN_IND; //Connectable
	currentAdvertisingParams.p_peer_addr = NULL; //Unidirected, not directed
	currentAdvertisingParams.fp = BLE_GAP_ADV_FP_ANY; //Filter policy
	currentAdvertisingParams.p_whitelist = NULL;
   1ceb6:	60ee      	str	r6, [r5, #12]
	currentAdvertisingParams.interval = 0x0200; // Advertising interval between 0x0020 and 0x4000 in 0.625 ms units (20ms to 10.24s), see @ref BLE_GAP_ADV_INTERVALS
	currentAdvertisingParams.timeout = 0;
   1ceb8:	826e      	strh	r6, [r5, #18]
	//Define default Advertisement params
	currentAdvertisingParams.type = BLE_GAP_ADV_TYPE_ADV_SCAN_IND; //Connectable
	currentAdvertisingParams.p_peer_addr = NULL; //Unidirected, not directed
	currentAdvertisingParams.fp = BLE_GAP_ADV_FP_ANY; //Filter policy
	currentAdvertisingParams.p_whitelist = NULL;
	currentAdvertisingParams.interval = 0x0200; // Advertising interval between 0x0020 and 0x4000 in 0.625 ms units (20ms to 10.24s), see @ref BLE_GAP_ADV_INTERVALS
   1ceba:	822b      	strh	r3, [r5, #16]
	currentAdvertisingParams.timeout = 0;
	currentAdvertisingParams.channel_mask.ch_37_off = Config->advertiseOnChannel37 ? 0 : 1;
   1cebc:	f003 ffb4 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1cec0:	3030      	adds	r0, #48	; 0x30
   1cec2:	7803      	ldrb	r3, [r0, #0]
   1cec4:	2101      	movs	r1, #1
   1cec6:	425a      	negs	r2, r3
   1cec8:	415a      	adcs	r2, r3
   1ceca:	7d2b      	ldrb	r3, [r5, #20]
   1cecc:	438b      	bics	r3, r1
   1cece:	4313      	orrs	r3, r2
   1ced0:	752b      	strb	r3, [r5, #20]
	currentAdvertisingParams.channel_mask.ch_38_off = Config->advertiseOnChannel38 ? 0 : 1;
   1ced2:	f003 ffa9 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1ced6:	3031      	adds	r0, #49	; 0x31
   1ced8:	7802      	ldrb	r2, [r0, #0]
   1ceda:	4253      	negs	r3, r2
   1cedc:	4153      	adcs	r3, r2
   1cede:	005a      	lsls	r2, r3, #1
   1cee0:	7d2b      	ldrb	r3, [r5, #20]
   1cee2:	43bb      	bics	r3, r7
   1cee4:	4313      	orrs	r3, r2
   1cee6:	752b      	strb	r3, [r5, #20]
	currentAdvertisingParams.channel_mask.ch_39_off = Config->advertiseOnChannel39 ? 0 : 1;
   1cee8:	f003 ff9e 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1ceec:	3032      	adds	r0, #50	; 0x32
   1ceee:	7802      	ldrb	r2, [r0, #0]
   1cef0:	2104      	movs	r1, #4
   1cef2:	4253      	negs	r3, r2
   1cef4:	4153      	adcs	r3, r2
   1cef6:	009a      	lsls	r2, r3, #2
   1cef8:	7d2b      	ldrb	r3, [r5, #20]
	header->flags.type = BLE_GAP_AD_TYPE_FLAGS;
	header->flags.flags = BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED;

	// LENGTH will be set later //

	header->manufacturer.type = BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA;
   1cefa:	20ff      	movs	r0, #255	; 0xff
	currentAdvertisingParams.p_whitelist = NULL;
	currentAdvertisingParams.interval = 0x0200; // Advertising interval between 0x0020 and 0x4000 in 0.625 ms units (20ms to 10.24s), see @ref BLE_GAP_ADV_INTERVALS
	currentAdvertisingParams.timeout = 0;
	currentAdvertisingParams.channel_mask.ch_37_off = Config->advertiseOnChannel37 ? 0 : 1;
	currentAdvertisingParams.channel_mask.ch_38_off = Config->advertiseOnChannel38 ? 0 : 1;
	currentAdvertisingParams.channel_mask.ch_39_off = Config->advertiseOnChannel39 ? 0 : 1;
   1cefc:	438b      	bics	r3, r1
   1cefe:	4313      	orrs	r3, r2
   1cf00:	752b      	strb	r3, [r5, #20]

	//Set state
	advertisingState = ADV_STATE_OFF;
   1cf02:	4b1b      	ldr	r3, [pc, #108]	; (1cf70 <_ZN4Node26ConfigurationLoadedHandlerEv+0x188>)

	//----------------- Prefill advertisement header
	header = (advPacketHeader*) currentAdvertisementPacket;
   1cf04:	4a1b      	ldr	r2, [pc, #108]	; (1cf74 <_ZN4Node26ConfigurationLoadedHandlerEv+0x18c>)
	currentAdvertisingParams.channel_mask.ch_37_off = Config->advertiseOnChannel37 ? 0 : 1;
	currentAdvertisingParams.channel_mask.ch_38_off = Config->advertiseOnChannel38 ? 0 : 1;
	currentAdvertisingParams.channel_mask.ch_39_off = Config->advertiseOnChannel39 ? 0 : 1;

	//Set state
	advertisingState = ADV_STATE_OFF;
   1cf06:	801e      	strh	r6, [r3, #0]

	//----------------- Prefill advertisement header
	header = (advPacketHeader*) currentAdvertisementPacket;
   1cf08:	4b1b      	ldr	r3, [pc, #108]	; (1cf78 <_ZN4Node26ConfigurationLoadedHandlerEv+0x190>)
	header->flags.flags = BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED;

	// LENGTH will be set later //

	header->manufacturer.type = BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA;
	header->manufacturer.companyIdentifier = COMPANY_IDENTIFIER;
   1cf0a:	3149      	adds	r1, #73	; 0x49

	//Set state
	advertisingState = ADV_STATE_OFF;

	//----------------- Prefill advertisement header
	header = (advPacketHeader*) currentAdvertisementPacket;
   1cf0c:	6013      	str	r3, [r2, #0]
	header->flags.len = SIZEOF_ADV_STRUCTURE_FLAGS-1; //minus length field itself
	header->flags.type = BLE_GAP_AD_TYPE_FLAGS;
   1cf0e:	2201      	movs	r2, #1
   1cf10:	705a      	strb	r2, [r3, #1]
	header->flags.flags = BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED;
   1cf12:	3205      	adds	r2, #5
   1cf14:	709a      	strb	r2, [r3, #2]

	header->manufacturer.type = BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA;
	header->manufacturer.companyIdentifier = COMPANY_IDENTIFIER;

	//The specific instance of a mesh network
	header->meshIdentifier = MESH_IDENTIFIER;
   1cf16:	32ea      	adds	r2, #234	; 0xea
   1cf18:	71da      	strb	r2, [r3, #7]
	header->networkId = networkIdentifier;
   1cf1a:	466a      	mov	r2, sp
   1cf1c:	7912      	ldrb	r2, [r2, #4]
	//Set state
	advertisingState = ADV_STATE_OFF;

	//----------------- Prefill advertisement header
	header = (advPacketHeader*) currentAdvertisementPacket;
	header->flags.len = SIZEOF_ADV_STRUCTURE_FLAGS-1; //minus length field itself
   1cf1e:	701f      	strb	r7, [r3, #0]
	header->manufacturer.type = BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA;
	header->manufacturer.companyIdentifier = COMPANY_IDENTIFIER;

	//The specific instance of a mesh network
	header->meshIdentifier = MESH_IDENTIFIER;
	header->networkId = networkIdentifier;
   1cf20:	721a      	strb	r2, [r3, #8]
   1cf22:	9a01      	ldr	r2, [sp, #4]
	header->flags.flags = BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED;

	// LENGTH will be set later //

	header->manufacturer.type = BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA;
	header->manufacturer.companyIdentifier = COMPANY_IDENTIFIER;
   1cf24:	719f      	strb	r7, [r3, #6]

	//The specific instance of a mesh network
	header->meshIdentifier = MESH_IDENTIFIER;
	header->networkId = networkIdentifier;
   1cf26:	0a12      	lsrs	r2, r2, #8
	header->flags.type = BLE_GAP_AD_TYPE_FLAGS;
	header->flags.flags = BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED;

	// LENGTH will be set later //

	header->manufacturer.type = BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA;
   1cf28:	7118      	strb	r0, [r3, #4]
	header->manufacturer.companyIdentifier = COMPANY_IDENTIFIER;
   1cf2a:	7159      	strb	r1, [r3, #5]

	//The specific instance of a mesh network
	header->meshIdentifier = MESH_IDENTIFIER;
	header->networkId = networkIdentifier;
   1cf2c:	725a      	strb	r2, [r3, #9]

	//---------------- Prefill scan response header
	u16 size = 0;


	scanHeader = (scanPacketHeader*) currentScanResponsePacket;
   1cf2e:	4b13      	ldr	r3, [pc, #76]	; (1cf7c <_ZN4Node26ConfigurationLoadedHandlerEv+0x194>)
   1cf30:	4a13      	ldr	r2, [pc, #76]	; (1cf80 <_ZN4Node26ConfigurationLoadedHandlerEv+0x198>)

	scanHeader->name.len = 3;
	scanHeader->name.type = BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME;
   1cf32:	2509      	movs	r5, #9

	//---------------- Prefill scan response header
	u16 size = 0;


	scanHeader = (scanPacketHeader*) currentScanResponsePacket;
   1cf34:	6013      	str	r3, [r2, #0]

	scanHeader->name.len = 3;
   1cf36:	2203      	movs	r2, #3
	scanHeader->name.type = BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME;
   1cf38:	705d      	strb	r5, [r3, #1]
	scanHeader->name.name[0] = 'F';
   1cf3a:	353d      	adds	r5, #61	; 0x3d
   1cf3c:	709d      	strb	r5, [r3, #2]
	scanHeader->name.name[1] = 'M';
   1cf3e:	70d9      	strb	r1, [r3, #3]

	scanHeader->manufacturer.len = 3;
	scanHeader->manufacturer.type = BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA;
   1cf40:	7158      	strb	r0, [r3, #5]
	scanHeader->manufacturer.companyIdentifier = COMPANY_IDENTIFIER;
   1cf42:	7199      	strb	r1, [r3, #6]
   1cf44:	71df      	strb	r7, [r3, #7]
	u16 size = 0;


	scanHeader = (scanPacketHeader*) currentScanResponsePacket;

	scanHeader->name.len = 3;
   1cf46:	701a      	strb	r2, [r3, #0]
	scanHeader->name.type = BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME;
	scanHeader->name.name[0] = 'F';
	scanHeader->name.name[1] = 'M';

	scanHeader->manufacturer.len = 3;
   1cf48:	711a      	strb	r2, [r3, #4]

	//Fill JOIN_ME packet with data
	this->UpdateJoinMePacket();
   1cf4a:	1c20      	adds	r0, r4, #0
   1cf4c:	f000 ff2e 	bl	1ddac <_ZN4Node18UpdateJoinMePacketEv>
	//Print configuration and start node
//	logt("NODE", "Config loaded nodeId:%d, connLossCount:%u, networkId:%d", persistentConfig.nodeId, persistentConfig.connectionLossCounter, persistentConfig.networkId);


	//Go to Discovery
	ChangeState(discoveryState::DISCOVERY);
   1cf50:	1c39      	adds	r1, r7, #0
   1cf52:	1c20      	adds	r0, r4, #0
   1cf54:	f000 ff76 	bl	1de44 <_ZN4Node11ChangeStateE14discoveryState>
}
   1cf58:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   1cf5a:	46c0      	nop			; (mov r8, r8)
   1cf5c:	200033c0 	.word	0x200033c0
   1cf60:	20003394 	.word	0x20003394
   1cf64:	20003524 	.word	0x20003524
   1cf68:	200033dc 	.word	0x200033dc
   1cf6c:	2000357c 	.word	0x2000357c
   1cf70:	20003588 	.word	0x20003588
   1cf74:	20003580 	.word	0x20003580
   1cf78:	20003540 	.word	0x20003540
   1cf7c:	20003341 	.word	0x20003341
   1cf80:	200033ac 	.word	0x200033ac

0001cf84 <_ZThn8_N4Node26ConfigurationLoadedHandlerEv>:

		//Methods of TerminalCommandListener
		bool TerminalCommandHandler(string commandName, vector<string> commandArgs);

		//Implements Storage Callback for loading the configuration
		void ConfigurationLoadedHandler();
   1cf84:	b408      	push	{r3}
   1cf86:	4b02      	ldr	r3, [pc, #8]	; (1cf90 <_ZThn8_N4Node26ConfigurationLoadedHandlerEv+0xc>)
   1cf88:	469c      	mov	ip, r3
   1cf8a:	3808      	subs	r0, #8
   1cf8c:	bc08      	pop	{r3}
   1cf8e:	4760      	bx	ip
   1cf90:	0001cde9 	.word	0x0001cde9

0001cf94 <_ZN7StorageD0Ev>:
   1cf94:	b510      	push	{r4, lr}
   1cf96:	1c04      	adds	r4, r0, #0
   1cf98:	f004 f954 	bl	21244 <_ZdlPv>
   1cf9c:	1c20      	adds	r0, r4, #0
   1cf9e:	bd10      	pop	{r4, pc}

0001cfa0 <_ZN6LoggerD1Ev>:
#define __FILE_S__ (strrchr(__FILE__, '\\') ? strrchr(__FILE__, '\\') + 1 : __FILE__)
#else
#define __FILE_S__ (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)
#endif

class Logger : public TerminalCommandListener
   1cfa0:	b570      	push	{r4, r5, r6, lr}
   1cfa2:	1c04      	adds	r4, r0, #0
   1cfa4:	4b09      	ldr	r3, [pc, #36]	; (1cfcc <_ZN6LoggerD1Ev+0x2c>)
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      ~vector() _GLIBCXX_NOEXCEPT
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator()); }
   1cfa6:	6845      	ldr	r5, [r0, #4]
   1cfa8:	3308      	adds	r3, #8
   1cfaa:	6886      	ldr	r6, [r0, #8]
   1cfac:	6003      	str	r3, [r0, #0]
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
	{
	  for (; __first != __last; ++__first)
   1cfae:	42b5      	cmp	r5, r6
   1cfb0:	d004      	beq.n	1cfbc <_ZN6LoggerD1Ev+0x1c>
   * Destroy the object pointed to by a pointer type.
   */
  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }
   1cfb2:	1c28      	adds	r0, r5, #0
   1cfb4:	f004 f9aa 	bl	2130c <_ZNSsD1Ev>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
	{
	  for (; __first != __last; ++__first)
   1cfb8:	3504      	adds	r5, #4
   1cfba:	e7f8      	b.n	1cfae <_ZN6LoggerD1Ev+0xe>
      }
#endif

      ~_Vector_base() _GLIBCXX_NOEXCEPT
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start); }
   1cfbc:	6860      	ldr	r0, [r4, #4]

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
	if (__p)
   1cfbe:	2800      	cmp	r0, #0
   1cfc0:	d001      	beq.n	1cfc6 <_ZN6LoggerD1Ev+0x26>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
   1cfc2:	f004 f93f 	bl	21244 <_ZdlPv>
   1cfc6:	1c20      	adds	r0, r4, #0
   1cfc8:	bd70      	pop	{r4, r5, r6, pc}
   1cfca:	46c0      	nop			; (mov r8, r8)
   1cfcc:	00022968 	.word	0x00022968

0001cfd0 <_ZN6LoggerD0Ev>:
   1cfd0:	b510      	push	{r4, lr}
   1cfd2:	1c04      	adds	r4, r0, #0
   1cfd4:	f7ff ffe4 	bl	1cfa0 <_ZN6LoggerD1Ev>
   1cfd8:	1c20      	adds	r0, r4, #0
   1cfda:	f004 f933 	bl	21244 <_ZdlPv>
   1cfde:	1c20      	adds	r0, r4, #0
   1cfe0:	bd10      	pop	{r4, pc}
	...

0001cfe4 <__tcf_0>:

	char mhTraceBuffer[TRACE_BUFFER_SIZE] = { 0 };

public:
	static Logger& getInstance(){
		static Logger instance;
   1cfe4:	b508      	push	{r3, lr}
   1cfe6:	4802      	ldr	r0, [pc, #8]	; (1cff0 <__tcf_0+0xc>)
   1cfe8:	f7ff ffda 	bl	1cfa0 <_ZN6LoggerD1Ev>
   1cfec:	bd08      	pop	{r3, pc}
   1cfee:	46c0      	nop			; (mov r8, r8)
   1cff0:	2000336c 	.word	0x2000336c

0001cff4 <_ZN4Node21SendClusterInfoUpdateEP10ConnectionP27connPacketClusterInfoUpdate>:
}

//Saves a cluster update or all connections (except the one that caused it)
//This update will then be sent by a connection as soon as the connection is ready (handshakeDone)
void Node::SendClusterInfoUpdate(Connection* ignoreConnection, connPacketClusterInfoUpdate* packet)
{
   1cff4:	b5f0      	push	{r4, r5, r6, r7, lr}
	for(int i=0; i<Config->meshMaxConnections; i++){
   1cff6:	2300      	movs	r3, #0
}

//Saves a cluster update or all connections (except the one that caused it)
//This update will then be sent by a connection as soon as the connection is ready (handshakeDone)
void Node::SendClusterInfoUpdate(Connection* ignoreConnection, connPacketClusterInfoUpdate* packet)
{
   1cff8:	1c15      	adds	r5, r2, #0
   1cffa:	b085      	sub	sp, #20
   1cffc:	9002      	str	r0, [sp, #8]
   1cffe:	9103      	str	r1, [sp, #12]
	for(int i=0; i<Config->meshMaxConnections; i++){
   1d000:	9300      	str	r3, [sp, #0]
   1d002:	f003 ff11 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d006:	3035      	adds	r0, #53	; 0x35
   1d008:	7803      	ldrb	r3, [r0, #0]
   1d00a:	4e3d      	ldr	r6, [pc, #244]	; (1d100 <_ZN4Node21SendClusterInfoUpdateEP10ConnectionP27connPacketClusterInfoUpdate+0x10c>)
   1d00c:	9a00      	ldr	r2, [sp, #0]
		if(!cm->connections[i]->isConnected() || cm->connections[i] == ignoreConnection) continue;
   1d00e:	6830      	ldr	r0, [r6, #0]

//Saves a cluster update or all connections (except the one that caused it)
//This update will then be sent by a connection as soon as the connection is ready (handshakeDone)
void Node::SendClusterInfoUpdate(Connection* ignoreConnection, connPacketClusterInfoUpdate* packet)
{
	for(int i=0; i<Config->meshMaxConnections; i++){
   1d010:	429a      	cmp	r2, r3
   1d012:	da57      	bge.n	1d0c4 <_ZN4Node21SendClusterInfoUpdateEP10ConnectionP27connPacketClusterInfoUpdate+0xd0>
		if(!cm->connections[i]->isConnected() || cm->connections[i] == ignoreConnection) continue;
   1d014:	9b00      	ldr	r3, [sp, #0]
   1d016:	3308      	adds	r3, #8
   1d018:	009b      	lsls	r3, r3, #2
   1d01a:	5819      	ldr	r1, [r3, r0]
   1d01c:	9301      	str	r3, [sp, #4]
   1d01e:	7a0b      	ldrb	r3, [r1, #8]
   1d020:	2b01      	cmp	r3, #1
   1d022:	d94c      	bls.n	1d0be <_ZN4Node21SendClusterInfoUpdateEP10ConnectionP27connPacketClusterInfoUpdate+0xca>
   1d024:	9b03      	ldr	r3, [sp, #12]
   1d026:	4299      	cmp	r1, r3
   1d028:	d049      	beq.n	1d0be <_ZN4Node21SendClusterInfoUpdateEP10ConnectionP27connPacketClusterInfoUpdate+0xca>

		packet->payload.hopsToSink = cm->GetHopsToShortestSink(cm->connections[i]);
   1d02a:	f002 fe01 	bl	1fc30 <_ZN17ConnectionManager21GetHopsToShortestSinkEP10Connection>
   1d02e:	b280      	uxth	r0, r0
   1d030:	72e8      	strb	r0, [r5, #11]
   1d032:	0a00      	lsrs	r0, r0, #8
   1d034:	7328      	strb	r0, [r5, #12]

		//Get the current packet
		connPacketClusterInfoUpdate* currentPacket = &(cm->connections[i]->currentClusterInfoUpdatePacket);
   1d036:	9b01      	ldr	r3, [sp, #4]
   1d038:	6830      	ldr	r0, [r6, #0]

		//If another clusterUpdate message is about to be sent
		if(currentPacket->header.messageType == MESSAGE_TYPE_CLUSTER_INFO_UPDATE){
   1d03a:	2201      	movs	r2, #1
		if(!cm->connections[i]->isConnected() || cm->connections[i] == ignoreConnection) continue;

		packet->payload.hopsToSink = cm->GetHopsToShortestSink(cm->connections[i]);

		//Get the current packet
		connPacketClusterInfoUpdate* currentPacket = &(cm->connections[i]->currentClusterInfoUpdatePacket);
   1d03c:	581c      	ldr	r4, [r3, r0]

		//If another clusterUpdate message is about to be sent
		if(currentPacket->header.messageType == MESSAGE_TYPE_CLUSTER_INFO_UPDATE){
   1d03e:	235e      	movs	r3, #94	; 0x5e
   1d040:	33ff      	adds	r3, #255	; 0xff
   1d042:	5ce3      	ldrb	r3, [r4, r3]
   1d044:	4393      	bics	r3, r2
   1d046:	2b2e      	cmp	r3, #46	; 0x2e
   1d048:	d151      	bne.n	1d0ee <_ZN4Node21SendClusterInfoUpdateEP10ConnectionP27connPacketClusterInfoUpdate+0xfa>
//			logt("HANDSHAKE", "TO NODE %u Adding to clusterSize change:%d, id:%x, hops:%d", cm->connections[i]->partnerId, packet->payload.clusterSizeChange, packet->payload.newClusterId, packet->payload.hopsToSink);

			currentPacket->payload.clusterSizeChange += packet->payload.clusterSizeChange;
   1d04a:	1c27      	adds	r7, r4, #0
   1d04c:	7aaa      	ldrb	r2, [r5, #10]
   1d04e:	7a69      	ldrb	r1, [r5, #9]
   1d050:	0213      	lsls	r3, r2, #8
   1d052:	430b      	orrs	r3, r1
   1d054:	1c1a      	adds	r2, r3, #0
   1d056:	375e      	adds	r7, #94	; 0x5e
   1d058:	37ff      	adds	r7, #255	; 0xff
   1d05a:	7abb      	ldrb	r3, [r7, #10]
   1d05c:	7a79      	ldrb	r1, [r7, #9]
   1d05e:	021b      	lsls	r3, r3, #8
   1d060:	430b      	orrs	r3, r1
   1d062:	189b      	adds	r3, r3, r2
   1d064:	1c22      	adds	r2, r4, #0
   1d066:	3267      	adds	r2, #103	; 0x67
   1d068:	32ff      	adds	r2, #255	; 0xff
   1d06a:	b29b      	uxth	r3, r3
   1d06c:	7013      	strb	r3, [r2, #0]
   1d06e:	0a1b      	lsrs	r3, r3, #8
   1d070:	7053      	strb	r3, [r2, #1]
			currentPacket->payload.newClusterId = packet->payload.newClusterId; //TODO: we could intelligently choose our clusterID
   1d072:	79aa      	ldrb	r2, [r5, #6]
   1d074:	796b      	ldrb	r3, [r5, #5]
   1d076:	0212      	lsls	r2, r2, #8
   1d078:	431a      	orrs	r2, r3
   1d07a:	79eb      	ldrb	r3, [r5, #7]
   1d07c:	041b      	lsls	r3, r3, #16
   1d07e:	4313      	orrs	r3, r2
   1d080:	1c1a      	adds	r2, r3, #0
   1d082:	7a2b      	ldrb	r3, [r5, #8]
   1d084:	061b      	lsls	r3, r3, #24
   1d086:	4313      	orrs	r3, r2
   1d088:	1c22      	adds	r2, r4, #0
   1d08a:	3263      	adds	r2, #99	; 0x63
   1d08c:	32ff      	adds	r2, #255	; 0xff
   1d08e:	0a19      	lsrs	r1, r3, #8
   1d090:	7013      	strb	r3, [r2, #0]
   1d092:	7051      	strb	r1, [r2, #1]
   1d094:	0c19      	lsrs	r1, r3, #16
   1d096:	0e1b      	lsrs	r3, r3, #24
   1d098:	7091      	strb	r1, [r2, #2]
   1d09a:	70d3      	strb	r3, [r2, #3]
			currentPacket->payload.hopsToSink = cm->GetHopsToShortestSink(cm->connections[i]);
   1d09c:	1c21      	adds	r1, r4, #0
   1d09e:	f002 fdc7 	bl	1fc30 <_ZN17ConnectionManager21GetHopsToShortestSinkEP10Connection>

			//Check if our connection partner has a bigger cluster on his side, if yes, hand over the connection master bit if we have it
			if(
   1d0a2:	2182      	movs	r1, #130	; 0x82
					cm->connections[i]->connectionMasterBit
   1d0a4:	9a01      	ldr	r2, [sp, #4]
		if(currentPacket->header.messageType == MESSAGE_TYPE_CLUSTER_INFO_UPDATE){
//			logt("HANDSHAKE", "TO NODE %u Adding to clusterSize change:%d, id:%x, hops:%d", cm->connections[i]->partnerId, packet->payload.clusterSizeChange, packet->payload.newClusterId, packet->payload.hopsToSink);

			currentPacket->payload.clusterSizeChange += packet->payload.clusterSizeChange;
			currentPacket->payload.newClusterId = packet->payload.newClusterId; //TODO: we could intelligently choose our clusterID
			currentPacket->payload.hopsToSink = cm->GetHopsToShortestSink(cm->connections[i]);
   1d0a6:	3469      	adds	r4, #105	; 0x69

			//Check if our connection partner has a bigger cluster on his side, if yes, hand over the connection master bit if we have it
			if(
					cm->connections[i]->connectionMasterBit
   1d0a8:	6833      	ldr	r3, [r6, #0]
		if(currentPacket->header.messageType == MESSAGE_TYPE_CLUSTER_INFO_UPDATE){
//			logt("HANDSHAKE", "TO NODE %u Adding to clusterSize change:%d, id:%x, hops:%d", cm->connections[i]->partnerId, packet->payload.clusterSizeChange, packet->payload.newClusterId, packet->payload.hopsToSink);

			currentPacket->payload.clusterSizeChange += packet->payload.clusterSizeChange;
			currentPacket->payload.newClusterId = packet->payload.newClusterId; //TODO: we could intelligently choose our clusterID
			currentPacket->payload.hopsToSink = cm->GetHopsToShortestSink(cm->connections[i]);
   1d0aa:	34ff      	adds	r4, #255	; 0xff
   1d0ac:	b280      	uxth	r0, r0
   1d0ae:	7020      	strb	r0, [r4, #0]

			//Check if our connection partner has a bigger cluster on his side, if yes, hand over the connection master bit if we have it
			if(
					cm->connections[i]->connectionMasterBit
   1d0b0:	58d3      	ldr	r3, [r2, r3]
		if(currentPacket->header.messageType == MESSAGE_TYPE_CLUSTER_INFO_UPDATE){
//			logt("HANDSHAKE", "TO NODE %u Adding to clusterSize change:%d, id:%x, hops:%d", cm->connections[i]->partnerId, packet->payload.clusterSizeChange, packet->payload.newClusterId, packet->payload.hopsToSink);

			currentPacket->payload.clusterSizeChange += packet->payload.clusterSizeChange;
			currentPacket->payload.newClusterId = packet->payload.newClusterId; //TODO: we could intelligently choose our clusterID
			currentPacket->payload.hopsToSink = cm->GetHopsToShortestSink(cm->connections[i]);
   1d0b2:	0a00      	lsrs	r0, r0, #8
   1d0b4:	7060      	strb	r0, [r4, #1]

			//Check if our connection partner has a bigger cluster on his side, if yes, hand over the connection master bit if we have it
			if(
   1d0b6:	0089      	lsls	r1, r1, #2
   1d0b8:	5c5a      	ldrb	r2, [r3, r1]
   1d0ba:	2a00      	cmp	r2, #0
   1d0bc:	d106      	bne.n	1d0cc <_ZN4Node21SendClusterInfoUpdateEP10ConnectionP27connPacketClusterInfoUpdate+0xd8>

//Saves a cluster update or all connections (except the one that caused it)
//This update will then be sent by a connection as soon as the connection is ready (handshakeDone)
void Node::SendClusterInfoUpdate(Connection* ignoreConnection, connPacketClusterInfoUpdate* packet)
{
	for(int i=0; i<Config->meshMaxConnections; i++){
   1d0be:	9b00      	ldr	r3, [sp, #0]
   1d0c0:	3301      	adds	r3, #1
   1d0c2:	e79d      	b.n	1d000 <_ZN4Node21SendClusterInfoUpdateEP10ConnectionP27connPacketClusterInfoUpdate+0xc>
//			logt("HANDSHAKE", "TO NODE %u clusterSize change:%d, id:%x, hops:%d", cm->connections[i]->partnerId,  packet->payload.clusterSizeChange, packet->payload.newClusterId, packet->payload.hopsToSink);
			memcpy((u8*)currentPacket, (u8*)packet, sizeof(connPacketClusterInfoUpdate));
		}
	}
	//TODO: If we call fillTransmitBuffers after a timeout, they would accumulate more,...
	cm->fillTransmitBuffers();
   1d0c4:	f002 fe10 	bl	1fce8 <_ZN17ConnectionManager19fillTransmitBuffersEv>
}
   1d0c8:	b005      	add	sp, #20
   1d0ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
			currentPacket->payload.hopsToSink = cm->GetHopsToShortestSink(cm->connections[i]);

			//Check if our connection partner has a bigger cluster on his side, if yes, hand over the connection master bit if we have it
			if(
					cm->connections[i]->connectionMasterBit
					&& cm->connections[i]->connectedClusterSize > (clusterSize - cm->connections[i]->connectedClusterSize)
   1d0cc:	2284      	movs	r2, #132	; 0x84
   1d0ce:	0092      	lsls	r2, r2, #2
   1d0d0:	5e98      	ldrsh	r0, [r3, r2]
   1d0d2:	9a02      	ldr	r2, [sp, #8]
   1d0d4:	3278      	adds	r2, #120	; 0x78
   1d0d6:	2400      	movs	r4, #0
   1d0d8:	5f12      	ldrsh	r2, [r2, r4]
   1d0da:	1a12      	subs	r2, r2, r0
   1d0dc:	4290      	cmp	r0, r2
   1d0de:	ddee      	ble.n	1d0be <_ZN4Node21SendClusterInfoUpdateEP10ConnectionP27connPacketClusterInfoUpdate+0xca>
			){
				cm->connections[i]->connectionMasterBit = 0;
   1d0e0:	2200      	movs	r2, #0
   1d0e2:	545a      	strb	r2, [r3, r1]
				currentPacket->payload.connectionMasterBitHandover = 1;
   1d0e4:	7b7b      	ldrb	r3, [r7, #13]
   1d0e6:	3201      	adds	r2, #1
   1d0e8:	4313      	orrs	r3, r2
   1d0ea:	737b      	strb	r3, [r7, #13]
   1d0ec:	e7e7      	b.n	1d0be <_ZN4Node21SendClusterInfoUpdateEP10ConnectionP27connPacketClusterInfoUpdate+0xca>
			}

		//If no other clusterUpdate message is waiting to be sent
		} else {
//			logt("HANDSHAKE", "TO NODE %u clusterSize change:%d, id:%x, hops:%d", cm->connections[i]->partnerId,  packet->payload.clusterSizeChange, packet->payload.newClusterId, packet->payload.hopsToSink);
			memcpy((u8*)currentPacket, (u8*)packet, sizeof(connPacketClusterInfoUpdate));
   1d0ee:	1c20      	adds	r0, r4, #0
   1d0f0:	305e      	adds	r0, #94	; 0x5e
   1d0f2:	1c29      	adds	r1, r5, #0
   1d0f4:	220e      	movs	r2, #14
   1d0f6:	30ff      	adds	r0, #255	; 0xff
   1d0f8:	f004 fa8c 	bl	21614 <memcpy>
   1d0fc:	e7df      	b.n	1d0be <_ZN4Node21SendClusterInfoUpdateEP10ConnectionP27connPacketClusterInfoUpdate+0xca>
   1d0fe:	46c0      	nop			; (mov r8, r8)
   1d100:	200033d0 	.word	0x200033d0

0001d104 <_ZN4Node20DisconnectionHandlerEP10Connection>:
	//We are leaving the discoveryState::CONNECTING state
	ChangeState(discoveryState::DISCOVERY);
}

void Node::DisconnectionHandler(Connection* connection)
{
   1d104:	b5f0      	push	{r4, r5, r6, r7, lr}
	this->persistentConfig.connectionLossCounter++;
   1d106:	8f04      	ldrh	r4, [r0, #56]	; 0x38
	//We are leaving the discoveryState::CONNECTING state
	ChangeState(discoveryState::DISCOVERY);
}

void Node::DisconnectionHandler(Connection* connection)
{
   1d108:	b087      	sub	sp, #28
	this->persistentConfig.connectionLossCounter++;
   1d10a:	3401      	adds	r4, #1
   1d10c:	b2a4      	uxth	r4, r4
   1d10e:	8704      	strh	r4, [r0, #56]	; 0x38

	//If the handshake was already done, this node was part of our cluster
	//If the local host terminated the connection, we do not count it as a cluster Size change
	if (
   1d110:	7a8b      	ldrb	r3, [r1, #10]
	//We are leaving the discoveryState::CONNECTING state
	ChangeState(discoveryState::DISCOVERY);
}

void Node::DisconnectionHandler(Connection* connection)
{
   1d112:	1c05      	adds	r5, r0, #0
   1d114:	1c0e      	adds	r6, r1, #0
	this->persistentConfig.connectionLossCounter++;

	//If the handshake was already done, this node was part of our cluster
	//If the local host terminated the connection, we do not count it as a cluster Size change
	if (
   1d116:	2b03      	cmp	r3, #3
   1d118:	d965      	bls.n	1d1e6 <_ZN4Node20DisconnectionHandlerEP10Connection+0xe2>
		connection->connectionStateBeforeDisconnection >= Connection::ConnectionState::HANDSHAKE_DONE
	){
		//CASE 1: if our partner has the connection master bit, we must dissolve
		//It may happen that the connection master bit was just passed over and that neither node has it
		//This will result in two clusters dissolving
		if (!connection->connectionMasterBit)
   1d11a:	2382      	movs	r3, #130	; 0x82
   1d11c:	009b      	lsls	r3, r3, #2
   1d11e:	5cc9      	ldrb	r1, [r1, r3]
   1d120:	3308      	adds	r3, #8
   1d122:	2900      	cmp	r1, #0
   1d124:	d12f      	bne.n	1d186 <_ZN4Node20DisconnectionHandlerEP10Connection+0x82>
		{
			this->clusterId = GenerateClusterID();

//			logt("HANDSHAKE", "ClusterSize Change from %d to %d", this->clusterSize, this->clusterSize - connection->connectedClusterSize);

			this->clusterSize -= connection->connectedClusterSize;
   1d126:	1c02      	adds	r2, r0, #0

//Generates a new clusterID by using connectionLoss and the unique id of the node
clusterID Node::GenerateClusterID(void)
{
	//Combine connection loss and nodeId to generate a unique cluster id
	clusterID newId = this->persistentConfig.nodeId + (this->persistentConfig.connectionLossCounter << 16);
   1d128:	8cc7      	ldrh	r7, [r0, #38]	; 0x26
   1d12a:	0424      	lsls	r4, r4, #16
   1d12c:	193c      	adds	r4, r7, r4
		//CASE 1: if our partner has the connection master bit, we must dissolve
		//It may happen that the connection master bit was just passed over and that neither node has it
		//This will result in two clusters dissolving
		if (!connection->connectionMasterBit)
		{
			this->clusterId = GenerateClusterID();
   1d12e:	67c4      	str	r4, [r0, #124]	; 0x7c

//			logt("HANDSHAKE", "ClusterSize Change from %d to %d", this->clusterSize, this->clusterSize - connection->connectedClusterSize);

			this->clusterSize -= connection->connectedClusterSize;
   1d130:	5af3      	ldrh	r3, [r6, r3]
   1d132:	3278      	adds	r2, #120	; 0x78
   1d134:	9301      	str	r3, [sp, #4]
   1d136:	8813      	ldrh	r3, [r2, #0]
   1d138:	9801      	ldr	r0, [sp, #4]
   1d13a:	1a1b      	subs	r3, r3, r0
   1d13c:	8013      	strh	r3, [r2, #0]

			//Inform the rest of the cluster of our new ID and size
			connPacketClusterInfoUpdate packet;
			memset((u8*)&packet, 0x00, sizeof(connPacketClusterInfoUpdate));
   1d13e:	a802      	add	r0, sp, #8
   1d140:	220e      	movs	r2, #14
   1d142:	f004 fa84 	bl	2164e <memset>

			packet.header.messageType = MESSAGE_TYPE_CLUSTER_INFO_UPDATE;
   1d146:	ab02      	add	r3, sp, #8
   1d148:	781a      	ldrb	r2, [r3, #0]
   1d14a:	2301      	movs	r3, #1
   1d14c:	4013      	ands	r3, r2
   1d14e:	222e      	movs	r2, #46	; 0x2e
   1d150:	4313      	orrs	r3, r2
   1d152:	aa02      	add	r2, sp, #8
   1d154:	7013      	strb	r3, [r2, #0]
			packet.header.sender = this->persistentConfig.nodeId;
			packet.header.receiver = NODE_ID_BROADCAST;

			packet.payload.newClusterId = this->clusterId;
   1d156:	1c13      	adds	r3, r2, #0
			//Inform the rest of the cluster of our new ID and size
			connPacketClusterInfoUpdate packet;
			memset((u8*)&packet, 0x00, sizeof(connPacketClusterInfoUpdate));

			packet.header.messageType = MESSAGE_TYPE_CLUSTER_INFO_UPDATE;
			packet.header.sender = this->persistentConfig.nodeId;
   1d158:	7057      	strb	r7, [r2, #1]
   1d15a:	0a3f      	lsrs	r7, r7, #8
			packet.header.receiver = NODE_ID_BROADCAST;

			packet.payload.newClusterId = this->clusterId;
   1d15c:	7154      	strb	r4, [r2, #5]
			//Inform the rest of the cluster of our new ID and size
			connPacketClusterInfoUpdate packet;
			memset((u8*)&packet, 0x00, sizeof(connPacketClusterInfoUpdate));

			packet.header.messageType = MESSAGE_TYPE_CLUSTER_INFO_UPDATE;
			packet.header.sender = this->persistentConfig.nodeId;
   1d15e:	7097      	strb	r7, [r2, #2]
			packet.header.receiver = NODE_ID_BROADCAST;

			packet.payload.newClusterId = this->clusterId;
   1d160:	0a22      	lsrs	r2, r4, #8
   1d162:	719a      	strb	r2, [r3, #6]
   1d164:	0c22      	lsrs	r2, r4, #16
   1d166:	71da      	strb	r2, [r3, #7]
			packet.payload.clusterSizeChange = -connection->connectedClusterSize;
   1d168:	2209      	movs	r2, #9

			packet.header.messageType = MESSAGE_TYPE_CLUSTER_INFO_UPDATE;
			packet.header.sender = this->persistentConfig.nodeId;
			packet.header.receiver = NODE_ID_BROADCAST;

			packet.payload.newClusterId = this->clusterId;
   1d16a:	0e24      	lsrs	r4, r4, #24
   1d16c:	721c      	strb	r4, [r3, #8]
			packet.payload.clusterSizeChange = -connection->connectedClusterSize;
   1d16e:	9b01      	ldr	r3, [sp, #4]
   1d170:	a902      	add	r1, sp, #8
   1d172:	425b      	negs	r3, r3
   1d174:	1852      	adds	r2, r2, r1
   1d176:	b29b      	uxth	r3, r3
   1d178:	7013      	strb	r3, [r2, #0]
   1d17a:	0a1b      	lsrs	r3, r3, #8
   1d17c:	7053      	strb	r3, [r2, #1]

			SendClusterInfoUpdate(connection, &packet);
   1d17e:	1c28      	adds	r0, r5, #0
   1d180:	1c31      	adds	r1, r6, #0
   1d182:	aa02      	add	r2, sp, #8
   1d184:	e02d      	b.n	1d1e2 <_ZN4Node20DisconnectionHandlerEP10Connection+0xde>
		//CASE 2: If we have the master bit, we keep our clusterID (happens if we are the biggest cluster)
		else
		{
//			logt("HANDSHAKE", "ClusterSize Change from %d to %d", this->clusterSize, this->clusterSize - connection->connectedClusterSize);

			this->clusterSize -= connection->connectedClusterSize;
   1d186:	1c02      	adds	r2, r0, #0
   1d188:	3278      	adds	r2, #120	; 0x78
   1d18a:	5af4      	ldrh	r4, [r6, r3]
   1d18c:	8813      	ldrh	r3, [r2, #0]

			// Inform the rest of the cluster of our new size
			connPacketClusterInfoUpdate packet;
			memset((u8*)&packet, 0x00, sizeof(connPacketClusterInfoUpdate));
   1d18e:	2100      	movs	r1, #0
		//CASE 2: If we have the master bit, we keep our clusterID (happens if we are the biggest cluster)
		else
		{
//			logt("HANDSHAKE", "ClusterSize Change from %d to %d", this->clusterSize, this->clusterSize - connection->connectedClusterSize);

			this->clusterSize -= connection->connectedClusterSize;
   1d190:	1b1b      	subs	r3, r3, r4
   1d192:	8013      	strh	r3, [r2, #0]

			// Inform the rest of the cluster of our new size
			connPacketClusterInfoUpdate packet;
			memset((u8*)&packet, 0x00, sizeof(connPacketClusterInfoUpdate));
   1d194:	a802      	add	r0, sp, #8
   1d196:	220e      	movs	r2, #14
   1d198:	f004 fa59 	bl	2164e <memset>

			packet.header.messageType = MESSAGE_TYPE_CLUSTER_INFO_UPDATE;
   1d19c:	232e      	movs	r3, #46	; 0x2e
   1d19e:	aa02      	add	r2, sp, #8
   1d1a0:	7013      	strb	r3, [r2, #0]
			packet.header.sender = this->persistentConfig.nodeId;
   1d1a2:	1c13      	adds	r3, r2, #0
   1d1a4:	1dea      	adds	r2, r5, #7
   1d1a6:	7fd2      	ldrb	r2, [r2, #31]
			packet.header.receiver = NODE_ID_BROADCAST;

			packet.payload.newClusterId = connection->connectedClusterId;
			packet.payload.clusterSizeChange = -connection->connectedClusterSize;

			SendClusterInfoUpdate(connection, &packet);
   1d1a8:	1c28      	adds	r0, r5, #0
			// Inform the rest of the cluster of our new size
			connPacketClusterInfoUpdate packet;
			memset((u8*)&packet, 0x00, sizeof(connPacketClusterInfoUpdate));

			packet.header.messageType = MESSAGE_TYPE_CLUSTER_INFO_UPDATE;
			packet.header.sender = this->persistentConfig.nodeId;
   1d1aa:	705a      	strb	r2, [r3, #1]
   1d1ac:	1c2a      	adds	r2, r5, #0
   1d1ae:	3208      	adds	r2, #8
   1d1b0:	7fd2      	ldrb	r2, [r2, #31]
			packet.header.receiver = NODE_ID_BROADCAST;

			packet.payload.newClusterId = connection->connectedClusterId;
			packet.payload.clusterSizeChange = -connection->connectedClusterSize;
   1d1b2:	4264      	negs	r4, r4
			// Inform the rest of the cluster of our new size
			connPacketClusterInfoUpdate packet;
			memset((u8*)&packet, 0x00, sizeof(connPacketClusterInfoUpdate));

			packet.header.messageType = MESSAGE_TYPE_CLUSTER_INFO_UPDATE;
			packet.header.sender = this->persistentConfig.nodeId;
   1d1b4:	709a      	strb	r2, [r3, #2]
			packet.header.receiver = NODE_ID_BROADCAST;

			packet.payload.newClusterId = connection->connectedClusterId;
   1d1b6:	2283      	movs	r2, #131	; 0x83
   1d1b8:	0092      	lsls	r2, r2, #2
   1d1ba:	5cb2      	ldrb	r2, [r6, r2]
   1d1bc:	ab02      	add	r3, sp, #8
   1d1be:	715a      	strb	r2, [r3, #5]
   1d1c0:	2283      	movs	r2, #131	; 0x83
   1d1c2:	0092      	lsls	r2, r2, #2
   1d1c4:	18b2      	adds	r2, r6, r2
   1d1c6:	7851      	ldrb	r1, [r2, #1]
			packet.payload.clusterSizeChange = -connection->connectedClusterSize;
   1d1c8:	b2a4      	uxth	r4, r4

			packet.header.messageType = MESSAGE_TYPE_CLUSTER_INFO_UPDATE;
			packet.header.sender = this->persistentConfig.nodeId;
			packet.header.receiver = NODE_ID_BROADCAST;

			packet.payload.newClusterId = connection->connectedClusterId;
   1d1ca:	7199      	strb	r1, [r3, #6]
   1d1cc:	7891      	ldrb	r1, [r2, #2]
   1d1ce:	78d2      	ldrb	r2, [r2, #3]
   1d1d0:	71d9      	strb	r1, [r3, #7]
   1d1d2:	721a      	strb	r2, [r3, #8]
			packet.payload.clusterSizeChange = -connection->connectedClusterSize;
   1d1d4:	2309      	movs	r3, #9

			SendClusterInfoUpdate(connection, &packet);
   1d1d6:	1c31      	adds	r1, r6, #0
			packet.header.messageType = MESSAGE_TYPE_CLUSTER_INFO_UPDATE;
			packet.header.sender = this->persistentConfig.nodeId;
			packet.header.receiver = NODE_ID_BROADCAST;

			packet.payload.newClusterId = connection->connectedClusterId;
			packet.payload.clusterSizeChange = -connection->connectedClusterSize;
   1d1d8:	aa02      	add	r2, sp, #8
   1d1da:	189b      	adds	r3, r3, r2
   1d1dc:	701c      	strb	r4, [r3, #0]
   1d1de:	0a24      	lsrs	r4, r4, #8
   1d1e0:	705c      	strb	r4, [r3, #1]

			SendClusterInfoUpdate(connection, &packet);
   1d1e2:	f7ff ff07 	bl	1cff4 <_ZN4Node21SendClusterInfoUpdateEP10ConnectionP27connPacketClusterInfoUpdate>
	}

//	uart("CLUSTER", "{\"type\":\"cluster_disconnect\",\"size\":%d}" SEP, clusterSize);

	//In either case, we must update our advertising packet
	UpdateJoinMePacket();
   1d1e6:	1c28      	adds	r0, r5, #0
   1d1e8:	f000 fde0 	bl	1ddac <_ZN4Node18UpdateJoinMePacketEv>

	//Go to discovery mode, and force high mode
	noNodesFoundCounter = 0;
   1d1ec:	1c2b      	adds	r3, r5, #0
   1d1ee:	2200      	movs	r2, #0
   1d1f0:	3376      	adds	r3, #118	; 0x76
   1d1f2:	701a      	strb	r2, [r3, #0]

	//At this point we can start discovery again if we are in a stable mesh
	//That has discovery disabled. IMPORTANT: Do not change states if we are in Handshake
	if(currentDiscoveryState == discoveryState::DISCOVERY_OFF){
   1d1f4:	3b22      	subs	r3, #34	; 0x22
   1d1f6:	781b      	ldrb	r3, [r3, #0]
   1d1f8:	2b0a      	cmp	r3, #10
   1d1fa:	d103      	bne.n	1d204 <_ZN4Node20DisconnectionHandlerEP10Connection+0x100>
		ChangeState(discoveryState::DISCOVERY);
   1d1fc:	1c28      	adds	r0, r5, #0
   1d1fe:	2102      	movs	r1, #2
   1d200:	f000 fe20 	bl	1de44 <_ZN4Node11ChangeStateE14discoveryState>
	}
}
   1d204:	b007      	add	sp, #28
   1d206:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001d208 <_ZThn4_N4Node20DisconnectionHandlerEP10Connection>:

		//Methods of ConnectionManagerCallback
		void DisconnectionHandler(Connection* connection);
   1d208:	b408      	push	{r3}
   1d20a:	4b02      	ldr	r3, [pc, #8]	; (1d214 <_ZThn4_N4Node20DisconnectionHandlerEP10Connection+0xc>)
   1d20c:	469c      	mov	ip, r3
   1d20e:	3804      	subs	r0, #4
   1d210:	bc08      	pop	{r3}
   1d212:	4760      	bx	ip
   1d214:	0001d105 	.word	0x0001d105

0001d218 <sd_ble_gap_adv_data_set.lto_priv.63>:
 * @retval ::NRF_ERROR_INVALID_DATA Invalid data type(s) supplied, check the advertising data format specification.
 * @retval ::NRF_ERROR_INVALID_LENGTH Invalid data length(s) supplied.
 * @retval ::NRF_ERROR_NOT_SUPPORTED Unsupported data type.
 * @retval ::BLE_ERROR_GAP_UUID_LIST_MISMATCH Invalid UUID list supplied.
 */
SVCALL(SD_BLE_GAP_ADV_DATA_SET, uint32_t, sd_ble_gap_adv_data_set(uint8_t const *p_data, uint8_t dlen, uint8_t const *p_sr_data, uint8_t srdlen));
   1d218:	df72      	svc	114	; 0x72
   1d21a:	4770      	bx	lr

0001d21c <_ZN21AdvertisingController19SetAdvertisingStateE8advState>:
		return true;
	}
}

void AdvertisingController::SetAdvertisingState(advState newState)
{
   1d21c:	b570      	push	{r4, r5, r6, lr}
	if (newState == advertisingState)
   1d21e:	4d19      	ldr	r5, [pc, #100]	; (1d284 <_ZN21AdvertisingController19SetAdvertisingStateE8advState+0x68>)
		return true;
	}
}

void AdvertisingController::SetAdvertisingState(advState newState)
{
   1d220:	1c04      	adds	r4, r0, #0
	if (newState == advertisingState)
   1d222:	882b      	ldrh	r3, [r5, #0]
   1d224:	4298      	cmp	r0, r3
   1d226:	d02c      	beq.n	1d282 <_ZN21AdvertisingController19SetAdvertisingStateE8advState+0x66>
		return;

	u32 err;

	//Stop if it should be stopped or because it is currently running
	if (advertisingState != ADV_STATE_OFF)
   1d228:	2b00      	cmp	r3, #0
   1d22a:	d001      	beq.n	1d230 <_ZN21AdvertisingController19SetAdvertisingStateE8advState+0x14>
	{
		err = sd_ble_gap_adv_stop();
   1d22c:	f7ff fd90 	bl	1cd50 <sd_ble_gap_adv_stop>
		} else {
			//Was probably stopped before
		}
	}

	if (newState == ADV_STATE_HIGH)
   1d230:	2380      	movs	r3, #128	; 0x80
   1d232:	00db      	lsls	r3, r3, #3
   1d234:	429c      	cmp	r4, r3
   1d236:	d103      	bne.n	1d240 <_ZN21AdvertisingController19SetAdvertisingStateE8advState+0x24>
		currentAdvertisingParams.interval = Config->meshAdvertisingIntervalHigh;
   1d238:	f003 fdf6 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d23c:	8a42      	ldrh	r2, [r0, #18]
   1d23e:	e006      	b.n	1d24e <_ZN21AdvertisingController19SetAdvertisingStateE8advState+0x32>
	else if (newState == ADV_STATE_LOW)
   1d240:	23f0      	movs	r3, #240	; 0xf0
   1d242:	011b      	lsls	r3, r3, #4
   1d244:	429c      	cmp	r4, r3
   1d246:	d104      	bne.n	1d252 <_ZN21AdvertisingController19SetAdvertisingStateE8advState+0x36>
		currentAdvertisingParams.interval = Config->meshAdvertisingIntervalLow;
   1d248:	f003 fdee 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d24c:	8b02      	ldrh	r2, [r0, #24]
   1d24e:	4b0e      	ldr	r3, [pc, #56]	; (1d288 <_ZN21AdvertisingController19SetAdvertisingStateE8advState+0x6c>)
   1d250:	821a      	strh	r2, [r3, #16]

	//Check if the advertisement packet did not get updated before
	if(advertisingPacketAwaitingUpdate){
   1d252:	4e0e      	ldr	r6, [pc, #56]	; (1d28c <_ZN21AdvertisingController19SetAdvertisingStateE8advState+0x70>)
   1d254:	7833      	ldrb	r3, [r6, #0]
   1d256:	2b00      	cmp	r3, #0
   1d258:	d009      	beq.n	1d26e <_ZN21AdvertisingController19SetAdvertisingStateE8advState+0x52>
		err = sd_ble_gap_adv_data_set(currentAdvertisementPacket, currentAdvertisementPacketLength, NULL, 0);
   1d25a:	2200      	movs	r2, #0
   1d25c:	4b0c      	ldr	r3, [pc, #48]	; (1d290 <_ZN21AdvertisingController19SetAdvertisingStateE8advState+0x74>)
   1d25e:	480d      	ldr	r0, [pc, #52]	; (1d294 <_ZN21AdvertisingController19SetAdvertisingStateE8advState+0x78>)
   1d260:	7819      	ldrb	r1, [r3, #0]
   1d262:	1c13      	adds	r3, r2, #0
   1d264:	f7ff ffd8 	bl	1d218 <sd_ble_gap_adv_data_set.lto_priv.63>
		if(err == NRF_SUCCESS){
   1d268:	2800      	cmp	r0, #0
   1d26a:	d100      	bne.n	1d26e <_ZN21AdvertisingController19SetAdvertisingStateE8advState+0x52>
			advertisingPacketAwaitingUpdate = false;
   1d26c:	7030      	strb	r0, [r6, #0]
		}

	}

	//Start advertising if needed
	if (newState != ADV_STATE_OFF)
   1d26e:	2c00      	cmp	r4, #0
   1d270:	d006      	beq.n	1d280 <_ZN21AdvertisingController19SetAdvertisingStateE8advState+0x64>
	{
		err = sd_ble_gap_adv_start(&currentAdvertisingParams);
   1d272:	4805      	ldr	r0, [pc, #20]	; (1d288 <_ZN21AdvertisingController19SetAdvertisingStateE8advState+0x6c>)
   1d274:	f7ff fd6e 	bl	1cd54 <sd_ble_gap_adv_start>
		if(err == NRF_SUCCESS){
			logt("ADV", "Advertising started");
		} else {
			//Could not be started, ignore
			newState = ADV_STATE_OFF;
   1d278:	4243      	negs	r3, r0
   1d27a:	4158      	adcs	r0, r3
   1d27c:	4240      	negs	r0, r0
   1d27e:	4004      	ands	r4, r0
		}
	}

	advertisingState = newState;
   1d280:	802c      	strh	r4, [r5, #0]
}
   1d282:	bd70      	pop	{r4, r5, r6, pc}
   1d284:	20003588 	.word	0x20003588
   1d288:	20003524 	.word	0x20003524
   1d28c:	200033dc 	.word	0x200033dc
   1d290:	2000357c 	.word	0x2000357c
   1d294:	20003540 	.word	0x20003540

0001d298 <_ZN6Logger11getInstanceEv>:
	vector<string>::iterator logFilterIterator;

	char mhTraceBuffer[TRACE_BUFFER_SIZE] = { 0 };

public:
	static Logger& getInstance(){
   1d298:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		static Logger instance;
   1d29a:	2701      	movs	r7, #1
   1d29c:	4e0c      	ldr	r6, [pc, #48]	; (1d2d0 <_ZN6Logger11getInstanceEv+0x38>)
   1d29e:	4d0d      	ldr	r5, [pc, #52]	; (1d2d4 <_ZN6Logger11getInstanceEv+0x3c>)
   1d2a0:	6834      	ldr	r4, [r6, #0]
   1d2a2:	403c      	ands	r4, r7
   1d2a4:	d111      	bne.n	1d2ca <_ZN6Logger11getInstanceEv+0x32>
using namespace std;

Logger::errorLogEntry Logger::errorLog[NUM_ERROR_LOG_ENTRIES];
u8 Logger::errorLogPosition = 0;

Logger::Logger()
   1d2a6:	1c28      	adds	r0, r5, #0
   1d2a8:	4b0b      	ldr	r3, [pc, #44]	; (1d2d8 <_ZN6Logger11getInstanceEv+0x40>)
	pointer _M_start;
	pointer _M_finish;
	pointer _M_end_of_storage;

	_Vector_impl()
	: _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
   1d2aa:	606c      	str	r4, [r5, #4]
   1d2ac:	3308      	adds	r3, #8
   1d2ae:	60ac      	str	r4, [r5, #8]
   1d2b0:	60ec      	str	r4, [r5, #12]
      typedef typename __traits_type::difference_type 	difference_type;
      typedef typename __traits_type::reference 	reference;
      typedef typename __traits_type::pointer   	pointer;

      _GLIBCXX_CONSTEXPR __normal_iterator() _GLIBCXX_NOEXCEPT
      : _M_current(_Iterator()) { }
   1d2b2:	612c      	str	r4, [r5, #16]
   1d2b4:	3014      	adds	r0, #20
   1d2b6:	1c21      	adds	r1, r4, #0
   1d2b8:	220a      	movs	r2, #10
   1d2ba:	602b      	str	r3, [r5, #0]
   1d2bc:	f004 f9c7 	bl	2164e <memset>
   1d2c0:	4806      	ldr	r0, [pc, #24]	; (1d2dc <_ZN6Logger11getInstanceEv+0x44>)
   1d2c2:	77ac      	strb	r4, [r5, #30]
   1d2c4:	6037      	str	r7, [r6, #0]
   1d2c6:	f004 f932 	bl	2152e <atexit>
		return instance;
	}
   1d2ca:	1c28      	adds	r0, r5, #0
   1d2cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1d2ce:	46c0      	nop			; (mov r8, r8)
   1d2d0:	200033a0 	.word	0x200033a0
   1d2d4:	2000336c 	.word	0x2000336c
   1d2d8:	00022968 	.word	0x00022968
   1d2dc:	0001cfe5 	.word	0x0001cfe5

0001d2e0 <sd_ble_gattc_write.lto_priv.68>:
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
 * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
 * @retval ::NRF_ERROR_BUSY Procedure already in progress.
 * @retval ::BLE_ERROR_NO_TX_PACKETS No available application packets for this connection.
 */
SVCALL(SD_BLE_GATTC_WRITE, uint32_t, sd_ble_gattc_write(uint16_t conn_handle, ble_gattc_write_params_t const *p_write_params));
   1d2e0:	df98      	svc	152	; 0x98
   1d2e2:	4770      	bx	lr

0001d2e4 <sd_ble_gattc_characteristics_discover.lto_priv.115>:
 * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
 * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
 * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
 * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
 */
SVCALL(SD_BLE_GATTC_CHARACTERISTICS_DISCOVER, uint32_t, sd_ble_gattc_characteristics_discover(uint16_t conn_handle, ble_gattc_handle_range_t const *p_handle_range));
   1d2e4:	df92      	svc	146	; 0x92
   1d2e6:	4770      	bx	lr

0001d2e8 <sd_ble_gatts_sys_attr_set.lto_priv.116>:
 * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
 * @retval ::NRF_ERROR_INVALID_DATA Invalid data supplied, the data should be exactly the same as retrieved with @ref sd_ble_gatts_sys_attr_get.
 * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
 * @retval ::NRF_ERROR_BUSY The stack is busy. Retry at later time.
 */
SVCALL(SD_BLE_GATTS_SYS_ATTR_SET, uint32_t, sd_ble_gatts_sys_attr_set(uint16_t conn_handle, uint8_t const *p_sys_attr_data, uint16_t len, uint32_t flags));
   1d2e8:	dfa9      	svc	169	; 0xa9
   1d2ea:	4770      	bx	lr

0001d2ec <_ZN13GAPController19connectToPeripheralEP14ble_gap_addr_ttt.part.0.lto_priv.71>:

}


//Connect to a specific peripheral
bool GAPController::connectToPeripheral(ble_gap_addr_t* address, u16 connectionInterval, u16 timeout)
   1d2ec:	b5f0      	push	{r4, r5, r6, r7, lr}
{
	if(currentlyConnecting) return false;

	currentlyConnecting = true;
   1d2ee:	2501      	movs	r5, #1

}


//Connect to a specific peripheral
bool GAPController::connectToPeripheral(ble_gap_addr_t* address, u16 connectionInterval, u16 timeout)
   1d2f0:	b089      	sub	sp, #36	; 0x24
   1d2f2:	9201      	str	r2, [sp, #4]

	ble_gap_scan_params_t scan_params;
	ble_gap_conn_params_t conn_params;

	scan_params.selective = 0;
	scan_params.active = 0; /* No active scanning */
   1d2f4:	2202      	movs	r2, #2
//Connect to a specific peripheral
bool GAPController::connectToPeripheral(ble_gap_addr_t* address, u16 connectionInterval, u16 timeout)
{
	if(currentlyConnecting) return false;

	currentlyConnecting = true;
   1d2f6:	4b17      	ldr	r3, [pc, #92]	; (1d354 <_ZN13GAPController19connectToPeripheralEP14ble_gap_addr_ttt.part.0.lto_priv.71+0x68>)
	u32 err = 0;

	ble_gap_scan_params_t scan_params;
	ble_gap_conn_params_t conn_params;

	scan_params.selective = 0;
   1d2f8:	ac04      	add	r4, sp, #16
//Connect to a specific peripheral
bool GAPController::connectToPeripheral(ble_gap_addr_t* address, u16 connectionInterval, u16 timeout)
{
	if(currentlyConnecting) return false;

	currentlyConnecting = true;
   1d2fa:	701d      	strb	r5, [r3, #0]
	u32 err = 0;

	ble_gap_scan_params_t scan_params;
	ble_gap_conn_params_t conn_params;

	scan_params.selective = 0;
   1d2fc:	7823      	ldrb	r3, [r4, #0]

}


//Connect to a specific peripheral
bool GAPController::connectToPeripheral(ble_gap_addr_t* address, u16 connectionInterval, u16 timeout)
   1d2fe:	1c0e      	adds	r6, r1, #0

	ble_gap_scan_params_t scan_params;
	ble_gap_conn_params_t conn_params;

	scan_params.selective = 0;
	scan_params.active = 0; /* No active scanning */
   1d300:	4393      	bics	r3, r2
   1d302:	43ab      	bics	r3, r5

}


//Connect to a specific peripheral
bool GAPController::connectToPeripheral(ble_gap_addr_t* address, u16 connectionInterval, u16 timeout)
   1d304:	1c07      	adds	r7, r0, #0

	ble_gap_scan_params_t scan_params;
	ble_gap_conn_params_t conn_params;

	scan_params.selective = 0;
	scan_params.active = 0; /* No active scanning */
   1d306:	7023      	strb	r3, [r4, #0]
	scan_params.interval = Config->meshConnectingScanInterval;
   1d308:	f003 fd8e 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d30c:	8bc3      	ldrh	r3, [r0, #30]
   1d30e:	8123      	strh	r3, [r4, #8]
	scan_params.window = Config->meshConnectingScanWindow;
   1d310:	f003 fd8a 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d314:	8c03      	ldrh	r3, [r0, #32]
   1d316:	8163      	strh	r3, [r4, #10]
	scan_params.timeout = timeout;
   1d318:	466b      	mov	r3, sp
   1d31a:	889b      	ldrh	r3, [r3, #4]
   1d31c:	81a3      	strh	r3, [r4, #12]

	conn_params.min_conn_interval = connectionInterval;
   1d31e:	ab02      	add	r3, sp, #8
   1d320:	801e      	strh	r6, [r3, #0]
	conn_params.max_conn_interval = connectionInterval;
   1d322:	805e      	strh	r6, [r3, #2]
	conn_params.slave_latency = Config->meshPeripheralSlaveLatency;
   1d324:	f003 fd80 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d328:	8983      	ldrh	r3, [r0, #12]
   1d32a:	aa02      	add	r2, sp, #8
   1d32c:	8093      	strh	r3, [r2, #4]
	conn_params.conn_sup_timeout = Config->meshConnectionSupervisionTimeout;
   1d32e:	f003 fd7b 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d332:	89c3      	ldrh	r3, [r0, #14]
   1d334:	aa02      	add	r2, sp, #8

	//Connect to the peripheral
	err = sd_ble_gap_connect(address, &scan_params, &conn_params);
   1d336:	1c38      	adds	r0, r7, #0
   1d338:	1c21      	adds	r1, r4, #0
	scan_params.timeout = timeout;

	conn_params.min_conn_interval = connectionInterval;
	conn_params.max_conn_interval = connectionInterval;
	conn_params.slave_latency = Config->meshPeripheralSlaveLatency;
	conn_params.conn_sup_timeout = Config->meshConnectionSupervisionTimeout;
   1d33a:	80d3      	strh	r3, [r2, #6]

	//Connect to the peripheral
	err = sd_ble_gap_connect(address, &scan_params, &conn_params);
   1d33c:	f7ff fd12 	bl	1cd64 <sd_ble_gap_connect>
	if(err != NRF_SUCCESS){
		logt("ERROR", "GATT fail %d", err);
		//Just ignore it, the connection will not happen
		return false;
   1d340:	2300      	movs	r3, #0
	conn_params.slave_latency = Config->meshPeripheralSlaveLatency;
	conn_params.conn_sup_timeout = Config->meshConnectionSupervisionTimeout;

	//Connect to the peripheral
	err = sd_ble_gap_connect(address, &scan_params, &conn_params);
	if(err != NRF_SUCCESS){
   1d342:	4298      	cmp	r0, r3
   1d344:	d102      	bne.n	1d34c <_ZN13GAPController19connectToPeripheralEP14ble_gap_addr_ttt.part.0.lto_priv.71+0x60>
		//Just ignore it, the connection will not happen
		return false;
	}

	//Set scan state off. Connecting uses scan itself and deactivates the scan procedure
	ScanController::scanningState = SCAN_STATE_OFF;
   1d346:	4a04      	ldr	r2, [pc, #16]	; (1d358 <_ZN13GAPController19connectToPeripheralEP14ble_gap_addr_ttt.part.0.lto_priv.71+0x6c>)
   1d348:	8013      	strh	r3, [r2, #0]

	logt("CONN", "pairing");

	return true;
   1d34a:	1c2b      	adds	r3, r5, #0
}
   1d34c:	1c18      	adds	r0, r3, #0
   1d34e:	b009      	add	sp, #36	; 0x24
   1d350:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1d352:	46c0      	nop			; (mov r8, r8)
   1d354:	200033d4 	.word	0x200033d4
   1d358:	20003394 	.word	0x20003394

0001d35c <sd_ble_gap_sec_info_reply.lto_priv.117>:
 * @retval ::NRF_SUCCESS Successfully accepted security information.
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
 * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
 * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
 */
SVCALL(SD_BLE_GAP_SEC_INFO_REPLY, uint32_t, sd_ble_gap_sec_info_reply(uint16_t conn_handle, ble_gap_enc_info_t const *p_enc_info, ble_gap_irk_t const *p_id_info, ble_gap_sign_info_t const *p_sign_info));
   1d35c:	df86      	svc	134	; 0x86
   1d35e:	4770      	bx	lr

0001d360 <sd_ble_gap_encrypt.lto_priv.69>:
 * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
 * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
 * @retval ::BLE_ERROR_INVALID_ROLE Operation is not supported in the Peripheral role.
 * @retval ::NRF_ERROR_BUSY Procedure already in progress or not allowed at this time, wait for pending procedures to complete and retry.
 */
SVCALL(SD_BLE_GAP_ENCRYPT, uint32_t, sd_ble_gap_encrypt(uint16_t conn_handle, ble_gap_master_id_t const *p_master_id, ble_gap_enc_info_t const *p_enc_info));
   1d360:	df85      	svc	133	; 0x85
   1d362:	4770      	bx	lr

0001d364 <sd_ble_gap_disconnect.lto_priv.67>:
 * @retval ::NRF_SUCCESS The disconnection procedure has been started successfully.
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
 * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
 * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation (disconnection is already in progress).
 */
SVCALL(SD_BLE_GAP_DISCONNECT, uint32_t, sd_ble_gap_disconnect(uint16_t conn_handle, uint8_t hci_status_code));
   1d364:	df76      	svc	118	; 0x76
   1d366:	4770      	bx	lr

0001d368 <_ZN14ScanController12SetScanStateE9scanState>:
}


//Start scanning with the specified scanning parameters
void ScanController::SetScanState(scanState newState)
{
   1d368:	b570      	push	{r4, r5, r6, lr}
	u32 err = 0;
	if (newState == scanningState) return;
   1d36a:	4d17      	ldr	r5, [pc, #92]	; (1d3c8 <_ZN14ScanController12SetScanStateE9scanState+0x60>)
}


//Start scanning with the specified scanning parameters
void ScanController::SetScanState(scanState newState)
{
   1d36c:	1c04      	adds	r4, r0, #0
	u32 err = 0;
	if (newState == scanningState) return;
   1d36e:	882b      	ldrh	r3, [r5, #0]
   1d370:	4298      	cmp	r0, r3
   1d372:	d028      	beq.n	1d3c6 <_ZN14ScanController12SetScanStateE9scanState+0x5e>

	//Stop scanning to either leave it stopped or update it
	if (scanningState != SCAN_STATE_OFF)
   1d374:	2b00      	cmp	r3, #0
   1d376:	d001      	beq.n	1d37c <_ZN14ScanController12SetScanStateE9scanState+0x14>
	{
		err = sd_ble_gap_scan_stop();
   1d378:	f7ff fcfe 	bl	1cd78 <sd_ble_gap_scan_stop>
			//We'll just ignore NRF_ERROR_INVALID_STATE and hope that scanning is stopped
		}
		logt("C", "Scanning stopped");
	}

	if (newState == SCAN_STATE_HIGH)
   1d37c:	2380      	movs	r3, #128	; 0x80
   1d37e:	00db      	lsls	r3, r3, #3
   1d380:	429c      	cmp	r4, r3
   1d382:	d108      	bne.n	1d396 <_ZN14ScanController12SetScanStateE9scanState+0x2e>
	{
		currentScanParams.interval = Config->meshScanIntervalHigh;
   1d384:	f003 fd50 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d388:	4e10      	ldr	r6, [pc, #64]	; (1d3cc <_ZN14ScanController12SetScanStateE9scanState+0x64>)
   1d38a:	8a83      	ldrh	r3, [r0, #20]
   1d38c:	8133      	strh	r3, [r6, #8]
		currentScanParams.window = Config->meshScanWindowHigh;
   1d38e:	f003 fd4b 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d392:	8ac3      	ldrh	r3, [r0, #22]
   1d394:	e00b      	b.n	1d3ae <_ZN14ScanController12SetScanStateE9scanState+0x46>
	}
	else if (newState == SCAN_STATE_LOW)
   1d396:	23f0      	movs	r3, #240	; 0xf0
   1d398:	011b      	lsls	r3, r3, #4
   1d39a:	429c      	cmp	r4, r3
   1d39c:	d109      	bne.n	1d3b2 <_ZN14ScanController12SetScanStateE9scanState+0x4a>
	{
		currentScanParams.interval = Config->meshScanIntervalLow;
   1d39e:	f003 fd43 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d3a2:	4e0a      	ldr	r6, [pc, #40]	; (1d3cc <_ZN14ScanController12SetScanStateE9scanState+0x64>)
   1d3a4:	8b43      	ldrh	r3, [r0, #26]
   1d3a6:	8133      	strh	r3, [r6, #8]
		currentScanParams.window = Config->meshScanWindowLow;
   1d3a8:	f003 fd3e 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d3ac:	8b83      	ldrh	r3, [r0, #28]
   1d3ae:	8173      	strh	r3, [r6, #10]
   1d3b0:	e001      	b.n	1d3b6 <_ZN14ScanController12SetScanStateE9scanState+0x4e>
	}

	//FIXME: Add Saveguard. Because if we are currently in connecting state, we can not scan

	if (newState != SCAN_STATE_OFF)
   1d3b2:	2c00      	cmp	r4, #0
   1d3b4:	d006      	beq.n	1d3c4 <_ZN14ScanController12SetScanStateE9scanState+0x5c>
	{
		err = sd_ble_gap_scan_start(&currentScanParams);
   1d3b6:	4805      	ldr	r0, [pc, #20]	; (1d3cc <_ZN14ScanController12SetScanStateE9scanState+0x64>)
   1d3b8:	f7ff fce0 	bl	1cd7c <sd_ble_gap_scan_start>
		if(err == NRF_SUCCESS){
			logt("C", "Scanning started");
		} else {
			//Ignore all errors, scanning could not be started
			newState = SCAN_STATE_OFF;
   1d3bc:	4243      	negs	r3, r0
   1d3be:	4158      	adcs	r0, r3
   1d3c0:	4240      	negs	r0, r0
   1d3c2:	4004      	ands	r4, r0
		}
	}

	scanningState = newState;
   1d3c4:	802c      	strh	r4, [r5, #0]
}
   1d3c6:	bd70      	pop	{r4, r5, r6, pc}
   1d3c8:	20003394 	.word	0x20003394
   1d3cc:	200033c0 	.word	0x200033c0

0001d3d0 <HardFault_Handler>:
		}
	}

	//This is, where the program will get stuck in the case of a Hard fault
	void HardFault_Handler(void)
	{
   1d3d0:	b508      	push	{r3, lr}

		if(Config->debugMode) while(1){
   1d3d2:	f003 fd29 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d3d6:	78c3      	ldrb	r3, [r0, #3]
   1d3d8:	2b00      	cmp	r3, #0
   1d3da:	d00f      	beq.n	1d3fc <HardFault_Handler+0x2c>
#elif defined ( __GNUC__ )

static void __INLINE nrf_delay_us(uint32_t volatile number_of_us) __attribute__((always_inline));
static void __INLINE nrf_delay_us(uint32_t volatile number_of_us)
{
register uint32_t delay __ASM ("r0") = number_of_us;
   1d3dc:	4808      	ldr	r0, [pc, #32]	; (1d400 <HardFault_Handler+0x30>)
#endif
    " BNE 1b\n"
#ifdef NRF51
    ".syntax divided\n"
#endif
    : "+r" (delay));
   1d3de:	3801      	subs	r0, #1
   1d3e0:	46c0      	nop			; (mov r8, r8)
   1d3e2:	46c0      	nop			; (mov r8, r8)
   1d3e4:	46c0      	nop			; (mov r8, r8)
   1d3e6:	46c0      	nop			; (mov r8, r8)
   1d3e8:	46c0      	nop			; (mov r8, r8)
   1d3ea:	46c0      	nop			; (mov r8, r8)
   1d3ec:	46c0      	nop			; (mov r8, r8)
   1d3ee:	46c0      	nop			; (mov r8, r8)
   1d3f0:	46c0      	nop			; (mov r8, r8)
   1d3f2:	46c0      	nop			; (mov r8, r8)
   1d3f4:	46c0      	nop			; (mov r8, r8)
   1d3f6:	46c0      	nop			; (mov r8, r8)
   1d3f8:	d1f1      	bne.n	1d3de <HardFault_Handler+0xe>
   1d3fa:	e7ef      	b.n	1d3dc <HardFault_Handler+0xc>
			nrf_delay_us(50000);
		}
		else NVIC_SystemReset();
   1d3fc:	f003 fd06 	bl	20e0c <NVIC_SystemReset.lto_priv.72>
   1d400:	0000c350 	.word	0x0000c350

0001d404 <app_error_handler>:
volatile uint32_t keepPc;
volatile uint32_t keepInfo;

	//The app_error handler is called by all APP_ERROR_CHECK functions
	void app_error_handler(uint32_t error_code, uint32_t line_num, const uint8_t * p_file_name)
	{
   1d404:	b508      	push	{r3, lr}
		if(Config->debugMode) while(1){
   1d406:	f003 fd0f 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d40a:	78c3      	ldrb	r3, [r0, #3]
   1d40c:	2b00      	cmp	r3, #0
   1d40e:	d00f      	beq.n	1d430 <app_error_handler+0x2c>
#elif defined ( __GNUC__ )

static void __INLINE nrf_delay_us(uint32_t volatile number_of_us) __attribute__((always_inline));
static void __INLINE nrf_delay_us(uint32_t volatile number_of_us)
{
register uint32_t delay __ASM ("r0") = number_of_us;
   1d410:	4808      	ldr	r0, [pc, #32]	; (1d434 <app_error_handler+0x30>)
#endif
    " BNE 1b\n"
#ifdef NRF51
    ".syntax divided\n"
#endif
    : "+r" (delay));
   1d412:	3801      	subs	r0, #1
   1d414:	46c0      	nop			; (mov r8, r8)
   1d416:	46c0      	nop			; (mov r8, r8)
   1d418:	46c0      	nop			; (mov r8, r8)
   1d41a:	46c0      	nop			; (mov r8, r8)
   1d41c:	46c0      	nop			; (mov r8, r8)
   1d41e:	46c0      	nop			; (mov r8, r8)
   1d420:	46c0      	nop			; (mov r8, r8)
   1d422:	46c0      	nop			; (mov r8, r8)
   1d424:	46c0      	nop			; (mov r8, r8)
   1d426:	46c0      	nop			; (mov r8, r8)
   1d428:	46c0      	nop			; (mov r8, r8)
   1d42a:	46c0      	nop			; (mov r8, r8)
   1d42c:	d1f1      	bne.n	1d412 <app_error_handler+0xe>
   1d42e:	e7ef      	b.n	1d410 <app_error_handler+0xc>
			nrf_delay_us(50000);
		}

		else NVIC_SystemReset();
   1d430:	f003 fcec 	bl	20e0c <NVIC_SystemReset.lto_priv.72>
   1d434:	0000c350 	.word	0x0000c350

0001d438 <_ZN4Node23messageReceivedCallbackEP16connectionPacket>:
	//TODO: If we call fillTransmitBuffers after a timeout, they would accumulate more,...
	cm->fillTransmitBuffers();
}

void Node::messageReceivedCallback(connectionPacket* inPacket)
{
   1d438:	b5f0      	push	{r4, r5, r6, r7, lr}
	Connection* connection = cm->GetConnectionFromHandle(inPacket->connectionHandle);
   1d43a:	4d9b      	ldr	r5, [pc, #620]	; (1d6a8 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x270>)
	//TODO: If we call fillTransmitBuffers after a timeout, they would accumulate more,...
	cm->fillTransmitBuffers();
}

void Node::messageReceivedCallback(connectionPacket* inPacket)
{
   1d43c:	b091      	sub	sp, #68	; 0x44
   1d43e:	9003      	str	r0, [sp, #12]
   1d440:	9106      	str	r1, [sp, #24]
	Connection* connection = cm->GetConnectionFromHandle(inPacket->connectionHandle);
   1d442:	6828      	ldr	r0, [r5, #0]
   1d444:	8809      	ldrh	r1, [r1, #0]
   1d446:	f000 fb7d 	bl	1db44 <_ZN17ConnectionManager23GetConnectionFromHandleEt>
	u8* data = inPacket->data;
   1d44a:	9b06      	ldr	r3, [sp, #24]
	cm->fillTransmitBuffers();
}

void Node::messageReceivedCallback(connectionPacket* inPacket)
{
	Connection* connection = cm->GetConnectionFromHandle(inPacket->connectionHandle);
   1d44c:	9004      	str	r0, [sp, #16]
	u8* data = inPacket->data;
   1d44e:	685c      	ldr	r4, [r3, #4]
	u16 dataLength = inPacket->dataLength;
   1d450:	891b      	ldrh	r3, [r3, #8]
   1d452:	9305      	str	r3, [sp, #20]

	connPacketHeader* packetHeader = (connPacketHeader*) data;

	//If the packet is a handshake packet it will not be forwarded to the node but will be
	//handled in the connection. All other packets go here for further processing
	switch (packetHeader->messageType)
   1d454:	7823      	ldrb	r3, [r4, #0]
   1d456:	085b      	lsrs	r3, r3, #1
   1d458:	2b1f      	cmp	r3, #31
   1d45a:	d100      	bne.n	1d45e <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x26>
   1d45c:	e085      	b.n	1d56a <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x132>
   1d45e:	2b51      	cmp	r3, #81	; 0x51
   1d460:	d06c      	beq.n	1d53c <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x104>
   1d462:	2b17      	cmp	r3, #23
   1d464:	d000      	beq.n	1d468 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x30>
   1d466:	e0af      	b.n	1d5c8 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x190>
	{
		case MESSAGE_TYPE_CLUSTER_INFO_UPDATE:
			if (dataLength == SIZEOF_CONN_PACKET_CLUSTER_INFO_UPDATE)
   1d468:	9b05      	ldr	r3, [sp, #20]
   1d46a:	2b0e      	cmp	r3, #14
   1d46c:	d000      	beq.n	1d470 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x38>
   1d46e:	e0ab      	b.n	1d5c8 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x190>
//Handles incoming cluster info update
void Node::ReceiveClusterInfoUpdate(Connection* connection, connPacketClusterInfoUpdate* packet)
{
	//Prepare cluster update packet for other connections
	connPacketClusterInfoUpdate outPacket;
	memset((u8*)&outPacket, 0x00, sizeof(connPacketClusterInfoUpdate));
   1d470:	ad09      	add	r5, sp, #36	; 0x24
   1d472:	1c1a      	adds	r2, r3, #0
   1d474:	2100      	movs	r1, #0
   1d476:	1c28      	adds	r0, r5, #0
   1d478:	f004 f8e9 	bl	2164e <memset>

	outPacket.header.messageType = MESSAGE_TYPE_CLUSTER_INFO_UPDATE;
   1d47c:	2301      	movs	r3, #1
   1d47e:	782a      	ldrb	r2, [r5, #0]
	outPacket.header.receiver = NODE_ID_BROADCAST;
	outPacket.header.sender = persistentConfig.nodeId;

	outPacket.payload.clusterSizeChange = packet->payload.clusterSizeChange;
   1d480:	a906      	add	r1, sp, #24
{
	//Prepare cluster update packet for other connections
	connPacketClusterInfoUpdate outPacket;
	memset((u8*)&outPacket, 0x00, sizeof(connPacketClusterInfoUpdate));

	outPacket.header.messageType = MESSAGE_TYPE_CLUSTER_INFO_UPDATE;
   1d482:	4013      	ands	r3, r2
   1d484:	222e      	movs	r2, #46	; 0x2e
   1d486:	4313      	orrs	r3, r2
   1d488:	702b      	strb	r3, [r5, #0]
	outPacket.header.receiver = NODE_ID_BROADCAST;
	outPacket.header.sender = persistentConfig.nodeId;
   1d48a:	230d      	movs	r3, #13
   1d48c:	aa06      	add	r2, sp, #24
   1d48e:	189b      	adds	r3, r3, r2
   1d490:	9a03      	ldr	r2, [sp, #12]
   1d492:	3207      	adds	r2, #7
   1d494:	7fd2      	ldrb	r2, [r2, #31]
   1d496:	701a      	strb	r2, [r3, #0]
   1d498:	9a03      	ldr	r2, [sp, #12]
   1d49a:	3208      	adds	r2, #8
   1d49c:	7fd2      	ldrb	r2, [r2, #31]
   1d49e:	705a      	strb	r2, [r3, #1]

	outPacket.payload.clusterSizeChange = packet->payload.clusterSizeChange;
   1d4a0:	7aa3      	ldrb	r3, [r4, #10]
   1d4a2:	7a62      	ldrb	r2, [r4, #9]
   1d4a4:	021b      	lsls	r3, r3, #8
   1d4a6:	4313      	orrs	r3, r2
   1d4a8:	2215      	movs	r2, #21
   1d4aa:	1852      	adds	r2, r2, r1
   1d4ac:	0a19      	lsrs	r1, r3, #8
   1d4ae:	7013      	strb	r3, [r2, #0]
   1d4b0:	7051      	strb	r1, [r2, #1]

	//Update hops to sink
	//Another sink may have joined or left the network, update this
	//FIXME: race conditions can cause this to work incorrectly...

	if(packet->payload.clusterSizeChange != 0){
   1d4b2:	2b00      	cmp	r3, #0
   1d4b4:	d00c      	beq.n	1d4d0 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x98>
//		logt("HANDSHAKE", "ClusterSize Change from %d to %d", this->clusterSize, this->clusterSize + packet->payload.clusterSizeChange);
		this->clusterSize += packet->payload.clusterSizeChange;
   1d4b6:	9903      	ldr	r1, [sp, #12]
   1d4b8:	b29b      	uxth	r3, r3
   1d4ba:	3178      	adds	r1, #120	; 0x78
   1d4bc:	880a      	ldrh	r2, [r1, #0]
   1d4be:	189a      	adds	r2, r3, r2
   1d4c0:	800a      	strh	r2, [r1, #0]
		connection->connectedClusterSize += packet->payload.clusterSizeChange;
   1d4c2:	2184      	movs	r1, #132	; 0x84
   1d4c4:	9a04      	ldr	r2, [sp, #16]
   1d4c6:	0089      	lsls	r1, r1, #2
   1d4c8:	5a52      	ldrh	r2, [r2, r1]
   1d4ca:	189b      	adds	r3, r3, r2
   1d4cc:	9a04      	ldr	r2, [sp, #16]
   1d4ce:	5253      	strh	r3, [r2, r1]
	}

	connection->hopsToSink = packet->payload.hopsToSink > -1 ? packet->payload.hopsToSink + 1 : -1;
   1d4d0:	7b23      	ldrb	r3, [r4, #12]
   1d4d2:	7ae2      	ldrb	r2, [r4, #11]
   1d4d4:	021b      	lsls	r3, r3, #8
   1d4d6:	4313      	orrs	r3, r2
   1d4d8:	b21a      	sxth	r2, r3
   1d4da:	2a00      	cmp	r2, #0
   1d4dc:	db02      	blt.n	1d4e4 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0xac>
   1d4de:	3301      	adds	r3, #1
   1d4e0:	b29b      	uxth	r3, r3
   1d4e2:	e000      	b.n	1d4e6 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0xae>
   1d4e4:	4b71      	ldr	r3, [pc, #452]	; (1d6ac <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x274>)
   1d4e6:	4a72      	ldr	r2, [pc, #456]	; (1d6b0 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x278>)
   1d4e8:	9904      	ldr	r1, [sp, #16]
   1d4ea:	528b      	strh	r3, [r1, r2]

	this->clusterId = packet->payload.newClusterId;
   1d4ec:	79a2      	ldrb	r2, [r4, #6]
   1d4ee:	7960      	ldrb	r0, [r4, #5]
   1d4f0:	79e3      	ldrb	r3, [r4, #7]
   1d4f2:	0212      	lsls	r2, r2, #8
   1d4f4:	4302      	orrs	r2, r0
   1d4f6:	041b      	lsls	r3, r3, #16
   1d4f8:	4313      	orrs	r3, r2
   1d4fa:	1c1a      	adds	r2, r3, #0
   1d4fc:	7a23      	ldrb	r3, [r4, #8]
	outPacket.payload.newClusterId = packet->payload.newClusterId;
   1d4fe:	a906      	add	r1, sp, #24
		connection->connectedClusterSize += packet->payload.clusterSizeChange;
	}

	connection->hopsToSink = packet->payload.hopsToSink > -1 ? packet->payload.hopsToSink + 1 : -1;

	this->clusterId = packet->payload.newClusterId;
   1d500:	061b      	lsls	r3, r3, #24
   1d502:	4313      	orrs	r3, r2
   1d504:	9a03      	ldr	r2, [sp, #12]
   1d506:	67d3      	str	r3, [r2, #124]	; 0x7c
	outPacket.payload.newClusterId = packet->payload.newClusterId;
   1d508:	2211      	movs	r2, #17
   1d50a:	1852      	adds	r2, r2, r1
   1d50c:	0a19      	lsrs	r1, r3, #8
   1d50e:	7013      	strb	r3, [r2, #0]
   1d510:	7051      	strb	r1, [r2, #1]
   1d512:	0c19      	lsrs	r1, r3, #16
   1d514:	0e1b      	lsrs	r3, r3, #24
   1d516:	70d3      	strb	r3, [r2, #3]

	//Now look if our partner has passed over the connection master bit
	if(packet->payload.connectionMasterBitHandover){
   1d518:	2301      	movs	r3, #1
	}

	connection->hopsToSink = packet->payload.hopsToSink > -1 ? packet->payload.hopsToSink + 1 : -1;

	this->clusterId = packet->payload.newClusterId;
	outPacket.payload.newClusterId = packet->payload.newClusterId;
   1d51a:	7091      	strb	r1, [r2, #2]

	//Now look if our partner has passed over the connection master bit
	if(packet->payload.connectionMasterBitHandover){
   1d51c:	7b62      	ldrb	r2, [r4, #13]
   1d51e:	421a      	tst	r2, r3
   1d520:	d003      	beq.n	1d52a <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0xf2>
		connection->connectionMasterBit = 1;
   1d522:	2282      	movs	r2, #130	; 0x82
   1d524:	9904      	ldr	r1, [sp, #16]
   1d526:	0092      	lsls	r2, r2, #2
   1d528:	548b      	strb	r3, [r1, r2]
	}

	//hops to sink are updated in the send method
	//current cluster id is updated in the send method

	SendClusterInfoUpdate(connection, &outPacket);
   1d52a:	9803      	ldr	r0, [sp, #12]
   1d52c:	9904      	ldr	r1, [sp, #16]
   1d52e:	aa09      	add	r2, sp, #36	; 0x24
   1d530:	f7ff fd60 	bl	1cff4 <_ZN4Node21SendClusterInfoUpdateEP10ConnectionP27connPacketClusterInfoUpdate>

	//Log Cluster change to UART
//	uart("CLUSTER", "{\"type\":\"cluster_update\",\"size\":%d,\"newId\":%u,\"masterBit\":%u}" SEP, clusterSize, clusterId, packet->payload.connectionMasterBitHandover);

	//Update adverting packet
	this->UpdateJoinMePacket();
   1d534:	9803      	ldr	r0, [sp, #12]
   1d536:	f000 fc39 	bl	1ddac <_ZN4Node18UpdateJoinMePacketEv>
   1d53a:	e045      	b.n	1d5c8 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x190>
				//tracef("data is %u/%u/%u" EOL, packet->payload.data[0], packet->payload.data[1], packet->payload.data[2]);
			}
			break;

		case MESSAGE_TYPE_DATA_2:
			if (dataLength == SIZEOF_CONN_PACKET_DATA_2)
   1d53c:	9b05      	ldr	r3, [sp, #20]
   1d53e:	2b14      	cmp	r3, #20
   1d540:	d142      	bne.n	1d5c8 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x190>
u32 AdvertisingController::SetScanResponse(sizedData* payload){
	u32 err;

	scanHeader->manufacturer.len = 3 + payload->length;

	memcpy(currentScanResponsePacket + SIZEOF_SCAN_PACKET_HEADER, payload->data, payload->length);
   1d542:	4e5c      	ldr	r6, [pc, #368]	; (1d6b4 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x27c>)
}

u32 AdvertisingController::SetScanResponse(sizedData* payload){
	u32 err;

	scanHeader->manufacturer.len = 3 + payload->length;
   1d544:	4b5c      	ldr	r3, [pc, #368]	; (1d6b8 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x280>)

	memcpy(currentScanResponsePacket + SIZEOF_SCAN_PACKET_HEADER, payload->data, payload->length);
   1d546:	1c30      	adds	r0, r6, #0
			{
				connPacketData2* packet = (connPacketData2*) data;

				//Update our scan response with the data from this campaign
				this->UpdateScanResponsePacket(packet->payload.data, packet->payload.length);
   1d548:	7965      	ldrb	r5, [r4, #5]
}

u32 AdvertisingController::SetScanResponse(sizedData* payload){
	u32 err;

	scanHeader->manufacturer.len = 3 + payload->length;
   1d54a:	681b      	ldr	r3, [r3, #0]
   1d54c:	1cea      	adds	r2, r5, #3
   1d54e:	711a      	strb	r2, [r3, #4]

	memcpy(currentScanResponsePacket + SIZEOF_SCAN_PACKET_HEADER, payload->data, payload->length);
   1d550:	1da1      	adds	r1, r4, #6
   1d552:	1c2a      	adds	r2, r5, #0
   1d554:	3008      	adds	r0, #8
   1d556:	f004 f85d 	bl	21614 <memcpy>

	err = sd_ble_gap_adv_data_set(NULL, 0, currentScanResponsePacket, SIZEOF_SCAN_PACKET_HEADER + payload->length);
   1d55a:	2000      	movs	r0, #0
   1d55c:	3508      	adds	r5, #8
   1d55e:	b2eb      	uxtb	r3, r5
   1d560:	1c01      	adds	r1, r0, #0
   1d562:	1c32      	adds	r2, r6, #0
   1d564:	f7ff fe58 	bl	1d218 <sd_ble_gap_adv_data_set.lto_priv.63>
   1d568:	e02e      	b.n	1d5c8 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x190>

			}
			break;

		case MESSAGE_TYPE_UPDATE_CONNECTION_INTERVAL:
			if(dataLength == SIZEOF_CONN_PACKET_UPDATE_CONNECTION_INTERVAL)
   1d56a:	9b05      	ldr	r3, [sp, #20]
   1d56c:	2b07      	cmp	r3, #7
   1d56e:	d12b      	bne.n	1d5c8 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x190>
			{
				connPacketUpdateConnectionInterval* packet = (connPacketUpdateConnectionInterval*) data;

				cm->SetConnectionInterval(packet->newInterval);
   1d570:	682b      	ldr	r3, [r5, #0]
}

void ConnectionManager::SetConnectionInterval(u16 connectionInterval)
{
	//Go through all connections that we control as a central
	for(int i=0; i < Config->meshMaxOutConnections; i++){
   1d572:	2500      	movs	r5, #0
   1d574:	9307      	str	r3, [sp, #28]
   1d576:	79a7      	ldrb	r7, [r4, #6]
   1d578:	7963      	ldrb	r3, [r4, #5]
   1d57a:	023f      	lsls	r7, r7, #8
   1d57c:	431f      	orrs	r7, r3
   1d57e:	f003 fc53 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d582:	3034      	adds	r0, #52	; 0x34
   1d584:	7803      	ldrb	r3, [r0, #0]
   1d586:	429d      	cmp	r5, r3
   1d588:	da1e      	bge.n	1d5c8 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x190>
   1d58a:	9a07      	ldr	r2, [sp, #28]
   1d58c:	00ab      	lsls	r3, r5, #2
   1d58e:	18d3      	adds	r3, r2, r3
		if(outConnections[i]->handshakeDone()){
   1d590:	695b      	ldr	r3, [r3, #20]
   1d592:	7a1a      	ldrb	r2, [r3, #8]
   1d594:	2a03      	cmp	r2, #3
   1d596:	d915      	bls.n	1d5c4 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x18c>
			GAPController::RequestConnectionParameterUpdate(outConnections[i]->connectionHandle, connectionInterval, connectionInterval, 0, Config->meshConnectionSupervisionTimeout);
   1d598:	22e9      	movs	r2, #233	; 0xe9
   1d59a:	0052      	lsls	r2, r2, #1
   1d59c:	5a9e      	ldrh	r6, [r3, r2]
   1d59e:	f003 fc43 	bl	20e28 <_ZN4Conf11getInstanceEv>
	u32 err = 0;

	ble_gap_conn_params_t connParams;
	connParams.min_conn_interval = minConnectionInterval;
	connParams.max_conn_interval = maxConnectionInterval;
	connParams.slave_latency = slaveLatency;
   1d5a2:	2200      	movs	r2, #0
   1d5a4:	89c3      	ldrh	r3, [r0, #14]
void GAPController::RequestConnectionParameterUpdate(u16 connectionHandle, u16 minConnectionInterval, u16 maxConnectionInterval, u16 slaveLatency, u16 supervisionTimeout)
{
	u32 err = 0;

	ble_gap_conn_params_t connParams;
	connParams.min_conn_interval = minConnectionInterval;
   1d5a6:	a909      	add	r1, sp, #36	; 0x24
	connParams.max_conn_interval = maxConnectionInterval;
	connParams.slave_latency = slaveLatency;
	connParams.conn_sup_timeout = supervisionTimeout;

	//TODO: Check against compatibility with gap connection parameters limits
	err = sd_ble_gap_conn_param_update(connectionHandle, &connParams);
   1d5a8:	1c30      	adds	r0, r6, #0
void GAPController::RequestConnectionParameterUpdate(u16 connectionHandle, u16 minConnectionInterval, u16 maxConnectionInterval, u16 slaveLatency, u16 supervisionTimeout)
{
	u32 err = 0;

	ble_gap_conn_params_t connParams;
	connParams.min_conn_interval = minConnectionInterval;
   1d5aa:	800f      	strh	r7, [r1, #0]
	connParams.max_conn_interval = maxConnectionInterval;
   1d5ac:	804f      	strh	r7, [r1, #2]
	connParams.slave_latency = slaveLatency;
   1d5ae:	808a      	strh	r2, [r1, #4]
	connParams.conn_sup_timeout = supervisionTimeout;
   1d5b0:	80cb      	strh	r3, [r1, #6]

	//TODO: Check against compatibility with gap connection parameters limits
	err = sd_ble_gap_conn_param_update(connectionHandle, &connParams);
   1d5b2:	f7ff fbdf 	bl	1cd74 <sd_ble_gap_conn_param_update>
	APP_ERROR_CHECK(err);
   1d5b6:	2800      	cmp	r0, #0
   1d5b8:	d004      	beq.n	1d5c4 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x18c>
   1d5ba:	212e      	movs	r1, #46	; 0x2e
   1d5bc:	4a3f      	ldr	r2, [pc, #252]	; (1d6bc <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x284>)
   1d5be:	31ff      	adds	r1, #255	; 0xff
   1d5c0:	f7ff ff20 	bl	1d404 <app_error_handler>
}

void ConnectionManager::SetConnectionInterval(u16 connectionInterval)
{
	//Go through all connections that we control as a central
	for(int i=0; i < Config->meshMaxOutConnections; i++){
   1d5c4:	3501      	adds	r5, #1
   1d5c6:	e7da      	b.n	1d57e <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x146>
			}
			break;

	}

	if(packetHeader->messageType == MESSAGE_TYPE_MODULE_CONFIG)
   1d5c8:	2301      	movs	r3, #1
   1d5ca:	7827      	ldrb	r7, [r4, #0]
   1d5cc:	439f      	bics	r7, r3
   1d5ce:	2f64      	cmp	r7, #100	; 0x64
   1d5d0:	d13e      	bne.n	1d650 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x218>
	{
		connPacketModule* packet = (connPacketModule*) packetHeader;


		if(packet->actionType == Module::ModuleConfigMessages::GET_MODULE_LIST)
   1d5d2:	79e3      	ldrb	r3, [r4, #7]
   1d5d4:	2b06      	cmp	r3, #6
   1d5d6:	d140      	bne.n	1d65a <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x222>
		{
			SendModuleList(packet->header.sender, 7);
   1d5d8:	78a5      	ldrb	r5, [r4, #2]


inline void Node::SendModuleList(nodeID toNode, u8 requestHandle)
{
u8 buffer[SIZEOF_CONN_PACKET_MODULE + MAX_MODULE_COUNT*4];
		memset(buffer, 0, sizeof(buffer));
   1d5da:	ae09      	add	r6, sp, #36	; 0x24
		connPacketModule* packet = (connPacketModule*) packetHeader;


		if(packet->actionType == Module::ModuleConfigMessages::GET_MODULE_LIST)
		{
			SendModuleList(packet->header.sender, 7);
   1d5dc:	7863      	ldrb	r3, [r4, #1]


inline void Node::SendModuleList(nodeID toNode, u8 requestHandle)
{
u8 buffer[SIZEOF_CONN_PACKET_MODULE + MAX_MODULE_COUNT*4];
		memset(buffer, 0, sizeof(buffer));
   1d5de:	221c      	movs	r2, #28
		connPacketModule* packet = (connPacketModule*) packetHeader;


		if(packet->actionType == Module::ModuleConfigMessages::GET_MODULE_LIST)
		{
			SendModuleList(packet->header.sender, 7);
   1d5e0:	022d      	lsls	r5, r5, #8


inline void Node::SendModuleList(nodeID toNode, u8 requestHandle)
{
u8 buffer[SIZEOF_CONN_PACKET_MODULE + MAX_MODULE_COUNT*4];
		memset(buffer, 0, sizeof(buffer));
   1d5e2:	1c30      	adds	r0, r6, #0
   1d5e4:	2100      	movs	r1, #0
		connPacketModule* packet = (connPacketModule*) packetHeader;


		if(packet->actionType == Module::ModuleConfigMessages::GET_MODULE_LIST)
		{
			SendModuleList(packet->header.sender, 7);
   1d5e6:	431d      	orrs	r5, r3


inline void Node::SendModuleList(nodeID toNode, u8 requestHandle)
{
u8 buffer[SIZEOF_CONN_PACKET_MODULE + MAX_MODULE_COUNT*4];
		memset(buffer, 0, sizeof(buffer));
   1d5e8:	f004 f831 	bl	2164e <memset>

		connPacketModule* outPacket = (connPacketModule*)buffer;
		outPacket->header.messageType = MESSAGE_TYPE_MODULE_CONFIG;
		outPacket->header.sender = persistentConfig.nodeId;
   1d5ec:	230d      	movs	r3, #13
   1d5ee:	aa06      	add	r2, sp, #24
   1d5f0:	189b      	adds	r3, r3, r2
   1d5f2:	9a03      	ldr	r2, [sp, #12]
{
u8 buffer[SIZEOF_CONN_PACKET_MODULE + MAX_MODULE_COUNT*4];
		memset(buffer, 0, sizeof(buffer));

		connPacketModule* outPacket = (connPacketModule*)buffer;
		outPacket->header.messageType = MESSAGE_TYPE_MODULE_CONFIG;
   1d5f4:	7037      	strb	r7, [r6, #0]
		outPacket->header.sender = persistentConfig.nodeId;
   1d5f6:	3207      	adds	r2, #7
   1d5f8:	7fd2      	ldrb	r2, [r2, #31]
   1d5fa:	9f03      	ldr	r7, [sp, #12]
   1d5fc:	701a      	strb	r2, [r3, #0]
   1d5fe:	9a03      	ldr	r2, [sp, #12]
   1d600:	3740      	adds	r7, #64	; 0x40
   1d602:	3208      	adds	r2, #8
   1d604:	7fd2      	ldrb	r2, [r2, #31]
   1d606:	705a      	strb	r2, [r3, #1]
		outPacket->header.receiver = toNode;
   1d608:	230f      	movs	r3, #15
   1d60a:	aa06      	add	r2, sp, #24
   1d60c:	189b      	adds	r3, r3, r2
   1d60e:	701d      	strb	r5, [r3, #0]
   1d610:	0a2d      	lsrs	r5, r5, #8
   1d612:	705d      	strb	r5, [r3, #1]

		outPacket->moduleId = moduleID::NODE;
		outPacket->requestHandle = requestHandle;
   1d614:	2307      	movs	r3, #7
   1d616:	ad0b      	add	r5, sp, #44	; 0x2c
   1d618:	71b3      	strb	r3, [r6, #6]
		outPacket->actionType = Module::ModuleConfigMessages::MODULE_LIST;
   1d61a:	71f3      	strb	r3, [r6, #7]


		for(int i = 0; i<MAX_MODULE_COUNT; i++){
			if(activeModules[i] != NULL){
   1d61c:	683e      	ldr	r6, [r7, #0]
   1d61e:	2e00      	cmp	r6, #0
   1d620:	d00a      	beq.n	1d638 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x200>
				//TODO: can we do this better? the data region is unaligned in memory
				memcpy(outPacket->data + i*4, &activeModules[i]->configurationPointer->moduleId, 2);
   1d622:	1c28      	adds	r0, r5, #0
   1d624:	6a31      	ldr	r1, [r6, #32]
   1d626:	2202      	movs	r2, #2
   1d628:	f003 fff4 	bl	21614 <memcpy>
				memcpy(outPacket->data + i*4 + 2, &activeModules[i]->configurationPointer->moduleVersion, 1);
   1d62c:	6a33      	ldr	r3, [r6, #32]
   1d62e:	785b      	ldrb	r3, [r3, #1]
   1d630:	70ab      	strb	r3, [r5, #2]
				memcpy(outPacket->data + i*4 + 3, &activeModules[i]->configurationPointer->moduleActive, 1);
   1d632:	6a33      	ldr	r3, [r6, #32]
   1d634:	789b      	ldrb	r3, [r3, #2]
   1d636:	70eb      	strb	r3, [r5, #3]
   1d638:	3504      	adds	r5, #4
		outPacket->moduleId = moduleID::NODE;
		outPacket->requestHandle = requestHandle;
		outPacket->actionType = Module::ModuleConfigMessages::MODULE_LIST;


		for(int i = 0; i<MAX_MODULE_COUNT; i++){
   1d63a:	ab10      	add	r3, sp, #64	; 0x40
   1d63c:	3704      	adds	r7, #4
   1d63e:	429d      	cmp	r5, r3
   1d640:	d1ec      	bne.n	1d61c <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x1e4>
		char* strbuffer[200];
		Logger::getInstance().convertBufferToHexString(buffer, SIZEOF_CONN_PACKET_MODULE + MAX_MODULE_COUNT*4, (char*)strbuffer);
		logt("MODULE", "Sending: %s", strbuffer);
*/

		cm->SendMessageToReceiver(NULL, (u8*)outPacket, SIZEOF_CONN_PACKET_MODULE + MAX_MODULE_COUNT*4, true);
   1d642:	4b19      	ldr	r3, [pc, #100]	; (1d6a8 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x270>)
   1d644:	a909      	add	r1, sp, #36	; 0x24
   1d646:	6818      	ldr	r0, [r3, #0]
   1d648:	221c      	movs	r2, #28
   1d64a:	2301      	movs	r3, #1
   1d64c:	f001 fda6 	bl	1f19c <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10>
   1d650:	9d03      	ldr	r5, [sp, #12]
   1d652:	9e03      	ldr	r6, [sp, #12]
   1d654:	3540      	adds	r5, #64	; 0x40
   1d656:	3654      	adds	r6, #84	; 0x54
   1d658:	e015      	b.n	1d686 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x24e>
		if(packet->actionType == Module::ModuleConfigMessages::GET_MODULE_LIST)
		{
			SendModuleList(packet->header.sender, 7);

		}
		else if(packet->actionType == Module::ModuleConfigMessages::MODULE_LIST)
   1d65a:	2b07      	cmp	r3, #7
   1d65c:	d1f8      	bne.n	1d650 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x218>
   1d65e:	1c27      	adds	r7, r4, #0

//			uart("MODULE", "{\"nodeId\":%u,\"type\":\"module_list\",\"modules\":[", packet->header.sender);

			u16 moduleCount = (dataLength - SIZEOF_CONN_PACKET_MODULE) / 4;
			bool first = true;
			for(int i=0; i<moduleCount; i++){
   1d660:	2600      	movs	r6, #0
		else if(packet->actionType == Module::ModuleConfigMessages::MODULE_LIST)
		{

//			uart("MODULE", "{\"nodeId\":%u,\"type\":\"module_list\",\"modules\":[", packet->header.sender);

			u16 moduleCount = (dataLength - SIZEOF_CONN_PACKET_MODULE) / 4;
   1d662:	9b05      	ldr	r3, [sp, #20]
   1d664:	3708      	adds	r7, #8
   1d666:	3b08      	subs	r3, #8
   1d668:	17dd      	asrs	r5, r3, #31
   1d66a:	0fad      	lsrs	r5, r5, #30
   1d66c:	18ed      	adds	r5, r5, r3
   1d66e:	10ad      	asrs	r5, r5, #2
			bool first = true;
			for(int i=0; i<moduleCount; i++){
   1d670:	b2ab      	uxth	r3, r5
   1d672:	429e      	cmp	r6, r3
   1d674:	daec      	bge.n	1d650 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x218>
				u8 moduleId = 0, version = 0, active = 0;
				memcpy(&moduleId, packet->data + i*4+0, 2);
   1d676:	1c39      	adds	r1, r7, #0
   1d678:	a809      	add	r0, sp, #36	; 0x24
   1d67a:	2202      	movs	r2, #2
   1d67c:	f003 ffca 	bl	21614 <memcpy>

//			uart("MODULE", "{\"nodeId\":%u,\"type\":\"module_list\",\"modules\":[", packet->header.sender);

			u16 moduleCount = (dataLength - SIZEOF_CONN_PACKET_MODULE) / 4;
			bool first = true;
			for(int i=0; i<moduleCount; i++){
   1d680:	3601      	adds	r6, #1
   1d682:	3704      	adds	r7, #4
   1d684:	e7f4      	b.n	1d670 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x238>
		}
	}

	//Now we must pass the message to all of our modules for further processing
	for(int i=0; i<MAX_MODULE_COUNT; i++){
		if(activeModules[i] != 0){
   1d686:	6828      	ldr	r0, [r5, #0]
   1d688:	2800      	cmp	r0, #0
   1d68a:	d007      	beq.n	1d69c <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x264>
			activeModules[i]->ConnectionPacketReceivedEventHandler(inPacket, connection, packetHeader, dataLength);
   1d68c:	9a05      	ldr	r2, [sp, #20]
   1d68e:	6803      	ldr	r3, [r0, #0]
   1d690:	9200      	str	r2, [sp, #0]
   1d692:	6b1f      	ldr	r7, [r3, #48]	; 0x30
   1d694:	9906      	ldr	r1, [sp, #24]
   1d696:	9a04      	ldr	r2, [sp, #16]
   1d698:	1c23      	adds	r3, r4, #0
   1d69a:	47b8      	blx	r7
   1d69c:	3504      	adds	r5, #4
//			uart("MODULE", "]}" SEP);
		}
	}

	//Now we must pass the message to all of our modules for further processing
	for(int i=0; i<MAX_MODULE_COUNT; i++){
   1d69e:	42b5      	cmp	r5, r6
   1d6a0:	d1f1      	bne.n	1d686 <_ZN4Node23messageReceivedCallbackEP16connectionPacket+0x24e>
		if(activeModules[i] != 0){
			activeModules[i]->ConnectionPacketReceivedEventHandler(inPacket, connection, packetHeader, dataLength);
		}
	}

}
   1d6a2:	b011      	add	sp, #68	; 0x44
   1d6a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1d6a6:	46c0      	nop			; (mov r8, r8)
   1d6a8:	200033d0 	.word	0x200033d0
   1d6ac:	0000ffff 	.word	0x0000ffff
   1d6b0:	00000212 	.word	0x00000212
   1d6b4:	20003341 	.word	0x20003341
   1d6b8:	200033ac 	.word	0x200033ac
   1d6bc:	000228a3 	.word	0x000228a3

0001d6c0 <_ZThn4_N4Node23messageReceivedCallbackEP16connectionPacket>:
		void ConnectionSuccessfulHandler(ble_evt_t* bleEvent);
		void ConnectingTimeoutHandler(ble_evt_t* bleEvent);
		void messageReceivedCallback(connectionPacket* inPacket);
   1d6c0:	b408      	push	{r3}
   1d6c2:	4b02      	ldr	r3, [pc, #8]	; (1d6cc <_ZThn4_N4Node23messageReceivedCallbackEP16connectionPacket+0xc>)
   1d6c4:	469c      	mov	ip, r3
   1d6c6:	3804      	subs	r0, #4
   1d6c8:	bc08      	pop	{r3}
   1d6ca:	4760      	bx	ip
   1d6cc:	0001d439 	.word	0x0001d439

0001d6d0 <_ZN17ConnectionManager11getInstanceEv>:

		//An outConnection is initialized before being connected (saved here during initializing phase)
		Connection* pendingConnection;

	public:
		static ConnectionManager* getInstance(){
   1d6d0:	b5f0      	push	{r4, r5, r6, r7, lr}
			if(!instance){
   1d6d2:	4bac      	ldr	r3, [pc, #688]	; (1d984 <_ZN17ConnectionManager11getInstanceEv+0x2b4>)

		//An outConnection is initialized before being connected (saved here during initializing phase)
		Connection* pendingConnection;

	public:
		static ConnectionManager* getInstance(){
   1d6d4:	b099      	sub	sp, #100	; 0x64
			if(!instance){
   1d6d6:	681d      	ldr	r5, [r3, #0]
   1d6d8:	2d00      	cmp	r5, #0
   1d6da:	d000      	beq.n	1d6de <_ZN17ConnectionManager11getInstanceEv+0xe>
   1d6dc:	e14d      	b.n	1d97a <_ZN17ConnectionManager11getInstanceEv+0x2aa>
				instance = new ConnectionManager();
   1d6de:	2030      	movs	r0, #48	; 0x30
   1d6e0:	f003 fd9e 	bl	21220 <_Znwj>


	public:
		static Node* getInstance()
		{
			return instance;
   1d6e4:	4ba8      	ldr	r3, [pc, #672]	; (1d988 <_ZN17ConnectionManager11getInstanceEv+0x2b8>)
	u32 err = 0;
	//Set up an open link write permission
	//There are multiple security modes defined in the BLE spec
	//Use these macros: http://developer.nordicsemi.com/nRF51_SDK/doc/7.1.0/s110/html/a00813.html
	ble_gap_conn_sec_mode_t secPermissionOpen;
	BLE_GAP_CONN_SEC_MODE_SET_OPEN(&secPermissionOpen);
   1d6e6:	2601      	movs	r6, #1

ConnectionManager* ConnectionManager::instance = NULL;

ConnectionManager::ConnectionManager(){

	this->node = Node::getInstance();
   1d6e8:	681b      	ldr	r3, [r3, #0]
	connectionManagerCallback = NULL;
   1d6ea:	6085      	str	r5, [r0, #8]

ConnectionManager* ConnectionManager::instance = NULL;

ConnectionManager::ConnectionManager(){

	this->node = Node::getInstance();
   1d6ec:	6043      	str	r3, [r0, #4]
   1d6ee:	2310      	movs	r3, #16

	//Set the GAP device name
	err = sd_ble_gap_device_name_set(&secPermissionOpen, (u8*)DEVICE_NAME, strlen(DEVICE_NAME));
   1d6f0:	49a6      	ldr	r1, [pc, #664]	; (1d98c <_ZN17ConnectionManager11getInstanceEv+0x2bc>)
	u32 err = 0;
	//Set up an open link write permission
	//There are multiple security modes defined in the BLE spec
	//Use these macros: http://developer.nordicsemi.com/nRF51_SDK/doc/7.1.0/s110/html/a00813.html
	ble_gap_conn_sec_mode_t secPermissionOpen;
	BLE_GAP_CONN_SEC_MODE_SET_OPEN(&secPermissionOpen);
   1d6f2:	4333      	orrs	r3, r6
   1d6f4:	1c04      	adds	r4, r0, #0

	//Set the GAP device name
	err = sd_ble_gap_device_name_set(&secPermissionOpen, (u8*)DEVICE_NAME, strlen(DEVICE_NAME));
   1d6f6:	2202      	movs	r2, #2
	u32 err = 0;
	//Set up an open link write permission
	//There are multiple security modes defined in the BLE spec
	//Use these macros: http://developer.nordicsemi.com/nRF51_SDK/doc/7.1.0/s110/html/a00813.html
	ble_gap_conn_sec_mode_t secPermissionOpen;
	BLE_GAP_CONN_SEC_MODE_SET_OPEN(&secPermissionOpen);
   1d6f8:	a80c      	add	r0, sp, #48	; 0x30
   1d6fa:	7003      	strb	r3, [r0, #0]

	//Set the GAP device name
	err = sd_ble_gap_device_name_set(&secPermissionOpen, (u8*)DEVICE_NAME, strlen(DEVICE_NAME));
   1d6fc:	f7ff fb34 	bl	1cd68 <sd_ble_gap_device_name_set>
	u32 err = 0;
	//Set up an open link write permission
	//There are multiple security modes defined in the BLE spec
	//Use these macros: http://developer.nordicsemi.com/nRF51_SDK/doc/7.1.0/s110/html/a00813.html
	ble_gap_conn_sec_mode_t secPermissionOpen;
	BLE_GAP_CONN_SEC_MODE_SET_OPEN(&secPermissionOpen);
   1d700:	350f      	adds	r5, #15

	//Set the GAP device name
	err = sd_ble_gap_device_name_set(&secPermissionOpen, (u8*)DEVICE_NAME, strlen(DEVICE_NAME));
	APP_ERROR_CHECK(err); //OK
   1d702:	2145      	movs	r1, #69	; 0x45
   1d704:	2800      	cmp	r0, #0
   1d706:	d105      	bne.n	1d714 <_ZN17ConnectionManager11getInstanceEv+0x44>

	//Set the appearance of the device as defined in http://developer.nordicsemi.com/nRF51_SDK/doc/7.1.0/s110/html/a00837.html
	err = sd_ble_gap_appearance_set(BLE_APPEARANCE_GENERIC_COMPUTER);
   1d708:	2080      	movs	r0, #128	; 0x80
   1d70a:	f7ff fb31 	bl	1cd70 <sd_ble_gap_appearance_set>
	APP_ERROR_CHECK(err); //OK
   1d70e:	2800      	cmp	r0, #0
   1d710:	d003      	beq.n	1d71a <_ZN17ConnectionManager11getInstanceEv+0x4a>
   1d712:	2149      	movs	r1, #73	; 0x49
   1d714:	4a9e      	ldr	r2, [pc, #632]	; (1d990 <_ZN17ConnectionManager11getInstanceEv+0x2c0>)
   1d716:	f7ff fe75 	bl	1d404 <app_error_handler>

	//Set gap peripheral preferred connection parameters (not used by the mesh implementation)
	ble_gap_conn_params_t gapConnectionParams;
	memset(&gapConnectionParams, 0, sizeof(gapConnectionParams));
   1d71a:	af11      	add	r7, sp, #68	; 0x44
   1d71c:	9011      	str	r0, [sp, #68]	; 0x44
   1d71e:	6078      	str	r0, [r7, #4]
	gapConnectionParams.min_conn_interval = Config->meshMinConnectionInterval;
   1d720:	f003 fb82 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d724:	8903      	ldrh	r3, [r0, #8]
   1d726:	803b      	strh	r3, [r7, #0]
	gapConnectionParams.max_conn_interval = Config->meshMaxConnectionInterval;
   1d728:	f003 fb7e 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d72c:	8943      	ldrh	r3, [r0, #10]
   1d72e:	807b      	strh	r3, [r7, #2]
	gapConnectionParams.slave_latency = Config->meshPeripheralSlaveLatency;
   1d730:	f003 fb7a 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d734:	8983      	ldrh	r3, [r0, #12]
   1d736:	80bb      	strh	r3, [r7, #4]
	gapConnectionParams.conn_sup_timeout = Config->meshConnectionSupervisionTimeout;
   1d738:	f003 fb76 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d73c:	89c3      	ldrh	r3, [r0, #14]
	err = sd_ble_gap_ppcp_set(&gapConnectionParams);
   1d73e:	1c38      	adds	r0, r7, #0
	ble_gap_conn_params_t gapConnectionParams;
	memset(&gapConnectionParams, 0, sizeof(gapConnectionParams));
	gapConnectionParams.min_conn_interval = Config->meshMinConnectionInterval;
	gapConnectionParams.max_conn_interval = Config->meshMaxConnectionInterval;
	gapConnectionParams.slave_latency = Config->meshPeripheralSlaveLatency;
	gapConnectionParams.conn_sup_timeout = Config->meshConnectionSupervisionTimeout;
   1d740:	80fb      	strh	r3, [r7, #6]
	err = sd_ble_gap_ppcp_set(&gapConnectionParams);
   1d742:	f7ff fb13 	bl	1cd6c <sd_ble_gap_ppcp_set>
	APP_ERROR_CHECK(err); //OK
   1d746:	2153      	movs	r1, #83	; 0x53
   1d748:	2800      	cmp	r0, #0
   1d74a:	d1e3      	bne.n	1d714 <_ZN17ConnectionManager11getInstanceEv+0x44>

void GATTController::bleMeshServiceInit()
{
	u32 err = 0;

	meshService.connectionHandle = BLE_CONN_HANDLE_INVALID;
   1d74c:	2301      	movs	r3, #1
   1d74e:	4f91      	ldr	r7, [pc, #580]	; (1d994 <_ZN17ConnectionManager11getInstanceEv+0x2c4>)
   1d750:	425b      	negs	r3, r3

	//##### At first, we register our custom service
	//Add our Service UUID to the BLE stack for management
	ble_uuid128_t baseUUID128 = { MESH_SERVICE_BASE_UUID128 };
   1d752:	4991      	ldr	r1, [pc, #580]	; (1d998 <_ZN17ConnectionManager11getInstanceEv+0x2c8>)
   1d754:	2210      	movs	r2, #16
   1d756:	a808      	add	r0, sp, #32

void GATTController::bleMeshServiceInit()
{
	u32 err = 0;

	meshService.connectionHandle = BLE_CONN_HANDLE_INVALID;
   1d758:	833b      	strh	r3, [r7, #24]

	//##### At first, we register our custom service
	//Add our Service UUID to the BLE stack for management
	ble_uuid128_t baseUUID128 = { MESH_SERVICE_BASE_UUID128 };
   1d75a:	f003 ff5b 	bl	21614 <memcpy>
	err = sd_ble_uuid_vs_add(&baseUUID128, &meshService.serviceUuid.type);
   1d75e:	498f      	ldr	r1, [pc, #572]	; (1d99c <_ZN17ConnectionManager11getInstanceEv+0x2cc>)
   1d760:	a808      	add	r0, sp, #32
   1d762:	f7ff faf9 	bl	1cd58 <sd_ble_uuid_vs_add>
	APP_ERROR_CHECK(err); //OK
   1d766:	2137      	movs	r1, #55	; 0x37
   1d768:	2800      	cmp	r0, #0
   1d76a:	d17a      	bne.n	1d862 <_ZN17ConnectionManager11getInstanceEv+0x192>

	//Add the service
	err = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &meshService.serviceUuid, &meshService.serviceHandle);
   1d76c:	498c      	ldr	r1, [pc, #560]	; (1d9a0 <_ZN17ConnectionManager11getInstanceEv+0x2d0>)
   1d76e:	1c30      	adds	r0, r6, #0
   1d770:	1c3a      	adds	r2, r7, #0
   1d772:	f7ff faf5 	bl	1cd60 <sd_ble_gatts_service_add>
	APP_ERROR_CHECK(err); //OK
   1d776:	213b      	movs	r1, #59	; 0x3b
   1d778:	2800      	cmp	r0, #0
   1d77a:	d172      	bne.n	1d862 <_ZN17ConnectionManager11getInstanceEv+0x192>
	//##### Now we need to add a characteristic to that service

	//BLE GATT Attribute Metadata http://developer.nordicsemi.com/nRF51_SDK/doc/7.1.0/s120/html/a00163.html
	//Read and write permissions, variable length, etc...
	ble_gatts_attr_md_t attributeMetadata;
	memset(&attributeMetadata, 0, sizeof(ble_gatts_attr_md_t));
   1d77c:	ab02      	add	r3, sp, #8
   1d77e:	8018      	strh	r0, [r3, #0]
   1d780:	7098      	strb	r0, [r3, #2]

	//If encryption is enabled, we want our mesh handle only to be accessable over an
	//encrypted connection with authentication
	if(Config->encryptionEnabled){
   1d782:	f003 fb51 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d786:	ab02      	add	r3, sp, #8
   1d788:	781b      	ldrb	r3, [r3, #0]
   1d78a:	3056      	adds	r0, #86	; 0x56
		BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&attributeMetadata.read_perm);
   1d78c:	43ab      	bics	r3, r5
	ble_gatts_attr_md_t attributeMetadata;
	memset(&attributeMetadata, 0, sizeof(ble_gatts_attr_md_t));

	//If encryption is enabled, we want our mesh handle only to be accessable over an
	//encrypted connection with authentication
	if(Config->encryptionEnabled){
   1d78e:	7801      	ldrb	r1, [r0, #0]
   1d790:	aa02      	add	r2, sp, #8
		BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&attributeMetadata.read_perm);
   1d792:	4333      	orrs	r3, r6
   1d794:	7852      	ldrb	r2, [r2, #1]
   1d796:	402b      	ands	r3, r5
	ble_gatts_attr_md_t attributeMetadata;
	memset(&attributeMetadata, 0, sizeof(ble_gatts_attr_md_t));

	//If encryption is enabled, we want our mesh handle only to be accessable over an
	//encrypted connection with authentication
	if(Config->encryptionEnabled){
   1d798:	2900      	cmp	r1, #0
   1d79a:	d009      	beq.n	1d7b0 <_ZN17ConnectionManager11getInstanceEv+0xe0>
		BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&attributeMetadata.read_perm);
   1d79c:	2120      	movs	r1, #32
		BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&attributeMetadata.write_perm);
   1d79e:	43aa      	bics	r2, r5
   1d7a0:	4316      	orrs	r6, r2
	memset(&attributeMetadata, 0, sizeof(ble_gatts_attr_md_t));

	//If encryption is enabled, we want our mesh handle only to be accessable over an
	//encrypted connection with authentication
	if(Config->encryptionEnabled){
		BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&attributeMetadata.read_perm);
   1d7a2:	430b      	orrs	r3, r1
   1d7a4:	a802      	add	r0, sp, #8
		BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&attributeMetadata.write_perm);
   1d7a6:	4035      	ands	r5, r6
	memset(&attributeMetadata, 0, sizeof(ble_gatts_attr_md_t));

	//If encryption is enabled, we want our mesh handle only to be accessable over an
	//encrypted connection with authentication
	if(Config->encryptionEnabled){
		BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&attributeMetadata.read_perm);
   1d7a8:	7003      	strb	r3, [r0, #0]
		BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&attributeMetadata.write_perm);
   1d7aa:	430d      	orrs	r5, r1
   1d7ac:	1c03      	adds	r3, r0, #0
   1d7ae:	e009      	b.n	1d7c4 <_ZN17ConnectionManager11getInstanceEv+0xf4>
	}
	else
	{
		BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attributeMetadata.read_perm);
   1d7b0:	2110      	movs	r1, #16
   1d7b2:	430b      	orrs	r3, r1
   1d7b4:	a902      	add	r1, sp, #8
   1d7b6:	700b      	strb	r3, [r1, #0]
		BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attributeMetadata.write_perm);
   1d7b8:	2310      	movs	r3, #16
   1d7ba:	43aa      	bics	r2, r5
   1d7bc:	4316      	orrs	r6, r2
   1d7be:	4035      	ands	r5, r6
   1d7c0:	431d      	orrs	r5, r3
   1d7c2:	1c0b      	adds	r3, r1, #0
	}

	attributeMetadata.vloc = BLE_GATTS_VLOC_STACK; //We currently have the value on the SoftDevice stack, we might port that to the application space
   1d7c4:	2206      	movs	r2, #6
	attributeMetadata.rd_auth = 0;
	attributeMetadata.wr_auth = 0;
   1d7c6:	2610      	movs	r6, #16
		BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&attributeMetadata.write_perm);
	}
	else
	{
		BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attributeMetadata.read_perm);
		BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attributeMetadata.write_perm);
   1d7c8:	705d      	strb	r5, [r3, #1]
	}

	attributeMetadata.vloc = BLE_GATTS_VLOC_STACK; //We currently have the value on the SoftDevice stack, we might port that to the application space
   1d7ca:	ab02      	add	r3, sp, #8
   1d7cc:	789b      	ldrb	r3, [r3, #2]
	attributeMetadata.wr_auth = 0;
	attributeMetadata.vlen = 1; //Make it a variable length attribute

	//Client Characteristic Configuration Descriptor, whatever....
	ble_gatts_attr_md_t clientCharacteristicConfigurationDescriptor;
	memset(&clientCharacteristicConfigurationDescriptor, 0, sizeof(ble_gatts_attr_md_t));
   1d7ce:	af03      	add	r7, sp, #12
	{
		BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attributeMetadata.read_perm);
		BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attributeMetadata.write_perm);
	}

	attributeMetadata.vloc = BLE_GATTS_VLOC_STACK; //We currently have the value on the SoftDevice stack, we might port that to the application space
   1d7d0:	4393      	bics	r3, r2
	attributeMetadata.rd_auth = 0;
   1d7d2:	3a04      	subs	r2, #4
   1d7d4:	4313      	orrs	r3, r2
	attributeMetadata.wr_auth = 0;
   1d7d6:	3206      	adds	r2, #6
   1d7d8:	4393      	bics	r3, r2
	attributeMetadata.vlen = 1; //Make it a variable length attribute
   1d7da:	43b3      	bics	r3, r6
   1d7dc:	3a07      	subs	r2, #7
   1d7de:	4313      	orrs	r3, r2
   1d7e0:	aa02      	add	r2, sp, #8
   1d7e2:	7093      	strb	r3, [r2, #2]

	//Client Characteristic Configuration Descriptor, whatever....
	ble_gatts_attr_md_t clientCharacteristicConfigurationDescriptor;
	memset(&clientCharacteristicConfigurationDescriptor, 0, sizeof(ble_gatts_attr_md_t));
	clientCharacteristicConfigurationDescriptor.vloc = BLE_GATTS_VLOC_STACK;
   1d7e4:	2302      	movs	r3, #2
   1d7e6:	70bb      	strb	r3, [r7, #2]
	BLE_GAP_CONN_SEC_MODE_SET_OPEN(&clientCharacteristicConfigurationDescriptor.read_perm);
   1d7e8:	3b01      	subs	r3, #1
   1d7ea:	4333      	orrs	r3, r6
   1d7ec:	703b      	strb	r3, [r7, #0]
	BLE_GAP_CONN_SEC_MODE_SET_OPEN(&clientCharacteristicConfigurationDescriptor.write_perm);
   1d7ee:	2301      	movs	r3, #1

	//Characteristic metadata, whatever....
	ble_gatts_char_md_t characteristicMetadata;
	memset(&characteristicMetadata, 0, sizeof(ble_gatts_char_md_t));
   1d7f0:	ad11      	add	r5, sp, #68	; 0x44
	//Client Characteristic Configuration Descriptor, whatever....
	ble_gatts_attr_md_t clientCharacteristicConfigurationDescriptor;
	memset(&clientCharacteristicConfigurationDescriptor, 0, sizeof(ble_gatts_attr_md_t));
	clientCharacteristicConfigurationDescriptor.vloc = BLE_GATTS_VLOC_STACK;
	BLE_GAP_CONN_SEC_MODE_SET_OPEN(&clientCharacteristicConfigurationDescriptor.read_perm);
	BLE_GAP_CONN_SEC_MODE_SET_OPEN(&clientCharacteristicConfigurationDescriptor.write_perm);
   1d7f2:	4333      	orrs	r3, r6

	//Characteristic metadata, whatever....
	ble_gatts_char_md_t characteristicMetadata;
	memset(&characteristicMetadata, 0, sizeof(ble_gatts_char_md_t));
   1d7f4:	2100      	movs	r1, #0
   1d7f6:	221c      	movs	r2, #28
   1d7f8:	1c28      	adds	r0, r5, #0
	//Client Characteristic Configuration Descriptor, whatever....
	ble_gatts_attr_md_t clientCharacteristicConfigurationDescriptor;
	memset(&clientCharacteristicConfigurationDescriptor, 0, sizeof(ble_gatts_attr_md_t));
	clientCharacteristicConfigurationDescriptor.vloc = BLE_GATTS_VLOC_STACK;
	BLE_GAP_CONN_SEC_MODE_SET_OPEN(&clientCharacteristicConfigurationDescriptor.read_perm);
	BLE_GAP_CONN_SEC_MODE_SET_OPEN(&clientCharacteristicConfigurationDescriptor.write_perm);
   1d7fa:	707b      	strb	r3, [r7, #1]

	//Characteristic metadata, whatever....
	ble_gatts_char_md_t characteristicMetadata;
	memset(&characteristicMetadata, 0, sizeof(ble_gatts_char_md_t));
   1d7fc:	f003 ff27 	bl	2164e <memset>
	characteristicMetadata.char_props.read = 1; /*Reading value permitted*/
	characteristicMetadata.char_props.write = 1; /*Writing value with Write Request permitted*/
	characteristicMetadata.char_props.write_wo_resp = 1; /*Writing value with Write Command permitted*/
   1d800:	2202      	movs	r2, #2
   1d802:	2308      	movs	r3, #8
   1d804:	4313      	orrs	r3, r2
	characteristicMetadata.char_props.auth_signed_wr = 0; /*Writing value with Signed Write Command not permitted*/
	characteristicMetadata.char_props.notify = 1; /*Notications of value permitted*/
   1d806:	1892      	adds	r2, r2, r2
   1d808:	4313      	orrs	r3, r2
   1d80a:	431e      	orrs	r6, r3
   1d80c:	702e      	strb	r6, [r5, #0]
	characteristicMetadata.char_props.indicate = 0; /*Indications of value not permitted*/
	characteristicMetadata.p_cccd_md = &clientCharacteristicConfigurationDescriptor;

	//Set human readable name
	u8 humanReadableCharacteristicDescription[] = "meshWrite";
   1d80e:	ae05      	add	r6, sp, #20
   1d810:	4964      	ldr	r1, [pc, #400]	; (1d9a4 <_ZN17ConnectionManager11getInstanceEv+0x2d4>)
   1d812:	3206      	adds	r2, #6
   1d814:	1c30      	adds	r0, r6, #0
	characteristicMetadata.char_props.write = 1; /*Writing value with Write Request permitted*/
	characteristicMetadata.char_props.write_wo_resp = 1; /*Writing value with Write Command permitted*/
	characteristicMetadata.char_props.auth_signed_wr = 0; /*Writing value with Signed Write Command not permitted*/
	characteristicMetadata.char_props.notify = 1; /*Notications of value permitted*/
	characteristicMetadata.char_props.indicate = 0; /*Indications of value not permitted*/
	characteristicMetadata.p_cccd_md = &clientCharacteristicConfigurationDescriptor;
   1d816:	616f      	str	r7, [r5, #20]

	//Set human readable name
	u8 humanReadableCharacteristicDescription[] = "meshWrite";
   1d818:	f003 fefc 	bl	21614 <memcpy>
	characteristicMetadata.p_char_user_desc = humanReadableCharacteristicDescription;
	characteristicMetadata.char_user_desc_max_size = strlen((const char*) humanReadableCharacteristicDescription);
   1d81c:	1c30      	adds	r0, r6, #0
	characteristicMetadata.char_props.indicate = 0; /*Indications of value not permitted*/
	characteristicMetadata.p_cccd_md = &clientCharacteristicConfigurationDescriptor;

	//Set human readable name
	u8 humanReadableCharacteristicDescription[] = "meshWrite";
	characteristicMetadata.p_char_user_desc = humanReadableCharacteristicDescription;
   1d81e:	606e      	str	r6, [r5, #4]
	characteristicMetadata.char_user_desc_max_size = strlen((const char*) humanReadableCharacteristicDescription);
   1d820:	f004 f83a 	bl	21898 <strlen>
   1d824:	8128      	strh	r0, [r5, #8]
	characteristicMetadata.char_user_desc_size = strlen((const char*) humanReadableCharacteristicDescription);
   1d826:	1c30      	adds	r0, r6, #0
   1d828:	f004 f836 	bl	21898 <strlen>


	//Finally, the attribute
	ble_gatts_attr_t attribute;
	memset(&attribute, 0, sizeof(ble_gatts_attr_t));
   1d82c:	2714      	movs	r7, #20
   1d82e:	ae0c      	add	r6, sp, #48	; 0x30
   1d830:	1c3a      	adds	r2, r7, #0

	//Set human readable name
	u8 humanReadableCharacteristicDescription[] = "meshWrite";
	characteristicMetadata.p_char_user_desc = humanReadableCharacteristicDescription;
	characteristicMetadata.char_user_desc_max_size = strlen((const char*) humanReadableCharacteristicDescription);
	characteristicMetadata.char_user_desc_size = strlen((const char*) humanReadableCharacteristicDescription);
   1d832:	8168      	strh	r0, [r5, #10]


	//Finally, the attribute
	ble_gatts_attr_t attribute;
	memset(&attribute, 0, sizeof(ble_gatts_attr_t));
   1d834:	2100      	movs	r1, #0
   1d836:	1c30      	adds	r0, r6, #0
   1d838:	f003 ff09 	bl	2164e <memset>

	ble_uuid_t attributeUUID;
	attributeUUID.type = meshService.serviceUuid.type;
   1d83c:	4a55      	ldr	r2, [pc, #340]	; (1d994 <_ZN17ConnectionManager11getInstanceEv+0x2c4>)
   1d83e:	ab04      	add	r3, sp, #16
   1d840:	7d91      	ldrb	r1, [r2, #22]
	attributeUUID.uuid = MESH_SERVICE_CHARACTERISTIC_UUID;

	attribute.p_uuid = &attributeUUID; /* The UUID of the Attribute*/
   1d842:	930c      	str	r3, [sp, #48]	; 0x30
	//Finally, the attribute
	ble_gatts_attr_t attribute;
	memset(&attribute, 0, sizeof(ble_gatts_attr_t));

	ble_uuid_t attributeUUID;
	attributeUUID.type = meshService.serviceUuid.type;
   1d844:	7099      	strb	r1, [r3, #2]
	attributeUUID.uuid = MESH_SERVICE_CHARACTERISTIC_UUID;
   1d846:	4958      	ldr	r1, [pc, #352]	; (1d9a8 <_ZN17ConnectionManager11getInstanceEv+0x2d8>)
	attribute.max_len = MESH_CHARACTERISTIC_MAX_LENGTH;
	attribute.init_len = 0;
	attribute.init_offs = 0;

	//Finally, add the characteristic
	err = sd_ble_gatts_characteristic_add(meshService.serviceHandle, &characteristicMetadata, &attribute, &meshService.sendMessageCharacteristicHandle);
   1d848:	8810      	ldrh	r0, [r2, #0]
	ble_gatts_attr_t attribute;
	memset(&attribute, 0, sizeof(ble_gatts_attr_t));

	ble_uuid_t attributeUUID;
	attributeUUID.type = meshService.serviceUuid.type;
	attributeUUID.uuid = MESH_SERVICE_CHARACTERISTIC_UUID;
   1d84a:	8019      	strh	r1, [r3, #0]

	attribute.p_uuid = &attributeUUID; /* The UUID of the Attribute*/
	attribute.p_attr_md = &attributeMetadata; /* The previously defined attribute Metadata */
   1d84c:	ab02      	add	r3, sp, #8
   1d84e:	6073      	str	r3, [r6, #4]
	attribute.max_len = MESH_CHARACTERISTIC_MAX_LENGTH;
	attribute.init_len = 0;
	attribute.init_offs = 0;

	//Finally, add the characteristic
	err = sd_ble_gatts_characteristic_add(meshService.serviceHandle, &characteristicMetadata, &attribute, &meshService.sendMessageCharacteristicHandle);
   1d850:	1c29      	adds	r1, r5, #0
   1d852:	1c32      	adds	r2, r6, #0
   1d854:	4b55      	ldr	r3, [pc, #340]	; (1d9ac <_ZN17ConnectionManager11getInstanceEv+0x2dc>)
	attributeUUID.type = meshService.serviceUuid.type;
	attributeUUID.uuid = MESH_SERVICE_CHARACTERISTIC_UUID;

	attribute.p_uuid = &attributeUUID; /* The UUID of the Attribute*/
	attribute.p_attr_md = &attributeMetadata; /* The previously defined attribute Metadata */
	attribute.max_len = MESH_CHARACTERISTIC_MAX_LENGTH;
   1d856:	81b7      	strh	r7, [r6, #12]
	attribute.init_len = 0;
	attribute.init_offs = 0;

	//Finally, add the characteristic
	err = sd_ble_gatts_characteristic_add(meshService.serviceHandle, &characteristicMetadata, &attribute, &meshService.sendMessageCharacteristicHandle);
   1d858:	f7ff fa80 	bl	1cd5c <sd_ble_gatts_characteristic_add>
   1d85c:	1e07      	subs	r7, r0, #0
	APP_ERROR_CHECK(err); //OK
   1d85e:	d002      	beq.n	1d866 <_ZN17ConnectionManager11getInstanceEv+0x196>
   1d860:	217e      	movs	r1, #126	; 0x7e
   1d862:	4a53      	ldr	r2, [pc, #332]	; (1d9b0 <_ZN17ConnectionManager11getInstanceEv+0x2e0>)
   1d864:	e757      	b.n	1d716 <_ZN17ConnectionManager11getInstanceEv+0x46>
	//Initialize GAP and GATT
	GAPController::bleConfigureGAP();
	GATTController::bleMeshServiceInit();

	//Config->
	doHandshake = true;
   1d866:	2301      	movs	r3, #1

	//init vars
	pendingConnection = NULL;
   1d868:	6020      	str	r0, [r4, #0]
	//Initialize GAP and GATT
	GAPController::bleConfigureGAP();
	GATTController::bleMeshServiceInit();

	//Config->
	doHandshake = true;
   1d86a:	7323      	strb	r3, [r4, #12]

	//init vars
	pendingConnection = NULL;
	freeOutConnections = Config->meshMaxOutConnections;
   1d86c:	f003 fadc 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d870:	3034      	adds	r0, #52	; 0x34
   1d872:	7803      	ldrb	r3, [r0, #0]
   1d874:	73a3      	strb	r3, [r4, #14]
	freeInConnections = Config->meshMaxInConnections;
   1d876:	f003 fad7 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d87a:	3033      	adds	r0, #51	; 0x33
   1d87c:	7803      	ldrb	r3, [r0, #0]

	//Create all connections
	inConnection = connections[0] = new Connection(0, this, node, Connection::CONNECTION_DIRECTION_IN);
   1d87e:	2088      	movs	r0, #136	; 0x88
	doHandshake = true;

	//init vars
	pendingConnection = NULL;
	freeOutConnections = Config->meshMaxOutConnections;
	freeInConnections = Config->meshMaxInConnections;
   1d880:	7363      	strb	r3, [r4, #13]

	//Create all connections
	inConnection = connections[0] = new Connection(0, this, node, Connection::CONNECTION_DIRECTION_IN);
   1d882:	0080      	lsls	r0, r0, #2
   1d884:	f003 fccc 	bl	21220 <_Znwj>
   1d888:	6863      	ldr	r3, [r4, #4]
   1d88a:	1c05      	adds	r5, r0, #0
   1d88c:	6003      	str	r3, [r0, #0]


Connection::Connection(u8 id, ConnectionManager* cm, Node* node, ConnectionDirection direction)
{
	this->cm = cm;
	this->connectionId = id;
   1d88e:	7307      	strb	r7, [r0, #12]
	this->node = node;
	this->direction = direction;
   1d890:	7347      	strb	r7, [r0, #13]
//The parallel flow of multiple connections


Connection::Connection(u8 id, ConnectionManager* cm, Node* node, ConnectionDirection direction)
{
	this->cm = cm;
   1d892:	6044      	str	r4, [r0, #4]
	this->connectionId = id;
	this->node = node;
	this->direction = direction;
	this->packetSendQueue = new PacketQueue(packetSendBuffer, PACKET_SEND_BUFFER_SIZE);
   1d894:	2018      	movs	r0, #24
   1d896:	f003 fcc3 	bl	21220 <_Znwj>

PacketQueue::PacketQueue(u8* buffer, u16 bufferLength)
{
	this->_numElements = 0;
	this->bufferStart = buffer;
	this->bufferEnd = buffer + bufferLength - 1; //FIXME: workaround to avoid 1byte overflow of the packet queue
   1d89a:	1c2b      	adds	r3, r5, #0
   1d89c:	1c06      	adds	r6, r0, #0
   1d89e:	3341      	adds	r3, #65	; 0x41
   1d8a0:	33ff      	adds	r3, #255	; 0xff
   1d8a2:	6073      	str	r3, [r6, #4]
   1d8a4:	1c28      	adds	r0, r5, #0
	this->bufferLength = bufferLength - 1; // s.o.
   1d8a6:	232c      	movs	r3, #44	; 0x2c
	this->readPointer = this->bufferStart;
	this->writePointer = this->bufferStart;

	writePointer[0] = 0;

	memset(buffer, 0, bufferLength);
   1d8a8:	2296      	movs	r2, #150	; 0x96
   1d8aa:	3015      	adds	r0, #21
PacketQueue::PacketQueue(u8* buffer, u16 bufferLength)
{
	this->_numElements = 0;
	this->bufferStart = buffer;
	this->bufferEnd = buffer + bufferLength - 1; //FIXME: workaround to avoid 1byte overflow of the packet queue
	this->bufferLength = bufferLength - 1; // s.o.
   1d8ac:	33ff      	adds	r3, #255	; 0xff
	this->readPointer = this->bufferStart;
	this->writePointer = this->bufferStart;

	writePointer[0] = 0;

	memset(buffer, 0, bufferLength);
   1d8ae:	1c39      	adds	r1, r7, #0
#include <cstring>
}

PacketQueue::PacketQueue(u8* buffer, u16 bufferLength)
{
	this->_numElements = 0;
   1d8b0:	82b7      	strh	r7, [r6, #20]
	this->bufferStart = buffer;
	this->bufferEnd = buffer + bufferLength - 1; //FIXME: workaround to avoid 1byte overflow of the packet queue
	this->bufferLength = bufferLength - 1; // s.o.
   1d8b2:	8133      	strh	r3, [r6, #8]
	this->readPointer = this->bufferStart;
	this->writePointer = this->bufferStart;

	writePointer[0] = 0;

	memset(buffer, 0, bufferLength);
   1d8b4:	0052      	lsls	r2, r2, #1
}

PacketQueue::PacketQueue(u8* buffer, u16 bufferLength)
{
	this->_numElements = 0;
	this->bufferStart = buffer;
   1d8b6:	6030      	str	r0, [r6, #0]
	this->bufferEnd = buffer + bufferLength - 1; //FIXME: workaround to avoid 1byte overflow of the packet queue
	this->bufferLength = bufferLength - 1; // s.o.

	this->readPointer = this->bufferStart;
   1d8b8:	60f0      	str	r0, [r6, #12]
	this->writePointer = this->bufferStart;
   1d8ba:	6130      	str	r0, [r6, #16]

	writePointer[0] = 0;

	memset(buffer, 0, bufferLength);
   1d8bc:	f003 fec7 	bl	2164e <memset>
   1d8c0:	1c2b      	adds	r3, r5, #0
   1d8c2:	33fc      	adds	r3, #252	; 0xfc
   1d8c4:	649e      	str	r6, [r3, #72]	; 0x48

	ResetValues();
   1d8c6:	1c28      	adds	r0, r5, #0
   1d8c8:	f002 f948 	bl	1fb5c <_ZN10Connection11ResetValuesEv>

	for(int i=1; i<=Config->meshMaxOutConnections; i++){
   1d8cc:	2301      	movs	r3, #1
   1d8ce:	9300      	str	r3, [sp, #0]
   1d8d0:	232c      	movs	r3, #44	; 0x2c
   1d8d2:	1c27      	adds	r7, r4, #0
   1d8d4:	33ff      	adds	r3, #255	; 0xff
	pendingConnection = NULL;
	freeOutConnections = Config->meshMaxOutConnections;
	freeInConnections = Config->meshMaxInConnections;

	//Create all connections
	inConnection = connections[0] = new Connection(0, this, node, Connection::CONNECTION_DIRECTION_IN);
   1d8d6:	6225      	str	r5, [r4, #32]
   1d8d8:	6125      	str	r5, [r4, #16]
   1d8da:	3714      	adds	r7, #20
   1d8dc:	9301      	str	r3, [sp, #4]

	for(int i=1; i<=Config->meshMaxOutConnections; i++){
   1d8de:	f003 faa3 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1d8e2:	3034      	adds	r0, #52	; 0x34
   1d8e4:	7803      	ldrb	r3, [r0, #0]
   1d8e6:	9a00      	ldr	r2, [sp, #0]
   1d8e8:	429a      	cmp	r2, r3
   1d8ea:	dc2f      	bgt.n	1d94c <_ZN17ConnectionManager11getInstanceEv+0x27c>
		connections[i] = outConnections[i-1] = new Connection(i, this, node, Connection::CONNECTION_DIRECTION_OUT);
   1d8ec:	2088      	movs	r0, #136	; 0x88
   1d8ee:	0080      	lsls	r0, r0, #2
   1d8f0:	f003 fc96 	bl	21220 <_Znwj>
   1d8f4:	6863      	ldr	r3, [r4, #4]
   1d8f6:	1c05      	adds	r5, r0, #0
   1d8f8:	6003      	str	r3, [r0, #0]


Connection::Connection(u8 id, ConnectionManager* cm, Node* node, ConnectionDirection direction)
{
	this->cm = cm;
	this->connectionId = id;
   1d8fa:	466b      	mov	r3, sp
   1d8fc:	781b      	ldrb	r3, [r3, #0]
//The parallel flow of multiple connections


Connection::Connection(u8 id, ConnectionManager* cm, Node* node, ConnectionDirection direction)
{
	this->cm = cm;
   1d8fe:	6044      	str	r4, [r0, #4]
	this->connectionId = id;
   1d900:	7303      	strb	r3, [r0, #12]
	this->node = node;
	this->direction = direction;
   1d902:	2301      	movs	r3, #1
   1d904:	7343      	strb	r3, [r0, #13]
	this->packetSendQueue = new PacketQueue(packetSendBuffer, PACKET_SEND_BUFFER_SIZE);
   1d906:	2018      	movs	r0, #24
   1d908:	f003 fc8a 	bl	21220 <_Znwj>

PacketQueue::PacketQueue(u8* buffer, u16 bufferLength)
{
	this->_numElements = 0;
	this->bufferStart = buffer;
	this->bufferEnd = buffer + bufferLength - 1; //FIXME: workaround to avoid 1byte overflow of the packet queue
   1d90c:	1c2b      	adds	r3, r5, #0
   1d90e:	1c06      	adds	r6, r0, #0
   1d910:	3341      	adds	r3, #65	; 0x41
   1d912:	33ff      	adds	r3, #255	; 0xff
   1d914:	6073      	str	r3, [r6, #4]
	this->bufferLength = bufferLength - 1; // s.o.
   1d916:	466b      	mov	r3, sp
   1d918:	1c28      	adds	r0, r5, #0
#include <cstring>
}

PacketQueue::PacketQueue(u8* buffer, u16 bufferLength)
{
	this->_numElements = 0;
   1d91a:	2100      	movs	r1, #0
	this->readPointer = this->bufferStart;
	this->writePointer = this->bufferStart;

	writePointer[0] = 0;

	memset(buffer, 0, bufferLength);
   1d91c:	2296      	movs	r2, #150	; 0x96
PacketQueue::PacketQueue(u8* buffer, u16 bufferLength)
{
	this->_numElements = 0;
	this->bufferStart = buffer;
	this->bufferEnd = buffer + bufferLength - 1; //FIXME: workaround to avoid 1byte overflow of the packet queue
	this->bufferLength = bufferLength - 1; // s.o.
   1d91e:	889b      	ldrh	r3, [r3, #4]
   1d920:	3015      	adds	r0, #21
#include <cstring>
}

PacketQueue::PacketQueue(u8* buffer, u16 bufferLength)
{
	this->_numElements = 0;
   1d922:	82b1      	strh	r1, [r6, #20]
	this->bufferStart = buffer;
	this->bufferEnd = buffer + bufferLength - 1; //FIXME: workaround to avoid 1byte overflow of the packet queue
	this->bufferLength = bufferLength - 1; // s.o.
   1d924:	8133      	strh	r3, [r6, #8]
	this->readPointer = this->bufferStart;
	this->writePointer = this->bufferStart;

	writePointer[0] = 0;

	memset(buffer, 0, bufferLength);
   1d926:	0052      	lsls	r2, r2, #1
}

PacketQueue::PacketQueue(u8* buffer, u16 bufferLength)
{
	this->_numElements = 0;
	this->bufferStart = buffer;
   1d928:	6030      	str	r0, [r6, #0]
	this->bufferEnd = buffer + bufferLength - 1; //FIXME: workaround to avoid 1byte overflow of the packet queue
	this->bufferLength = bufferLength - 1; // s.o.

	this->readPointer = this->bufferStart;
   1d92a:	60f0      	str	r0, [r6, #12]
	this->writePointer = this->bufferStart;
   1d92c:	6130      	str	r0, [r6, #16]

	writePointer[0] = 0;

	memset(buffer, 0, bufferLength);
   1d92e:	f003 fe8e 	bl	2164e <memset>
   1d932:	1c2b      	adds	r3, r5, #0
   1d934:	33fc      	adds	r3, #252	; 0xfc
   1d936:	649e      	str	r6, [r3, #72]	; 0x48

	ResetValues();
   1d938:	1c28      	adds	r0, r5, #0
   1d93a:	f002 f90f 	bl	1fb5c <_ZN10Connection11ResetValuesEv>
	freeInConnections = Config->meshMaxInConnections;

	//Create all connections
	inConnection = connections[0] = new Connection(0, this, node, Connection::CONNECTION_DIRECTION_IN);

	for(int i=1; i<=Config->meshMaxOutConnections; i++){
   1d93e:	9b00      	ldr	r3, [sp, #0]
		connections[i] = outConnections[i-1] = new Connection(i, this, node, Connection::CONNECTION_DIRECTION_OUT);
   1d940:	603d      	str	r5, [r7, #0]
	freeInConnections = Config->meshMaxInConnections;

	//Create all connections
	inConnection = connections[0] = new Connection(0, this, node, Connection::CONNECTION_DIRECTION_IN);

	for(int i=1; i<=Config->meshMaxOutConnections; i++){
   1d942:	3301      	adds	r3, #1
		connections[i] = outConnections[i-1] = new Connection(i, this, node, Connection::CONNECTION_DIRECTION_OUT);
   1d944:	613d      	str	r5, [r7, #16]
	freeInConnections = Config->meshMaxInConnections;

	//Create all connections
	inConnection = connections[0] = new Connection(0, this, node, Connection::CONNECTION_DIRECTION_IN);

	for(int i=1; i<=Config->meshMaxOutConnections; i++){
   1d946:	9300      	str	r3, [sp, #0]
   1d948:	3704      	adds	r7, #4
   1d94a:	e7c8      	b.n	1d8de <_ZN17ConnectionManager11getInstanceEv+0x20e>
	connectionEncryptedCallback = callback;
}

void GAPController::setDisconnectionHandler(void (*callback)(ble_evt_t* bleEvent))
{
	disconnectionCallback = callback;
   1d94c:	4a19      	ldr	r2, [pc, #100]	; (1d9b4 <_ZN17ConnectionManager11getInstanceEv+0x2e4>)
   1d94e:	4b1a      	ldr	r3, [pc, #104]	; (1d9b8 <_ZN17ConnectionManager11getInstanceEv+0x2e8>)
   1d950:	601a      	str	r2, [r3, #0]
	connectingTimeoutCallback = callback;
}

void GAPController::setConnectionSuccessfulHandler(void (*callback)(ble_evt_t* bleEvent))
{
	connectionSuccessCallback = callback;
   1d952:	4a1a      	ldr	r2, [pc, #104]	; (1d9bc <_ZN17ConnectionManager11getInstanceEv+0x2ec>)
   1d954:	4b1a      	ldr	r3, [pc, #104]	; (1d9c0 <_ZN17ConnectionManager11getInstanceEv+0x2f0>)
   1d956:	601a      	str	r2, [r3, #0]
}

void GAPController::setConnectionEncryptedHandler(void (*callback)(ble_evt_t* bleEvent))
{
	connectionEncryptedCallback = callback;
   1d958:	4a1a      	ldr	r2, [pc, #104]	; (1d9c4 <_ZN17ConnectionManager11getInstanceEv+0x2f4>)
   1d95a:	4b1b      	ldr	r3, [pc, #108]	; (1d9c8 <_ZN17ConnectionManager11getInstanceEv+0x2f8>)
   1d95c:	601a      	str	r2, [r3, #0]
	return false;
}

void GAPController::setConnectingTimeoutHandler(void (*callback)(ble_evt_t* bleEvent))
{
	connectingTimeoutCallback = callback;
   1d95e:	4a1b      	ldr	r2, [pc, #108]	; (1d9cc <_ZN17ConnectionManager11getInstanceEv+0x2fc>)
   1d960:	4b1b      	ldr	r3, [pc, #108]	; (1d9d0 <_ZN17ConnectionManager11getInstanceEv+0x300>)
   1d962:	601a      	str	r2, [r3, #0]

}

void GATTController::setMessageReceivedCallback(void (*callback)(ble_evt_t* bleEvent))
{
	messageReceivedCallback = callback;
   1d964:	4a1b      	ldr	r2, [pc, #108]	; (1d9d4 <_ZN17ConnectionManager11getInstanceEv+0x304>)
   1d966:	4b1c      	ldr	r3, [pc, #112]	; (1d9d8 <_ZN17ConnectionManager11getInstanceEv+0x308>)
   1d968:	601a      	str	r2, [r3, #0]
}

void GATTController::setHandleDiscoveredCallback(void (*callback)(u16 connectionHandle, u16 characteristicHandle))
{
	handleDiscoveredCallback = callback;
   1d96a:	4a1c      	ldr	r2, [pc, #112]	; (1d9dc <_ZN17ConnectionManager11getInstanceEv+0x30c>)
   1d96c:	4b1c      	ldr	r3, [pc, #112]	; (1d9e0 <_ZN17ConnectionManager11getInstanceEv+0x310>)
   1d96e:	601a      	str	r2, [r3, #0]
}

void GATTController::setDataTransmittedCallback(void (*callback)(ble_evt_t* bleEvent))
{
	dataTransmittedCallback = callback;
   1d970:	4b1c      	ldr	r3, [pc, #112]	; (1d9e4 <_ZN17ConnectionManager11getInstanceEv+0x314>)
   1d972:	4a1d      	ldr	r2, [pc, #116]	; (1d9e8 <_ZN17ConnectionManager11getInstanceEv+0x318>)
   1d974:	601a      	str	r2, [r3, #0]
   1d976:	4b03      	ldr	r3, [pc, #12]	; (1d984 <_ZN17ConnectionManager11getInstanceEv+0x2b4>)
   1d978:	601c      	str	r4, [r3, #0]
			}
			return instance;
   1d97a:	4b02      	ldr	r3, [pc, #8]	; (1d984 <_ZN17ConnectionManager11getInstanceEv+0x2b4>)
   1d97c:	6818      	ldr	r0, [r3, #0]
		}
   1d97e:	b019      	add	sp, #100	; 0x64
   1d980:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1d982:	46c0      	nop			; (mov r8, r8)
   1d984:	2000339c 	.word	0x2000339c
   1d988:	200033d8 	.word	0x200033d8
   1d98c:	00022954 	.word	0x00022954
   1d990:	000228a3 	.word	0x000228a3
   1d994:	2000358a 	.word	0x2000358a
   1d998:	00022944 	.word	0x00022944
   1d99c:	200035a0 	.word	0x200035a0
   1d9a0:	2000359e 	.word	0x2000359e
   1d9a4:	00022957 	.word	0x00022957
   1d9a8:	00001524 	.word	0x00001524
   1d9ac:	20003594 	.word	0x20003594
   1d9b0:	000228be 	.word	0x000228be
   1d9b4:	0001db7f 	.word	0x0001db7f
   1d9b8:	20003398 	.word	0x20003398
   1d9bc:	0001e2f5 	.word	0x0001e2f5
   1d9c0:	200033bc 	.word	0x200033bc
   1d9c4:	0001dc1b 	.word	0x0001dc1b
   1d9c8:	2000338c 	.word	0x2000338c
   1d9cc:	0001da17 	.word	0x0001da17
   1d9d0:	200033b8 	.word	0x200033b8
   1d9d4:	00020299 	.word	0x00020299
   1d9d8:	200033a8 	.word	0x200033a8
   1d9dc:	0001dbe9 	.word	0x0001dbe9
   1d9e0:	200033b0 	.word	0x200033b0
   1d9e4:	200033a4 	.word	0x200033a4
   1d9e8:	00020389 	.word	0x00020389

0001d9ec <sd_ble_gap_disconnect>:
   1d9ec:	df76      	svc	118	; 0x76
   1d9ee:	4770      	bx	lr

0001d9f0 <_ZN4NodeD1Ev.lto_priv.93>:
	i8 rssi;
	u32 receivedTimeDs;
	advPacketPayloadJoinMeV0 payload;
}joinMeBufferPacket;

class Node:
   1d9f0:	4770      	bx	lr
	...

0001d9f4 <_ZThn4_N4NodeD1Ev.lto_priv.95>:
   1d9f4:	b408      	push	{r3}
   1d9f6:	4b02      	ldr	r3, [pc, #8]	; (1da00 <_ZThn4_N4NodeD1Ev.lto_priv.95+0xc>)
   1d9f8:	469c      	mov	ip, r3
   1d9fa:	3804      	subs	r0, #4
   1d9fc:	bc08      	pop	{r3}
   1d9fe:	4760      	bx	ip
   1da00:	0001d9f1 	.word	0x0001d9f1

0001da04 <_ZThn8_N4NodeD1Ev.lto_priv.96>:
   1da04:	b408      	push	{r3}
   1da06:	4b02      	ldr	r3, [pc, #8]	; (1da10 <_ZThn8_N4NodeD1Ev.lto_priv.96+0xc>)
   1da08:	469c      	mov	ip, r3
   1da0a:	3808      	subs	r0, #8
   1da0c:	bc08      	pop	{r3}
   1da0e:	4760      	bx	ip
   1da10:	0001d9f1 	.word	0x0001d9f1

0001da14 <_ZN4Node17RadioEventHandlerEb>:
     {
     LedGreen->On();
     }

     }*/
}
   1da14:	4770      	bx	lr

0001da16 <_ZN17ConnectionManager24ConnectingTimeoutHandlerEP9ble_evt_t>:
	connection->ResetValues();
}

//Called when a connecting request times out
void ConnectionManager::ConnectingTimeoutHandler(ble_evt_t* bleEvent)
{
   1da16:	b538      	push	{r3, r4, r5, lr}
   1da18:	1c05      	adds	r5, r0, #0
	ConnectionManager* cm = ConnectionManager::getInstance();
   1da1a:	f7ff fe59 	bl	1d6d0 <_ZN17ConnectionManager11getInstanceEv>
   1da1e:	1c04      	adds	r4, r0, #0

	if(cm->pendingConnection != NULL){
   1da20:	6800      	ldr	r0, [r0, #0]
   1da22:	2800      	cmp	r0, #0
   1da24:	d003      	beq.n	1da2e <_ZN17ConnectionManager24ConnectingTimeoutHandlerEP9ble_evt_t+0x18>
		cm->pendingConnection->ResetValues();
   1da26:	f002 f899 	bl	1fb5c <_ZN10Connection11ResetValuesEv>

		cm->pendingConnection = NULL;
   1da2a:	2300      	movs	r3, #0
   1da2c:	6023      	str	r3, [r4, #0]
	}

	cm->connectionManagerCallback->ConnectingTimeoutHandler(bleEvent);
   1da2e:	68a0      	ldr	r0, [r4, #8]
   1da30:	1c29      	adds	r1, r5, #0
   1da32:	6803      	ldr	r3, [r0, #0]
   1da34:	691b      	ldr	r3, [r3, #16]
   1da36:	4798      	blx	r3

}
   1da38:	bd38      	pop	{r3, r4, r5, pc}

0001da3a <_ZN4NodeD0Ev.lto_priv.94>:
   1da3a:	b510      	push	{r4, lr}
   1da3c:	1c04      	adds	r4, r0, #0
   1da3e:	f003 fc01 	bl	21244 <_ZdlPv>
   1da42:	1c20      	adds	r0, r4, #0
   1da44:	bd10      	pop	{r4, pc}
	...

0001da48 <_ZThn4_N4NodeD0Ev>:
   1da48:	b408      	push	{r3}
   1da4a:	4b02      	ldr	r3, [pc, #8]	; (1da54 <_ZThn4_N4NodeD0Ev+0xc>)
   1da4c:	469c      	mov	ip, r3
   1da4e:	3804      	subs	r0, #4
   1da50:	bc08      	pop	{r3}
   1da52:	4760      	bx	ip
   1da54:	0001da3b 	.word	0x0001da3b

0001da58 <_ZThn8_N4NodeD0Ev.lto_priv.97>:
   1da58:	b408      	push	{r3}
   1da5a:	4b02      	ldr	r3, [pc, #8]	; (1da64 <_ZThn8_N4NodeD0Ev.lto_priv.97+0xc>)
   1da5c:	469c      	mov	ip, r3
   1da5e:	3808      	subs	r0, #8
   1da60:	bc08      	pop	{r3}
   1da62:	4760      	bx	ip
   1da64:	0001da3b 	.word	0x0001da3b

0001da68 <_ZN17ConnectionManager25FinalDisconnectionHandlerEP10Connection>:
	}
}

//Is called when a connection is closed after
void ConnectionManager::FinalDisconnectionHandler(Connection* connection)
{
   1da68:	b570      	push	{r4, r5, r6, lr}
	ConnectionManager* cm = ConnectionManager::getInstance();

	Logger::getInstance().logError(Logger::errorTypes::CUSTOM, Logger::customErrorTypes::FINAL_DISCONNECTION, connection->partnerId);
   1da6a:	26e8      	movs	r6, #232	; 0xe8
	}
}

//Is called when a connection is closed after
void ConnectionManager::FinalDisconnectionHandler(Connection* connection)
{
   1da6c:	1c0c      	adds	r4, r1, #0
	ConnectionManager* cm = ConnectionManager::getInstance();
   1da6e:	f7ff fe2f 	bl	1d6d0 <_ZN17ConnectionManager11getInstanceEv>

	Logger::getInstance().logError(Logger::errorTypes::CUSTOM, Logger::customErrorTypes::FINAL_DISCONNECTION, connection->partnerId);
   1da72:	0076      	lsls	r6, r6, #1
}

//Is called when a connection is closed after
void ConnectionManager::FinalDisconnectionHandler(Connection* connection)
{
	ConnectionManager* cm = ConnectionManager::getInstance();
   1da74:	1c05      	adds	r5, r0, #0

	Logger::getInstance().logError(Logger::errorTypes::CUSTOM, Logger::customErrorTypes::FINAL_DISCONNECTION, connection->partnerId);
   1da76:	f7ff fc0f 	bl	1d298 <_ZN6Logger11getInstanceEv>
   1da7a:	5ba3      	ldrh	r3, [r4, r6]
   1da7c:	2102      	movs	r1, #2
   1da7e:	2203      	movs	r2, #3
   1da80:	f001 ffd2 	bl	1fa28 <_ZN6Logger8logErrorENS_10errorTypesEmt>

	//LOG disconnection reason
	Logger::getInstance().logError(Logger::errorTypes::HCI_ERROR, connection->disconnectionReason, connection->partnerId);
   1da84:	f7ff fc08 	bl	1d298 <_ZN6Logger11getInstanceEv>
   1da88:	5ba3      	ldrh	r3, [r4, r6]
   1da8a:	7ae2      	ldrb	r2, [r4, #11]
   1da8c:	2101      	movs	r1, #1
   1da8e:	f001 ffcb 	bl	1fa28 <_ZN6Logger8logErrorENS_10errorTypesEmt>

	logt("CM", "Connection %u to %u DISCONNECTED", connection->connectionId, connection->partnerId);

	if (connection->direction == Connection::CONNECTION_DIRECTION_IN) cm->freeInConnections++;
   1da92:	7b63      	ldrb	r3, [r4, #13]
   1da94:	2b00      	cmp	r3, #0
   1da96:	d103      	bne.n	1daa0 <_ZN17ConnectionManager25FinalDisconnectionHandlerEP10Connection+0x38>
   1da98:	7b6b      	ldrb	r3, [r5, #13]
   1da9a:	3301      	adds	r3, #1
   1da9c:	736b      	strb	r3, [r5, #13]
   1da9e:	e002      	b.n	1daa6 <_ZN17ConnectionManager25FinalDisconnectionHandlerEP10Connection+0x3e>
	else cm->freeOutConnections++;
   1daa0:	7bab      	ldrb	r3, [r5, #14]
   1daa2:	3301      	adds	r3, #1
   1daa4:	73ab      	strb	r3, [r5, #14]

	//If this was the pending connection, we clear it
	if(cm->pendingConnection == connection) cm->pendingConnection = NULL;
   1daa6:	682b      	ldr	r3, [r5, #0]
   1daa8:	42a3      	cmp	r3, r4
   1daaa:	d101      	bne.n	1dab0 <_ZN17ConnectionManager25FinalDisconnectionHandlerEP10Connection+0x48>
   1daac:	2300      	movs	r3, #0
   1daae:	602b      	str	r3, [r5, #0]
{
	//Reason?
	logt("DISCONNECT", "Disconnected %u from connId:%u, HCI:%u %s", partnerId, connectionId, disconnectionReason, Logger::getHciErrorString(disconnectionReason));

	//Save connection state before disconnection
	if(connectionState != ConnectionState::DISCONNECTED) connectionStateBeforeDisconnection = connectionState;
   1dab0:	7a23      	ldrb	r3, [r4, #8]
   1dab2:	2b00      	cmp	r3, #0
   1dab4:	d000      	beq.n	1dab8 <_ZN17ConnectionManager25FinalDisconnectionHandlerEP10Connection+0x50>
   1dab6:	72a3      	strb	r3, [r4, #10]
	connectionState = ConnectionState::DISCONNECTED;
   1dab8:	2300      	movs	r3, #0

	//Notify the connection itself
	connection->DisconnectionHandler();

	//Notify the callback of the disconnection (The Node probably)
	cm->connectionManagerCallback->DisconnectionHandler(connection);
   1daba:	68a8      	ldr	r0, [r5, #8]
   1dabc:	7223      	strb	r3, [r4, #8]
   1dabe:	6803      	ldr	r3, [r0, #0]
   1dac0:	1c21      	adds	r1, r4, #0
   1dac2:	689b      	ldr	r3, [r3, #8]
   1dac4:	4798      	blx	r3

	//Reset connection variables
	connection->ResetValues();
   1dac6:	1c20      	adds	r0, r4, #0
   1dac8:	f002 f848 	bl	1fb5c <_ZN10Connection11ResetValuesEv>
}
   1dacc:	bd70      	pop	{r4, r5, r6, pc}

0001dace <_ZN17ConnectionManager17GetPendingPacketsEv>:
			GAPController::RequestConnectionParameterUpdate(outConnections[i]->connectionHandle, connectionInterval, connectionInterval, 0, Config->meshConnectionSupervisionTimeout);
		}
	}
}

u16 ConnectionManager::GetPendingPackets(){
   1dace:	b570      	push	{r4, r5, r6, lr}
	u16 pendingPackets = 0;
	for(int i=0; i<Config->meshMaxConnections; i++){
   1dad0:	2400      	movs	r4, #0
			GAPController::RequestConnectionParameterUpdate(outConnections[i]->connectionHandle, connectionInterval, connectionInterval, 0, Config->meshConnectionSupervisionTimeout);
		}
	}
}

u16 ConnectionManager::GetPendingPackets(){
   1dad2:	1c06      	adds	r6, r0, #0
	u16 pendingPackets = 0;
   1dad4:	1c25      	adds	r5, r4, #0
	for(int i=0; i<Config->meshMaxConnections; i++){
   1dad6:	f003 f9a7 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1dada:	3035      	adds	r0, #53	; 0x35
   1dadc:	7803      	ldrb	r3, [r0, #0]
   1dade:	429c      	cmp	r4, r3
   1dae0:	da13      	bge.n	1db0a <_ZN17ConnectionManager17GetPendingPacketsEv+0x3c>
}

//Returns the number of packets that this connection has not yet sent
u16 Connection::GetPendingPackets(){
	return packetSendQueue->_numElements
			+ (currentClusterInfoUpdatePacket.header.messageType == MESSAGE_TYPE_CLUSTER_INFO_UPDATE ? 1 : 0);
   1dae2:	225e      	movs	r2, #94	; 0x5e
   1dae4:	00a3      	lsls	r3, r4, #2
   1dae6:	18f3      	adds	r3, r6, r3
		pendingPackets += connections[i]->GetPendingPackets();
   1dae8:	6a1b      	ldr	r3, [r3, #32]
   1daea:	32ff      	adds	r2, #255	; 0xff
   1daec:	5c98      	ldrb	r0, [r3, r2]
   1daee:	3a5d      	subs	r2, #93	; 0x5d
   1daf0:	3aff      	subs	r2, #255	; 0xff
   1daf2:	4390      	bics	r0, r2
   1daf4:	382e      	subs	r0, #46	; 0x2e
   1daf6:	4242      	negs	r2, r0
   1daf8:	4150      	adcs	r0, r2
   1dafa:	33fc      	adds	r3, #252	; 0xfc
   1dafc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
	}
}

u16 ConnectionManager::GetPendingPackets(){
	u16 pendingPackets = 0;
	for(int i=0; i<Config->meshMaxConnections; i++){
   1dafe:	3401      	adds	r4, #1
   1db00:	8a9b      	ldrh	r3, [r3, #20]
   1db02:	18c0      	adds	r0, r0, r3
		pendingPackets += connections[i]->GetPendingPackets();
   1db04:	1945      	adds	r5, r0, r5
   1db06:	b2ad      	uxth	r5, r5
   1db08:	e7e5      	b.n	1dad6 <_ZN17ConnectionManager17GetPendingPacketsEv+0x8>
	}
	return pendingPackets;
}
   1db0a:	1c28      	adds	r0, r5, #0
   1db0c:	bd70      	pop	{r4, r5, r6, pc}

0001db0e <_ZN17ConnectionManager31ForceDisconnectOtherConnectionsEP10Connection>:
}

//Disconnects either all connections or all except one
//Cluster updates from this connection should be ignored
void ConnectionManager::ForceDisconnectOtherConnections(Connection* connection)
{
   1db0e:	3020      	adds	r0, #32
   1db10:	b570      	push	{r4, r5, r6, lr}
   1db12:	1c0e      	adds	r6, r1, #0
   1db14:	1c04      	adds	r4, r0, #0
	for (int i = 0; i < Config->meshMaxOutConnections+1; i++)
   1db16:	2500      	movs	r5, #0
   1db18:	f003 f986 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1db1c:	3034      	adds	r0, #52	; 0x34
   1db1e:	7803      	ldrb	r3, [r0, #0]
   1db20:	42ab      	cmp	r3, r5
   1db22:	db0e      	blt.n	1db42 <_ZN17ConnectionManager31ForceDisconnectOtherConnectionsEP10Connection+0x34>
	{
		if (connections[i] != connection && !connections[i]->isDisconnected()){
   1db24:	6820      	ldr	r0, [r4, #0]
   1db26:	42b0      	cmp	r0, r6
   1db28:	d002      	beq.n	1db30 <_ZN17ConnectionManager31ForceDisconnectOtherConnectionsEP10Connection+0x22>
   1db2a:	7a03      	ldrb	r3, [r0, #8]
   1db2c:	2b00      	cmp	r3, #0
   1db2e:	d102      	bne.n	1db36 <_ZN17ConnectionManager31ForceDisconnectOtherConnectionsEP10Connection+0x28>

//Disconnects either all connections or all except one
//Cluster updates from this connection should be ignored
void ConnectionManager::ForceDisconnectOtherConnections(Connection* connection)
{
	for (int i = 0; i < Config->meshMaxOutConnections+1; i++)
   1db30:	3501      	adds	r5, #1
   1db32:	3404      	adds	r4, #4
   1db34:	e7f0      	b.n	1db18 <_ZN17ConnectionManager31ForceDisconnectOtherConnectionsEP10Connection+0xa>
	{
		if (connections[i] != connection && !connections[i]->isDisconnected()){
			connections[i]->Disconnect();
   1db36:	f001 fffd 	bl	1fb34 <_ZN10Connection10DisconnectEv>
			connections[i]->connectionStateBeforeDisconnection = Connection::ConnectionState::DISCONNECTED;
   1db3a:	2300      	movs	r3, #0
   1db3c:	6822      	ldr	r2, [r4, #0]
   1db3e:	7293      	strb	r3, [r2, #10]
   1db40:	e7f6      	b.n	1db30 <_ZN17ConnectionManager31ForceDisconnectOtherConnectionsEP10Connection+0x22>
		}
	}
}
   1db42:	bd70      	pop	{r4, r5, r6, pc}

0001db44 <_ZN17ConnectionManager23GetConnectionFromHandleEt>:
}

//Looks through all connections for the right handle and then passes the event to that connection
Connection* ConnectionManager::GetConnectionFromHandle(u16 connectionHandle)
{
	if (connectionHandle == inConnection->connectionHandle)
   1db44:	22e9      	movs	r2, #233	; 0xe9
	return NULL;
}

//Looks through all connections for the right handle and then passes the event to that connection
Connection* ConnectionManager::GetConnectionFromHandle(u16 connectionHandle)
{
   1db46:	b570      	push	{r4, r5, r6, lr}
	if (connectionHandle == inConnection->connectionHandle)
   1db48:	6903      	ldr	r3, [r0, #16]
   1db4a:	0052      	lsls	r2, r2, #1
   1db4c:	5a9a      	ldrh	r2, [r3, r2]
   1db4e:	428a      	cmp	r2, r1
   1db50:	d013      	beq.n	1db7a <_ZN17ConnectionManager23GetConnectionFromHandleEt+0x36>
   1db52:	1c0e      	adds	r6, r1, #0
   1db54:	1c05      	adds	r5, r0, #0
   1db56:	2400      	movs	r4, #0
		return inConnection;
	for (int i = 0; i < Config->meshMaxOutConnections; i++)
   1db58:	f003 f966 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1db5c:	3034      	adds	r0, #52	; 0x34
   1db5e:	7803      	ldrb	r3, [r0, #0]
   1db60:	429c      	cmp	r4, r3
   1db62:	da09      	bge.n	1db78 <_ZN17ConnectionManager23GetConnectionFromHandleEt+0x34>
	{
		if (outConnections[i]->connectionHandle == connectionHandle)
   1db64:	22e9      	movs	r2, #233	; 0xe9
   1db66:	00a3      	lsls	r3, r4, #2
   1db68:	18eb      	adds	r3, r5, r3
   1db6a:	695b      	ldr	r3, [r3, #20]
   1db6c:	0052      	lsls	r2, r2, #1
   1db6e:	5a9a      	ldrh	r2, [r3, r2]
   1db70:	42b2      	cmp	r2, r6
   1db72:	d002      	beq.n	1db7a <_ZN17ConnectionManager23GetConnectionFromHandleEt+0x36>
//Looks through all connections for the right handle and then passes the event to that connection
Connection* ConnectionManager::GetConnectionFromHandle(u16 connectionHandle)
{
	if (connectionHandle == inConnection->connectionHandle)
		return inConnection;
	for (int i = 0; i < Config->meshMaxOutConnections; i++)
   1db74:	3401      	adds	r4, #1
   1db76:	e7ef      	b.n	1db58 <_ZN17ConnectionManager23GetConnectionFromHandleEt+0x14>
	{
		if (outConnections[i]->connectionHandle == connectionHandle)
			return outConnections[i];
	}
	return NULL;
   1db78:	2300      	movs	r3, #0
}
   1db7a:	1c18      	adds	r0, r3, #0
   1db7c:	bd70      	pop	{r4, r5, r6, pc}

0001db7e <_ZN17ConnectionManager20DisconnectionHandlerEP9ble_evt_t>:
//Is called whenever a connection had been established and is now disconnected
//due to a timeout, deliberate disconnection by the localhost, remote, etc,...
//We might however decide to sustain it. it will only be lost after
//the finalDisconnectionHander is called
void ConnectionManager::DisconnectionHandler(ble_evt_t* bleEvent)
{
   1db7e:	b570      	push	{r4, r5, r6, lr}
   1db80:	1c06      	adds	r6, r0, #0

	ConnectionManager* cm = ConnectionManager::getInstance();
   1db82:	f7ff fda5 	bl	1d6d0 <_ZN17ConnectionManager11getInstanceEv>
	Connection* connection = cm->GetConnectionFromHandle(bleEvent->evt.gap_evt.conn_handle);
   1db86:	88b1      	ldrh	r1, [r6, #4]
//We might however decide to sustain it. it will only be lost after
//the finalDisconnectionHander is called
void ConnectionManager::DisconnectionHandler(ble_evt_t* bleEvent)
{

	ConnectionManager* cm = ConnectionManager::getInstance();
   1db88:	1c05      	adds	r5, r0, #0
	Connection* connection = cm->GetConnectionFromHandle(bleEvent->evt.gap_evt.conn_handle);
   1db8a:	f7ff ffdb 	bl	1db44 <_ZN17ConnectionManager23GetConnectionFromHandleEt>
   1db8e:	1e04      	subs	r4, r0, #0

	if(connection == NULL) return;
   1db90:	d029      	beq.n	1dbe6 <_ZN17ConnectionManager20DisconnectionHandlerEP9ble_evt_t+0x68>

	//Save disconnction reason
	connection->disconnectionReason = bleEvent->evt.gap_evt.params.disconnected.reason;
   1db92:	7a33      	ldrb	r3, [r6, #8]
   1db94:	72c3      	strb	r3, [r0, #11]
	//(e.g. If it's been handshaked for more than 7 seconds and ran into a timeout)
	if(
			connection->handshakeDone()
			&& cm->node->appTimerDs - connection->connectionHandshakedTimestampDs > SEC_TO_DS(60)
			//&& bleEvent->evt.gap_evt.params.disconnected.reason == BLE_HCI_CONNECTION_TIMEOUT => problematic since there are multiple reasons, including the ominous BLE_GATTC_EVT_TIMEOUT
			&& connection->reestablishTimeSec != 0
   1db96:	7a03      	ldrb	r3, [r0, #8]
   1db98:	2b03      	cmp	r3, #3
   1db9a:	d920      	bls.n	1dbde <_ZN17ConnectionManager20DisconnectionHandlerEP9ble_evt_t+0x60>

	//Check if the connection should be sustained
	//(e.g. If it's been handshaked for more than 7 seconds and ran into a timeout)
	if(
			connection->handshakeDone()
			&& cm->node->appTimerDs - connection->connectionHandshakedTimestampDs > SEC_TO_DS(60)
   1db9c:	22f0      	movs	r2, #240	; 0xf0
   1db9e:	686b      	ldr	r3, [r5, #4]
   1dba0:	0052      	lsls	r2, r2, #1
   1dba2:	5882      	ldr	r2, [r0, r2]
   1dba4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
   1dba6:	1a9b      	subs	r3, r3, r2
   1dba8:	2296      	movs	r2, #150	; 0x96
   1dbaa:	0092      	lsls	r2, r2, #2
   1dbac:	4293      	cmp	r3, r2
   1dbae:	d916      	bls.n	1dbde <_ZN17ConnectionManager20DisconnectionHandlerEP9ble_evt_t+0x60>
			//&& bleEvent->evt.gap_evt.params.disconnected.reason == BLE_HCI_CONNECTION_TIMEOUT => problematic since there are multiple reasons, including the ominous BLE_GATTC_EVT_TIMEOUT
			&& connection->reestablishTimeSec != 0
   1dbb0:	23f4      	movs	r3, #244	; 0xf4
   1dbb2:	005b      	lsls	r3, r3, #1
   1dbb4:	5ac3      	ldrh	r3, [r0, r3]
   1dbb6:	2b00      	cmp	r3, #0
   1dbb8:	d011      	beq.n	1dbde <_ZN17ConnectionManager20DisconnectionHandlerEP9ble_evt_t+0x60>
	){
		logt("CM", "Connection should be sustained");

		//Log connection suspension
		Logger::getInstance().logError(Logger::errorTypes::CUSTOM, Logger::customErrorTypes::TRYING_CONNECTION_SUSTAIN, connection->partnerId);
   1dbba:	f7ff fb6d 	bl	1d298 <_ZN6Logger11getInstanceEv>
   1dbbe:	23e8      	movs	r3, #232	; 0xe8
   1dbc0:	2102      	movs	r1, #2
   1dbc2:	005b      	lsls	r3, r3, #1
   1dbc4:	5ae3      	ldrh	r3, [r4, r3]
   1dbc6:	1c0a      	adds	r2, r1, #0
   1dbc8:	f001 ff2e 	bl	1fa28 <_ZN6Logger8logErrorENS_10errorTypesEmt>

		//Mark the connection as reestablishing, the state machine of the node
		//will then try to reestablish it.
		connection->disconnectedTimestampDs = cm->node->appTimerDs;
   1dbcc:	686b      	ldr	r3, [r5, #4]
   1dbce:	6e5a      	ldr	r2, [r3, #100]	; 0x64
   1dbd0:	23f2      	movs	r3, #242	; 0xf2
   1dbd2:	005b      	lsls	r3, r3, #1
   1dbd4:	50e2      	str	r2, [r4, r3]
		connection->connectionState = Connection::ConnectionState::REESTABLISHING;
   1dbd6:	3be0      	subs	r3, #224	; 0xe0
   1dbd8:	3bff      	subs	r3, #255	; 0xff
   1dbda:	7223      	strb	r3, [r4, #8]
   1dbdc:	e003      	b.n	1dbe6 <_ZN17ConnectionManager20DisconnectionHandlerEP9ble_evt_t+0x68>
	}
	//Connection will not be sustained
	else
	{
		cm->FinalDisconnectionHandler(connection);
   1dbde:	1c28      	adds	r0, r5, #0
   1dbe0:	1c21      	adds	r1, r4, #0
   1dbe2:	f7ff ff41 	bl	1da68 <_ZN17ConnectionManager25FinalDisconnectionHandlerEP10Connection>
	}
}
   1dbe6:	bd70      	pop	{r4, r5, r6, pc}

0001dbe8 <_ZN17ConnectionManager24handleDiscoveredCallbackEtt>:
	}
}

//When the mesh handle has been discovered
void ConnectionManager::handleDiscoveredCallback(u16 connectionHandle, u16 characteristicHandle)
{
   1dbe8:	b570      	push	{r4, r5, r6, lr}
   1dbea:	1c06      	adds	r6, r0, #0
   1dbec:	1c0d      	adds	r5, r1, #0
	ConnectionManager* cm = ConnectionManager::getInstance();
   1dbee:	f7ff fd6f 	bl	1d6d0 <_ZN17ConnectionManager11getInstanceEv>

	Connection* connection = cm->GetConnectionFromHandle(connectionHandle);
   1dbf2:	1c31      	adds	r1, r6, #0
}

//When the mesh handle has been discovered
void ConnectionManager::handleDiscoveredCallback(u16 connectionHandle, u16 characteristicHandle)
{
	ConnectionManager* cm = ConnectionManager::getInstance();
   1dbf4:	1c04      	adds	r4, r0, #0

	Connection* connection = cm->GetConnectionFromHandle(connectionHandle);
   1dbf6:	f7ff ffa5 	bl	1db44 <_ZN17ConnectionManager23GetConnectionFromHandleEt>
	if (connection != NULL)
   1dbfa:	2800      	cmp	r0, #0
   1dbfc:	d00c      	beq.n	1dc18 <_ZN17ConnectionManager24handleDiscoveredCallbackEtt+0x30>
	{
		connection->writeCharacteristicHandle = characteristicHandle;
   1dbfe:	23ee      	movs	r3, #238	; 0xee
   1dc00:	005b      	lsls	r3, r3, #1
   1dc02:	52c5      	strh	r5, [r0, r3]

		if(cm->doHandshake) connection->StartHandshake();
   1dc04:	7b21      	ldrb	r1, [r4, #12]
   1dc06:	2900      	cmp	r1, #0
   1dc08:	d002      	beq.n	1dc10 <_ZN17ConnectionManager24handleDiscoveredCallbackEtt+0x28>
   1dc0a:	f001 ff43 	bl	1fa94 <_ZN10Connection14StartHandshakeEv>
   1dc0e:	e003      	b.n	1dc18 <_ZN17ConnectionManager24handleDiscoveredCallbackEtt+0x30>
		else {
			cm->connectionManagerCallback->ConnectionSuccessfulHandler(NULL);
   1dc10:	68a0      	ldr	r0, [r4, #8]
   1dc12:	6803      	ldr	r3, [r0, #0]
   1dc14:	68db      	ldr	r3, [r3, #12]
   1dc16:	4798      	blx	r3
		}
	}
}
   1dc18:	bd70      	pop	{r4, r5, r6, pc}

0001dc1a <_ZN17ConnectionManager26ConnectionEncryptedHandlerEP9ble_evt_t>:
	return NULL;
}

//When a connection changes to encrypted
void ConnectionManager::ConnectionEncryptedHandler(ble_evt_t* bleEvent)
{
   1dc1a:	b538      	push	{r3, r4, r5, lr}
   1dc1c:	1c05      	adds	r5, r0, #0
	ConnectionManager* cm = ConnectionManager::getInstance();
   1dc1e:	f7ff fd57 	bl	1d6d0 <_ZN17ConnectionManager11getInstanceEv>
	Connection* c = cm->GetConnectionFromHandle(bleEvent->evt.gap_evt.conn_handle);
   1dc22:	88a9      	ldrh	r1, [r5, #4]
}

//When a connection changes to encrypted
void ConnectionManager::ConnectionEncryptedHandler(ble_evt_t* bleEvent)
{
	ConnectionManager* cm = ConnectionManager::getInstance();
   1dc24:	1c04      	adds	r4, r0, #0
	Connection* c = cm->GetConnectionFromHandle(bleEvent->evt.gap_evt.conn_handle);
   1dc26:	f7ff ff8d 	bl	1db44 <_ZN17ConnectionManager23GetConnectionFromHandleEt>

	logt("CM", "Connection id %u is now encrypted", c->connectionId);
	c->encryptionState = Connection::EncryptionState::ENCRYPTED;
   1dc2a:	2302      	movs	r3, #2
   1dc2c:	7243      	strb	r3, [r0, #9]

	//We are peripheral
	if(c->direction == Connection::CONNECTION_DIRECTION_IN)
   1dc2e:	7b43      	ldrb	r3, [r0, #13]
   1dc30:	2b00      	cmp	r3, #0
   1dc32:	d103      	bne.n	1dc3c <_ZN17ConnectionManager26ConnectionEncryptedHandlerEP9ble_evt_t+0x22>
	{
		if(!cm->doHandshake){
   1dc34:	7b23      	ldrb	r3, [r4, #12]
   1dc36:	2b00      	cmp	r3, #0
   1dc38:	d10a      	bne.n	1dc50 <_ZN17ConnectionManager26ConnectionEncryptedHandlerEP9ble_evt_t+0x36>
   1dc3a:	e007      	b.n	1dc4c <_ZN17ConnectionManager26ConnectionEncryptedHandlerEP9ble_evt_t+0x32>
			c->connectionState = Connection::ConnectionState::HANDSHAKE_DONE;
		}
	}
	//We are central
	else if(c->direction == Connection::CONNECTION_DIRECTION_OUT)
   1dc3c:	2b01      	cmp	r3, #1
   1dc3e:	d107      	bne.n	1dc50 <_ZN17ConnectionManager26ConnectionEncryptedHandlerEP9ble_evt_t+0x36>
	{
		if(cm->doHandshake)
   1dc40:	7b23      	ldrb	r3, [r4, #12]
   1dc42:	2b00      	cmp	r3, #0
   1dc44:	d002      	beq.n	1dc4c <_ZN17ConnectionManager26ConnectionEncryptedHandlerEP9ble_evt_t+0x32>
		{
			c->StartHandshake();
   1dc46:	f001 ff25 	bl	1fa94 <_ZN10Connection14StartHandshakeEv>
   1dc4a:	e001      	b.n	1dc50 <_ZN17ConnectionManager26ConnectionEncryptedHandlerEP9ble_evt_t+0x36>
		}
		//If the handshake is disabled, we just set the variable
		else
		{
			c->connectionState = Connection::ConnectionState::HANDSHAKE_DONE;
   1dc4c:	2304      	movs	r3, #4
   1dc4e:	7203      	strb	r3, [r0, #8]
		}
	}
}
   1dc50:	bd38      	pop	{r3, r4, r5, pc}

0001dc52 <_ZN17ConnectionManager11QueuePacketEP10ConnectionPhtb>:
	{
		SendMessageOverConnections(originConnection, data, dataLength, reliable);
	}
}

void ConnectionManager::QueuePacket(Connection* connection, u8* data, u16 dataLength, bool reliable){
   1dc52:	b5f0      	push	{r4, r5, r6, r7, lr}
   1dc54:	b0e9      	sub	sp, #420	; 0x1a4
   1dc56:	1c1d      	adds	r5, r3, #0
   1dc58:	ab6e      	add	r3, sp, #440	; 0x1b8
   1dc5a:	781b      	ldrb	r3, [r3, #0]
   1dc5c:	1c0e      	adds	r6, r1, #0
   1dc5e:	9202      	str	r2, [sp, #8]
   1dc60:	9303      	str	r3, [sp, #12]
	//Print packet as hex
	char stringBuffer[400];
	Logger::getInstance().convertBufferToHexString(data, dataLength, stringBuffer, 400);
   1dc62:	f7ff fb19 	bl	1d298 <_ZN6Logger11getInstanceEv>
   1dc66:	23c8      	movs	r3, #200	; 0xc8
   1dc68:	005b      	lsls	r3, r3, #1
   1dc6a:	1c2a      	adds	r2, r5, #0
   1dc6c:	9300      	str	r3, [sp, #0]
   1dc6e:	9902      	ldr	r1, [sp, #8]
   1dc70:	ab04      	add	r3, sp, #16
   1dc72:	f001 fead 	bl	1f9d0 <_ZN6Logger24convertBufferToHexStringEPhmPct>

	logt("CONN_DATA", "PUT_PACKET(%d):len:%d,type:%d, hex: %s",connection->connectionId, dataLength, data[0], stringBuffer);

	//Save packet
	bool putResult = connection->packetSendQueue->Put(data, dataLength, reliable);
   1dc76:	1c33      	adds	r3, r6, #0
   1dc78:	33fc      	adds	r3, #252	; 0xfc
   1dc7a:	6c9c      	ldr	r4, [r3, #72]	; 0x48
   1dc7c:	b2ed      	uxtb	r5, r5
	//Keep one byte for (un)reliable flag, one byte for sizeField and one byte to not let read and write pointers overlap
	u8 elementSize = dataLength + 1 + 1 + 1;

	//If the writePointer is ahead (or at the same point) of the read pointer && bufferSpace
	//at the end is not enough && dataSize at the beginning is enough
	if (writePointer >= readPointer && bufferEnd - writePointer <= elementSize && readPointer - bufferStart >= elementSize)
   1dc7e:	6921      	ldr	r1, [r4, #16]
   1dc80:	68e2      	ldr	r2, [r4, #12]

//Put does only allow data sizes up to 200 byte per element
bool PacketQueue::Put(u8* data, u8 dataLength, bool reliable)
{
	//Keep one byte for (un)reliable flag, one byte for sizeField and one byte to not let read and write pointers overlap
	u8 elementSize = dataLength + 1 + 1 + 1;
   1dc82:	1ceb      	adds	r3, r5, #3
   1dc84:	b2db      	uxtb	r3, r3

	//If the writePointer is ahead (or at the same point) of the read pointer && bufferSpace
	//at the end is not enough && dataSize at the beginning is enough
	if (writePointer >= readPointer && bufferEnd - writePointer <= elementSize && readPointer - bufferStart >= elementSize)
   1dc86:	4291      	cmp	r1, r2
   1dc88:	d30b      	bcc.n	1dca2 <_ZN17ConnectionManager11QueuePacketEP10ConnectionPhtb+0x50>
   1dc8a:	6860      	ldr	r0, [r4, #4]
   1dc8c:	1a40      	subs	r0, r0, r1
   1dc8e:	4298      	cmp	r0, r3
   1dc90:	dc07      	bgt.n	1dca2 <_ZN17ConnectionManager11QueuePacketEP10ConnectionPhtb+0x50>
   1dc92:	6820      	ldr	r0, [r4, #0]
   1dc94:	1a17      	subs	r7, r2, r0
   1dc96:	429f      	cmp	r7, r3
   1dc98:	db03      	blt.n	1dca2 <_ZN17ConnectionManager11QueuePacketEP10ConnectionPhtb+0x50>
	{
		writePointer = bufferStart;
		writePointer[0] = 0;
   1dc9a:	2300      	movs	r3, #0

	//If the writePointer is ahead (or at the same point) of the read pointer && bufferSpace
	//at the end is not enough && dataSize at the beginning is enough
	if (writePointer >= readPointer && bufferEnd - writePointer <= elementSize && readPointer - bufferStart >= elementSize)
	{
		writePointer = bufferStart;
   1dc9c:	6120      	str	r0, [r4, #16]
		writePointer[0] = 0;
   1dc9e:	7003      	strb	r3, [r0, #0]
   1dca0:	e005      	b.n	1dcae <_ZN17ConnectionManager11QueuePacketEP10ConnectionPhtb+0x5c>
   1dca2:	18cb      	adds	r3, r1, r3
	}

	//Check if Buffer can hold the item
	else if (readPointer <= writePointer && writePointer + elementSize >= bufferEnd)
   1dca4:	428a      	cmp	r2, r1
   1dca6:	d800      	bhi.n	1dcaa <_ZN17ConnectionManager11QueuePacketEP10ConnectionPhtb+0x58>
   1dca8:	6862      	ldr	r2, [r4, #4]
	{
		return false;
	}
	else if (readPointer > writePointer && writePointer + elementSize >= readPointer)
   1dcaa:	429a      	cmp	r2, r3
   1dcac:	d916      	bls.n	1dcdc <_ZN17ConnectionManager11QueuePacketEP10ConnectionPhtb+0x8a>
	{
		return false;
	}

	this->writePointer[0] = dataLength+1; //+1 for the reliable flag
   1dcae:	6922      	ldr	r2, [r4, #16]
   1dcb0:	1c6b      	adds	r3, r5, #1
   1dcb2:	7013      	strb	r3, [r2, #0]
	this->writePointer[1] = reliable ? 1 : 0;
   1dcb4:	466a      	mov	r2, sp
   1dcb6:	6923      	ldr	r3, [r4, #16]
   1dcb8:	7b12      	ldrb	r2, [r2, #12]
	memcpy(this->writePointer + 2, data, dataLength);
   1dcba:	9902      	ldr	r1, [sp, #8]
	{
		return false;
	}

	this->writePointer[0] = dataLength+1; //+1 for the reliable flag
	this->writePointer[1] = reliable ? 1 : 0;
   1dcbc:	705a      	strb	r2, [r3, #1]
	memcpy(this->writePointer + 2, data, dataLength);
   1dcbe:	6923      	ldr	r3, [r4, #16]
   1dcc0:	1c2a      	adds	r2, r5, #0
   1dcc2:	1c98      	adds	r0, r3, #2
   1dcc4:	f003 fca6 	bl	21614 <memcpy>

	this->writePointer += dataLength + 2;
   1dcc8:	6923      	ldr	r3, [r4, #16]
   1dcca:	3502      	adds	r5, #2
   1dccc:	195d      	adds	r5, r3, r5
	//Set length to 0 for next datafield
	this->writePointer[0] = 0;
   1dcce:	2300      	movs	r3, #0

	this->writePointer[0] = dataLength+1; //+1 for the reliable flag
	this->writePointer[1] = reliable ? 1 : 0;
	memcpy(this->writePointer + 2, data, dataLength);

	this->writePointer += dataLength + 2;
   1dcd0:	6125      	str	r5, [r4, #16]
	//Set length to 0 for next datafield
	this->writePointer[0] = 0;
   1dcd2:	702b      	strb	r3, [r5, #0]

	_numElements++;
   1dcd4:	8aa3      	ldrh	r3, [r4, #20]
   1dcd6:	3301      	adds	r3, #1
   1dcd8:	82a3      	strh	r3, [r4, #20]
   1dcda:	e004      	b.n	1dce6 <_ZN17ConnectionManager11QueuePacketEP10ConnectionPhtb+0x94>

	if(!putResult) {
		connection->droppedPackets++;
   1dcdc:	2286      	movs	r2, #134	; 0x86
   1dcde:	0092      	lsls	r2, r2, #2
   1dce0:	5ab3      	ldrh	r3, [r6, r2]
   1dce2:	3301      	adds	r3, #1
   1dce4:	52b3      	strh	r3, [r6, r2]
		//TODO: Error handling: What should happen when the queue is full?
		//Currently, additional packets are dropped
		logt("ERROR", "Send queue is already full");
	}
}
   1dce6:	b069      	add	sp, #420	; 0x1a4
   1dce8:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001dcea <_ZN17ConnectionManager26SendMessageOverConnectionsEP10ConnectionPhtb>:
	}
}

//Send a message over all connections, except one connection
void ConnectionManager::SendMessageOverConnections(Connection* ignoreConnection, u8* data, u16 dataLength, bool reliable)
{
   1dcea:	b5f0      	push	{r4, r5, r6, r7, lr}
   1dcec:	1c05      	adds	r5, r0, #0
   1dcee:	1c17      	adds	r7, r2, #0
	for (int i = 0; i < Config->meshMaxConnections; i++)
   1dcf0:	2400      	movs	r4, #0
	}
}

//Send a message over all connections, except one connection
void ConnectionManager::SendMessageOverConnections(Connection* ignoreConnection, u8* data, u16 dataLength, bool reliable)
{
   1dcf2:	b085      	sub	sp, #20
   1dcf4:	1c1e      	adds	r6, r3, #0
   1dcf6:	ab0a      	add	r3, sp, #40	; 0x28
   1dcf8:	781b      	ldrb	r3, [r3, #0]
   1dcfa:	9102      	str	r1, [sp, #8]
   1dcfc:	9303      	str	r3, [sp, #12]
	for (int i = 0; i < Config->meshMaxConnections; i++)
   1dcfe:	f003 f893 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1dd02:	3035      	adds	r0, #53	; 0x35
   1dd04:	7803      	ldrb	r3, [r0, #0]
   1dd06:	429c      	cmp	r4, r3
   1dd08:	da0a      	bge.n	1dd20 <_ZN17ConnectionManager26SendMessageOverConnectionsEP10ConnectionPhtb+0x36>
   1dd0a:	00a3      	lsls	r3, r4, #2
   1dd0c:	18eb      	adds	r3, r5, r3
	{
		if (connections[i] != ignoreConnection && connections[i]->handshakeDone()){
   1dd0e:	6a19      	ldr	r1, [r3, #32]
   1dd10:	9b02      	ldr	r3, [sp, #8]
   1dd12:	4299      	cmp	r1, r3
   1dd14:	d002      	beq.n	1dd1c <_ZN17ConnectionManager26SendMessageOverConnectionsEP10ConnectionPhtb+0x32>
   1dd16:	7a0b      	ldrb	r3, [r1, #8]
   1dd18:	2b03      	cmp	r3, #3
   1dd1a:	d806      	bhi.n	1dd2a <_ZN17ConnectionManager26SendMessageOverConnectionsEP10ConnectionPhtb+0x40>
}

//Send a message over all connections, except one connection
void ConnectionManager::SendMessageOverConnections(Connection* ignoreConnection, u8* data, u16 dataLength, bool reliable)
{
	for (int i = 0; i < Config->meshMaxConnections; i++)
   1dd1c:	3401      	adds	r4, #1
   1dd1e:	e7ee      	b.n	1dcfe <_ZN17ConnectionManager26SendMessageOverConnectionsEP10ConnectionPhtb+0x14>
		if (connections[i] != ignoreConnection && connections[i]->handshakeDone()){
			QueuePacket(connections[i], data, dataLength, reliable);
		}
	}

	fillTransmitBuffers();
   1dd20:	1c28      	adds	r0, r5, #0
   1dd22:	f001 ffe1 	bl	1fce8 <_ZN17ConnectionManager19fillTransmitBuffersEv>
}
   1dd26:	b005      	add	sp, #20
   1dd28:	bdf0      	pop	{r4, r5, r6, r7, pc}
void ConnectionManager::SendMessageOverConnections(Connection* ignoreConnection, u8* data, u16 dataLength, bool reliable)
{
	for (int i = 0; i < Config->meshMaxConnections; i++)
	{
		if (connections[i] != ignoreConnection && connections[i]->handshakeDone()){
			QueuePacket(connections[i], data, dataLength, reliable);
   1dd2a:	9b03      	ldr	r3, [sp, #12]
   1dd2c:	1c28      	adds	r0, r5, #0
   1dd2e:	9300      	str	r3, [sp, #0]
   1dd30:	1c3a      	adds	r2, r7, #0
   1dd32:	1c33      	adds	r3, r6, #0
   1dd34:	f7ff ff8d 	bl	1dc52 <_ZN17ConnectionManager11QueuePacketEP10ConnectionPhtb>
   1dd38:	e7f0      	b.n	1dd1c <_ZN17ConnectionManager26SendMessageOverConnectionsEP10ConnectionPhtb+0x32>
	...

0001dd3c <_ZN4Node16UpdateGlobalTimeEv>:
	app_timer_cnt_get(&rtc1);
	app_timer_cnt_diff_compute(rtc1, previousRtcTicks, &passedTime);
	previousRtcTicks = rtc1;

	//Update the global time seconds and save the remainder for the next iteration
	passedTime += globalTimeRemainderTicks;
   1dd3c:	1c01      	adds	r1, r0, #0
        //Go to the next state
        ChangeState(nextDiscoveryState);
    }
}

void Node::UpdateGlobalTime(){
   1dd3e:	b510      	push	{r4, lr}
 *
 * @return     Current value of the RTC1 counter.
 */
static __INLINE uint32_t rtc1_counter_get(void)
{
    return NRF_RTC1->COUNTER;
   1dd40:	4b09      	ldr	r3, [pc, #36]	; (1dd68 <_ZN4Node16UpdateGlobalTimeEv+0x2c>)
   1dd42:	4a0a      	ldr	r2, [pc, #40]	; (1dd6c <_ZN4Node16UpdateGlobalTimeEv+0x30>)
	app_timer_cnt_get(&rtc1);
	app_timer_cnt_diff_compute(rtc1, previousRtcTicks, &passedTime);
	previousRtcTicks = rtc1;

	//Update the global time seconds and save the remainder for the next iteration
	passedTime += globalTimeRemainderTicks;
   1dd44:	3160      	adds	r1, #96	; 0x60
   1dd46:	58d2      	ldr	r2, [r2, r3]
 *
 * @return     Number of ticks elapsed from ticks_old to ticks_now.
 */
static __INLINE uint32_t ticks_diff_get(uint32_t ticks_now, uint32_t ticks_old)
{
    return ((ticks_now - ticks_old) & MAX_RTC_COUNTER_VAL);
   1dd48:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
void Node::UpdateGlobalTime(){
	//Request the Realtimeclock counter
	u32 rtc1, passedTime;
	app_timer_cnt_get(&rtc1);
	app_timer_cnt_diff_compute(rtc1, previousRtcTicks, &passedTime);
	previousRtcTicks = rtc1;
   1dd4a:	65c2      	str	r2, [r0, #92]	; 0x5c
   1dd4c:	1ad3      	subs	r3, r2, r3
   1dd4e:	021b      	lsls	r3, r3, #8

	//Update the global time seconds and save the remainder for the next iteration
	passedTime += globalTimeRemainderTicks;
   1dd50:	880a      	ldrh	r2, [r1, #0]
   1dd52:	0a1b      	lsrs	r3, r3, #8
	globalTimeSec += passedTime / APP_TIMER_CLOCK_FREQ;
   1dd54:	6d84      	ldr	r4, [r0, #88]	; 0x58
	app_timer_cnt_get(&rtc1);
	app_timer_cnt_diff_compute(rtc1, previousRtcTicks, &passedTime);
	previousRtcTicks = rtc1;

	//Update the global time seconds and save the remainder for the next iteration
	passedTime += globalTimeRemainderTicks;
   1dd56:	189b      	adds	r3, r3, r2
	globalTimeSec += passedTime / APP_TIMER_CLOCK_FREQ;
   1dd58:	0bda      	lsrs	r2, r3, #15
	globalTimeRemainderTicks = passedTime % APP_TIMER_CLOCK_FREQ;
   1dd5a:	045b      	lsls	r3, r3, #17
	app_timer_cnt_diff_compute(rtc1, previousRtcTicks, &passedTime);
	previousRtcTicks = rtc1;

	//Update the global time seconds and save the remainder for the next iteration
	passedTime += globalTimeRemainderTicks;
	globalTimeSec += passedTime / APP_TIMER_CLOCK_FREQ;
   1dd5c:	18a2      	adds	r2, r4, r2
	globalTimeRemainderTicks = passedTime % APP_TIMER_CLOCK_FREQ;
   1dd5e:	0c5b      	lsrs	r3, r3, #17
	app_timer_cnt_diff_compute(rtc1, previousRtcTicks, &passedTime);
	previousRtcTicks = rtc1;

	//Update the global time seconds and save the remainder for the next iteration
	passedTime += globalTimeRemainderTicks;
	globalTimeSec += passedTime / APP_TIMER_CLOCK_FREQ;
   1dd60:	6582      	str	r2, [r0, #88]	; 0x58
	globalTimeRemainderTicks = passedTime % APP_TIMER_CLOCK_FREQ;
   1dd62:	800b      	strh	r3, [r1, #0]
}
   1dd64:	bd10      	pop	{r4, pc}
   1dd66:	46c0      	nop			; (mov r8, r8)
   1dd68:	00000504 	.word	0x00000504
   1dd6c:	40011000 	.word	0x40011000

0001dd70 <_ZN4Node17SaveConfigurationEv>:
 */
#define ________________CONFIGURATION___________________
#pragma region configuration

void Node::SaveConfiguration()
{
   1dd70:	b530      	push	{r4, r5, lr}
   1dd72:	1c04      	adds	r4, r0, #0
   1dd74:	b085      	sub	sp, #20
	Storage::getInstance().QueuedWrite((u8*) &persistentConfig, sizeof(NodeConfiguration), 0, this);
   1dd76:	f002 ff75 	bl	20c64 <_ZN7Storage11getInstanceEv>
   1dd7a:	1c23      	adds	r3, r4, #0
   1dd7c:	3318      	adds	r3, #24

void Storage::QueuedWrite(u8* data, u16 dataLength, u32 blockId, StorageEventListener* callback)
{
	taskitem task;
	task.data = data;
	task.dataLength = dataLength;
   1dd7e:	466a      	mov	r2, sp
}

void Storage::QueuedWrite(u8* data, u16 dataLength, u32 blockId, StorageEventListener* callback)
{
	taskitem task;
	task.data = data;
   1dd80:	9302      	str	r3, [sp, #8]
	task.dataLength = dataLength;
   1dd82:	2328      	movs	r3, #40	; 0x28
   1dd84:	8053      	strh	r3, [r2, #2]
	task.storageBlock = blockId;
   1dd86:	2300      	movs	r3, #0
   1dd88:	9301      	str	r3, [sp, #4]
	task.callback = callback;
	task.operation = operation::OPERATION_WRITE;
   1dd8a:	3301      	adds	r3, #1
   1dd8c:	8013      	strh	r3, [r2, #0]

	taskQueue->Put((u8*)&task, sizeof(taskitem));
   1dd8e:	1c03      	adds	r3, r0, #0
   1dd90:	1c05      	adds	r5, r0, #0
   1dd92:	33a4      	adds	r3, #164	; 0xa4
   1dd94:	6818      	ldr	r0, [r3, #0]
   1dd96:	4669      	mov	r1, sp
   1dd98:	3408      	adds	r4, #8
{
	taskitem task;
	task.data = data;
	task.dataLength = dataLength;
	task.storageBlock = blockId;
	task.callback = callback;
   1dd9a:	9403      	str	r4, [sp, #12]
	task.operation = operation::OPERATION_WRITE;

	taskQueue->Put((u8*)&task, sizeof(taskitem));
   1dd9c:	f001 f9a4 	bl	1f0e8 <_ZN11SimpleQueue3PutEPhm.constprop.15>

	ProcessQueue();
   1dda0:	1c28      	adds	r0, r5, #0
   1dda2:	f001 fbb5 	bl	1f510 <_ZN7Storage12ProcessQueueEv>
}
   1dda6:	b005      	add	sp, #20
   1dda8:	bd30      	pop	{r4, r5, pc}
	...

0001ddac <_ZN4Node18UpdateJoinMePacketEv>:
#define ________________ADVERTISING___________________
#pragma region advertising

//Start to broadcast our own clusterInfo, set ackID if we want to have an ack or an ack response
void Node::UpdateJoinMePacket()
{
   1ddac:	b570      	push	{r4, r5, r6, lr}

	//Build a JOIN_ME packet and set it in the advertisement data
	advPacketPayloadJoinMeV0 packet;

	packet.sender = this->persistentConfig.nodeId;
	packet.clusterId = this->clusterId;
   1ddae:	1c02      	adds	r2, r0, #0
	SetTerminalTitle();

	//Build a JOIN_ME packet and set it in the advertisement data
	advPacketPayloadJoinMeV0 packet;

	packet.sender = this->persistentConfig.nodeId;
   1ddb0:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
#define ________________ADVERTISING___________________
#pragma region advertising

//Start to broadcast our own clusterInfo, set ackID if we want to have an ack or an ack response
void Node::UpdateJoinMePacket()
{
   1ddb2:	b088      	sub	sp, #32
	SetTerminalTitle();

	//Build a JOIN_ME packet and set it in the advertisement data
	advPacketPayloadJoinMeV0 packet;

	packet.sender = this->persistentConfig.nodeId;
   1ddb4:	ac03      	add	r4, sp, #12
   1ddb6:	8023      	strh	r3, [r4, #0]
	packet.clusterId = this->clusterId;
   1ddb8:	230e      	movs	r3, #14
   1ddba:	327c      	adds	r2, #124	; 0x7c
   1ddbc:	8812      	ldrh	r2, [r2, #0]
   1ddbe:	446b      	add	r3, sp
   1ddc0:	801a      	strh	r2, [r3, #0]
   1ddc2:	1c02      	adds	r2, r0, #0
   1ddc4:	327e      	adds	r2, #126	; 0x7e
   1ddc6:	8812      	ldrh	r2, [r2, #0]
	packet.clusterSize = this->clusterSize;
	packet.freeInConnections = cm->freeInConnections;
   1ddc8:	4e1c      	ldr	r6, [pc, #112]	; (1de3c <_ZN4Node18UpdateJoinMePacketEv+0x90>)

	//Build a JOIN_ME packet and set it in the advertisement data
	advPacketPayloadJoinMeV0 packet;

	packet.sender = this->persistentConfig.nodeId;
	packet.clusterId = this->clusterId;
   1ddca:	805a      	strh	r2, [r3, #2]
	packet.clusterSize = this->clusterSize;
   1ddcc:	1c03      	adds	r3, r0, #0
   1ddce:	3378      	adds	r3, #120	; 0x78
   1ddd0:	881b      	ldrh	r3, [r3, #0]
#define ________________ADVERTISING___________________
#pragma region advertising

//Start to broadcast our own clusterInfo, set ackID if we want to have an ack or an ack response
void Node::UpdateJoinMePacket()
{
   1ddd2:	1c05      	adds	r5, r0, #0
	//Build a JOIN_ME packet and set it in the advertisement data
	advPacketPayloadJoinMeV0 packet;

	packet.sender = this->persistentConfig.nodeId;
	packet.clusterId = this->clusterId;
	packet.clusterSize = this->clusterSize;
   1ddd4:	80e3      	strh	r3, [r4, #6]
	packet.freeInConnections = cm->freeInConnections;
   1ddd6:	2307      	movs	r3, #7
   1ddd8:	6830      	ldr	r0, [r6, #0]
   1ddda:	7b42      	ldrb	r2, [r0, #13]
   1dddc:	401a      	ands	r2, r3
   1ddde:	1c11      	adds	r1, r2, #0
   1dde0:	7a22      	ldrb	r2, [r4, #8]
   1dde2:	439a      	bics	r2, r3
   1dde4:	430a      	orrs	r2, r1
   1dde6:	7222      	strb	r2, [r4, #8]
	packet.freeOutConnections = cm->freeOutConnections;
   1dde8:	7a21      	ldrb	r1, [r4, #8]
   1ddea:	7b82      	ldrb	r2, [r0, #14]
   1ddec:	400b      	ands	r3, r1
   1ddee:	00d2      	lsls	r2, r2, #3
   1ddf0:	4313      	orrs	r3, r2
   1ddf2:	7223      	strb	r3, [r4, #8]

	packet.txPower = Config->radioTransmitPower;
   1ddf4:	f003 f818 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1ddf8:	3080      	adds	r0, #128	; 0x80
   1ddfa:	7803      	ldrb	r3, [r0, #0]
	packet.deviceType = persistentConfig.deviceType;
	packet.hopsToSink = cm->GetHopsToShortestSink(NULL);
   1ddfc:	2100      	movs	r1, #0
	packet.clusterId = this->clusterId;
	packet.clusterSize = this->clusterSize;
	packet.freeInConnections = cm->freeInConnections;
	packet.freeOutConnections = cm->freeOutConnections;

	packet.txPower = Config->radioTransmitPower;
   1ddfe:	72a3      	strb	r3, [r4, #10]
	packet.deviceType = persistentConfig.deviceType;
   1de00:	1c2b      	adds	r3, r5, #0
   1de02:	333a      	adds	r3, #58	; 0x3a
   1de04:	781b      	ldrb	r3, [r3, #0]
	packet.hopsToSink = cm->GetHopsToShortestSink(NULL);
   1de06:	6830      	ldr	r0, [r6, #0]
	packet.clusterSize = this->clusterSize;
	packet.freeInConnections = cm->freeInConnections;
	packet.freeOutConnections = cm->freeOutConnections;

	packet.txPower = Config->radioTransmitPower;
	packet.deviceType = persistentConfig.deviceType;
   1de08:	72e3      	strb	r3, [r4, #11]
	packet.hopsToSink = cm->GetHopsToShortestSink(NULL);
   1de0a:	f001 ff11 	bl	1fc30 <_ZN17ConnectionManager21GetHopsToShortestSinkEP10Connection>
	}
}

u16 GATTController::getMeshWriteHandle()
{
	return meshService.sendMessageCharacteristicHandle.value_handle;
   1de0e:	4b0c      	ldr	r3, [pc, #48]	; (1de40 <_ZN4Node18UpdateJoinMePacketEv+0x94>)
   1de10:	81a0      	strh	r0, [r4, #12]
	packet.meshWriteHandle = GATTController::getMeshWriteHandle();
   1de12:	895b      	ldrh	r3, [r3, #10]
	} else {
		packet.ackField = 0;
	}

	sizedData data;
	data.data = (u8*) &packet;
   1de14:	a801      	add	r0, sp, #4
	packet.freeOutConnections = cm->freeOutConnections;

	packet.txPower = Config->radioTransmitPower;
	packet.deviceType = persistentConfig.deviceType;
	packet.hopsToSink = cm->GetHopsToShortestSink(NULL);
	packet.meshWriteHandle = GATTController::getMeshWriteHandle();
   1de16:	81e3      	strh	r3, [r4, #14]

	if (currentAckId != 0)
   1de18:	696b      	ldr	r3, [r5, #20]
	} else {
		packet.ackField = 0;
	}

	sizedData data;
	data.data = (u8*) &packet;
   1de1a:	9401      	str	r4, [sp, #4]
	packet.txPower = Config->radioTransmitPower;
	packet.deviceType = persistentConfig.deviceType;
	packet.hopsToSink = cm->GetHopsToShortestSink(NULL);
	packet.meshWriteHandle = GATTController::getMeshWriteHandle();

	if (currentAckId != 0)
   1de1c:	6123      	str	r3, [r4, #16]
		packet.ackField = 0;
	}

	sizedData data;
	data.data = (u8*) &packet;
	data.length = SIZEOF_ADV_PACKET_PAYLOAD_JOIN_ME_V0;
   1de1e:	2314      	movs	r3, #20
   1de20:	8083      	strh	r3, [r0, #4]

//	logt("JOIN", "JOIN_ME updated clusterId:%x, clusterSize:%d, freeIn:%u, freeOut:%u, handle:%u, ack:%u", packet.clusterId, packet.clusterSize, packet.freeInConnections, packet.freeOutConnections, packet.meshWriteHandle, packet.ackField);

	//Broadcast connectable advertisement if we have a free inConnection, otherwise, we can only act as master
	if (cm->inConnection->isDisconnected() || cm->inConnection->connectionState == Connection::ConnectionState::REESTABLISHING){
   1de22:	6833      	ldr	r3, [r6, #0]
   1de24:	691b      	ldr	r3, [r3, #16]
   1de26:	7a1b      	ldrb	r3, [r3, #8]
   1de28:	2b00      	cmp	r3, #0
   1de2a:	d002      	beq.n	1de32 <_ZN4Node18UpdateJoinMePacketEv+0x86>
		AdvertisingController::UpdateAdvertisingData(MESSAGE_TYPE_JOIN_ME_V0, &data, true);
	}
	else AdvertisingController::UpdateAdvertisingData(MESSAGE_TYPE_JOIN_ME_V0, &data, false);
   1de2c:	2100      	movs	r1, #0
	data.length = SIZEOF_ADV_PACKET_PAYLOAD_JOIN_ME_V0;

//	logt("JOIN", "JOIN_ME updated clusterId:%x, clusterSize:%d, freeIn:%u, freeOut:%u, handle:%u, ack:%u", packet.clusterId, packet.clusterSize, packet.freeInConnections, packet.freeOutConnections, packet.meshWriteHandle, packet.ackField);

	//Broadcast connectable advertisement if we have a free inConnection, otherwise, we can only act as master
	if (cm->inConnection->isDisconnected() || cm->inConnection->connectionState == Connection::ConnectionState::REESTABLISHING){
   1de2e:	2b05      	cmp	r3, #5
   1de30:	d100      	bne.n	1de34 <_ZN4Node18UpdateJoinMePacketEv+0x88>
		AdvertisingController::UpdateAdvertisingData(MESSAGE_TYPE_JOIN_ME_V0, &data, true);
   1de32:	2101      	movs	r1, #1
	}
	else AdvertisingController::UpdateAdvertisingData(MESSAGE_TYPE_JOIN_ME_V0, &data, false);
   1de34:	f001 f910 	bl	1f058 <_ZN21AdvertisingController21UpdateAdvertisingDataEhP9sizedDatab.constprop.16>
}
   1de38:	b008      	add	sp, #32
   1de3a:	bd70      	pop	{r4, r5, r6, pc}
   1de3c:	200033d0 	.word	0x200033d0
   1de40:	2000358a 	.word	0x2000358a

0001de44 <_ZN4Node11ChangeStateE14discoveryState>:
#define ________________STATES___________________
#pragma region states

void Node::ChangeState(discoveryState newState)
{
	if (currentDiscoveryState == newState || stateMachineDisabled) return;
   1de44:	1c03      	adds	r3, r0, #0
 */
#define ________________STATES___________________
#pragma region states

void Node::ChangeState(discoveryState newState)
{
   1de46:	b5f0      	push	{r4, r5, r6, r7, lr}
   1de48:	b091      	sub	sp, #68	; 0x44
   1de4a:	9102      	str	r1, [sp, #8]
	if (currentDiscoveryState == newState || stateMachineDisabled) return;
   1de4c:	3354      	adds	r3, #84	; 0x54
   1de4e:	781a      	ldrb	r2, [r3, #0]
 */
#define ________________STATES___________________
#pragma region states

void Node::ChangeState(discoveryState newState)
{
   1de50:	1c04      	adds	r4, r0, #0
	if (currentDiscoveryState == newState || stateMachineDisabled) return;
   1de52:	428a      	cmp	r2, r1
   1de54:	d100      	bne.n	1de58 <_ZN4Node11ChangeStateE14discoveryState+0x14>
   1de56:	e249      	b.n	1e2ec <_ZN4Node11ChangeStateE14discoveryState+0x4a8>
   1de58:	7b05      	ldrb	r5, [r0, #12]
   1de5a:	2d00      	cmp	r5, #0
   1de5c:	d000      	beq.n	1de60 <_ZN4Node11ChangeStateE14discoveryState+0x1c>
   1de5e:	e245      	b.n	1e2ec <_ZN4Node11ChangeStateE14discoveryState+0x4a8>

	discoveryState oldState = currentDiscoveryState;
	currentDiscoveryState = newState;
   1de60:	466a      	mov	r2, sp
   1de62:	7a12      	ldrb	r2, [r2, #8]
   1de64:	701a      	strb	r2, [r3, #0]

	//Check what we have to do to leave our old state

	//Now let's check what we do on entry of the new state
	if (newState == discoveryState::DISCOVERY)
   1de66:	2902      	cmp	r1, #2
   1de68:	d10f      	bne.n	1de8a <_ZN4Node11ChangeStateE14discoveryState+0x46>
	{
		nextDiscoveryState = discoveryState::INVALID_STATE;
   1de6a:	1c03      	adds	r3, r0, #0
   1de6c:	3355      	adds	r3, #85	; 0x55
   1de6e:	701d      	strb	r5, [r3, #0]

		//Use Low instead of High discovery if no nodes have been found for a while
		if (noNodesFoundCounter < Config->discoveryHighToLowTransitionDuration)
   1de70:	3321      	adds	r3, #33	; 0x21
   1de72:	781d      	ldrb	r5, [r3, #0]
   1de74:	f002 ffd8 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1de78:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
		{
			ChangeState(discoveryState::DISCOVERY_HIGH);
   1de7a:	2103      	movs	r1, #3
   1de7c:	1c20      	adds	r0, r4, #0
	if (newState == discoveryState::DISCOVERY)
	{
		nextDiscoveryState = discoveryState::INVALID_STATE;

		//Use Low instead of High discovery if no nodes have been found for a while
		if (noNodesFoundCounter < Config->discoveryHighToLowTransitionDuration)
   1de7e:	42ab      	cmp	r3, r5
   1de80:	d800      	bhi.n	1de84 <_ZN4Node11ChangeStateE14discoveryState+0x40>
		{
			ChangeState(discoveryState::DISCOVERY_HIGH);
		}
		else
		{
			ChangeState(discoveryState::DISCOVERY_LOW);
   1de82:	2104      	movs	r1, #4
   1de84:	f7ff ffde 	bl	1de44 <_ZN4Node11ChangeStateE14discoveryState>
   1de88:	e073      	b.n	1df72 <_ZN4Node11ChangeStateE14discoveryState+0x12e>
		}

		//FIXME: this disables discovery low mode
		ChangeState(discoveryState::DISCOVERY_HIGH);
	}
	else if (newState == discoveryState::DISCOVERY_HIGH)
   1de8a:	9b02      	ldr	r3, [sp, #8]
   1de8c:	2b03      	cmp	r3, #3
   1de8e:	d10e      	bne.n	1deae <_ZN4Node11ChangeStateE14discoveryState+0x6a>
	{
		currentStateTimeoutDs = Config->meshStateTimeoutHighDs;
   1de90:	f002 ffca 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1de94:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
		nextDiscoveryState = discoveryState::DECIDING;
   1de96:	2205      	movs	r2, #5
		//FIXME: this disables discovery low mode
		ChangeState(discoveryState::DISCOVERY_HIGH);
	}
	else if (newState == discoveryState::DISCOVERY_HIGH)
	{
		currentStateTimeoutDs = Config->meshStateTimeoutHighDs;
   1de98:	66a3      	str	r3, [r4, #104]	; 0x68
		nextDiscoveryState = discoveryState::DECIDING;
   1de9a:	1c23      	adds	r3, r4, #0

//		logt("STATES", "-- DISCOVERY HIGH --");
		AdvertisingController::SetAdvertisingState(ADV_STATE_HIGH);
   1de9c:	2080      	movs	r0, #128	; 0x80
		ChangeState(discoveryState::DISCOVERY_HIGH);
	}
	else if (newState == discoveryState::DISCOVERY_HIGH)
	{
		currentStateTimeoutDs = Config->meshStateTimeoutHighDs;
		nextDiscoveryState = discoveryState::DECIDING;
   1de9e:	3355      	adds	r3, #85	; 0x55

//		logt("STATES", "-- DISCOVERY HIGH --");
		AdvertisingController::SetAdvertisingState(ADV_STATE_HIGH);
   1dea0:	00c0      	lsls	r0, r0, #3
		ChangeState(discoveryState::DISCOVERY_HIGH);
	}
	else if (newState == discoveryState::DISCOVERY_HIGH)
	{
		currentStateTimeoutDs = Config->meshStateTimeoutHighDs;
		nextDiscoveryState = discoveryState::DECIDING;
   1dea2:	701a      	strb	r2, [r3, #0]

//		logt("STATES", "-- DISCOVERY HIGH --");
		AdvertisingController::SetAdvertisingState(ADV_STATE_HIGH);
   1dea4:	f7ff f9ba 	bl	1d21c <_ZN21AdvertisingController19SetAdvertisingStateE8advState>
		ScanController::SetScanState(SCAN_STATE_HIGH);
   1dea8:	2080      	movs	r0, #128	; 0x80
   1deaa:	00c0      	lsls	r0, r0, #3
   1deac:	e010      	b.n	1ded0 <_ZN4Node11ChangeStateE14discoveryState+0x8c>

	}
	else if (newState == discoveryState::DISCOVERY_LOW)
   1deae:	9b02      	ldr	r3, [sp, #8]
   1deb0:	2b04      	cmp	r3, #4
   1deb2:	d113      	bne.n	1dedc <_ZN4Node11ChangeStateE14discoveryState+0x98>
	{
		currentStateTimeoutDs = Config->meshStateTimeoutLowDs;
   1deb4:	f002 ffb8 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1deb8:	8d03      	ldrh	r3, [r0, #40]	; 0x28
		nextDiscoveryState = discoveryState::DECIDING;
   1deba:	2205      	movs	r2, #5
		ScanController::SetScanState(SCAN_STATE_HIGH);

	}
	else if (newState == discoveryState::DISCOVERY_LOW)
	{
		currentStateTimeoutDs = Config->meshStateTimeoutLowDs;
   1debc:	66a3      	str	r3, [r4, #104]	; 0x68
		nextDiscoveryState = discoveryState::DECIDING;
   1debe:	1c23      	adds	r3, r4, #0

//		logt("STATES", "-- DISCOVERY LOW --");
		AdvertisingController::SetAdvertisingState(ADV_STATE_LOW);
   1dec0:	20f0      	movs	r0, #240	; 0xf0

	}
	else if (newState == discoveryState::DISCOVERY_LOW)
	{
		currentStateTimeoutDs = Config->meshStateTimeoutLowDs;
		nextDiscoveryState = discoveryState::DECIDING;
   1dec2:	3355      	adds	r3, #85	; 0x55

//		logt("STATES", "-- DISCOVERY LOW --");
		AdvertisingController::SetAdvertisingState(ADV_STATE_LOW);
   1dec4:	0100      	lsls	r0, r0, #4

	}
	else if (newState == discoveryState::DISCOVERY_LOW)
	{
		currentStateTimeoutDs = Config->meshStateTimeoutLowDs;
		nextDiscoveryState = discoveryState::DECIDING;
   1dec6:	701a      	strb	r2, [r3, #0]

//		logt("STATES", "-- DISCOVERY LOW --");
		AdvertisingController::SetAdvertisingState(ADV_STATE_LOW);
   1dec8:	f7ff f9a8 	bl	1d21c <_ZN21AdvertisingController19SetAdvertisingStateE8advState>
		ScanController::SetScanState(SCAN_STATE_LOW);
   1decc:	20f0      	movs	r0, #240	; 0xf0
   1dece:	0100      	lsls	r0, r0, #4
   1ded0:	f7ff fa4a 	bl	1d368 <_ZN14ScanController12SetScanStateE9scanState>
   1ded4:	1c25      	adds	r5, r4, #0
   1ded6:	3454      	adds	r4, #84	; 0x54
   1ded8:	3540      	adds	r5, #64	; 0x40
   1deda:	e1ee      	b.n	1e2ba <_ZN4Node11ChangeStateE14discoveryState+0x476>

	}
	else if (newState == discoveryState::DECIDING)
   1dedc:	9b02      	ldr	r3, [sp, #8]
   1dede:	2b05      	cmp	r3, #5
   1dee0:	d000      	beq.n	1dee4 <_ZN4Node11ChangeStateE14discoveryState+0xa0>
   1dee2:	e16f      	b.n	1e1c4 <_ZN4Node11ChangeStateE14discoveryState+0x380>
	{
		nextDiscoveryState = discoveryState::INVALID_STATE;
   1dee4:	1c03      	adds	r3, r0, #0
   1dee6:	3355      	adds	r3, #85	; 0x55
   1dee8:	701d      	strb	r5, [r3, #0]

//		logt("STATES", "-- DECIDING --");

		//Disable scanning and advertising first
		AdvertisingController::SetAdvertisingState(ADV_STATE_OFF);
   1deea:	1c28      	adds	r0, r5, #0
   1deec:	f7ff f996 	bl	1d21c <_ZN21AdvertisingController19SetAdvertisingStateE8advState>
		ScanController::SetScanState(SCAN_STATE_OFF);
   1def0:	1c28      	adds	r0, r5, #0
   1def2:	f7ff fa39 	bl	1d368 <_ZN14ScanController12SetScanStateE9scanState>

		//Check if we want to reestablish a connection
		int result = cm->ReestablishConnections();
   1def6:	4fbc      	ldr	r7, [pc, #752]	; (1e1e8 <_ZN4Node11ChangeStateE14discoveryState+0x3a4>)
   1def8:	683e      	ldr	r6, [r7, #0]

/** Tries to reestablish connections */
int ConnectionManager::ReestablishConnections(){

	//Check if any of the reestablish connections should be disconnected forever
	for(int i=0; i<Config->meshMaxConnections; i++){
   1defa:	f002 ff95 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1defe:	3035      	adds	r0, #53	; 0x35
   1df00:	7803      	ldrb	r3, [r0, #0]
   1df02:	429d      	cmp	r5, r3
   1df04:	da1f      	bge.n	1df46 <_ZN4Node11ChangeStateE14discoveryState+0x102>
   1df06:	00ab      	lsls	r3, r5, #2
   1df08:	18f3      	adds	r3, r6, r3
		if(
			connections[i]->connectionState == Connection::ConnectionState::REESTABLISHING
   1df0a:	6a1b      	ldr	r3, [r3, #32]
/** Tries to reestablish connections */
int ConnectionManager::ReestablishConnections(){

	//Check if any of the reestablish connections should be disconnected forever
	for(int i=0; i<Config->meshMaxConnections; i++){
		if(
   1df0c:	7a1a      	ldrb	r2, [r3, #8]
   1df0e:	2a05      	cmp	r2, #5
   1df10:	d117      	bne.n	1df42 <_ZN4Node11ChangeStateE14discoveryState+0xfe>
			connections[i]->connectionState == Connection::ConnectionState::REESTABLISHING
			&& node->appTimerDs - connections[i]->disconnectedTimestampDs > SEC_TO_DS(connections[i]->reestablishTimeSec)
   1df12:	6872      	ldr	r2, [r6, #4]
   1df14:	6e51      	ldr	r1, [r2, #100]	; 0x64
   1df16:	22f2      	movs	r2, #242	; 0xf2
   1df18:	0052      	lsls	r2, r2, #1
   1df1a:	589a      	ldr	r2, [r3, r2]
   1df1c:	1a89      	subs	r1, r1, r2
   1df1e:	22f4      	movs	r2, #244	; 0xf4
   1df20:	0052      	lsls	r2, r2, #1
   1df22:	5a98      	ldrh	r0, [r3, r2]
   1df24:	3adf      	subs	r2, #223	; 0xdf
   1df26:	3aff      	subs	r2, #255	; 0xff
   1df28:	4342      	muls	r2, r0
   1df2a:	4291      	cmp	r1, r2
   1df2c:	d909      	bls.n	1df42 <_ZN4Node11ChangeStateE14discoveryState+0xfe>
		){
			Disconnect(connections[i]->connectionHandle);
   1df2e:	22e9      	movs	r2, #233	; 0xe9
   1df30:	0052      	lsls	r2, r2, #1


//Disconnects a specific connection
void ConnectionManager::Disconnect(u16 connectionHandle)
{
	Connection* connection = GetConnectionFromHandle(connectionHandle);
   1df32:	5a99      	ldrh	r1, [r3, r2]
   1df34:	1c30      	adds	r0, r6, #0
   1df36:	f7ff fe05 	bl	1db44 <_ZN17ConnectionManager23GetConnectionFromHandleEt>
	if (connection != NULL)
   1df3a:	2800      	cmp	r0, #0
   1df3c:	d001      	beq.n	1df42 <_ZN4Node11ChangeStateE14discoveryState+0xfe>
	{
		connection->Disconnect();
   1df3e:	f001 fdf9 	bl	1fb34 <_ZN10Connection10DisconnectEv>

/** Tries to reestablish connections */
int ConnectionManager::ReestablishConnections(){

	//Check if any of the reestablish connections should be disconnected forever
	for(int i=0; i<Config->meshMaxConnections; i++){
   1df42:	3501      	adds	r5, #1
   1df44:	e7d9      	b.n	1defa <_ZN4Node11ChangeStateE14discoveryState+0xb6>
   1df46:	2500      	movs	r5, #0

	//First, check which connection needs reestablishing
	//TODO: We could use a whitelist of connection partner is we need to reestablish
	//multiple
	Connection* connection = NULL;
	for(int i=0; i<Config->meshMaxConnections; i++){
   1df48:	f002 ff6e 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1df4c:	3035      	adds	r0, #53	; 0x35
   1df4e:	7803      	ldrb	r3, [r0, #0]
   1df50:	429d      	cmp	r5, r3
   1df52:	da21      	bge.n	1df98 <_ZN4Node11ChangeStateE14discoveryState+0x154>
   1df54:	00ab      	lsls	r3, r5, #2
   1df56:	18f3      	adds	r3, r6, r3
		if(connections[i]->connectionState == Connection::ConnectionState::REESTABLISHING){
   1df58:	6a18      	ldr	r0, [r3, #32]
   1df5a:	7a03      	ldrb	r3, [r0, #8]
   1df5c:	2b05      	cmp	r3, #5
   1df5e:	d106      	bne.n	1df6e <_ZN4Node11ChangeStateE14discoveryState+0x12a>

	//Do not reestablish if nothing was found
	if(connection == NULL) return 0;

	//We have been a Peripheral in this connection, start to advertise
	if(connection->direction == Connection::ConnectionDirection::CONNECTION_DIRECTION_IN){
   1df60:	7b43      	ldrb	r3, [r0, #13]
   1df62:	2b00      	cmp	r3, #0
   1df64:	d108      	bne.n	1df78 <_ZN4Node11ChangeStateE14discoveryState+0x134>
		logt("CM", "Waiting for node %u to reconnect", connection->partnerId);
		//Update packet to make it connectable
		node->UpdateJoinMePacket();
   1df66:	6870      	ldr	r0, [r6, #4]
   1df68:	f7ff ff20 	bl	1ddac <_ZN4Node18UpdateJoinMePacketEv>
   1df6c:	e001      	b.n	1df72 <_ZN4Node11ChangeStateE14discoveryState+0x12e>

	//First, check which connection needs reestablishing
	//TODO: We could use a whitelist of connection partner is we need to reestablish
	//multiple
	Connection* connection = NULL;
	for(int i=0; i<Config->meshMaxConnections; i++){
   1df6e:	3501      	adds	r5, #1
   1df70:	e7ea      	b.n	1df48 <_ZN4Node11ChangeStateE14discoveryState+0x104>

		if(result == 1){
			//as peripheral
			ChangeState(discoveryState::DISCOVERY_HIGH);
   1df72:	1c20      	adds	r0, r4, #0
   1df74:	2103      	movs	r1, #3
   1df76:	e185      	b.n	1e284 <_ZN4Node11ChangeStateE14discoveryState+0x440>

		//try to connect with same settings as previous connection as master
		bool result = GAPController::connectToPeripheral(
				&connection->partnerAddress,
				connection->currentConnectionIntervalMs,
				connection->reestablishTimeSec);
   1df78:	23ef      	movs	r3, #239	; 0xef
   1df7a:	005b      	lsls	r3, r3, #1
   1df7c:	5ac1      	ldrh	r1, [r0, r3]
   1df7e:	330a      	adds	r3, #10
   1df80:	5ac2      	ldrh	r2, [r0, r3]


//Connect to a specific peripheral
bool GAPController::connectToPeripheral(ble_gap_addr_t* address, u16 connectionInterval, u16 timeout)
{
	if(currentlyConnecting) return false;
   1df82:	4b9a      	ldr	r3, [pc, #616]	; (1e1ec <_ZN4Node11ChangeStateE14discoveryState+0x3a8>)
   1df84:	781b      	ldrb	r3, [r3, #0]
   1df86:	2b00      	cmp	r3, #0
   1df88:	d106      	bne.n	1df98 <_ZN4Node11ChangeStateE14discoveryState+0x154>
   1df8a:	30d5      	adds	r0, #213	; 0xd5
   1df8c:	30ff      	adds	r0, #255	; 0xff
   1df8e:	f7ff f9ad 	bl	1d2ec <_ZN13GAPController19connectToPeripheralEP14ble_gap_addr_ttt.part.0.lto_priv.71>

		if(result){
   1df92:	2800      	cmp	r0, #0
   1df94:	d000      	beq.n	1df98 <_ZN4Node11ChangeStateE14discoveryState+0x154>
   1df96:	e1a6      	b.n	1e2e6 <_ZN4Node11ChangeStateE14discoveryState+0x4a2>
//STEP 3: After collecting all available clusters, we want to connect to the best cluster that is available
//If the other clusters were not good and we have something better, we advertise it.
Node::decisionResult Node::DetermineBestClusterAvailable(void)
{
	//If no clusters have been advertised since the first time, there is no work to do
	if (joinMePacketBuffer->_numElements == 0)
   1df98:	6923      	ldr	r3, [r4, #16]
   1df9a:	9306      	str	r3, [sp, #24]
   1df9c:	8a1b      	ldrh	r3, [r3, #16]
   1df9e:	9307      	str	r3, [sp, #28]
   1dfa0:	2b00      	cmp	r3, #0
   1dfa2:	d100      	bne.n	1dfa6 <_ZN4Node11ChangeStateE14discoveryState+0x162>
   1dfa4:	e18d      	b.n	1e2c2 <_ZN4Node11ChangeStateE14discoveryState+0x47e>
	u32 bestScore = 0;
	joinMeBufferPacket* bestCluster = NULL;
	joinMeBufferPacket* packet = NULL;

	//Determine the best Cluster to connect to as a master
	if (cm->freeOutConnections > 0)
   1dfa6:	683b      	ldr	r3, [r7, #0]
   1dfa8:	9303      	str	r3, [sp, #12]
   1dfaa:	7b9b      	ldrb	r3, [r3, #14]
   1dfac:	2b00      	cmp	r3, #0
   1dfae:	d101      	bne.n	1dfb4 <_ZN4Node11ChangeStateE14discoveryState+0x170>
	{
//		logt("DISCOVERY", "No other nodes discovered");
		return Node::DECISION_NO_NODES_FOUND;
	}

	u32 bestScore = 0;
   1dfb0:	9305      	str	r3, [sp, #20]
   1dfb2:	e055      	b.n	1e060 <_ZN4Node11ChangeStateE14discoveryState+0x21c>
	joinMeBufferPacket* bestCluster = NULL;
	joinMeBufferPacket* packet = NULL;

	//Determine the best Cluster to connect to as a master
	if (cm->freeOutConnections > 0)
   1dfb4:	2700      	movs	r7, #0
   1dfb6:	9704      	str	r7, [sp, #16]
   1dfb8:	9705      	str	r7, [sp, #20]
	{
		for (int i = 0; i < joinMePacketBuffer->_numElements; i++)
   1dfba:	9b07      	ldr	r3, [sp, #28]
   1dfbc:	429f      	cmp	r7, r3
   1dfbe:	da4c      	bge.n	1e05a <_ZN4Node11ChangeStateE14discoveryState+0x216>
		{
			packet = (joinMeBufferPacket*) joinMePacketBuffer->PeekItemAt(i);
   1dfc0:	b2b9      	uxth	r1, r7
   1dfc2:	9806      	ldr	r0, [sp, #24]
   1dfc4:	f001 fd5c 	bl	1fa80 <_ZN12SimpleBuffer10PeekItemAtEt>
//Connect to big clusters but big clusters must connect nodes that are not able 
u32 Node::CalculateClusterScoreAsMaster(joinMeBufferPacket* packet)
{

	//If the packet is too old, filter it out
	if (appTimerDs - packet->receivedTimeDs > MAX_JOIN_ME_PACKET_AGE_DS) return 0;
   1dfc8:	6e63      	ldr	r3, [r4, #100]	; 0x64
   1dfca:	68c2      	ldr	r2, [r0, #12]
   1dfcc:	1a9b      	subs	r3, r3, r2
   1dfce:	2b96      	cmp	r3, #150	; 0x96
   1dfd0:	d841      	bhi.n	1e056 <_ZN4Node11ChangeStateE14discoveryState+0x212>

	//If we are already connected to that cluster, the score is 0
	if (packet->payload.clusterId == this->clusterId) return 0;
   1dfd2:	8a83      	ldrh	r3, [r0, #20]
   1dfd4:	8a42      	ldrh	r2, [r0, #18]
   1dfd6:	041b      	lsls	r3, r3, #16
   1dfd8:	6fe5      	ldr	r5, [r4, #124]	; 0x7c
   1dfda:	4313      	orrs	r3, r2
   1dfdc:	469c      	mov	ip, r3
   1dfde:	42ab      	cmp	r3, r5
   1dfe0:	d039      	beq.n	1e056 <_ZN4Node11ChangeStateE14discoveryState+0x212>

	//If there are zero free in connections, we cannot connect as master
	if (packet->payload.freeInConnections == 0) return 0;
   1dfe2:	7e02      	ldrb	r2, [r0, #24]
   1dfe4:	0752      	lsls	r2, r2, #29
   1dfe6:	d036      	beq.n	1e056 <_ZN4Node11ChangeStateE14discoveryState+0x212>

	//If his cluster is bigger, but only if it is not faked (when setting an ack)
	if (packet->payload.ackField == 0 && (packet->payload.clusterSize > this->clusterSize || (packet->payload.clusterSize == this->clusterSize && packet->payload.clusterId > this->clusterId)))
   1dfe8:	6a02      	ldr	r2, [r0, #32]
   1dfea:	2a00      	cmp	r2, #0
   1dfec:	d10a      	bne.n	1e004 <_ZN4Node11ChangeStateE14discoveryState+0x1c0>
   1dfee:	2116      	movs	r1, #22
   1dff0:	5e46      	ldrsh	r6, [r0, r1]
   1dff2:	1c21      	adds	r1, r4, #0
   1dff4:	3178      	adds	r1, #120	; 0x78
   1dff6:	2300      	movs	r3, #0
   1dff8:	5ec9      	ldrsh	r1, [r1, r3]
   1dffa:	428e      	cmp	r6, r1
   1dffc:	dc2b      	bgt.n	1e056 <_ZN4Node11ChangeStateE14discoveryState+0x212>
   1dffe:	d101      	bne.n	1e004 <_ZN4Node11ChangeStateE14discoveryState+0x1c0>
   1e000:	45ac      	cmp	ip, r5
   1e002:	d828      	bhi.n	1e056 <_ZN4Node11ChangeStateE14discoveryState+0x212>
	{
		return 0;
	}

	//Connection should have a minimum of stability
	if(packet->rssi < -88) return 0;
   1e004:	2308      	movs	r3, #8
   1e006:	56c3      	ldrsb	r3, [r0, r3]
   1e008:	1c19      	adds	r1, r3, #0
   1e00a:	3158      	adds	r1, #88	; 0x58
   1e00c:	db23      	blt.n	1e056 <_ZN4Node11ChangeStateE14discoveryState+0x212>

	//If the ack field is not 0 and set to a different nodeID than ours, somebody else wants to connect to him
	if (packet->payload.ackField != 0 && packet->payload.ackField != this->persistentConfig.nodeId)
   1e00e:	2a00      	cmp	r2, #0
   1e010:	d00a      	beq.n	1e028 <_ZN4Node11ChangeStateE14discoveryState+0x1e4>
   1e012:	8ce1      	ldrh	r1, [r4, #38]	; 0x26
   1e014:	428a      	cmp	r2, r1
   1e016:	d007      	beq.n	1e028 <_ZN4Node11ChangeStateE14discoveryState+0x1e4>
	{
		//Override ack field if our clustersize is similar or bigger
		if (packet->payload.clusterSize <= this->clusterSize)
   1e018:	2216      	movs	r2, #22
   1e01a:	5e81      	ldrsh	r1, [r0, r2]
   1e01c:	1c22      	adds	r2, r4, #0
   1e01e:	3278      	adds	r2, #120	; 0x78
   1e020:	2500      	movs	r5, #0
   1e022:	5f52      	ldrsh	r2, [r2, r5]
   1e024:	4291      	cmp	r1, r2
   1e026:	dc16      	bgt.n	1e056 <_ZN4Node11ChangeStateE14discoveryState+0x212>
		{
			return 0;
		}
	}
	u32 rssiScore = 0;
	if(packet->payload.freeOutConnections > 2){
   1e028:	7e06      	ldrb	r6, [r0, #24]
		rssiScore = (100+packet->rssi)*(1000);
	} else {
		rssiScore = (100+packet->rssi)*(1);
   1e02a:	3364      	adds	r3, #100	; 0x64
		{
			return 0;
		}
	}
	u32 rssiScore = 0;
	if(packet->payload.freeOutConnections > 2){
   1e02c:	08f2      	lsrs	r2, r6, #3
		rssiScore = (100+packet->rssi)*(1000);
	} else {
		rssiScore = (100+packet->rssi)*(1);
   1e02e:	1c1d      	adds	r5, r3, #0
		{
			return 0;
		}
	}
	u32 rssiScore = 0;
	if(packet->payload.freeOutConnections > 2){
   1e030:	2a02      	cmp	r2, #2
   1e032:	dd02      	ble.n	1e03a <_ZN4Node11ChangeStateE14discoveryState+0x1f6>
		rssiScore = (100+packet->rssi)*(1000);
   1e034:	23fa      	movs	r3, #250	; 0xfa
   1e036:	009b      	lsls	r3, r3, #2
   1e038:	435d      	muls	r5, r3
		rssiScore = (100+packet->rssi)*(1);
	}

	//Free in connections are best, free out connections are good as well
	//TODO: RSSI should be factored into the score as well, maybe battery runtime, device type, etc...
	return packet->payload.freeInConnections * 1000 + packet->payload.freeOutConnections * 100 + rssiScore;
   1e03a:	23fa      	movs	r3, #250	; 0xfa
   1e03c:	2164      	movs	r1, #100	; 0x64
   1e03e:	0776      	lsls	r6, r6, #29
   1e040:	009b      	lsls	r3, r3, #2
   1e042:	0f76      	lsrs	r6, r6, #29
   1e044:	435e      	muls	r6, r3
   1e046:	4351      	muls	r1, r2
   1e048:	1872      	adds	r2, r6, r1
   1e04a:	18ab      	adds	r3, r5, r2
		for (int i = 0; i < joinMePacketBuffer->_numElements; i++)
		{
			packet = (joinMeBufferPacket*) joinMePacketBuffer->PeekItemAt(i);

			u32 score = CalculateClusterScoreAsMaster(packet);
			if (score > bestScore)
   1e04c:	9a05      	ldr	r2, [sp, #20]
   1e04e:	4293      	cmp	r3, r2
   1e050:	d901      	bls.n	1e056 <_ZN4Node11ChangeStateE14discoveryState+0x212>
   1e052:	9004      	str	r0, [sp, #16]
   1e054:	9305      	str	r3, [sp, #20]
	joinMeBufferPacket* packet = NULL;

	//Determine the best Cluster to connect to as a master
	if (cm->freeOutConnections > 0)
	{
		for (int i = 0; i < joinMePacketBuffer->_numElements; i++)
   1e056:	3701      	adds	r7, #1
   1e058:	e7af      	b.n	1dfba <_ZN4Node11ChangeStateE14discoveryState+0x176>
			}
		}

		//Now, if we want to be a master in the connection, we simply answer the ad packet that
		//informs us about that cluster
		if (bestCluster != NULL)
   1e05a:	9b04      	ldr	r3, [sp, #16]
   1e05c:	2b00      	cmp	r3, #0
   1e05e:	d102      	bne.n	1e066 <_ZN4Node11ChangeStateE14discoveryState+0x222>
		currentAckId = 0;

		packet = (joinMeBufferPacket*) joinMePacketBuffer->PeekItemAt(i);

		u32 score = CalculateClusterScoreAsSlave(packet);
		if (score > bestScore)
   1e060:	2600      	movs	r6, #0
   1e062:	1c35      	adds	r5, r6, #0
   1e064:	e069      	b.n	1e13a <_ZN4Node11ChangeStateE14discoveryState+0x2f6>

		//Now, if we want to be a master in the connection, we simply answer the ad packet that
		//informs us about that cluster
		if (bestCluster != NULL)
		{
			currentAckId = 0;
   1e066:	2300      	movs	r3, #0

			ble_gap_addr_t address;
			address.addr_type = bestCluster->bleAddressType;
			memcpy(address.addr, bestCluster->bleAddress, BLE_GAP_ADDR_LEN);
   1e068:	200d      	movs	r0, #13

		//Now, if we want to be a master in the connection, we simply answer the ad packet that
		//informs us about that cluster
		if (bestCluster != NULL)
		{
			currentAckId = 0;
   1e06a:	6163      	str	r3, [r4, #20]

			ble_gap_addr_t address;
			address.addr_type = bestCluster->bleAddressType;
   1e06c:	9b04      	ldr	r3, [sp, #16]
   1e06e:	781a      	ldrb	r2, [r3, #0]
   1e070:	ab09      	add	r3, sp, #36	; 0x24
   1e072:	701a      	strb	r2, [r3, #0]
			memcpy(address.addr, bestCluster->bleAddress, BLE_GAP_ADDR_LEN);
   1e074:	9b04      	ldr	r3, [sp, #16]
   1e076:	2206      	movs	r2, #6
   1e078:	1c59      	adds	r1, r3, #1
   1e07a:	ab06      	add	r3, sp, #24
   1e07c:	18c0      	adds	r0, r0, r3
   1e07e:	f003 fac9 	bl	21614 <memcpy>

			cm->ConnectAsMaster(bestCluster->payload.sender, &address, bestCluster->payload.meshWriteHandle);
   1e082:	9b04      	ldr	r3, [sp, #16]
   1e084:	8bde      	ldrh	r6, [r3, #30]

//Connects to a peripheral as Master, writecharacteristichandle can be BLE_GATT_HANDLE_INVALID
Connection* ConnectionManager::ConnectAsMaster(nodeID partnerId, ble_gap_addr_t* address, u16 writeCharacteristicHandle)
{
	//Only connect when not currently in another connection or when there are no more free connections
	if (freeOutConnections <= 0 || pendingConnection != NULL) return NULL;
   1e086:	9b03      	ldr	r3, [sp, #12]
   1e088:	7b9b      	ldrb	r3, [r3, #14]
   1e08a:	2b00      	cmp	r3, #0
   1e08c:	d03b      	beq.n	1e106 <_ZN4Node11ChangeStateE14discoveryState+0x2c2>
   1e08e:	9b03      	ldr	r3, [sp, #12]
   1e090:	681f      	ldr	r7, [r3, #0]
   1e092:	2f00      	cmp	r7, #0
   1e094:	d137      	bne.n	1e106 <_ZN4Node11ChangeStateE14discoveryState+0x2c2>
}

//Looks if there is a free connection available
Connection* ConnectionManager::GetFreeOutConnection()
{
	for (int i = 0; i < Config->meshMaxOutConnections; i++)
   1e096:	f002 fec7 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1e09a:	3034      	adds	r0, #52	; 0x34
   1e09c:	7803      	ldrb	r3, [r0, #0]
   1e09e:	429f      	cmp	r7, r3
   1e0a0:	db00      	blt.n	1e0a4 <_ZN4Node11ChangeStateE14discoveryState+0x260>
   1e0a2:	e11b      	b.n	1e2dc <_ZN4Node11ChangeStateE14discoveryState+0x498>
   1e0a4:	9a03      	ldr	r2, [sp, #12]
   1e0a6:	00bb      	lsls	r3, r7, #2
   1e0a8:	18d3      	adds	r3, r2, r3
	{
		if (outConnections[i]->isDisconnected()) return outConnections[i];
   1e0aa:	695d      	ldr	r5, [r3, #20]
   1e0ac:	7a2b      	ldrb	r3, [r5, #8]
   1e0ae:	2b00      	cmp	r3, #0
   1e0b0:	d10c      	bne.n	1e0cc <_ZN4Node11ChangeStateE14discoveryState+0x288>
	if (freeOutConnections <= 0 || pendingConnection != NULL) return NULL;

	Connection* connection = GetFreeOutConnection();

	//Disperse connection intervals over time, maybe this leads to less connection losses
	u16 connectionInterval = Config->meshMinConnectionInterval + connection->connectionId;
   1e0b2:	f002 feb9 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1e0b6:	7b2b      	ldrb	r3, [r5, #12]
   1e0b8:	8907      	ldrh	r7, [r0, #8]
   1e0ba:	9305      	str	r3, [sp, #20]

	//Tell the GAP Layer to connect, it will return if it is trying or if there was an error
	bool status = GAPController::connectToPeripheral(address, connectionInterval, Config->meshConnectingScanTimeout);
   1e0bc:	f002 feb4 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1e0c0:	4b4a      	ldr	r3, [pc, #296]	; (1e1ec <_ZN4Node11ChangeStateE14discoveryState+0x3a8>)
   1e0c2:	8c42      	ldrh	r2, [r0, #34]	; 0x22
   1e0c4:	781b      	ldrb	r3, [r3, #0]
   1e0c6:	2b00      	cmp	r3, #0
   1e0c8:	d11d      	bne.n	1e106 <_ZN4Node11ChangeStateE14discoveryState+0x2c2>
   1e0ca:	e001      	b.n	1e0d0 <_ZN4Node11ChangeStateE14discoveryState+0x28c>
}

//Looks if there is a free connection available
Connection* ConnectionManager::GetFreeOutConnection()
{
	for (int i = 0; i < Config->meshMaxOutConnections; i++)
   1e0cc:	3701      	adds	r7, #1
   1e0ce:	e7e2      	b.n	1e096 <_ZN4Node11ChangeStateE14discoveryState+0x252>
	if (freeOutConnections <= 0 || pendingConnection != NULL) return NULL;

	Connection* connection = GetFreeOutConnection();

	//Disperse connection intervals over time, maybe this leads to less connection losses
	u16 connectionInterval = Config->meshMinConnectionInterval + connection->connectionId;
   1e0d0:	9b05      	ldr	r3, [sp, #20]
   1e0d2:	a809      	add	r0, sp, #36	; 0x24
   1e0d4:	18ff      	adds	r7, r7, r3
   1e0d6:	b2b9      	uxth	r1, r7
   1e0d8:	f7ff f908 	bl	1d2ec <_ZN13GAPController19connectToPeripheralEP14ble_gap_addr_ttt.part.0.lto_priv.71>

	//Tell the GAP Layer to connect, it will return if it is trying or if there was an error
	bool status = GAPController::connectToPeripheral(address, connectionInterval, Config->meshConnectingScanTimeout);

	if(status){
   1e0dc:	2800      	cmp	r0, #0
   1e0de:	d012      	beq.n	1e106 <_ZN4Node11ChangeStateE14discoveryState+0x2c2>
		//Get a free connection and set it as pending
		pendingConnection = connection;
   1e0e0:	9b03      	ldr	r3, [sp, #12]

		//Put address and writeHandle into the connection
		pendingConnection->PrepareConnection(address, writeCharacteristicHandle);
   1e0e2:	a909      	add	r1, sp, #36	; 0x24
	//Tell the GAP Layer to connect, it will return if it is trying or if there was an error
	bool status = GAPController::connectToPeripheral(address, connectionInterval, Config->meshConnectingScanTimeout);

	if(status){
		//Get a free connection and set it as pending
		pendingConnection = connection;
   1e0e4:	601d      	str	r5, [r3, #0]

		//Put address and writeHandle into the connection
		pendingConnection->PrepareConnection(address, writeCharacteristicHandle);
   1e0e6:	1c32      	adds	r2, r6, #0
   1e0e8:	1c28      	adds	r0, r5, #0
   1e0ea:	f001 fdd7 	bl	1fc9c <_ZN10Connection17PrepareConnectionEP14ble_gap_addr_tt>

		char addrString[20];
		Logger::getInstance().convertBufferToHexString(pendingConnection->partnerAddress.addr, 6, addrString, 20);
   1e0ee:	f7ff f8d3 	bl	1d298 <_ZN6Logger11getInstanceEv>
   1e0f2:	9b03      	ldr	r3, [sp, #12]
   1e0f4:	2206      	movs	r2, #6
   1e0f6:	6819      	ldr	r1, [r3, #0]
   1e0f8:	2314      	movs	r3, #20
   1e0fa:	31d6      	adds	r1, #214	; 0xd6
   1e0fc:	9300      	str	r3, [sp, #0]
   1e0fe:	31ff      	adds	r1, #255	; 0xff
   1e100:	ab0b      	add	r3, sp, #44	; 0x2c
   1e102:	f001 fc65 	bl	1f9d0 <_ZN6Logger24convertBufferToHexStringEPhmPct>

			//We clear this packet from the buffer, because if the connetion fails, we want to try a different node
			memset(bestCluster, 0x00, sizeof(joinMeBufferPacket));
   1e106:	2224      	movs	r2, #36	; 0x24
   1e108:	2100      	movs	r1, #0
   1e10a:	9804      	ldr	r0, [sp, #16]
   1e10c:	f003 fa9f 	bl	2164e <memset>
					noNodesFoundCounter++;
				ChangeState(discoveryState::BACK_OFF);
			}
			else if (decision == Node::DECISION_CONNECT_AS_MASTER)
			{
				ChangeState(discoveryState::CONNECTING);
   1e110:	1c20      	adds	r0, r4, #0
   1e112:	2108      	movs	r1, #8
   1e114:	f7ff fe96 	bl	1de44 <_ZN4Node11ChangeStateE14discoveryState>
				noNodesFoundCounter = 0;
   1e118:	1c23      	adds	r3, r4, #0
   1e11a:	2200      	movs	r2, #0
   1e11c:	3376      	adds	r3, #118	; 0x76
   1e11e:	701a      	strb	r2, [r3, #0]
   1e120:	e6d8      	b.n	1ded4 <_ZN4Node11ChangeStateE14discoveryState+0x90>
	//If no good cluster could be found (all are bigger than mine)
	//Find the best cluster that should connect to us (we as slave)
	packet = NULL;
	for (int i = 0; i < joinMePacketBuffer->_numElements; i++)
	{
		currentAckId = 0;
   1e122:	2300      	movs	r3, #0

		packet = (joinMeBufferPacket*) joinMePacketBuffer->PeekItemAt(i);
   1e124:	b2b1      	uxth	r1, r6
	//If no good cluster could be found (all are bigger than mine)
	//Find the best cluster that should connect to us (we as slave)
	packet = NULL;
	for (int i = 0; i < joinMePacketBuffer->_numElements; i++)
	{
		currentAckId = 0;
   1e126:	6163      	str	r3, [r4, #20]

		packet = (joinMeBufferPacket*) joinMePacketBuffer->PeekItemAt(i);
   1e128:	9806      	ldr	r0, [sp, #24]
   1e12a:	f001 fca9 	bl	1fa80 <_ZN12SimpleBuffer10PeekItemAtEt>
//And set its id in our ack field
u32 Node::CalculateClusterScoreAsSlave(joinMeBufferPacket* packet)
{

	//If the packet is too old, filter it out
	if (appTimerDs - packet->receivedTimeDs > MAX_JOIN_ME_PACKET_AGE_DS) return 0;
   1e12e:	6e63      	ldr	r3, [r4, #100]	; 0x64
   1e130:	68c2      	ldr	r2, [r0, #12]
   1e132:	1a9b      	subs	r3, r3, r2
   1e134:	2b96      	cmp	r3, #150	; 0x96
   1e136:	d904      	bls.n	1e142 <_ZN4Node11ChangeStateE14discoveryState+0x2fe>
	}

	//If no good cluster could be found (all are bigger than mine)
	//Find the best cluster that should connect to us (we as slave)
	packet = NULL;
	for (int i = 0; i < joinMePacketBuffer->_numElements; i++)
   1e138:	3601      	adds	r6, #1
   1e13a:	9b07      	ldr	r3, [sp, #28]
   1e13c:	429e      	cmp	r6, r3
   1e13e:	dbf0      	blt.n	1e122 <_ZN4Node11ChangeStateE14discoveryState+0x2de>
   1e140:	e01f      	b.n	1e182 <_ZN4Node11ChangeStateE14discoveryState+0x33e>

	//If the packet is too old, filter it out
	if (appTimerDs - packet->receivedTimeDs > MAX_JOIN_ME_PACKET_AGE_DS) return 0;

	//If we are already connected to that cluster, the score is 0
	if (packet->payload.clusterId == this->clusterId) return 0;
   1e142:	8a83      	ldrh	r3, [r0, #20]
   1e144:	8a42      	ldrh	r2, [r0, #18]
   1e146:	041b      	lsls	r3, r3, #16
   1e148:	4313      	orrs	r3, r2
   1e14a:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
   1e14c:	4293      	cmp	r3, r2
   1e14e:	d0f3      	beq.n	1e138 <_ZN4Node11ChangeStateE14discoveryState+0x2f4>

	//If the ack field is set, we do not want to connect as slave
	if (packet->payload.ackField != 0) return 0;
   1e150:	6a03      	ldr	r3, [r0, #32]
   1e152:	2b00      	cmp	r3, #0
   1e154:	d1f0      	bne.n	1e138 <_ZN4Node11ChangeStateE14discoveryState+0x2f4>

	//He could not connect to us, leave him alone
	if (packet->payload.freeOutConnections == 0) return 0;
   1e156:	7e02      	ldrb	r2, [r0, #24]
   1e158:	3307      	adds	r3, #7
   1e15a:	1c11      	adds	r1, r2, #0
   1e15c:	4399      	bics	r1, r3
   1e15e:	d0eb      	beq.n	1e138 <_ZN4Node11ChangeStateE14discoveryState+0x2f4>

	//Connection should have a minimum of stability
	if(packet->rssi < -88) return 0;
   1e160:	2308      	movs	r3, #8
   1e162:	56c3      	ldrsb	r3, [r0, r3]
   1e164:	3358      	adds	r3, #88	; 0x58
   1e166:	dbe7      	blt.n	1e138 <_ZN4Node11ChangeStateE14discoveryState+0x2f4>

	//Choose the one with the biggest cluster size, if there are more, prefer the most outConnections
	return packet->payload.clusterSize * 1000 + packet->payload.freeOutConnections;
   1e168:	2316      	movs	r3, #22
   1e16a:	5ec1      	ldrsh	r1, [r0, r3]
   1e16c:	23fa      	movs	r3, #250	; 0xfa
   1e16e:	009b      	lsls	r3, r3, #2
   1e170:	434b      	muls	r3, r1
   1e172:	08d2      	lsrs	r2, r2, #3
   1e174:	189b      	adds	r3, r3, r2
		currentAckId = 0;

		packet = (joinMeBufferPacket*) joinMePacketBuffer->PeekItemAt(i);

		u32 score = CalculateClusterScoreAsSlave(packet);
		if (score > bestScore)
   1e176:	9a05      	ldr	r2, [sp, #20]
   1e178:	4293      	cmp	r3, r2
   1e17a:	d9dd      	bls.n	1e138 <_ZN4Node11ChangeStateE14discoveryState+0x2f4>
   1e17c:	1c05      	adds	r5, r0, #0
   1e17e:	9305      	str	r3, [sp, #20]
   1e180:	e7da      	b.n	1e138 <_ZN4Node11ChangeStateE14discoveryState+0x2f4>
			bestCluster = packet;
		}
	}

	//Set our ack field to the best Cluster
	if (bestCluster != NULL)
   1e182:	2d00      	cmp	r5, #0
   1e184:	d100      	bne.n	1e188 <_ZN4Node11ChangeStateE14discoveryState+0x344>
   1e186:	e09c      	b.n	1e2c2 <_ZN4Node11ChangeStateE14discoveryState+0x47e>
	{
//		logt("DISCOVERY", "Other clusters are bigger, we are going to be a slave");

		currentAckId = bestCluster->payload.clusterId;
   1e188:	8aab      	ldrh	r3, [r5, #20]
   1e18a:	8a6a      	ldrh	r2, [r5, #18]
   1e18c:	041b      	lsls	r3, r3, #16
   1e18e:	4313      	orrs	r3, r2
   1e190:	6163      	str	r3, [r4, #20]

		//CASE 1: The ack field is already set to our cluster id, we can reach each other
		//Kill connections and broadcast our preferred partner with the ack field
		//so that he connects to us
		if (bestCluster->payload.ackField == clusterId)
   1e192:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
   1e194:	6a2b      	ldr	r3, [r5, #32]
   1e196:	4293      	cmp	r3, r2
   1e198:	d10c      	bne.n	1e1b4 <_ZN4Node11ChangeStateE14discoveryState+0x370>
		{
			cm->ForceDisconnectOtherConnections(NULL);
   1e19a:	9803      	ldr	r0, [sp, #12]
   1e19c:	2100      	movs	r1, #0
   1e19e:	f7ff fcb6 	bl	1db0e <_ZN17ConnectionManager31ForceDisconnectOtherConnectionsEP10Connection>

			clusterSize = 1;
   1e1a2:	1c23      	adds	r3, r4, #0
   1e1a4:	2201      	movs	r2, #1
   1e1a6:	3378      	adds	r3, #120	; 0x78
   1e1a8:	801a      	strh	r2, [r3, #0]

//Generates a new clusterID by using connectionLoss and the unique id of the node
clusterID Node::GenerateClusterID(void)
{
	//Combine connection loss and nodeId to generate a unique cluster id
	clusterID newId = this->persistentConfig.nodeId + (this->persistentConfig.connectionLossCounter << 16);
   1e1aa:	8f23      	ldrh	r3, [r4, #56]	; 0x38
   1e1ac:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
   1e1ae:	041b      	lsls	r3, r3, #16
   1e1b0:	18d3      	adds	r3, r2, r3
		if (bestCluster->payload.ackField == clusterId)
		{
			cm->ForceDisconnectOtherConnections(NULL);

			clusterSize = 1;
			clusterId = GenerateClusterID();
   1e1b2:	67e3      	str	r3, [r4, #124]	; 0x7c
		}
		//CASE 2: The ack field is not set to our id, set our ack field to his id
		//And wait for him to confirm that he can reach us
		else
		{
			UpdateJoinMePacket();
   1e1b4:	1c20      	adds	r0, r4, #0
   1e1b6:	f7ff fdf9 	bl	1ddac <_ZN4Node18UpdateJoinMePacketEv>
				ChangeState(discoveryState::CONNECTING);
				noNodesFoundCounter = 0;
			}
			else if (decision == Node::DECISION_CONNECT_AS_SLAVE)
			{
				noNodesFoundCounter = 0;
   1e1ba:	1c23      	adds	r3, r4, #0
   1e1bc:	2200      	movs	r2, #0
   1e1be:	3376      	adds	r3, #118	; 0x76
   1e1c0:	701a      	strb	r2, [r3, #0]
   1e1c2:	e05d      	b.n	1e280 <_ZN4Node11ChangeStateE14discoveryState+0x43c>

		}


	}
	else if (newState == discoveryState::BACK_OFF)
   1e1c4:	9b02      	ldr	r3, [sp, #8]
   1e1c6:	2b09      	cmp	r3, #9
   1e1c8:	d121      	bne.n	1e20e <_ZN4Node11ChangeStateE14discoveryState+0x3ca>
	{
		nextDiscoveryState = discoveryState::DISCOVERY;
   1e1ca:	1c03      	adds	r3, r0, #0
   1e1cc:	2202      	movs	r2, #2
   1e1ce:	3355      	adds	r3, #85	; 0x55
   1e1d0:	701a      	strb	r2, [r3, #0]
		if(Config->meshStateTimeoutBackOffDs == 0) currentStateTimeoutDs = Config->meshStateTimeoutBackOffDs;
   1e1d2:	f002 fe29 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1e1d6:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
   1e1d8:	2b00      	cmp	r3, #0
   1e1da:	d109      	bne.n	1e1f0 <_ZN4Node11ChangeStateE14discoveryState+0x3ac>
   1e1dc:	f002 fe24 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1e1e0:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
   1e1e2:	66a3      	str	r3, [r4, #104]	; 0x68
   1e1e4:	e02e      	b.n	1e244 <_ZN4Node11ChangeStateE14discoveryState+0x400>
   1e1e6:	46c0      	nop			; (mov r8, r8)
   1e1e8:	200033d0 	.word	0x200033d0
   1e1ec:	200033d4 	.word	0x200033d4
		else currentStateTimeoutDs = (Config->meshStateTimeoutBackOffDs + (Utility::GetRandomInteger() % Config->meshStateTimeoutBackOffVarianceDs)); // 5 - 8 sec
   1e1f0:	f002 fe1a 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1e1f4:	8d45      	ldrh	r5, [r0, #42]	; 0x2a
   1e1f6:	f001 fc31 	bl	1fa5c <_ZN7Utility16GetRandomIntegerEv>
   1e1fa:	1c06      	adds	r6, r0, #0
   1e1fc:	f002 fe14 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1e200:	8d81      	ldrh	r1, [r0, #44]	; 0x2c
   1e202:	1c30      	adds	r0, r6, #0
   1e204:	f003 ffbe 	bl	22184 <__aeabi_uidivmod>
   1e208:	194d      	adds	r5, r1, r5
   1e20a:	66a5      	str	r5, [r4, #104]	; 0x68
   1e20c:	e01a      	b.n	1e244 <_ZN4Node11ChangeStateE14discoveryState+0x400>

//		logt("STATES", "-- BACK OFF --");
		AdvertisingController::SetAdvertisingState(ADV_STATE_OFF);
		ScanController::SetScanState(SCAN_STATE_OFF);
	}
	else if (newState == discoveryState::CONNECTING)
   1e20e:	9b02      	ldr	r3, [sp, #8]
   1e210:	2b08      	cmp	r3, #8
   1e212:	d107      	bne.n	1e224 <_ZN4Node11ChangeStateE14discoveryState+0x3e0>
	{
		//Connection will be terminated by connection procedure itself
		//This might be a timeout, or a success
		//Which will call the Handshake state
		//But we will set a high timeout in case anything fails
		currentStateTimeoutDs = SEC_TO_DS(30);
   1e214:	3325      	adds	r3, #37	; 0x25
   1e216:	33ff      	adds	r3, #255	; 0xff
   1e218:	6683      	str	r3, [r0, #104]	; 0x68
		nextDiscoveryState = discoveryState::DECIDING;
   1e21a:	1c03      	adds	r3, r0, #0
   1e21c:	2205      	movs	r2, #5
   1e21e:	3355      	adds	r3, #85	; 0x55
   1e220:	701a      	strb	r2, [r3, #0]
   1e222:	e03a      	b.n	1e29a <_ZN4Node11ChangeStateE14discoveryState+0x456>
//		logt("STATES", "-- CONNECT_AS_MASTER --");
		AdvertisingController::SetAdvertisingState(ADV_STATE_OFF);
		ScanController::SetScanState(SCAN_STATE_OFF);

	}
	else if (newState == discoveryState::HANDSHAKE)
   1e224:	9b02      	ldr	r3, [sp, #8]
   1e226:	2b06      	cmp	r3, #6
   1e228:	d111      	bne.n	1e24e <_ZN4Node11ChangeStateE14discoveryState+0x40a>
	{
		//Use a timeout that is high enough for the handshake to finish
		if(Config->meshHandshakeTimeoutDs != 0){
   1e22a:	f002 fdfd 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1e22e:	8c83      	ldrh	r3, [r0, #36]	; 0x24
   1e230:	2b00      	cmp	r3, #0
   1e232:	d003      	beq.n	1e23c <_ZN4Node11ChangeStateE14discoveryState+0x3f8>
			currentStateTimeoutDs = Config->meshHandshakeTimeoutDs;
   1e234:	f002 fdf8 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1e238:	8c83      	ldrh	r3, [r0, #36]	; 0x24
   1e23a:	66a3      	str	r3, [r4, #104]	; 0x68
		}
		nextDiscoveryState = discoveryState::HANDSHAKE_TIMEOUT;
   1e23c:	1c23      	adds	r3, r4, #0
   1e23e:	2207      	movs	r2, #7
   1e240:	3355      	adds	r3, #85	; 0x55
   1e242:	701a      	strb	r2, [r3, #0]


//		logt("STATES", "-- HANDSHAKE --");
		AdvertisingController::SetAdvertisingState(ADV_STATE_OFF);
   1e244:	2000      	movs	r0, #0
   1e246:	f7fe ffe9 	bl	1d21c <_ZN21AdvertisingController19SetAdvertisingStateE8advState>
		ScanController::SetScanState(SCAN_STATE_OFF);
   1e24a:	2000      	movs	r0, #0
   1e24c:	e640      	b.n	1ded0 <_ZN4Node11ChangeStateE14discoveryState+0x8c>


	}
	else if (newState == discoveryState::HANDSHAKE_TIMEOUT)
   1e24e:	9b02      	ldr	r3, [sp, #8]
   1e250:	2b07      	cmp	r3, #7
   1e252:	d11a      	bne.n	1e28a <_ZN4Node11ChangeStateE14discoveryState+0x446>
	{
		nextDiscoveryState = discoveryState::INVALID_STATE;
   1e254:	1c03      	adds	r3, r0, #0
   1e256:	2500      	movs	r5, #0
   1e258:	3355      	adds	r3, #85	; 0x55
   1e25a:	701d      	strb	r5, [r3, #0]
void Node::HandshakeTimeoutHandler()
{
//	logt("HANDSHAKE", "############ Handshake TIMEOUT ###############");

	//Disconnect the hanging connection
	for(int i=0; i<Config->meshMaxConnections; i++){
   1e25c:	f002 fde4 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1e260:	3035      	adds	r0, #53	; 0x35
   1e262:	7803      	ldrb	r3, [r0, #0]
   1e264:	429d      	cmp	r5, r3
   1e266:	da0b      	bge.n	1e280 <_ZN4Node11ChangeStateE14discoveryState+0x43c>
		if(cm->connections[i]->isConnected() && !cm->connections[i]->handshakeDone()){
   1e268:	4b21      	ldr	r3, [pc, #132]	; (1e2f0 <_ZN4Node11ChangeStateE14discoveryState+0x4ac>)
   1e26a:	681a      	ldr	r2, [r3, #0]
   1e26c:	1c2b      	adds	r3, r5, #0
   1e26e:	3308      	adds	r3, #8
   1e270:	009b      	lsls	r3, r3, #2
   1e272:	5898      	ldr	r0, [r3, r2]
   1e274:	7a03      	ldrb	r3, [r0, #8]
   1e276:	3b02      	subs	r3, #2
   1e278:	2b01      	cmp	r3, #1
   1e27a:	d92c      	bls.n	1e2d6 <_ZN4Node11ChangeStateE14discoveryState+0x492>
void Node::HandshakeTimeoutHandler()
{
//	logt("HANDSHAKE", "############ Handshake TIMEOUT ###############");

	//Disconnect the hanging connection
	for(int i=0; i<Config->meshMaxConnections; i++){
   1e27c:	3501      	adds	r5, #1
   1e27e:	e7ed      	b.n	1e25c <_ZN4Node11ChangeStateE14discoveryState+0x418>
			cm->connections[i]->Disconnect();
		}
	}

	//Go back to discovery
	ChangeState(discoveryState::DISCOVERY);
   1e280:	1c20      	adds	r0, r4, #0
   1e282:	2102      	movs	r1, #2
   1e284:	f7ff fdde 	bl	1de44 <_ZN4Node11ChangeStateE14discoveryState>
   1e288:	e624      	b.n	1ded4 <_ZN4Node11ChangeStateE14discoveryState+0x90>
//		logt("STATES", "-- HANDSHAKE TIMEOUT --");
		HandshakeTimeoutHandler();


	}
	else if (newState == discoveryState::DISCOVERY_OFF)
   1e28a:	9b02      	ldr	r3, [sp, #8]
   1e28c:	2b0a      	cmp	r3, #10
   1e28e:	d000      	beq.n	1e292 <_ZN4Node11ChangeStateE14discoveryState+0x44e>
   1e290:	e620      	b.n	1ded4 <_ZN4Node11ChangeStateE14discoveryState+0x90>
	{
		nextDiscoveryState = discoveryState::INVALID_STATE;
   1e292:	1c03      	adds	r3, r0, #0
   1e294:	2500      	movs	r5, #0
   1e296:	3355      	adds	r3, #85	; 0x55
   1e298:	701d      	strb	r5, [r3, #0]


//		logt("STATES", "-- DISCOVERY OFF --");
		AdvertisingController::SetAdvertisingState(ADV_STATE_OFF);
   1e29a:	1c28      	adds	r0, r5, #0
   1e29c:	f7fe ffbe 	bl	1d21c <_ZN21AdvertisingController19SetAdvertisingStateE8advState>
		ScanController::SetScanState(SCAN_STATE_OFF);
   1e2a0:	1c28      	adds	r0, r5, #0
   1e2a2:	e615      	b.n	1ded0 <_ZN4Node11ChangeStateE14discoveryState+0x8c>
	}

	//Inform all modules of the new state
	//Dispatch event to all modules
	for(int i=0; i<MAX_MODULE_COUNT; i++){
		if(activeModules[i] != 0 && activeModules[i]->configurationPointer->moduleActive){
   1e2a4:	6a03      	ldr	r3, [r0, #32]
   1e2a6:	789b      	ldrb	r3, [r3, #2]
   1e2a8:	2b00      	cmp	r3, #0
   1e2aa:	d003      	beq.n	1e2b4 <_ZN4Node11ChangeStateE14discoveryState+0x470>
			activeModules[i]->NodeStateChangedHandler(newState);
   1e2ac:	6803      	ldr	r3, [r0, #0]
   1e2ae:	9902      	ldr	r1, [sp, #8]
   1e2b0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   1e2b2:	4798      	blx	r3
   1e2b4:	3504      	adds	r5, #4

	}

	//Inform all modules of the new state
	//Dispatch event to all modules
	for(int i=0; i<MAX_MODULE_COUNT; i++){
   1e2b6:	42a5      	cmp	r5, r4
   1e2b8:	d018      	beq.n	1e2ec <_ZN4Node11ChangeStateE14discoveryState+0x4a8>
		if(activeModules[i] != 0 && activeModules[i]->configurationPointer->moduleActive){
   1e2ba:	6828      	ldr	r0, [r5, #0]
   1e2bc:	2800      	cmp	r0, #0
   1e2be:	d1f1      	bne.n	1e2a4 <_ZN4Node11ChangeStateE14discoveryState+0x460>
   1e2c0:	e7f8      	b.n	1e2b4 <_ZN4Node11ChangeStateE14discoveryState+0x470>
			Node::decisionResult decision = DetermineBestClusterAvailable();


			if (decision == Node::DECISION_NO_NODES_FOUND)
			{
				if (noNodesFoundCounter < 100) //Do not overflow
   1e2c2:	1c22      	adds	r2, r4, #0
   1e2c4:	3276      	adds	r2, #118	; 0x76
   1e2c6:	7813      	ldrb	r3, [r2, #0]
   1e2c8:	2b63      	cmp	r3, #99	; 0x63
   1e2ca:	d801      	bhi.n	1e2d0 <_ZN4Node11ChangeStateE14discoveryState+0x48c>
					noNodesFoundCounter++;
   1e2cc:	3301      	adds	r3, #1
   1e2ce:	7013      	strb	r3, [r2, #0]
				ChangeState(discoveryState::BACK_OFF);
   1e2d0:	1c20      	adds	r0, r4, #0
   1e2d2:	2109      	movs	r1, #9
   1e2d4:	e7d6      	b.n	1e284 <_ZN4Node11ChangeStateE14discoveryState+0x440>
//	logt("HANDSHAKE", "############ Handshake TIMEOUT ###############");

	//Disconnect the hanging connection
	for(int i=0; i<Config->meshMaxConnections; i++){
		if(cm->connections[i]->isConnected() && !cm->connections[i]->handshakeDone()){
			cm->connections[i]->Disconnect();
   1e2d6:	f001 fc2d 	bl	1fb34 <_ZN10Connection10DisconnectEv>
   1e2da:	e7cf      	b.n	1e27c <_ZN4Node11ChangeStateE14discoveryState+0x438>
	if (freeOutConnections <= 0 || pendingConnection != NULL) return NULL;

	Connection* connection = GetFreeOutConnection();

	//Disperse connection intervals over time, maybe this leads to less connection losses
	u16 connectionInterval = Config->meshMinConnectionInterval + connection->connectionId;
   1e2dc:	f002 fda4 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1e2e0:	2300      	movs	r3, #0
   1e2e2:	7b1b      	ldrb	r3, [r3, #12]
   1e2e4:	deff      	udf	#255	; 0xff

		if(result == 1){
			//as peripheral
			ChangeState(discoveryState::DISCOVERY_HIGH);
		} else if(result == 2){
			ChangeState(discoveryState::CONNECTING);
   1e2e6:	1c20      	adds	r0, r4, #0
   1e2e8:	2108      	movs	r1, #8
   1e2ea:	e7cb      	b.n	1e284 <_ZN4Node11ChangeStateE14discoveryState+0x440>
	for(int i=0; i<MAX_MODULE_COUNT; i++){
		if(activeModules[i] != 0 && activeModules[i]->configurationPointer->moduleActive){
			activeModules[i]->NodeStateChangedHandler(newState);
		}
	}
}
   1e2ec:	b011      	add	sp, #68	; 0x44
   1e2ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1e2f0:	200033d0 	.word	0x200033d0

0001e2f4 <_ZN17ConnectionManager27ConnectionSuccessfulHandlerEP9ble_evt_t>:
}


//Called as soon as a new connection is made, either as central or peripheral
void ConnectionManager::ConnectionSuccessfulHandler(ble_evt_t* bleEvent)
{
   1e2f4:	b5f0      	push	{r4, r5, r6, r7, lr}
   1e2f6:	1c05      	adds	r5, r0, #0
   1e2f8:	b08b      	sub	sp, #44	; 0x2c
	ConnectionManager* cm = ConnectionManager::getInstance();
   1e2fa:	f7ff f9e9 	bl	1d6d0 <_ZN17ConnectionManager11getInstanceEv>
}

Connection* ConnectionManager::IsConnectionReestablishment(ble_evt_t* bleEvent)
{
	//Check if we already have a connection for this peer, identified by its address
	ble_gap_addr_t* peerAddress = &bleEvent->evt.gap_evt.params.connected.peer_addr;
   1e2fe:	1c2b      	adds	r3, r5, #0


//Called as soon as a new connection is made, either as central or peripheral
void ConnectionManager::ConnectionSuccessfulHandler(ble_evt_t* bleEvent)
{
	ConnectionManager* cm = ConnectionManager::getInstance();
   1e300:	1c04      	adds	r4, r0, #0

Connection* ConnectionManager::IsConnectionReestablishment(ble_evt_t* bleEvent)
{
	//Check if we already have a connection for this peer, identified by its address
	ble_gap_addr_t* peerAddress = &bleEvent->evt.gap_evt.params.connected.peer_addr;
	for(int i=0; i<Config->meshMaxConnections; i++){
   1e302:	2700      	movs	r7, #0
}

Connection* ConnectionManager::IsConnectionReestablishment(ble_evt_t* bleEvent)
{
	//Check if we already have a connection for this peer, identified by its address
	ble_gap_addr_t* peerAddress = &bleEvent->evt.gap_evt.params.connected.peer_addr;
   1e304:	3308      	adds	r3, #8
   1e306:	9301      	str	r3, [sp, #4]
	for(int i=0; i<Config->meshMaxConnections; i++){
   1e308:	f002 fd8e 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1e30c:	3035      	adds	r0, #53	; 0x35
   1e30e:	7803      	ldrb	r3, [r0, #0]
   1e310:	429f      	cmp	r7, r3
   1e312:	da24      	bge.n	1e35e <_ZN17ConnectionManager27ConnectionSuccessfulHandlerEP9ble_evt_t+0x6a>
   1e314:	00bb      	lsls	r3, r7, #2
   1e316:	18e3      	adds	r3, r4, r3
		if(connections[i]->connectionState == Connection::ConnectionState::REESTABLISHING){
   1e318:	6a1e      	ldr	r6, [r3, #32]
   1e31a:	7a33      	ldrb	r3, [r6, #8]
   1e31c:	2b05      	cmp	r3, #5
   1e31e:	d11c      	bne.n	1e35a <_ZN17ConnectionManager27ConnectionSuccessfulHandlerEP9ble_evt_t+0x66>
			if(memcmp(&connections[i]->partnerAddress, peerAddress, sizeof(ble_gap_addr_t)) == 0){
   1e320:	1c30      	adds	r0, r6, #0
   1e322:	30d5      	adds	r0, #213	; 0xd5
   1e324:	30ff      	adds	r0, #255	; 0xff
   1e326:	9901      	ldr	r1, [sp, #4]
   1e328:	2207      	movs	r2, #7
   1e32a:	f003 f964 	bl	215f6 <memcmp>
   1e32e:	2800      	cmp	r0, #0
   1e330:	d113      	bne.n	1e35a <_ZN17ConnectionManager27ConnectionSuccessfulHandlerEP9ble_evt_t+0x66>
}

void Connection::ReconnectionSuccessfulHandler(ble_evt_t* bleEvent){
	logt("CONN", "Reconnection Successful");

	connectionHandle = bleEvent->evt.gap_evt.conn_handle;
   1e332:	23e9      	movs	r3, #233	; 0xe9
	sd_ble_tx_packet_count_get(this->connectionHandle, &unreliableBuffersFree);
   1e334:	1c31      	adds	r1, r6, #0
}

void Connection::ReconnectionSuccessfulHandler(ble_evt_t* bleEvent){
	logt("CONN", "Reconnection Successful");

	connectionHandle = bleEvent->evt.gap_evt.conn_handle;
   1e336:	88a8      	ldrh	r0, [r5, #4]
   1e338:	005b      	lsls	r3, r3, #1
   1e33a:	52f0      	strh	r0, [r6, r3]
	sd_ble_tx_packet_count_get(this->connectionHandle, &unreliableBuffersFree);
   1e33c:	3113      	adds	r1, #19
   1e33e:	f001 fc75 	bl	1fc2c <sd_ble_tx_packet_count_get.lto_priv.70>
	reliableBuffersFree = 1;
   1e342:	2301      	movs	r3, #1
   1e344:	7533      	strb	r3, [r6, #20]

	connectionState = ConnectionState::HANDSHAKE_DONE;
   1e346:	3303      	adds	r3, #3

	/* Part A: We have a connection reestablishment */
	if(connection != NULL)
	{
		connection->ReconnectionSuccessfulHandler(bleEvent);
		cm->fillTransmitBuffers();
   1e348:	1c20      	adds	r0, r4, #0
   1e34a:	7233      	strb	r3, [r6, #8]
   1e34c:	f001 fccc 	bl	1fce8 <_ZN17ConnectionManager19fillTransmitBuffersEv>
		cm->node->ChangeState(discoveryState::DISCOVERY);
   1e350:	6860      	ldr	r0, [r4, #4]
   1e352:	2102      	movs	r1, #2
   1e354:	f7ff fd76 	bl	1de44 <_ZN4Node11ChangeStateE14discoveryState>
   1e358:	e093      	b.n	1e482 <_ZN17ConnectionManager27ConnectionSuccessfulHandlerEP9ble_evt_t+0x18e>

Connection* ConnectionManager::IsConnectionReestablishment(ble_evt_t* bleEvent)
{
	//Check if we already have a connection for this peer, identified by its address
	ble_gap_addr_t* peerAddress = &bleEvent->evt.gap_evt.params.connected.peer_addr;
	for(int i=0; i<Config->meshMaxConnections; i++){
   1e35a:	3701      	adds	r7, #1
   1e35c:	e7d4      	b.n	1e308 <_ZN17ConnectionManager27ConnectionSuccessfulHandlerEP9ble_evt_t+0x14>
	//Set a variable here that a handshake is ongoing and block any other handshake
	//From happening in the meantime, just disconnect the intruder

	//If we are currently doing a Handshake, we disconnect this connection
	//beacuse we cannot do two handshakes at the same time
	if(cm->node->currentDiscoveryState == discoveryState::HANDSHAKE){
   1e35e:	6863      	ldr	r3, [r4, #4]
   1e360:	3354      	adds	r3, #84	; 0x54
   1e362:	781b      	ldrb	r3, [r3, #0]
   1e364:	2b06      	cmp	r3, #6
   1e366:	d103      	bne.n	1e370 <_ZN17ConnectionManager27ConnectionSuccessfulHandlerEP9ble_evt_t+0x7c>
		logt("ERROR", "CURRENTLY IN HANDSHAKE!!!!!!!!!!");

		sd_ble_gap_disconnect(bleEvent->evt.gap_evt.conn_handle, BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION);
   1e368:	88a8      	ldrh	r0, [r5, #4]
   1e36a:	2113      	movs	r1, #19
   1e36c:	f7ff fb3e 	bl	1d9ec <sd_ble_gap_disconnect>


	Connection* c = NULL;

	//We are slave (peripheral)
	if (bleEvent->evt.gap_evt.params.connected.role == BLE_GAP_ROLE_PERIPH)
   1e370:	7daf      	ldrb	r7, [r5, #22]
   1e372:	2f01      	cmp	r7, #1
   1e374:	d12a      	bne.n	1e3cc <_ZN17ConnectionManager27ConnectionSuccessfulHandlerEP9ble_evt_t+0xd8>
	{
		c = cm->inConnection;
		cm->freeInConnections--;
   1e376:	7b63      	ldrb	r3, [r4, #13]
	Connection* c = NULL;

	//We are slave (peripheral)
	if (bleEvent->evt.gap_evt.params.connected.role == BLE_GAP_ROLE_PERIPH)
	{
		c = cm->inConnection;
   1e378:	6926      	ldr	r6, [r4, #16]
		cm->freeInConnections--;
   1e37a:	3b01      	subs	r3, #1
   1e37c:	7363      	strb	r3, [r4, #13]

		//At this point, the Write handle is still unknown
		c->PrepareConnection(&bleEvent->evt.gap_evt.params.connected.peer_addr, BLE_GATT_HANDLE_INVALID);
   1e37e:	9901      	ldr	r1, [sp, #4]
   1e380:	2200      	movs	r2, #0
   1e382:	1c30      	adds	r0, r6, #0
   1e384:	f001 fc8a 	bl	1fc9c <_ZN10Connection17PrepareConnectionEP14ble_gap_addr_tt>
/*######## HANDLER ###################################*/
void Connection::ConnectionSuccessfulHandler(ble_evt_t* bleEvent)
{
	u32 err = 0;

	this->handshakeStartedDs = node->appTimerDs;
   1e388:	6833      	ldr	r3, [r6, #0]
		logt("CONN", "Incoming connection %d connected", connectionId);
	else
		logt("CONN", "Outgoing connection %d connected", connectionId);

	connectionHandle = bleEvent->evt.gap_evt.conn_handle;
	err = sd_ble_tx_packet_count_get(this->connectionHandle, &unreliableBuffersFree);
   1e38a:	1c31      	adds	r1, r6, #0
/*######## HANDLER ###################################*/
void Connection::ConnectionSuccessfulHandler(ble_evt_t* bleEvent)
{
	u32 err = 0;

	this->handshakeStartedDs = node->appTimerDs;
   1e38c:	6e5a      	ldr	r2, [r3, #100]	; 0x64
   1e38e:	2385      	movs	r3, #133	; 0x85
   1e390:	009b      	lsls	r3, r3, #2
   1e392:	50f2      	str	r2, [r6, r3]
	if (direction == CONNECTION_DIRECTION_IN)
		logt("CONN", "Incoming connection %d connected", connectionId);
	else
		logt("CONN", "Outgoing connection %d connected", connectionId);

	connectionHandle = bleEvent->evt.gap_evt.conn_handle;
   1e394:	88a8      	ldrh	r0, [r5, #4]
   1e396:	3b42      	subs	r3, #66	; 0x42
   1e398:	52f0      	strh	r0, [r6, r3]
	err = sd_ble_tx_packet_count_get(this->connectionHandle, &unreliableBuffersFree);
   1e39a:	3113      	adds	r1, #19
   1e39c:	f001 fc46 	bl	1fc2c <sd_ble_tx_packet_count_get.lto_priv.70>
	if(err != NRF_SUCCESS){
		//BLE_ERROR_INVALID_CONN_HANDLE && NRF_ERROR_INVALID_ADDR can be ignored
	}

	//Save connection interval (min and max are the same values in this event)
	currentConnectionIntervalMs = bleEvent->evt.gap_evt.params.connected.conn_params.min_conn_interval;
   1e3a0:	23ef      	movs	r3, #239	; 0xef
   1e3a2:	8b2a      	ldrh	r2, [r5, #24]
   1e3a4:	005b      	lsls	r3, r3, #1
   1e3a6:	52f2      	strh	r2, [r6, r3]
		c->ConnectionSuccessfulHandler(bleEvent);
		cm->connectionManagerCallback->ConnectionSuccessfulHandler(bleEvent);
   1e3a8:	68a0      	ldr	r0, [r4, #8]

	connectionState = ConnectionState::CONNECTED;
   1e3aa:	3bdd      	subs	r3, #221	; 0xdd
   1e3ac:	3bff      	subs	r3, #255	; 0xff
   1e3ae:	7233      	strb	r3, [r6, #8]
   1e3b0:	6803      	ldr	r3, [r0, #0]
   1e3b2:	1c29      	adds	r1, r5, #0
   1e3b4:	68db      	ldr	r3, [r3, #12]
   1e3b6:	4798      	blx	r3

		//If encryption is enabled, we wait for the central to start encrypting
		if(Config->encryptionEnabled)
   1e3b8:	f002 fd36 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1e3bc:	3056      	adds	r0, #86	; 0x56
   1e3be:	7803      	ldrb	r3, [r0, #0]
   1e3c0:	2b00      	cmp	r3, #0
   1e3c2:	d15c      	bne.n	1e47e <_ZN17ConnectionManager27ConnectionSuccessfulHandlerEP9ble_evt_t+0x18a>
		{

		}
		//If handshake is disabled,
		else if(!cm->doHandshake){
   1e3c4:	7b23      	ldrb	r3, [r4, #12]
   1e3c6:	2b00      	cmp	r3, #0
   1e3c8:	d159      	bne.n	1e47e <_ZN17ConnectionManager27ConnectionSuccessfulHandlerEP9ble_evt_t+0x18a>
   1e3ca:	e056      	b.n	1e47a <_ZN17ConnectionManager27ConnectionSuccessfulHandlerEP9ble_evt_t+0x186>
			c->connectionState = Connection::ConnectionState::HANDSHAKE_DONE;
		}
	}
	//We are master (central)
	else if (bleEvent->evt.gap_evt.params.connected.role == BLE_GAP_ROLE_CENTRAL)
   1e3cc:	2f02      	cmp	r7, #2
   1e3ce:	d156      	bne.n	1e47e <_ZN17ConnectionManager27ConnectionSuccessfulHandlerEP9ble_evt_t+0x18a>
	{
		cm->freeOutConnections--;
   1e3d0:	7ba3      	ldrb	r3, [r4, #14]

		c = cm->pendingConnection;
   1e3d2:	6826      	ldr	r6, [r4, #0]
		}
	}
	//We are master (central)
	else if (bleEvent->evt.gap_evt.params.connected.role == BLE_GAP_ROLE_CENTRAL)
	{
		cm->freeOutConnections--;
   1e3d4:	3b01      	subs	r3, #1
   1e3d6:	73a3      	strb	r3, [r4, #14]

		c = cm->pendingConnection;

		//Call Prepare again so that the clusterID and size backup are created with up to date values
		c->PrepareConnection(&bleEvent->evt.gap_evt.params.connected.peer_addr, c->writeCharacteristicHandle);
   1e3d8:	23ee      	movs	r3, #238	; 0xee
   1e3da:	005b      	lsls	r3, r3, #1
   1e3dc:	5af2      	ldrh	r2, [r6, r3]
   1e3de:	9901      	ldr	r1, [sp, #4]
   1e3e0:	1c30      	adds	r0, r6, #0
   1e3e2:	f001 fc5b 	bl	1fc9c <_ZN10Connection17PrepareConnectionEP14ble_gap_addr_tt>
/*######## HANDLER ###################################*/
void Connection::ConnectionSuccessfulHandler(ble_evt_t* bleEvent)
{
	u32 err = 0;

	this->handshakeStartedDs = node->appTimerDs;
   1e3e6:	6833      	ldr	r3, [r6, #0]
		logt("CONN", "Incoming connection %d connected", connectionId);
	else
		logt("CONN", "Outgoing connection %d connected", connectionId);

	connectionHandle = bleEvent->evt.gap_evt.conn_handle;
	err = sd_ble_tx_packet_count_get(this->connectionHandle, &unreliableBuffersFree);
   1e3e8:	1c31      	adds	r1, r6, #0
/*######## HANDLER ###################################*/
void Connection::ConnectionSuccessfulHandler(ble_evt_t* bleEvent)
{
	u32 err = 0;

	this->handshakeStartedDs = node->appTimerDs;
   1e3ea:	6e5a      	ldr	r2, [r3, #100]	; 0x64
   1e3ec:	2385      	movs	r3, #133	; 0x85
   1e3ee:	009b      	lsls	r3, r3, #2
   1e3f0:	50f2      	str	r2, [r6, r3]
	if (direction == CONNECTION_DIRECTION_IN)
		logt("CONN", "Incoming connection %d connected", connectionId);
	else
		logt("CONN", "Outgoing connection %d connected", connectionId);

	connectionHandle = bleEvent->evt.gap_evt.conn_handle;
   1e3f2:	88a8      	ldrh	r0, [r5, #4]
   1e3f4:	3b42      	subs	r3, #66	; 0x42
   1e3f6:	52f0      	strh	r0, [r6, r3]
	err = sd_ble_tx_packet_count_get(this->connectionHandle, &unreliableBuffersFree);
   1e3f8:	3113      	adds	r1, #19
   1e3fa:	f001 fc17 	bl	1fc2c <sd_ble_tx_packet_count_get.lto_priv.70>
	if(err != NRF_SUCCESS){
		//BLE_ERROR_INVALID_CONN_HANDLE && NRF_ERROR_INVALID_ADDR can be ignored
	}

	//Save connection interval (min and max are the same values in this event)
	currentConnectionIntervalMs = bleEvent->evt.gap_evt.params.connected.conn_params.min_conn_interval;
   1e3fe:	23ef      	movs	r3, #239	; 0xef
   1e400:	8b2a      	ldrh	r2, [r5, #24]
		c->ConnectionSuccessfulHandler(bleEvent);
		cm->connectionManagerCallback->ConnectionSuccessfulHandler(bleEvent);
   1e402:	68a0      	ldr	r0, [r4, #8]
   1e404:	005b      	lsls	r3, r3, #1
   1e406:	52f2      	strh	r2, [r6, r3]
   1e408:	6803      	ldr	r3, [r0, #0]
   1e40a:	1c29      	adds	r1, r5, #0
   1e40c:	68db      	ldr	r3, [r3, #12]

	connectionState = ConnectionState::CONNECTED;
   1e40e:	7237      	strb	r7, [r6, #8]
   1e410:	4798      	blx	r3

		//If encryption is enabled, the central starts to encrypt the connection
		if(Config->encryptionEnabled)
   1e412:	f002 fd09 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1e416:	3056      	adds	r0, #86	; 0x56
   1e418:	7803      	ldrb	r3, [r0, #0]
   1e41a:	2b00      	cmp	r3, #0
   1e41c:	d026      	beq.n	1e46c <_ZN17ConnectionManager27ConnectionSuccessfulHandlerEP9ble_evt_t+0x178>
		{
			c->encryptionState = Connection::EncryptionState::ENCRYPTING;
   1e41e:	2301      	movs	r3, #1
	u32 err = 0;

	//Key identification data
	//We do not need a key identification currently, because we only have one
	ble_gap_master_id_t keyId;
	keyId.ediv = 0;
   1e420:	2100      	movs	r1, #0
   1e422:	7273      	strb	r3, [r6, #9]
   1e424:	ab02      	add	r3, sp, #8
			GAPController::startEncryptingConnection(bleEvent->evt.gap_evt.conn_handle);
   1e426:	88ae      	ldrh	r6, [r5, #4]
	memset(&keyId.rand, 0, 16);
   1e428:	1c98      	adds	r0, r3, #2

	//Our mesh network key
	ble_gap_enc_info_t key;
	key.auth = 1;
   1e42a:	ad05      	add	r5, sp, #20

	//Key identification data
	//We do not need a key identification currently, because we only have one
	ble_gap_master_id_t keyId;
	keyId.ediv = 0;
	memset(&keyId.rand, 0, 16);
   1e42c:	2210      	movs	r2, #16
	u32 err = 0;

	//Key identification data
	//We do not need a key identification currently, because we only have one
	ble_gap_master_id_t keyId;
	keyId.ediv = 0;
   1e42e:	8019      	strh	r1, [r3, #0]
	memset(&keyId.rand, 0, 16);
   1e430:	f003 f90d 	bl	2164e <memset>

	//Our mesh network key
	ble_gap_enc_info_t key;
	key.auth = 1;
   1e434:	7c2b      	ldrb	r3, [r5, #16]
	memcpy(&key.ltk, Node::getInstance()->persistentConfig.networkKey, 16);
   1e436:	2210      	movs	r2, #16
	keyId.ediv = 0;
	memset(&keyId.rand, 0, 16);

	//Our mesh network key
	ble_gap_enc_info_t key;
	key.auth = 1;
   1e438:	433b      	orrs	r3, r7
   1e43a:	742b      	strb	r3, [r5, #16]
	memcpy(&key.ltk, Node::getInstance()->persistentConfig.networkKey, 16);
   1e43c:	4b12      	ldr	r3, [pc, #72]	; (1e488 <_ZN17ConnectionManager27ConnectionSuccessfulHandlerEP9ble_evt_t+0x194>)
   1e43e:	1c28      	adds	r0, r5, #0
   1e440:	6819      	ldr	r1, [r3, #0]
   1e442:	3128      	adds	r1, #40	; 0x28
   1e444:	f003 f8e6 	bl	21614 <memcpy>
	key.ltk_len = 16;
   1e448:	2303      	movs	r3, #3
   1e44a:	7c2a      	ldrb	r2, [r5, #16]


	//This starts the Central Encryption Establishment using stored keys
	//http://infocenter.nordicsemi.com/topic/com.nordic.infocenter.s130.api.v1.0.0/group___b_l_e___g_a_p___c_e_n_t_r_a_l___e_n_c___m_s_c.html
	//http://infocenter.nordicsemi.com/topic/com.nordic.infocenter.s130.api.v1.0.0/group___b_l_e___g_a_p___p_e_r_i_p_h___e_n_c___m_s_c.html
	err = sd_ble_gap_encrypt(connectionHandle, &keyId, &key);
   1e44c:	1c30      	adds	r0, r6, #0

	//Our mesh network key
	ble_gap_enc_info_t key;
	key.auth = 1;
	memcpy(&key.ltk, Node::getInstance()->persistentConfig.networkKey, 16);
	key.ltk_len = 16;
   1e44e:	4013      	ands	r3, r2
   1e450:	2240      	movs	r2, #64	; 0x40


	//This starts the Central Encryption Establishment using stored keys
	//http://infocenter.nordicsemi.com/topic/com.nordic.infocenter.s130.api.v1.0.0/group___b_l_e___g_a_p___c_e_n_t_r_a_l___e_n_c___m_s_c.html
	//http://infocenter.nordicsemi.com/topic/com.nordic.infocenter.s130.api.v1.0.0/group___b_l_e___g_a_p___p_e_r_i_p_h___e_n_c___m_s_c.html
	err = sd_ble_gap_encrypt(connectionHandle, &keyId, &key);
   1e452:	a902      	add	r1, sp, #8

	//Our mesh network key
	ble_gap_enc_info_t key;
	key.auth = 1;
	memcpy(&key.ltk, Node::getInstance()->persistentConfig.networkKey, 16);
	key.ltk_len = 16;
   1e454:	4313      	orrs	r3, r2


	//This starts the Central Encryption Establishment using stored keys
	//http://infocenter.nordicsemi.com/topic/com.nordic.infocenter.s130.api.v1.0.0/group___b_l_e___g_a_p___c_e_n_t_r_a_l___e_n_c___m_s_c.html
	//http://infocenter.nordicsemi.com/topic/com.nordic.infocenter.s130.api.v1.0.0/group___b_l_e___g_a_p___p_e_r_i_p_h___e_n_c___m_s_c.html
	err = sd_ble_gap_encrypt(connectionHandle, &keyId, &key);
   1e456:	1c2a      	adds	r2, r5, #0

	//Our mesh network key
	ble_gap_enc_info_t key;
	key.auth = 1;
	memcpy(&key.ltk, Node::getInstance()->persistentConfig.networkKey, 16);
	key.ltk_len = 16;
   1e458:	742b      	strb	r3, [r5, #16]


	//This starts the Central Encryption Establishment using stored keys
	//http://infocenter.nordicsemi.com/topic/com.nordic.infocenter.s130.api.v1.0.0/group___b_l_e___g_a_p___c_e_n_t_r_a_l___e_n_c___m_s_c.html
	//http://infocenter.nordicsemi.com/topic/com.nordic.infocenter.s130.api.v1.0.0/group___b_l_e___g_a_p___p_e_r_i_p_h___e_n_c___m_s_c.html
	err = sd_ble_gap_encrypt(connectionHandle, &keyId, &key);
   1e45a:	f7fe ff81 	bl	1d360 <sd_ble_gap_encrypt.lto_priv.69>
	APP_ERROR_CHECK(err); //TODO: error handling
   1e45e:	2800      	cmp	r0, #0
   1e460:	d00d      	beq.n	1e47e <_ZN17ConnectionManager27ConnectionSuccessfulHandlerEP9ble_evt_t+0x18a>
   1e462:	218e      	movs	r1, #142	; 0x8e
   1e464:	4a09      	ldr	r2, [pc, #36]	; (1e48c <_ZN17ConnectionManager27ConnectionSuccessfulHandlerEP9ble_evt_t+0x198>)
   1e466:	0049      	lsls	r1, r1, #1
   1e468:	f7fe ffcc 	bl	1d404 <app_error_handler>
		}
		//If no encryption is enabled, we start the handshake
		else if(cm->doHandshake)
   1e46c:	7b23      	ldrb	r3, [r4, #12]
   1e46e:	2b00      	cmp	r3, #0
   1e470:	d003      	beq.n	1e47a <_ZN17ConnectionManager27ConnectionSuccessfulHandlerEP9ble_evt_t+0x186>
		{
			c->StartHandshake();
   1e472:	1c30      	adds	r0, r6, #0
   1e474:	f001 fb0e 	bl	1fa94 <_ZN10Connection14StartHandshakeEv>
   1e478:	e001      	b.n	1e47e <_ZN17ConnectionManager27ConnectionSuccessfulHandlerEP9ble_evt_t+0x18a>
		}
		//If the handshake is disabled, we just set the variable
		else
		{
			c->connectionState = Connection::ConnectionState::HANDSHAKE_DONE;
   1e47a:	2304      	movs	r3, #4
   1e47c:	7233      	strb	r3, [r6, #8]
		}
	}

	cm->pendingConnection = NULL;
   1e47e:	2300      	movs	r3, #0
   1e480:	6023      	str	r3, [r4, #0]
}
   1e482:	b00b      	add	sp, #44	; 0x2c
   1e484:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1e486:	46c0      	nop			; (mov r8, r8)
   1e488:	200033d8 	.word	0x200033d8
   1e48c:	000228a3 	.word	0x000228a3

0001e490 <_ZN4Node4StopEv>:
{
	stateMachineDisabled = disable;
}

//Convenience method for stopping all mesh activity
void Node::Stop(){
   1e490:	b510      	push	{r4, lr}
	ChangeState(discoveryState::DISCOVERY_OFF);
   1e492:	210a      	movs	r1, #10
{
	stateMachineDisabled = disable;
}

//Convenience method for stopping all mesh activity
void Node::Stop(){
   1e494:	1c04      	adds	r4, r0, #0
	ChangeState(discoveryState::DISCOVERY_OFF);
   1e496:	f7ff fcd5 	bl	1de44 <_ZN4Node11ChangeStateE14discoveryState>
	}
}

void Node::DisableStateMachine(bool disable)
{
	stateMachineDisabled = disable;
   1e49a:	2301      	movs	r3, #1
   1e49c:	7323      	strb	r3, [r4, #12]

//Convenience method for stopping all mesh activity
void Node::Stop(){
	ChangeState(discoveryState::DISCOVERY_OFF);
	DisableStateMachine(true);
}
   1e49e:	bd10      	pop	{r4, pc}

0001e4a0 <_ZN20StatusReporterModuleD1Ev.lto_priv.107>:
#pragma once

#include <Module.h>
#include <Terminal.h>

class StatusReporterModule: public Module
   1e4a0:	4770      	bx	lr
	...

0001e4a4 <_ZThn4_N20StatusReporterModuleD1Ev.lto_priv.108>:
   1e4a4:	b408      	push	{r3}
   1e4a6:	4b02      	ldr	r3, [pc, #8]	; (1e4b0 <_ZThn4_N20StatusReporterModuleD1Ev.lto_priv.108+0xc>)
   1e4a8:	469c      	mov	ip, r3
   1e4aa:	3804      	subs	r0, #4
   1e4ac:	bc08      	pop	{r3}
   1e4ae:	4760      	bx	ip
   1e4b0:	0001e4a1 	.word	0x0001e4a1

0001e4b4 <sd_ble_gap_rssi_start>:
 *
 * @retval ::NRF_SUCCESS                   Successfully activated RSSI reporting.
 * @retval ::NRF_ERROR_INVALID_STATE       Disconnection in progress. Invalid state to perform operation.
 * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
 */
SVCALL(SD_BLE_GAP_RSSI_START, uint32_t, sd_ble_gap_rssi_start(uint16_t conn_handle, uint8_t threshold_dbm, uint8_t skip_count));
   1e4b4:	df88      	svc	136	; 0x88
   1e4b6:	4770      	bx	lr

0001e4b8 <_ZN14ScanningModuleD1Ev.lto_priv.101>:
			u8 byteMask[31];
			u8 mandatory[31];

		} scanFilterEntry;

class ScanningModule: public Module
   1e4b8:	4770      	bx	lr
	...

0001e4bc <_ZThn4_N14ScanningModuleD1Ev.lto_priv.103>:
   1e4bc:	b408      	push	{r3}
   1e4be:	4b02      	ldr	r3, [pc, #8]	; (1e4c8 <_ZThn4_N14ScanningModuleD1Ev.lto_priv.103+0xc>)
   1e4c0:	469c      	mov	ip, r3
   1e4c2:	3804      	subs	r0, #4
   1e4c4:	bc08      	pop	{r3}
   1e4c6:	4760      	bx	ip
   1e4c8:	0001e4b9 	.word	0x0001e4b9

0001e4cc <_ZN6Module14GetDataHandlerEPhh>:

		//Called when the module should update configuration parameters
		virtual void SetConfigurationHandler(u8* configuration, u8 length){};

		//Called when the module should send back its data
		virtual void GetDataHandler(u8* request, u8 length){};
   1e4cc:	4770      	bx	lr

0001e4ce <_ZN6Module23SetConfigurationHandlerEPhh>:
		//A basic error-checking implementation is provided and can be called by the subclass
		//before reading the configuration
		void ConfigurationLoadedHandler();

		//Called when the module should update configuration parameters
		virtual void SetConfigurationHandler(u8* configuration, u8 length){};
   1e4ce:	4770      	bx	lr

0001e4d0 <_ZN20StatusReporterModule26ConfigurationLoadedHandlerEv>:
}

void StatusReporterModule::ConfigurationLoadedHandler()
{
   1e4d0:	b508      	push	{r3, lr}
	//Does basic testing on the loaded configuration
	Module::ConfigurationLoadedHandler();
   1e4d2:	f002 f85b 	bl	2058c <_ZN6Module26ConfigurationLoadedHandlerEv>
	//Version migration can be added here
	if(configuration.moduleVersion == 1){/* ... */};

	//Start the Module...

}
   1e4d6:	bd08      	pop	{r3, pc}

0001e4d8 <_ZN14ScanningModule26ConfigurationLoadedHandlerEv>:
}

void ScanningModule::ConfigurationLoadedHandler()
{
   1e4d8:	b510      	push	{r4, lr}
   1e4da:	1c04      	adds	r4, r0, #0
	//Does basic testing on the loaded configuration
	Module::ConfigurationLoadedHandler();
   1e4dc:	f002 f856 	bl	2058c <_ZN6Module26ConfigurationLoadedHandlerEv>
	return false;
}

void ScanningModule::resetAddressTable()
{
	addressPointer = 0;
   1e4e0:	23ce      	movs	r3, #206	; 0xce
   1e4e2:	2200      	movs	r2, #0
   1e4e4:	005b      	lsls	r3, r3, #1
   1e4e6:	54e2      	strb	r2, [r4, r3]
   1e4e8:	3331      	adds	r3, #49	; 0x31
   1e4ea:	33ff      	adds	r3, #255	; 0xff
   1e4ec:	18e2      	adds	r2, r4, r3
   1e4ee:	33c8      	adds	r3, #200	; 0xc8
   1e4f0:	18e3      	adds	r3, r4, r3

void ScanningModule::resetTotalRSSIsPerAddress()
{
	for (int i = 0; i < NUM_ADDRESSES_TRACKED; i++)
	{
		totalRSSIsPerAddress[i] = 0;
   1e4f2:	2100      	movs	r1, #0
   1e4f4:	c202      	stmia	r2!, {r1}
	addressPointer = 0;
}

void ScanningModule::resetTotalRSSIsPerAddress()
{
	for (int i = 0; i < NUM_ADDRESSES_TRACKED; i++)
   1e4f6:	429a      	cmp	r2, r3
   1e4f8:	d1fb      	bne.n	1e4f2 <_ZN14ScanningModule26ConfigurationLoadedHandlerEv+0x1a>
   1e4fa:	4a05      	ldr	r2, [pc, #20]	; (1e510 <_ZN14ScanningModule26ConfigurationLoadedHandlerEv+0x38>)
   1e4fc:	18a1      	adds	r1, r4, r2

void ScanningModule::resetTotalMessagesPerAdress()
{
	for (int i = 0; i < NUM_ADDRESSES_TRACKED; i++)
	{
		totalMessagesPerAdress[i] = 0;
   1e4fe:	2200      	movs	r2, #0
   1e500:	c304      	stmia	r3!, {r2}
	}
}

void ScanningModule::resetTotalMessagesPerAdress()
{
	for (int i = 0; i < NUM_ADDRESSES_TRACKED; i++)
   1e502:	428b      	cmp	r3, r1
   1e504:	d1fb      	bne.n	1e4fe <_ZN14ScanningModule26ConfigurationLoadedHandlerEv+0x26>
	// Reset address pointer to the beginning of the address table
	resetAddressTable();
	resetTotalRSSIsPerAddress();
	resetTotalMessagesPerAdress();

	totalMessages = 0;
   1e506:	4b02      	ldr	r3, [pc, #8]	; (1e510 <_ZN14ScanningModule26ConfigurationLoadedHandlerEv+0x38>)
   1e508:	50e2      	str	r2, [r4, r3]
	totalRSSI = 0;
   1e50a:	3304      	adds	r3, #4
   1e50c:	50e2      	str	r2, [r4, r3]

	//Start the Module...
}
   1e50e:	bd10      	pop	{r4, pc}
   1e510:	0000045c 	.word	0x0000045c

0001e514 <_ZN20StatusReporterModule28MeshConnectionChangedHandlerEP10Connection>:
		}
	}
}

void StatusReporterModule::MeshConnectionChangedHandler(Connection* connection)
{
   1e514:	b538      	push	{r3, r4, r5, lr}
	//New connection has just been made
	if(connection->handshakeDone()){
   1e516:	7a0b      	ldrb	r3, [r1, #8]
   1e518:	2b03      	cmp	r3, #3
   1e51a:	d922      	bls.n	1e562 <_ZN20StatusReporterModule28MeshConnectionChangedHandlerEP10Connection+0x4e>
   1e51c:	1c0c      	adds	r4, r1, #0
   1e51e:	1c05      	adds	r5, r0, #0
		//TODO: Implement low and medium rssi sampling with timer handler
		//TODO: disable and enable rssi sampling on existing connections
		if(Config->enableConnectionRSSIMeasurement){
   1e520:	f002 fc82 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1e524:	3037      	adds	r0, #55	; 0x37
   1e526:	7803      	ldrb	r3, [r0, #0]
   1e528:	2b00      	cmp	r3, #0
   1e52a:	d01a      	beq.n	1e562 <_ZN20StatusReporterModule28MeshConnectionChangedHandlerEP10Connection+0x4e>
			if(configuration.connectionRSSISamplingMode == RSSISampingModes::RSSI_SAMLING_HIGH){
   1e52c:	3530      	adds	r5, #48	; 0x30
   1e52e:	782b      	ldrb	r3, [r5, #0]
   1e530:	2b03      	cmp	r3, #3
   1e532:	d116      	bne.n	1e562 <_ZN20StatusReporterModule28MeshConnectionChangedHandlerEP10Connection+0x4e>
}

void StatusReporterModule::StartConnectionRSSIMeasurement(Connection* connection){
	u32 err = 0;

	if (connection->isConnected())
   1e534:	7a23      	ldrb	r3, [r4, #8]
   1e536:	2b01      	cmp	r3, #1
   1e538:	d913      	bls.n	1e562 <_ZN20StatusReporterModule28MeshConnectionChangedHandlerEP10Connection+0x4e>
	{
		//Reset old values
		connection->rssiSamplesNum = 0;
   1e53a:	2200      	movs	r2, #0
		connection->rssiSamplesSum = 0;

		err = sd_ble_gap_rssi_start(connection->connectionHandle, 0, 0);
   1e53c:	23e9      	movs	r3, #233	; 0xe9
	u32 err = 0;

	if (connection->isConnected())
	{
		//Reset old values
		connection->rssiSamplesNum = 0;
   1e53e:	8222      	strh	r2, [r4, #16]
		connection->rssiSamplesSum = 0;

		err = sd_ble_gap_rssi_start(connection->connectionHandle, 0, 0);
   1e540:	005b      	lsls	r3, r3, #1

	if (connection->isConnected())
	{
		//Reset old values
		connection->rssiSamplesNum = 0;
		connection->rssiSamplesSum = 0;
   1e542:	81e2      	strh	r2, [r4, #14]

		err = sd_ble_gap_rssi_start(connection->connectionHandle, 0, 0);
   1e544:	5ae0      	ldrh	r0, [r4, r3]
   1e546:	1c11      	adds	r1, r2, #0
   1e548:	f7ff ffb4 	bl	1e4b4 <sd_ble_gap_rssi_start>
		if(err == NRF_ERROR_INVALID_STATE || err == BLE_ERROR_INVALID_CONN_HANDLE){
   1e54c:	4b05      	ldr	r3, [pc, #20]	; (1e564 <_ZN20StatusReporterModule28MeshConnectionChangedHandlerEP10Connection+0x50>)
   1e54e:	4298      	cmp	r0, r3
   1e550:	d007      	beq.n	1e562 <_ZN20StatusReporterModule28MeshConnectionChangedHandlerEP10Connection+0x4e>
			//Both errors are due to a disconnect and we can simply ignore them
		} else {
			APP_ERROR_CHECK(err); //OK
   1e552:	2308      	movs	r3, #8
   1e554:	1c02      	adds	r2, r0, #0
   1e556:	439a      	bics	r2, r3
   1e558:	d003      	beq.n	1e562 <_ZN20StatusReporterModule28MeshConnectionChangedHandlerEP10Connection+0x4e>
   1e55a:	21f3      	movs	r1, #243	; 0xf3
   1e55c:	4a02      	ldr	r2, [pc, #8]	; (1e568 <_ZN20StatusReporterModule28MeshConnectionChangedHandlerEP10Connection+0x54>)
   1e55e:	f7fe ff51 	bl	1d404 <app_error_handler>
			if(configuration.connectionRSSISamplingMode == RSSISampingModes::RSSI_SAMLING_HIGH){
				StartConnectionRSSIMeasurement(connection);
			}
		}
	}
}
   1e562:	bd38      	pop	{r3, r4, r5, pc}
   1e564:	00003002 	.word	0x00003002
   1e568:	00022a80 	.word	0x00022a80

0001e56c <_ZN14ScanningModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert>:
		false
	);
}

void ScanningModule::ConnectionPacketReceivedEventHandler(connectionPacket* inPacket, Connection* connection, connPacketHeader* packetHeader, u16 dataLength)
{
   1e56c:	b530      	push	{r4, r5, lr}
   1e56e:	1c1c      	adds	r4, r3, #0
   1e570:	b085      	sub	sp, #20
   1e572:	ab08      	add	r3, sp, #32
   1e574:	881b      	ldrh	r3, [r3, #0]
   1e576:	1c05      	adds	r5, r0, #0
	//Must call superclass for handling
	Module::ConnectionPacketReceivedEventHandler(inPacket, connection, packetHeader, dataLength);
   1e578:	9300      	str	r3, [sp, #0]
   1e57a:	1c23      	adds	r3, r4, #0
   1e57c:	f002 fa40 	bl	20a00 <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert>

	if (packetHeader->messageType == MESSAGE_TYPE_MODULE_TRIGGER_ACTION)
   1e580:	2201      	movs	r2, #1
   1e582:	7823      	ldrb	r3, [r4, #0]
   1e584:	4393      	bics	r3, r2
   1e586:	2b66      	cmp	r3, #102	; 0x66
   1e588:	d112      	bne.n	1e5b0 <_ZN14ScanningModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x44>
	{
		connPacketModule* packet = (connPacketModule*) packetHeader;

		//Check if our module is meant and we should trigger an action
		if (packet->moduleId == moduleId)
   1e58a:	7962      	ldrb	r2, [r4, #5]
   1e58c:	7c2b      	ldrb	r3, [r5, #16]
   1e58e:	429a      	cmp	r2, r3
   1e590:	d10e      	bne.n	1e5b0 <_ZN14ScanningModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x44>
		{
			//It's a LED message
			if (packet->actionType == ScanModuleMessages::TOTAL_SCANNED_PACKETS)
   1e592:	79e3      	ldrb	r3, [r4, #7]
   1e594:	2b00      	cmp	r3, #0
   1e596:	d10b      	bne.n	1e5b0 <_ZN14ScanningModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x44>
			{

				u32 totalDevices;
				u32 totalRSSI;
				memcpy(&totalDevices, packet->data + 0, 4);
   1e598:	1c21      	adds	r1, r4, #0
   1e59a:	2204      	movs	r2, #4
   1e59c:	3108      	adds	r1, #8
   1e59e:	a802      	add	r0, sp, #8
   1e5a0:	f003 f838 	bl	21614 <memcpy>
				memcpy(&totalRSSI, packet->data + 4, 4);
   1e5a4:	1c21      	adds	r1, r4, #0
   1e5a6:	a803      	add	r0, sp, #12
   1e5a8:	310c      	adds	r1, #12
   1e5aa:	2204      	movs	r2, #4
   1e5ac:	f003 f832 	bl	21614 <memcpy>
				}
			}
			uart("SCANMOD", "]}" SEP);
		}
	}
}
   1e5b0:	b005      	add	sp, #20
   1e5b2:	bd30      	pop	{r4, r5, pc}

0001e5b4 <_ZN14ScanningModule27ResetToDefaultConfigurationEv>:
}

void ScanningModule::ResetToDefaultConfiguration()
{
	//Set default configuration values
	configuration.moduleId = moduleId;
   1e5b4:	1c03      	adds	r3, r0, #0

	//Start the Module...
}

void ScanningModule::ResetToDefaultConfiguration()
{
   1e5b6:	b530      	push	{r4, r5, lr}
	//Set default configuration values
	configuration.moduleId = moduleId;
   1e5b8:	7c02      	ldrb	r2, [r0, #16]
   1e5ba:	3328      	adds	r3, #40	; 0x28
   1e5bc:	701a      	strb	r2, [r3, #0]
	configuration.moduleActive = true;
   1e5be:	1c02      	adds	r2, r0, #0
   1e5c0:	2301      	movs	r3, #1
   1e5c2:	322a      	adds	r2, #42	; 0x2a
   1e5c4:	7013      	strb	r3, [r2, #0]
	configuration.moduleVersion = 1;
   1e5c6:	3a01      	subs	r2, #1
   1e5c8:	7013      	strb	r3, [r2, #0]

	//Set additional config values...
	configuration.assetReportingIntervalDs = SEC_TO_DS(3);
   1e5ca:	221e      	movs	r2, #30
   1e5cc:	85c2      	strh	r2, [r0, #46]	; 0x2e
	configuration.groupedReportingIntervalDs = SEC_TO_DS(25);
   1e5ce:	32dc      	adds	r2, #220	; 0xdc
   1e5d0:	8582      	strh	r2, [r0, #44]	; 0x2c
	configuration.groupedPacketRssiThreshold = -70;
   1e5d2:	1c02      	adds	r2, r0, #0
   1e5d4:	21ba      	movs	r1, #186	; 0xba
   1e5d6:	3230      	adds	r2, #48	; 0x30
   1e5d8:	7011      	strb	r1, [r2, #0]
//Will be evaluated against. If they pass the filter, they are reported
bool ScanningModule::setScanFilter(scanFilterEntry* filter)
{
	for (int i = 0; i < SCAN_FILTER_NUMBER; i++)
	{
		if (!scanFilters[i].active)
   1e5da:	7a11      	ldrb	r1, [r2, #8]
   1e5dc:	3208      	adds	r2, #8
   1e5de:	2900      	cmp	r1, #0
   1e5e0:	d10d      	bne.n	1e5fe <_ZN14ScanningModule27ResetToDefaultConfigurationEv+0x4a>
		{
			memcpy(scanFilters + i, filter, sizeof(scanFilterEntry));
   1e5e2:	1c01      	adds	r1, r0, #0
   1e5e4:	1c04      	adds	r4, r0, #0
   1e5e6:	3139      	adds	r1, #57	; 0x39
   1e5e8:	259c      	movs	r5, #156	; 0x9c
   1e5ea:	700b      	strb	r3, [r1, #0]
   1e5ec:	21ff      	movs	r1, #255	; 0xff
   1e5ee:	343a      	adds	r4, #58	; 0x3a
   1e5f0:	71e5      	strb	r5, [r4, #7]
   1e5f2:	3043      	adds	r0, #67	; 0x43
   1e5f4:	3d38      	subs	r5, #56	; 0x38
   1e5f6:	7021      	strb	r1, [r4, #0]
   1e5f8:	7225      	strb	r5, [r4, #8]
   1e5fa:	7001      	strb	r1, [r0, #0]
			scanFilters[i].active = 1;
   1e5fc:	7013      	strb	r3, [r2, #0]
	filter.minRSSI = -100;
	filter.maxRSSI = 100;

	setScanFilter(&filter);

}
   1e5fe:	bd30      	pop	{r4, r5, pc}

0001e600 <_ZN20StatusReporterModule18SendAllConnectionsEth>:
	//Build response and send
	u16 packetSize = SIZEOF_CONN_PACKET_MODULE + SIZEOF_STATUS_REPORTER_MODULE_CONNECTIONS_MESSAGE;
	u8 buffer[packetSize];
	connPacketModule* outPacket = (connPacketModule*)buffer;

	outPacket->header.messageType = MESSAGE_TYPE_MODULE_ACTION_RESPONSE;
   1e600:	2301      	movs	r3, #1
}


//This method sends information about the current connections over the network
void StatusReporterModule::SendAllConnections(nodeID toNode, u8 messageType)
{
   1e602:	b5f0      	push	{r4, r5, r6, r7, lr}
   1e604:	b087      	sub	sp, #28
	//Build response and send
	u16 packetSize = SIZEOF_CONN_PACKET_MODULE + SIZEOF_STATUS_REPORTER_MODULE_CONNECTIONS_MESSAGE;
	u8 buffer[packetSize];
	connPacketModule* outPacket = (connPacketModule*)buffer;

	outPacket->header.messageType = MESSAGE_TYPE_MODULE_ACTION_RESPONSE;
   1e606:	a901      	add	r1, sp, #4
   1e608:	780a      	ldrb	r2, [r1, #0]
	outPacket->header.receiver = NODE_ID_BROADCAST;
	outPacket->header.sender = node->persistentConfig.nodeId;
   1e60a:	466c      	mov	r4, sp
	//Build response and send
	u16 packetSize = SIZEOF_CONN_PACKET_MODULE + SIZEOF_STATUS_REPORTER_MODULE_CONNECTIONS_MESSAGE;
	u8 buffer[packetSize];
	connPacketModule* outPacket = (connPacketModule*)buffer;

	outPacket->header.messageType = MESSAGE_TYPE_MODULE_ACTION_RESPONSE;
   1e60c:	4013      	ands	r3, r2
   1e60e:	2268      	movs	r2, #104	; 0x68
   1e610:	4313      	orrs	r3, r2
   1e612:	700b      	strb	r3, [r1, #0]
	outPacket->header.receiver = NODE_ID_BROADCAST;
   1e614:	466b      	mov	r3, sp
   1e616:	1dda      	adds	r2, r3, #7
   1e618:	2300      	movs	r3, #0
   1e61a:	7013      	strb	r3, [r2, #0]
   1e61c:	7053      	strb	r3, [r2, #1]
	outPacket->header.sender = node->persistentConfig.nodeId;
   1e61e:	6882      	ldr	r2, [r0, #8]
   1e620:	1dd5      	adds	r5, r2, #7
   1e622:	7fed      	ldrb	r5, [r5, #31]
   1e624:	3208      	adds	r2, #8
   1e626:	7165      	strb	r5, [r4, #5]
   1e628:	7fd2      	ldrb	r2, [r2, #31]
   1e62a:	71a2      	strb	r2, [r4, #6]

	outPacket->moduleId = moduleId;
   1e62c:	7c02      	ldrb	r2, [r0, #16]
	outPacket->actionType = StatusModuleActionResponseMessages::ALL_CONNECTIONS;

	StatusReporterModuleConnectionsMessage* outPacketData = (StatusReporterModuleConnectionsMessage*)(outPacket->data);

	outPacketData->partner1 = cm->connections[0]->partnerId;
   1e62e:	68c0      	ldr	r0, [r0, #12]

	outPacket->header.messageType = MESSAGE_TYPE_MODULE_ACTION_RESPONSE;
	outPacket->header.receiver = NODE_ID_BROADCAST;
	outPacket->header.sender = node->persistentConfig.nodeId;

	outPacket->moduleId = moduleId;
   1e630:	714a      	strb	r2, [r1, #5]
	outPacket->actionType = StatusModuleActionResponseMessages::ALL_CONNECTIONS;
   1e632:	2203      	movs	r2, #3

	StatusReporterModuleConnectionsMessage* outPacketData = (StatusReporterModuleConnectionsMessage*)(outPacket->data);

	outPacketData->partner1 = cm->connections[0]->partnerId;
   1e634:	6a07      	ldr	r7, [r0, #32]
	outPacket->header.messageType = MESSAGE_TYPE_MODULE_ACTION_RESPONSE;
	outPacket->header.receiver = NODE_ID_BROADCAST;
	outPacket->header.sender = node->persistentConfig.nodeId;

	outPacket->moduleId = moduleId;
	outPacket->actionType = StatusModuleActionResponseMessages::ALL_CONNECTIONS;
   1e636:	71ca      	strb	r2, [r1, #7]

	StatusReporterModuleConnectionsMessage* outPacketData = (StatusReporterModuleConnectionsMessage*)(outPacket->data);

	outPacketData->partner1 = cm->connections[0]->partnerId;
   1e638:	32ce      	adds	r2, #206	; 0xce
   1e63a:	32ff      	adds	r2, #255	; 0xff
   1e63c:	5abc      	ldrh	r4, [r7, r2]
	outPacketData->partner2 = cm->connections[1]->partnerId;
   1e63e:	6a46      	ldr	r6, [r0, #36]	; 0x24
	outPacket->moduleId = moduleId;
	outPacket->actionType = StatusModuleActionResponseMessages::ALL_CONNECTIONS;

	StatusReporterModuleConnectionsMessage* outPacketData = (StatusReporterModuleConnectionsMessage*)(outPacket->data);

	outPacketData->partner1 = cm->connections[0]->partnerId;
   1e640:	810c      	strh	r4, [r1, #8]
	outPacketData->partner2 = cm->connections[1]->partnerId;
   1e642:	5ab4      	ldrh	r4, [r6, r2]
	outPacketData->partner3 = cm->connections[2]->partnerId;
   1e644:	6a85      	ldr	r5, [r0, #40]	; 0x28
	outPacket->actionType = StatusModuleActionResponseMessages::ALL_CONNECTIONS;

	StatusReporterModuleConnectionsMessage* outPacketData = (StatusReporterModuleConnectionsMessage*)(outPacket->data);

	outPacketData->partner1 = cm->connections[0]->partnerId;
	outPacketData->partner2 = cm->connections[1]->partnerId;
   1e646:	814c      	strh	r4, [r1, #10]
	outPacketData->partner3 = cm->connections[2]->partnerId;
   1e648:	5aac      	ldrh	r4, [r5, r2]
   1e64a:	818c      	strh	r4, [r1, #12]
	outPacketData->partner4 = cm->connections[3]->partnerId;
   1e64c:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
   1e64e:	5aa2      	ldrh	r2, [r4, r2]
   1e650:	81ca      	strh	r2, [r1, #14]

}

i8 Connection::GetAverageRSSI()
{
	if(connectionState >= ConnectionState::CONNECTED) return rssiAverage;
   1e652:	7a3a      	ldrb	r2, [r7, #8]
   1e654:	2a01      	cmp	r2, #1
   1e656:	d900      	bls.n	1e65a <_ZN20StatusReporterModule18SendAllConnectionsEth+0x5a>
   1e658:	7cbb      	ldrb	r3, [r7, #18]

	outPacketData->rssi1 = cm->connections[0]->GetAverageRSSI();
   1e65a:	740b      	strb	r3, [r1, #16]
   1e65c:	7a32      	ldrb	r2, [r6, #8]
	else return 0;
   1e65e:	2300      	movs	r3, #0

}

i8 Connection::GetAverageRSSI()
{
	if(connectionState >= ConnectionState::CONNECTED) return rssiAverage;
   1e660:	2a01      	cmp	r2, #1
   1e662:	d900      	bls.n	1e666 <_ZN20StatusReporterModule18SendAllConnectionsEth+0x66>
   1e664:	7cb3      	ldrb	r3, [r6, #18]
	outPacketData->rssi2 = cm->connections[1]->GetAverageRSSI();
   1e666:	744b      	strb	r3, [r1, #17]
   1e668:	7a2a      	ldrb	r2, [r5, #8]
	else return 0;
   1e66a:	2300      	movs	r3, #0

}

i8 Connection::GetAverageRSSI()
{
	if(connectionState >= ConnectionState::CONNECTED) return rssiAverage;
   1e66c:	2a01      	cmp	r2, #1
   1e66e:	d900      	bls.n	1e672 <_ZN20StatusReporterModule18SendAllConnectionsEth+0x72>
   1e670:	7cab      	ldrb	r3, [r5, #18]
	outPacketData->rssi3 = cm->connections[2]->GetAverageRSSI();
   1e672:	748b      	strb	r3, [r1, #18]
   1e674:	7a22      	ldrb	r2, [r4, #8]
	else return 0;
   1e676:	2300      	movs	r3, #0

}

i8 Connection::GetAverageRSSI()
{
	if(connectionState >= ConnectionState::CONNECTED) return rssiAverage;
   1e678:	2a01      	cmp	r2, #1
   1e67a:	d900      	bls.n	1e67e <_ZN20StatusReporterModule18SendAllConnectionsEth+0x7e>
   1e67c:	7ca3      	ldrb	r3, [r4, #18]
	outPacketData->rssi4 = cm->connections[3]->GetAverageRSSI();
   1e67e:	74cb      	strb	r3, [r1, #19]


	cm->SendMessageToReceiver(NULL, buffer, packetSize, true);
   1e680:	2214      	movs	r2, #20
   1e682:	2301      	movs	r3, #1
   1e684:	f000 fd8a 	bl	1f19c <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10>
}
   1e688:	b007      	add	sp, #28
   1e68a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001e68c <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert>:
	return Module::TerminalCommandHandler(commandName, commandArgs);
}


void StatusReporterModule::ConnectionPacketReceivedEventHandler(connectionPacket* inPacket, Connection* connection, connPacketHeader* packetHeader, u16 dataLength)
{
   1e68c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1e68e:	1c1c      	adds	r4, r3, #0
   1e690:	b08d      	sub	sp, #52	; 0x34
   1e692:	ab12      	add	r3, sp, #72	; 0x48
   1e694:	881b      	ldrh	r3, [r3, #0]
   1e696:	1c05      	adds	r5, r0, #0
   1e698:	9304      	str	r3, [sp, #16]
	//Must call superclass for handling
	Module::ConnectionPacketReceivedEventHandler(inPacket, connection, packetHeader, dataLength);
   1e69a:	9300      	str	r3, [sp, #0]
   1e69c:	1c23      	adds	r3, r4, #0
   1e69e:	f002 f9af 	bl	20a00 <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert>

	if(packetHeader->messageType == MESSAGE_TYPE_MODULE_TRIGGER_ACTION){
   1e6a2:	2301      	movs	r3, #1
   1e6a4:	7822      	ldrb	r2, [r4, #0]
   1e6a6:	439a      	bics	r2, r3
   1e6a8:	2a66      	cmp	r2, #102	; 0x66
   1e6aa:	d000      	beq.n	1e6ae <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x22>
   1e6ac:	e0b5      	b.n	1e81a <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x18e>
		connPacketModule* packet = (connPacketModule*)packetHeader;

		//Check if our module is meant and we should trigger an action
		if(packet->moduleId == moduleId){
   1e6ae:	7961      	ldrb	r1, [r4, #5]
   1e6b0:	7c2a      	ldrb	r2, [r5, #16]
   1e6b2:	4291      	cmp	r1, r2
   1e6b4:	d000      	beq.n	1e6b8 <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x2c>
   1e6b6:	e0b0      	b.n	1e81a <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x18e>

			//We were queried for our status
			if(packet->actionType == StatusModuleTriggerActionMessages::GET_STATUS)
   1e6b8:	79e2      	ldrb	r2, [r4, #7]
   1e6ba:	429a      	cmp	r2, r3
   1e6bc:	d107      	bne.n	1e6ce <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x42>
			{
				SendStatus(packet->header.sender, MESSAGE_TYPE_MODULE_ACTION_RESPONSE);
   1e6be:	78a1      	ldrb	r1, [r4, #2]
   1e6c0:	7863      	ldrb	r3, [r4, #1]
   1e6c2:	0209      	lsls	r1, r1, #8
   1e6c4:	4319      	orrs	r1, r3
   1e6c6:	1c28      	adds	r0, r5, #0
   1e6c8:	f000 fdb9 	bl	1f23e <_ZN20StatusReporterModule10SendStatusEth.constprop.3>
   1e6cc:	e0a5      	b.n	1e81a <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x18e>

			}//We were queried for our device info
			else if(packet->actionType == StatusModuleTriggerActionMessages::GET_DEVICE_INFO)
   1e6ce:	2a02      	cmp	r2, #2
   1e6d0:	d107      	bne.n	1e6e2 <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x56>
			{
				SendDeviceInfo(packet->header.sender, MESSAGE_TYPE_MODULE_ACTION_RESPONSE);
   1e6d2:	78a1      	ldrb	r1, [r4, #2]
   1e6d4:	7863      	ldrb	r3, [r4, #1]
   1e6d6:	0209      	lsls	r1, r1, #8
   1e6d8:	4319      	orrs	r1, r3
   1e6da:	1c28      	adds	r0, r5, #0
   1e6dc:	f000 fdf4 	bl	1f2c8 <_ZN20StatusReporterModule14SendDeviceInfoEth.constprop.2>
   1e6e0:	e09b      	b.n	1e81a <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x18e>

			}
			//We were queried for our connections
			else if(packet->actionType == StatusModuleTriggerActionMessages::GET_ALL_CONNECTIONS)
   1e6e2:	2a03      	cmp	r2, #3
   1e6e4:	d108      	bne.n	1e6f8 <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x6c>
			{
				StatusReporterModule::SendAllConnections(packetHeader->sender, MESSAGE_TYPE_MODULE_ACTION_RESPONSE);
   1e6e6:	78a1      	ldrb	r1, [r4, #2]
   1e6e8:	7863      	ldrb	r3, [r4, #1]
   1e6ea:	0209      	lsls	r1, r1, #8
   1e6ec:	4319      	orrs	r1, r3
   1e6ee:	1c28      	adds	r0, r5, #0
   1e6f0:	3231      	adds	r2, #49	; 0x31
   1e6f2:	f7ff ff85 	bl	1e600 <_ZN20StatusReporterModule18SendAllConnectionsEth>
   1e6f6:	e090      	b.n	1e81a <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x18e>
			}
			//We were queried for nearby nodes (nodes in the join_me buffer)
			else if(packet->actionType == StatusModuleTriggerActionMessages::GET_NEARBY_NODES)
   1e6f8:	2a04      	cmp	r2, #4
   1e6fa:	d107      	bne.n	1e70c <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x80>
			{
				StatusReporterModule::SendNearbyNodes(packetHeader->sender, MESSAGE_TYPE_MODULE_ACTION_RESPONSE);
   1e6fc:	78a1      	ldrb	r1, [r4, #2]
   1e6fe:	7863      	ldrb	r3, [r4, #1]
   1e700:	0209      	lsls	r1, r1, #8
   1e702:	4319      	orrs	r1, r3
   1e704:	1c28      	adds	r0, r5, #0
   1e706:	f000 fe59 	bl	1f3bc <_ZN20StatusReporterModule15SendNearbyNodesEth.constprop.1>
   1e70a:	e086      	b.n	1e81a <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x18e>
			}
			//We should set ourselves initialized
			else if(packet->actionType == StatusModuleTriggerActionMessages::SET_INITIALIZED)
   1e70c:	2a05      	cmp	r2, #5
   1e70e:	d126      	bne.n	1e75e <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0xd2>
			{
				node->initializedByGateway = true;
   1e710:	68ae      	ldr	r6, [r5, #8]
   1e712:	1c31      	adds	r1, r6, #0
   1e714:	3185      	adds	r1, #133	; 0x85
   1e716:	700b      	strb	r3, [r1, #0]
					StatusModuleActionResponseMessages::SET_INITIALIZED_RESULT,
					0,
					NULL,
					0,
					false
				);
   1e718:	78a0      	ldrb	r0, [r4, #2]
   1e71a:	7861      	ldrb	r1, [r4, #1]
   1e71c:	0200      	lsls	r0, r0, #8
   1e71e:	4308      	orrs	r0, r1
void Module::SendModuleActionMessage(u8 messageType, nodeID toNode, u8 actionType, u8 requestHandle, u8* additionalData, u16 additionalDataSize, bool reliable)
{
	u8 buffer[SIZEOF_CONN_PACKET_MODULE + additionalDataSize];

	connPacketModule* outPacket = (connPacketModule*)buffer;
	outPacket->header.messageType = messageType;
   1e720:	a907      	add	r1, sp, #28
   1e722:	780f      	ldrb	r7, [r1, #0]
   1e724:	403b      	ands	r3, r7
   1e726:	2768      	movs	r7, #104	; 0x68
   1e728:	433b      	orrs	r3, r7
   1e72a:	700b      	strb	r3, [r1, #0]
	outPacket->header.sender = node->persistentConfig.nodeId;
   1e72c:	3f5b      	subs	r7, #91	; 0x5b
   1e72e:	ab04      	add	r3, sp, #16
   1e730:	18ff      	adds	r7, r7, r3
   1e732:	1df3      	adds	r3, r6, #7
   1e734:	7fdb      	ldrb	r3, [r3, #31]
   1e736:	3608      	adds	r6, #8
   1e738:	703b      	strb	r3, [r7, #0]
   1e73a:	7ff6      	ldrb	r6, [r6, #31]
	outPacket->header.receiver = toNode;
   1e73c:	ab04      	add	r3, sp, #16
{
	u8 buffer[SIZEOF_CONN_PACKET_MODULE + additionalDataSize];

	connPacketModule* outPacket = (connPacketModule*)buffer;
	outPacket->header.messageType = messageType;
	outPacket->header.sender = node->persistentConfig.nodeId;
   1e73e:	707e      	strb	r6, [r7, #1]
	outPacket->header.receiver = toNode;
   1e740:	260f      	movs	r6, #15
   1e742:	18f6      	adds	r6, r6, r3

	outPacket->moduleId = moduleId;
	outPacket->requestHandle = requestHandle;
   1e744:	2300      	movs	r3, #0
	u8 buffer[SIZEOF_CONN_PACKET_MODULE + additionalDataSize];

	connPacketModule* outPacket = (connPacketModule*)buffer;
	outPacket->header.messageType = messageType;
	outPacket->header.sender = node->persistentConfig.nodeId;
	outPacket->header.receiver = toNode;
   1e746:	7030      	strb	r0, [r6, #0]
   1e748:	0a00      	lsrs	r0, r0, #8
   1e74a:	7070      	strb	r0, [r6, #1]

	outPacket->moduleId = moduleId;
   1e74c:	7c28      	ldrb	r0, [r5, #16]
	outPacket->requestHandle = requestHandle;
	outPacket->actionType = actionType;
   1e74e:	71ca      	strb	r2, [r1, #7]
	connPacketModule* outPacket = (connPacketModule*)buffer;
	outPacket->header.messageType = messageType;
	outPacket->header.sender = node->persistentConfig.nodeId;
	outPacket->header.receiver = toNode;

	outPacket->moduleId = moduleId;
   1e750:	7148      	strb	r0, [r1, #5]
	outPacket->requestHandle = requestHandle;
   1e752:	718b      	strb	r3, [r1, #6]
	if(additionalData != NULL && additionalDataSize > 0)
	{
		memcpy(&outPacket->data, additionalData, additionalDataSize);
	}

	cm->SendMessageToReceiver(NULL, buffer, SIZEOF_CONN_PACKET_MODULE + additionalDataSize, reliable);
   1e754:	68e8      	ldr	r0, [r5, #12]
   1e756:	3203      	adds	r2, #3
   1e758:	f000 fd20 	bl	1f19c <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10>
   1e75c:	e05d      	b.n	1e81a <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x18e>
			}
			//Send back the errors
			else if(packet->actionType == StatusModuleTriggerActionMessages::GET_ERRORS)
   1e75e:	2a06      	cmp	r2, #6
   1e760:	d15b      	bne.n	1e81a <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x18e>
   1e762:	2300      	movs	r3, #0
   1e764:	4e3d      	ldr	r6, [pc, #244]	; (1e85c <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x1d0>)
   1e766:	9302      	str	r3, [sp, #8]
			{
				StatusReporterModuleErrorLogEntryMessage data;
				for(int i=0; i< Logger::errorLogPosition; i++){
   1e768:	4b3d      	ldr	r3, [pc, #244]	; (1e860 <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x1d4>)
   1e76a:	9a02      	ldr	r2, [sp, #8]
   1e76c:	781b      	ldrb	r3, [r3, #0]
   1e76e:	429a      	cmp	r2, r3
   1e770:	da53      	bge.n	1e81a <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x18e>
   1e772:	1eb3      	subs	r3, r6, #2
					data.errorType = Logger::errorLog[i].errorType;
   1e774:	781b      	ldrb	r3, [r3, #0]
void Module::SendModuleActionMessage(u8 messageType, nodeID toNode, u8 actionType, u8 requestHandle, u8* additionalData, u16 additionalDataSize, bool reliable)
{
	u8 buffer[SIZEOF_CONN_PACKET_MODULE + additionalDataSize];

	connPacketModule* outPacket = (connPacketModule*)buffer;
	outPacket->header.messageType = messageType;
   1e776:	a907      	add	r1, sp, #28
   1e778:	9305      	str	r3, [sp, #20]
					data.extraInfo = Logger::errorLog[i].extraInfo;
   1e77a:	8833      	ldrh	r3, [r6, #0]
   1e77c:	7808      	ldrb	r0, [r1, #0]
   1e77e:	9303      	str	r3, [sp, #12]
   1e780:	1cb3      	adds	r3, r6, #2
					data.errorCode = Logger::errorLog[i].errorCode;
   1e782:	681f      	ldr	r7, [r3, #0]
   1e784:	1db3      	adds	r3, r6, #6
					data.timestamp = Logger::errorLog[i].timestamp;
   1e786:	681b      	ldr	r3, [r3, #0]
						StatusModuleActionResponseMessages::ERROR_LOG_ENTRY,
						0,
						(u8*)&data,
						SIZEOF_STATUS_REPORTER_MODULE_ERROR_LOG_ENTRY_MESSAGE,
						false
					);
   1e788:	78a2      	ldrb	r2, [r4, #2]
				StatusReporterModuleErrorLogEntryMessage data;
				for(int i=0; i< Logger::errorLogPosition; i++){
					data.errorType = Logger::errorLog[i].errorType;
					data.extraInfo = Logger::errorLog[i].extraInfo;
					data.errorCode = Logger::errorLog[i].errorCode;
					data.timestamp = Logger::errorLog[i].timestamp;
   1e78a:	469c      	mov	ip, r3
						StatusModuleActionResponseMessages::ERROR_LOG_ENTRY,
						0,
						(u8*)&data,
						SIZEOF_STATUS_REPORTER_MODULE_ERROR_LOG_ENTRY_MESSAGE,
						false
					);
   1e78c:	7863      	ldrb	r3, [r4, #1]
   1e78e:	0212      	lsls	r2, r2, #8
   1e790:	431a      	orrs	r2, r3
   1e792:	2301      	movs	r3, #1
   1e794:	4003      	ands	r3, r0
   1e796:	2068      	movs	r0, #104	; 0x68
   1e798:	4303      	orrs	r3, r0
   1e79a:	700b      	strb	r3, [r1, #0]
	outPacket->header.sender = node->persistentConfig.nodeId;
   1e79c:	68ab      	ldr	r3, [r5, #8]
   1e79e:	360c      	adds	r6, #12
   1e7a0:	3307      	adds	r3, #7
   1e7a2:	7fd8      	ldrb	r0, [r3, #31]
   1e7a4:	ab04      	add	r3, sp, #16
   1e7a6:	7358      	strb	r0, [r3, #13]
   1e7a8:	68a8      	ldr	r0, [r5, #8]
   1e7aa:	3008      	adds	r0, #8
   1e7ac:	7fc0      	ldrb	r0, [r0, #31]
   1e7ae:	7398      	strb	r0, [r3, #14]
	outPacket->header.receiver = toNode;
   1e7b0:	200f      	movs	r0, #15
   1e7b2:	18c0      	adds	r0, r0, r3

	outPacket->moduleId = moduleId;
	outPacket->requestHandle = requestHandle;
   1e7b4:	2300      	movs	r3, #0
	u8 buffer[SIZEOF_CONN_PACKET_MODULE + additionalDataSize];

	connPacketModule* outPacket = (connPacketModule*)buffer;
	outPacket->header.messageType = messageType;
	outPacket->header.sender = node->persistentConfig.nodeId;
	outPacket->header.receiver = toNode;
   1e7b6:	7002      	strb	r2, [r0, #0]
   1e7b8:	0a12      	lsrs	r2, r2, #8
   1e7ba:	7042      	strb	r2, [r0, #1]

	outPacket->moduleId = moduleId;
   1e7bc:	7c2a      	ldrb	r2, [r5, #16]
	outPacket->requestHandle = requestHandle;
   1e7be:	718b      	strb	r3, [r1, #6]
	outPacket->actionType = actionType;

	if(additionalData != NULL && additionalDataSize > 0)
	{
		memcpy(&outPacket->data, additionalData, additionalDataSize);
   1e7c0:	466b      	mov	r3, sp
	connPacketModule* outPacket = (connPacketModule*)buffer;
	outPacket->header.messageType = messageType;
	outPacket->header.sender = node->persistentConfig.nodeId;
	outPacket->header.receiver = toNode;

	outPacket->moduleId = moduleId;
   1e7c2:	714a      	strb	r2, [r1, #5]
	outPacket->requestHandle = requestHandle;
	outPacket->actionType = actionType;
   1e7c4:	2206      	movs	r2, #6

	if(additionalData != NULL && additionalDataSize > 0)
	{
		memcpy(&outPacket->data, additionalData, additionalDataSize);
   1e7c6:	7d1b      	ldrb	r3, [r3, #20]
	outPacket->header.sender = node->persistentConfig.nodeId;
	outPacket->header.receiver = toNode;

	outPacket->moduleId = moduleId;
	outPacket->requestHandle = requestHandle;
	outPacket->actionType = actionType;
   1e7c8:	71ca      	strb	r2, [r1, #7]

	if(additionalData != NULL && additionalDataSize > 0)
	{
		memcpy(&outPacket->data, additionalData, additionalDataSize);
   1e7ca:	720b      	strb	r3, [r1, #8]
   1e7cc:	320f      	adds	r2, #15
   1e7ce:	ab04      	add	r3, sp, #16
   1e7d0:	18d2      	adds	r2, r2, r3
   1e7d2:	466b      	mov	r3, sp
   1e7d4:	7b1b      	ldrb	r3, [r3, #12]
   1e7d6:	7013      	strb	r3, [r2, #0]
   1e7d8:	9b03      	ldr	r3, [sp, #12]
   1e7da:	0a18      	lsrs	r0, r3, #8
   1e7dc:	7050      	strb	r0, [r2, #1]
   1e7de:	2217      	movs	r2, #23
   1e7e0:	ab04      	add	r3, sp, #16
   1e7e2:	18d2      	adds	r2, r2, r3
   1e7e4:	0a38      	lsrs	r0, r7, #8
   1e7e6:	7050      	strb	r0, [r2, #1]
   1e7e8:	0c38      	lsrs	r0, r7, #16
   1e7ea:	7090      	strb	r0, [r2, #2]
   1e7ec:	0e38      	lsrs	r0, r7, #24
   1e7ee:	7017      	strb	r7, [r2, #0]
   1e7f0:	70d0      	strb	r0, [r2, #3]
   1e7f2:	221b      	movs	r2, #27
   1e7f4:	18d2      	adds	r2, r2, r3
   1e7f6:	4663      	mov	r3, ip
   1e7f8:	7013      	strb	r3, [r2, #0]
   1e7fa:	4663      	mov	r3, ip
   1e7fc:	0a18      	lsrs	r0, r3, #8
   1e7fe:	7050      	strb	r0, [r2, #1]
   1e800:	0c18      	lsrs	r0, r3, #16
   1e802:	7090      	strb	r0, [r2, #2]
   1e804:	0e18      	lsrs	r0, r3, #24
   1e806:	70d0      	strb	r0, [r2, #3]
	}

	cm->SendMessageToReceiver(NULL, buffer, SIZEOF_CONN_PACKET_MODULE + additionalDataSize, reliable);
   1e808:	2300      	movs	r3, #0
   1e80a:	68e8      	ldr	r0, [r5, #12]
   1e80c:	2213      	movs	r2, #19
   1e80e:	f000 fcc5 	bl	1f19c <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10>
			}
			//Send back the errors
			else if(packet->actionType == StatusModuleTriggerActionMessages::GET_ERRORS)
			{
				StatusReporterModuleErrorLogEntryMessage data;
				for(int i=0; i< Logger::errorLogPosition; i++){
   1e812:	9b02      	ldr	r3, [sp, #8]
   1e814:	3301      	adds	r3, #1
   1e816:	9302      	str	r3, [sp, #8]
   1e818:	e7a6      	b.n	1e768 <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0xdc>
			}
		}
	}

	//Parse Module responses
	if(packetHeader->messageType == MESSAGE_TYPE_MODULE_ACTION_RESPONSE){
   1e81a:	2201      	movs	r2, #1
   1e81c:	7823      	ldrb	r3, [r4, #0]
   1e81e:	4393      	bics	r3, r2
   1e820:	2b68      	cmp	r3, #104	; 0x68
   1e822:	d119      	bne.n	1e858 <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x1cc>

		connPacketModule* packet = (connPacketModule*)packetHeader;

		//Check if our module is meant and we should trigger an action
		if(packet->moduleId == moduleId)
   1e824:	7962      	ldrb	r2, [r4, #5]
   1e826:	7c2b      	ldrb	r3, [r5, #16]
   1e828:	429a      	cmp	r2, r3
   1e82a:	d115      	bne.n	1e858 <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x1cc>
			if(packet->actionType == StatusModuleActionResponseMessages::ALL_CONNECTIONS)
			{
				StatusReporterModuleConnectionsMessage* packetData = (StatusReporterModuleConnectionsMessage*) (packet->data);
				uart("STATUSMOD", "{\"type\":\"connections\",\"nodeId\":%d,\"module\":%d,\"partners\":[%d,%d,%d,%d],\"rssiValues\":[%d,%d,%d,%d]}" SEP, packet->header.sender, moduleId, packetData->partner1, packetData->partner2, packetData->partner3, packetData->partner4, packetData->rssi1, packetData->rssi2, packetData->rssi3, packetData->rssi4);
			}
			else if(packet->actionType == StatusModuleActionResponseMessages::DEVICE_INFO)
   1e82c:	79e3      	ldrb	r3, [r4, #7]
   1e82e:	2b04      	cmp	r3, #4
   1e830:	d112      	bne.n	1e858 <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x1cc>
			else if(packet->actionType == StatusModuleActionResponseMessages::NEARBY_NODES)
			{
				//Print packet to console
				uart("STATUSMOD", "{\"nodeId\":%u,\"type\":\"nearby_nodes\",\"module\":%u,\"nodes\":[", packet->header.sender, moduleId);

				u16 nodeCount = (dataLength - SIZEOF_CONN_PACKET_MODULE) / 3;
   1e832:	9804      	ldr	r0, [sp, #16]
   1e834:	2103      	movs	r1, #3
   1e836:	3808      	subs	r0, #8
   1e838:	f003 fcae 	bl	22198 <__aeabi_idiv>
				bool first = true;
				for(int i=0; i<nodeCount; i++){
   1e83c:	2500      	movs	r5, #0
			else if(packet->actionType == StatusModuleActionResponseMessages::NEARBY_NODES)
			{
				//Print packet to console
				uart("STATUSMOD", "{\"nodeId\":%u,\"type\":\"nearby_nodes\",\"module\":%u,\"nodes\":[", packet->header.sender, moduleId);

				u16 nodeCount = (dataLength - SIZEOF_CONN_PACKET_MODULE) / 3;
   1e83e:	1c06      	adds	r6, r0, #0
   1e840:	3408      	adds	r4, #8
				bool first = true;
				for(int i=0; i<nodeCount; i++){
   1e842:	b2b3      	uxth	r3, r6
   1e844:	429d      	cmp	r5, r3
   1e846:	da07      	bge.n	1e858 <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x1cc>
					u16 nodeId;
					i8 rssi;
					//TODO: Find a nicer way to access unaligned data in packets
					memcpy(&nodeId, packet->data + i*3+0, 2);
   1e848:	1c21      	adds	r1, r4, #0
   1e84a:	a807      	add	r0, sp, #28
   1e84c:	2202      	movs	r2, #2
   1e84e:	f002 fee1 	bl	21614 <memcpy>
				//Print packet to console
				uart("STATUSMOD", "{\"nodeId\":%u,\"type\":\"nearby_nodes\",\"module\":%u,\"nodes\":[", packet->header.sender, moduleId);

				u16 nodeCount = (dataLength - SIZEOF_CONN_PACKET_MODULE) / 3;
				bool first = true;
				for(int i=0; i<nodeCount; i++){
   1e852:	3501      	adds	r5, #1
   1e854:	3403      	adds	r4, #3
   1e856:	e7f4      	b.n	1e842 <_ZN20StatusReporterModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x1b6>
				uart("STATUSMOD", "\"errType\":%u,\"code\":%u,\"extra\":%u,\"time\":%u", data->errorType, data->errorCode, data->extraInfo, data->timestamp);
				uart("STATUSMOD", "}" SEP);
			}
		}
	}
}
   1e858:	b00d      	add	sp, #52	; 0x34
   1e85a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1e85c:	200034ae 	.word	0x200034ae
   1e860:	20003574 	.word	0x20003574

0001e864 <_ZN20StatusReporterModule17TimerEventHandlerEtm>:
}

void StatusReporterModule::TimerEventHandler(u16 passedTimeDs, u32 appTimerDs)
{
	//Device Info
	if(SHOULD_IV_TRIGGER(node->appTimerDs+node->appTimerRandomOffsetDs, passedTimeDs, configuration.deviceInfoReportingIntervalDs)){
   1e864:	6883      	ldr	r3, [r0, #8]


}

void StatusReporterModule::TimerEventHandler(u16 passedTimeDs, u32 appTimerDs)
{
   1e866:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	//Device Info
	if(SHOULD_IV_TRIGGER(node->appTimerDs+node->appTimerRandomOffsetDs, passedTimeDs, configuration.deviceInfoReportingIntervalDs)){
   1e868:	1c1a      	adds	r2, r3, #0
   1e86a:	3274      	adds	r2, #116	; 0x74
   1e86c:	8816      	ldrh	r6, [r2, #0]
   1e86e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
   1e870:	8e87      	ldrh	r7, [r0, #52]	; 0x34
   1e872:	18f6      	adds	r6, r6, r3


}

void StatusReporterModule::TimerEventHandler(u16 passedTimeDs, u32 appTimerDs)
{
   1e874:	1c04      	adds	r4, r0, #0
   1e876:	1c0d      	adds	r5, r1, #0
	//Device Info
	if(SHOULD_IV_TRIGGER(node->appTimerDs+node->appTimerRandomOffsetDs, passedTimeDs, configuration.deviceInfoReportingIntervalDs)){
   1e878:	1a70      	subs	r0, r6, r1
   1e87a:	1c39      	adds	r1, r7, #0
   1e87c:	f003 fc82 	bl	22184 <__aeabi_uidivmod>
   1e880:	1c30      	adds	r0, r6, #0
   1e882:	9101      	str	r1, [sp, #4]
   1e884:	1c39      	adds	r1, r7, #0
   1e886:	f003 fc7d 	bl	22184 <__aeabi_uidivmod>
   1e88a:	9b01      	ldr	r3, [sp, #4]
   1e88c:	428b      	cmp	r3, r1
   1e88e:	d303      	bcc.n	1e898 <_ZN20StatusReporterModule17TimerEventHandlerEtm+0x34>
		SendDeviceInfo(NODE_ID_BROADCAST, MESSAGE_TYPE_MODULE_ACTION_RESPONSE);
   1e890:	1c20      	adds	r0, r4, #0
   1e892:	2100      	movs	r1, #0
   1e894:	f000 fd18 	bl	1f2c8 <_ZN20StatusReporterModule14SendDeviceInfoEth.constprop.2>
	}
	//Status
	if(SHOULD_IV_TRIGGER(node->appTimerDs+node->appTimerRandomOffsetDs, passedTimeDs, configuration.statusReportingIntervalDs)){
   1e898:	68a3      	ldr	r3, [r4, #8]
   1e89a:	8de7      	ldrh	r7, [r4, #46]	; 0x2e
   1e89c:	1c1a      	adds	r2, r3, #0
   1e89e:	3274      	adds	r2, #116	; 0x74
   1e8a0:	8816      	ldrh	r6, [r2, #0]
   1e8a2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
   1e8a4:	1c39      	adds	r1, r7, #0
   1e8a6:	18f6      	adds	r6, r6, r3
   1e8a8:	1b70      	subs	r0, r6, r5
   1e8aa:	f003 fc6b 	bl	22184 <__aeabi_uidivmod>
   1e8ae:	1c30      	adds	r0, r6, #0
   1e8b0:	9101      	str	r1, [sp, #4]
   1e8b2:	1c39      	adds	r1, r7, #0
   1e8b4:	f003 fc66 	bl	22184 <__aeabi_uidivmod>
   1e8b8:	9b01      	ldr	r3, [sp, #4]
   1e8ba:	428b      	cmp	r3, r1
   1e8bc:	d303      	bcc.n	1e8c6 <_ZN20StatusReporterModule17TimerEventHandlerEtm+0x62>
		SendStatus(NODE_ID_BROADCAST, MESSAGE_TYPE_MODULE_ACTION_RESPONSE);
   1e8be:	1c20      	adds	r0, r4, #0
   1e8c0:	2100      	movs	r1, #0
   1e8c2:	f000 fcbc 	bl	1f23e <_ZN20StatusReporterModule10SendStatusEth.constprop.3>
	}
	//Connections
	if(SHOULD_IV_TRIGGER(node->appTimerDs+node->appTimerRandomOffsetDs, passedTimeDs, configuration.connectionReportingIntervalDs)){
   1e8c6:	68a3      	ldr	r3, [r4, #8]
   1e8c8:	8da7      	ldrh	r7, [r4, #44]	; 0x2c
   1e8ca:	1c1a      	adds	r2, r3, #0
   1e8cc:	3274      	adds	r2, #116	; 0x74
   1e8ce:	8816      	ldrh	r6, [r2, #0]
   1e8d0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
   1e8d2:	1c39      	adds	r1, r7, #0
   1e8d4:	18f6      	adds	r6, r6, r3
   1e8d6:	1b70      	subs	r0, r6, r5
   1e8d8:	f003 fc54 	bl	22184 <__aeabi_uidivmod>
   1e8dc:	1c30      	adds	r0, r6, #0
   1e8de:	9101      	str	r1, [sp, #4]
   1e8e0:	1c39      	adds	r1, r7, #0
   1e8e2:	f003 fc4f 	bl	22184 <__aeabi_uidivmod>
   1e8e6:	9b01      	ldr	r3, [sp, #4]
   1e8e8:	428b      	cmp	r3, r1
   1e8ea:	d304      	bcc.n	1e8f6 <_ZN20StatusReporterModule17TimerEventHandlerEtm+0x92>
		SendAllConnections(NODE_ID_BROADCAST, MESSAGE_TYPE_MODULE_GENERAL);
   1e8ec:	1c20      	adds	r0, r4, #0
   1e8ee:	2100      	movs	r1, #0
   1e8f0:	2235      	movs	r2, #53	; 0x35
   1e8f2:	f7ff fe85 	bl	1e600 <_ZN20StatusReporterModule18SendAllConnectionsEth>
	}
	//Nearby Nodes
	if(SHOULD_IV_TRIGGER(node->appTimerDs+node->appTimerRandomOffsetDs, passedTimeDs, configuration.nearbyReportingIntervalDs)){
   1e8f6:	68a3      	ldr	r3, [r4, #8]
   1e8f8:	8e67      	ldrh	r7, [r4, #50]	; 0x32
   1e8fa:	1c1a      	adds	r2, r3, #0
   1e8fc:	3274      	adds	r2, #116	; 0x74
   1e8fe:	8816      	ldrh	r6, [r2, #0]
   1e900:	6e5b      	ldr	r3, [r3, #100]	; 0x64
   1e902:	1c39      	adds	r1, r7, #0
   1e904:	18f6      	adds	r6, r6, r3
   1e906:	1b70      	subs	r0, r6, r5
   1e908:	f003 fc3c 	bl	22184 <__aeabi_uidivmod>
   1e90c:	1c30      	adds	r0, r6, #0
   1e90e:	1c0d      	adds	r5, r1, #0
   1e910:	1c39      	adds	r1, r7, #0
   1e912:	f003 fc37 	bl	22184 <__aeabi_uidivmod>
   1e916:	428d      	cmp	r5, r1
   1e918:	d303      	bcc.n	1e922 <_ZN20StatusReporterModule17TimerEventHandlerEtm+0xbe>
		SendNearbyNodes(NODE_ID_BROADCAST, MESSAGE_TYPE_MODULE_ACTION_RESPONSE);
   1e91a:	1c20      	adds	r0, r4, #0
   1e91c:	2100      	movs	r1, #0
   1e91e:	f000 fd4d 	bl	1f3bc <_ZN20StatusReporterModule15SendNearbyNodesEth.constprop.1>
	}
}
   1e922:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

0001e924 <_ZN20StatusReporterModule15BleEventHandlerEP9ble_evt_t>:
	}
}


//This handler receives all ble events and can act on them
void StatusReporterModule::BleEventHandler(ble_evt_t* bleEvent){
   1e924:	b538      	push	{r3, r4, r5, lr}

	//New RSSI measurement for connection received
	if(bleEvent->header.evt_id == BLE_GAP_EVT_RSSI_CHANGED)
   1e926:	880b      	ldrh	r3, [r1, #0]
   1e928:	2b1c      	cmp	r3, #28
   1e92a:	d118      	bne.n	1e95e <_ZN20StatusReporterModule15BleEventHandlerEP9ble_evt_t+0x3a>
   1e92c:	1c0d      	adds	r5, r1, #0
	{
		Connection* connection = cm->GetConnectionFromHandle(bleEvent->evt.gap_evt.conn_handle);
   1e92e:	68c0      	ldr	r0, [r0, #12]
   1e930:	8889      	ldrh	r1, [r1, #4]
   1e932:	f7ff f907 	bl	1db44 <_ZN17ConnectionManager23GetConnectionFromHandleEt>
   1e936:	1c04      	adds	r4, r0, #0
		i8 rssi = bleEvent->evt.gap_evt.params.rssi_changed.rssi;
   1e938:	7a28      	ldrb	r0, [r5, #8]

		connection->rssiSamplesNum++;
   1e93a:	8a21      	ldrh	r1, [r4, #16]
		connection->rssiSamplesSum += rssi;
   1e93c:	89e3      	ldrh	r3, [r4, #14]
   1e93e:	b240      	sxtb	r0, r0
	if(bleEvent->header.evt_id == BLE_GAP_EVT_RSSI_CHANGED)
	{
		Connection* connection = cm->GetConnectionFromHandle(bleEvent->evt.gap_evt.conn_handle);
		i8 rssi = bleEvent->evt.gap_evt.params.rssi_changed.rssi;

		connection->rssiSamplesNum++;
   1e940:	3101      	adds	r1, #1
		connection->rssiSamplesSum += rssi;
   1e942:	18c0      	adds	r0, r0, r3
	if(bleEvent->header.evt_id == BLE_GAP_EVT_RSSI_CHANGED)
	{
		Connection* connection = cm->GetConnectionFromHandle(bleEvent->evt.gap_evt.conn_handle);
		i8 rssi = bleEvent->evt.gap_evt.params.rssi_changed.rssi;

		connection->rssiSamplesNum++;
   1e944:	b289      	uxth	r1, r1
		connection->rssiSamplesSum += rssi;
   1e946:	b280      	uxth	r0, r0
	if(bleEvent->header.evt_id == BLE_GAP_EVT_RSSI_CHANGED)
	{
		Connection* connection = cm->GetConnectionFromHandle(bleEvent->evt.gap_evt.conn_handle);
		i8 rssi = bleEvent->evt.gap_evt.params.rssi_changed.rssi;

		connection->rssiSamplesNum++;
   1e948:	8221      	strh	r1, [r4, #16]
		connection->rssiSamplesSum += rssi;
   1e94a:	81e0      	strh	r0, [r4, #14]

		if(connection->rssiSamplesNum > 50){
   1e94c:	2932      	cmp	r1, #50	; 0x32
   1e94e:	d944      	bls.n	1e9da <_ZN20StatusReporterModule15BleEventHandlerEP9ble_evt_t+0xb6>
			connection->rssiAverage = connection->rssiSamplesSum / connection->rssiSamplesNum;
   1e950:	f003 fb92 	bl	22078 <__aeabi_uidiv>

			connection->rssiSamplesNum = 0;
   1e954:	2300      	movs	r3, #0

		connection->rssiSamplesNum++;
		connection->rssiSamplesSum += rssi;

		if(connection->rssiSamplesNum > 50){
			connection->rssiAverage = connection->rssiSamplesSum / connection->rssiSamplesNum;
   1e956:	74a0      	strb	r0, [r4, #18]

			connection->rssiSamplesNum = 0;
   1e958:	8223      	strh	r3, [r4, #16]
			connection->rssiSamplesSum = 0;
   1e95a:	81e3      	strh	r3, [r4, #14]
   1e95c:	e03d      	b.n	1e9da <_ZN20StatusReporterModule15BleEventHandlerEP9ble_evt_t+0xb6>

			//logt("STATUSMOD", "New RSSI average %d", connection->rssiAverage);
		}
	} else if(bleEvent->header.evt_id == BLE_GAP_EVT_ADV_REPORT){
   1e95e:	2b1d      	cmp	r3, #29
   1e960:	d13b      	bne.n	1e9da <_ZN20StatusReporterModule15BleEventHandlerEP9ble_evt_t+0xb6>
		u8* data = bleEvent->evt.gap_evt.params.adv_report.data;
		u16 dataLength = bleEvent->evt.gap_evt.params.adv_report.dlen;

		advPacketHeader* packetHeader = (advPacketHeader*) data;

		switch (packetHeader->messageType)
   1e962:	1c0b      	adds	r3, r1, #0
			//logt("STATUSMOD", "New RSSI average %d", connection->rssiAverage);
		}
	} else if(bleEvent->header.evt_id == BLE_GAP_EVT_ADV_REPORT){

		u8* data = bleEvent->evt.gap_evt.params.adv_report.data;
		u16 dataLength = bleEvent->evt.gap_evt.params.adv_report.dlen;
   1e964:	7c0a      	ldrb	r2, [r1, #16]

		advPacketHeader* packetHeader = (advPacketHeader*) data;

		switch (packetHeader->messageType)
   1e966:	7ecc      	ldrb	r4, [r1, #27]
			//logt("STATUSMOD", "New RSSI average %d", connection->rssiAverage);
		}
	} else if(bleEvent->header.evt_id == BLE_GAP_EVT_ADV_REPORT){

		u8* data = bleEvent->evt.gap_evt.params.adv_report.data;
		u16 dataLength = bleEvent->evt.gap_evt.params.adv_report.dlen;
   1e968:	08d2      	lsrs	r2, r2, #3

		advPacketHeader* packetHeader = (advPacketHeader*) data;

		switch (packetHeader->messageType)
   1e96a:	3311      	adds	r3, #17
   1e96c:	2c01      	cmp	r4, #1
   1e96e:	d134      	bne.n	1e9da <_ZN20StatusReporterModule15BleEventHandlerEP9ble_evt_t+0xb6>
		{
			case MESSAGE_TYPE_JOIN_ME_V0:
				if (dataLength == SIZEOF_ADV_PACKET_JOIN_ME)
   1e970:	2a1f      	cmp	r2, #31
   1e972:	d132      	bne.n	1e9da <_ZN20StatusReporterModule15BleEventHandlerEP9ble_evt_t+0xb6>
					advPacketJoinMeV0* packet = (advPacketJoinMeV0*) data;

					bool found = false;

					for(int i=0; i<NUM_NODE_MEASUREMENTS; i++){
						if(nodeMeasurements[i].nodeId == packet->payload.sender){
   1e974:	7b1c      	ldrb	r4, [r3, #12]
   1e976:	7ada      	ldrb	r2, [r3, #11]
   1e978:	0224      	lsls	r4, r4, #8
   1e97a:	4314      	orrs	r4, r2
   1e97c:	2200      	movs	r2, #0
   1e97e:	00d3      	lsls	r3, r2, #3
   1e980:	18c3      	adds	r3, r0, r3
   1e982:	8f9d      	ldrh	r5, [r3, #60]	; 0x3c
   1e984:	42a5      	cmp	r5, r4
   1e986:	d110      	bne.n	1e9aa <_ZN20StatusReporterModule15BleEventHandlerEP9ble_evt_t+0x86>
							nodeMeasurements[i].packetCount++;
							nodeMeasurements[i].rssiSum += bleEvent->evt.gap_evt.params.adv_report.rssi;
   1e988:	1c1c      	adds	r4, r3, #0

					bool found = false;

					for(int i=0; i<NUM_NODE_MEASUREMENTS; i++){
						if(nodeMeasurements[i].nodeId == packet->payload.sender){
							nodeMeasurements[i].packetCount++;
   1e98a:	1d18      	adds	r0, r3, #4
   1e98c:	8fc2      	ldrh	r2, [r0, #62]	; 0x3e
							nodeMeasurements[i].rssiSum += bleEvent->evt.gap_evt.params.adv_report.rssi;
   1e98e:	343e      	adds	r4, #62	; 0x3e

					bool found = false;

					for(int i=0; i<NUM_NODE_MEASUREMENTS; i++){
						if(nodeMeasurements[i].nodeId == packet->payload.sender){
							nodeMeasurements[i].packetCount++;
   1e990:	3201      	adds	r2, #1
   1e992:	87c2      	strh	r2, [r0, #62]	; 0x3e
							nodeMeasurements[i].rssiSum += bleEvent->evt.gap_evt.params.adv_report.rssi;
   1e994:	8862      	ldrh	r2, [r4, #2]
   1e996:	8fd8      	ldrh	r0, [r3, #62]	; 0x3e
   1e998:	7bc9      	ldrb	r1, [r1, #15]
   1e99a:	0412      	lsls	r2, r2, #16
   1e99c:	4302      	orrs	r2, r0
   1e99e:	b249      	sxtb	r1, r1
   1e9a0:	1852      	adds	r2, r2, r1
   1e9a2:	87da      	strh	r2, [r3, #62]	; 0x3e
   1e9a4:	0c12      	lsrs	r2, r2, #16
   1e9a6:	8062      	strh	r2, [r4, #2]
   1e9a8:	e017      	b.n	1e9da <_ZN20StatusReporterModule15BleEventHandlerEP9ble_evt_t+0xb6>
				{
					advPacketJoinMeV0* packet = (advPacketJoinMeV0*) data;

					bool found = false;

					for(int i=0; i<NUM_NODE_MEASUREMENTS; i++){
   1e9aa:	3201      	adds	r2, #1
   1e9ac:	2a14      	cmp	r2, #20
   1e9ae:	d1e6      	bne.n	1e97e <_ZN20StatusReporterModule15BleEventHandlerEP9ble_evt_t+0x5a>
   1e9b0:	2200      	movs	r2, #0
   1e9b2:	00d3      	lsls	r3, r2, #3
   1e9b4:	18c3      	adds	r3, r0, r3
							break;
						}
					}
					if(!found){
						for(int i=0; i<NUM_NODE_MEASUREMENTS; i++){
							if(nodeMeasurements[i].nodeId == 0){
   1e9b6:	8f9d      	ldrh	r5, [r3, #60]	; 0x3c
   1e9b8:	2d00      	cmp	r5, #0
   1e9ba:	d10b      	bne.n	1e9d4 <_ZN20StatusReporterModule15BleEventHandlerEP9ble_evt_t+0xb0>
								nodeMeasurements[i].nodeId = packet->payload.sender;
								nodeMeasurements[i].packetCount = 1;
   1e9bc:	2001      	movs	r0, #1
   1e9be:	1d1a      	adds	r2, r3, #4
						}
					}
					if(!found){
						for(int i=0; i<NUM_NODE_MEASUREMENTS; i++){
							if(nodeMeasurements[i].nodeId == 0){
								nodeMeasurements[i].nodeId = packet->payload.sender;
   1e9c0:	879c      	strh	r4, [r3, #60]	; 0x3c
								nodeMeasurements[i].packetCount = 1;
   1e9c2:	87d0      	strh	r0, [r2, #62]	; 0x3e
								nodeMeasurements[i].rssiSum = bleEvent->evt.gap_evt.params.adv_report.rssi;
   1e9c4:	220f      	movs	r2, #15
   1e9c6:	568a      	ldrsb	r2, [r1, r2]
   1e9c8:	1c19      	adds	r1, r3, #0
   1e9ca:	87da      	strh	r2, [r3, #62]	; 0x3e
   1e9cc:	313e      	adds	r1, #62	; 0x3e
   1e9ce:	0c12      	lsrs	r2, r2, #16
   1e9d0:	804a      	strh	r2, [r1, #2]
   1e9d2:	e002      	b.n	1e9da <_ZN20StatusReporterModule15BleEventHandlerEP9ble_evt_t+0xb6>
							found = true;
							break;
						}
					}
					if(!found){
						for(int i=0; i<NUM_NODE_MEASUREMENTS; i++){
   1e9d4:	3201      	adds	r2, #1
   1e9d6:	2a14      	cmp	r2, #20
   1e9d8:	d1eb      	bne.n	1e9b2 <_ZN20StatusReporterModule15BleEventHandlerEP9ble_evt_t+0x8e>

				}
		}

	}
}
   1e9da:	bd38      	pop	{r3, r4, r5, pc}

0001e9dc <_ZN20StatusReporterModule27ResetToDefaultConfigurationEv>:

}


void StatusReporterModule::ResetToDefaultConfiguration()
{
   1e9dc:	b508      	push	{r3, lr}
	//Set default configuration values
	configuration.moduleId = moduleId;
   1e9de:	1c03      	adds	r3, r0, #0
   1e9e0:	7c02      	ldrb	r2, [r0, #16]
   1e9e2:	3328      	adds	r3, #40	; 0x28
   1e9e4:	701a      	strb	r2, [r3, #0]
	configuration.moduleActive = true;
   1e9e6:	1c02      	adds	r2, r0, #0
   1e9e8:	2301      	movs	r3, #1
   1e9ea:	322a      	adds	r2, #42	; 0x2a
   1e9ec:	7013      	strb	r3, [r2, #0]
	configuration.moduleVersion = 1;
   1e9ee:	3a01      	subs	r2, #1
   1e9f0:	7013      	strb	r3, [r2, #0]

	configuration.statusReportingIntervalDs = SEC_TO_DS(80);
   1e9f2:	23c8      	movs	r3, #200	; 0xc8
   1e9f4:	009b      	lsls	r3, r3, #2
   1e9f6:	85c3      	strh	r3, [r0, #46]	; 0x2e
	configuration.connectionReportingIntervalDs = SEC_TO_DS(85);
   1e9f8:	4b08      	ldr	r3, [pc, #32]	; (1ea1c <_ZN20StatusReporterModule27ResetToDefaultConfigurationEv+0x40>)
	configuration.connectionRSSISamplingMode = RSSISampingModes::RSSI_SAMLING_HIGH;
	configuration.advertisingRSSISamplingMode = RSSISampingModes::RSSI_SAMLING_HIGH;
	configuration.nearbyReportingIntervalDs = SEC_TO_DS(180);
	configuration.deviceInfoReportingIntervalDs = SEC_TO_DS(100);

	memset(nodeMeasurements, 0x00, sizeof(nodeMeasurements));
   1e9fa:	2100      	movs	r1, #0
	configuration.moduleId = moduleId;
	configuration.moduleActive = true;
	configuration.moduleVersion = 1;

	configuration.statusReportingIntervalDs = SEC_TO_DS(80);
	configuration.connectionReportingIntervalDs = SEC_TO_DS(85);
   1e9fc:	8583      	strh	r3, [r0, #44]	; 0x2c
	configuration.connectionRSSISamplingMode = RSSISampingModes::RSSI_SAMLING_HIGH;
   1e9fe:	2303      	movs	r3, #3
   1ea00:	71d3      	strb	r3, [r2, #7]
	configuration.advertisingRSSISamplingMode = RSSISampingModes::RSSI_SAMLING_HIGH;
   1ea02:	7213      	strb	r3, [r2, #8]
	configuration.nearbyReportingIntervalDs = SEC_TO_DS(180);
   1ea04:	23e1      	movs	r3, #225	; 0xe1
   1ea06:	00db      	lsls	r3, r3, #3
   1ea08:	8643      	strh	r3, [r0, #50]	; 0x32
	configuration.deviceInfoReportingIntervalDs = SEC_TO_DS(100);
   1ea0a:	23fa      	movs	r3, #250	; 0xfa
   1ea0c:	009b      	lsls	r3, r3, #2
   1ea0e:	8683      	strh	r3, [r0, #52]	; 0x34

	memset(nodeMeasurements, 0x00, sizeof(nodeMeasurements));
   1ea10:	22a0      	movs	r2, #160	; 0xa0
   1ea12:	303c      	adds	r0, #60	; 0x3c
   1ea14:	f002 fe1b 	bl	2164e <memset>

	//Set additional config values...


}
   1ea18:	bd08      	pop	{r3, pc}
   1ea1a:	46c0      	nop			; (mov r8, r8)
   1ea1c:	00000352 	.word	0x00000352

0001ea20 <_ZN14ScanningModule17TimerEventHandlerEtm>:
		return false;
	}
}

void ScanningModule::TimerEventHandler(u16 passedTimeDs, u32 appTimerDs)
{
   1ea20:	b5f0      	push	{r4, r5, r6, r7, lr}
   1ea22:	b08f      	sub	sp, #60	; 0x3c
   1ea24:	af00      	add	r7, sp, #0
	if(SHOULD_IV_TRIGGER(appTimerDs, passedTimeDs, configuration.groupedReportingIntervalDs))
   1ea26:	1a53      	subs	r3, r2, r1
		return false;
	}
}

void ScanningModule::TimerEventHandler(u16 passedTimeDs, u32 appTimerDs)
{
   1ea28:	617a      	str	r2, [r7, #20]
	if(SHOULD_IV_TRIGGER(appTimerDs, passedTimeDs, configuration.groupedReportingIntervalDs))
   1ea2a:	613b      	str	r3, [r7, #16]
   1ea2c:	8d84      	ldrh	r4, [r0, #44]	; 0x2c
		return false;
	}
}

void ScanningModule::TimerEventHandler(u16 passedTimeDs, u32 appTimerDs)
{
   1ea2e:	1c06      	adds	r6, r0, #0
	if(SHOULD_IV_TRIGGER(appTimerDs, passedTimeDs, configuration.groupedReportingIntervalDs))
   1ea30:	1c21      	adds	r1, r4, #0
   1ea32:	1c18      	adds	r0, r3, #0
   1ea34:	f003 fba6 	bl	22184 <__aeabi_uidivmod>
   1ea38:	6978      	ldr	r0, [r7, #20]
   1ea3a:	1c0d      	adds	r5, r1, #0
   1ea3c:	1c21      	adds	r1, r4, #0
   1ea3e:	f003 fba1 	bl	22184 <__aeabi_uidivmod>
   1ea42:	428d      	cmp	r5, r1
   1ea44:	d372      	bcc.n	1eb2c <_ZN14ScanningModule17TimerEventHandlerEtm+0x10c>

void ScanningModule::SendReport()
{
	// The number of different addresses indicates the number of devices
	// that have been scanned during the last time slot.
	u32 totalDevices = addressPointer;
   1ea46:	23ce      	movs	r3, #206	; 0xce
   1ea48:	005b      	lsls	r3, r3, #1
   1ea4a:	5cf5      	ldrb	r5, [r6, r3]
{
	// Special case: If no devices have been found,
	// totalRSSI = 0 should be returned.
	if (addressPointer == 0)
	{
		return 0;
   1ea4c:	2400      	movs	r4, #0
   1ea4e:	466b      	mov	r3, sp
   1ea50:	607b      	str	r3, [r7, #4]

u32 ScanningModule::computeTotalRSSI()
{
	// Special case: If no devices have been found,
	// totalRSSI = 0 should be returned.
	if (addressPointer == 0)
   1ea52:	42a5      	cmp	r5, r4
   1ea54:	d022      	beq.n	1ea9c <_ZN14ScanningModule17TimerEventHandlerEtm+0x7c>
	{
		return 0;
	}

	// Compute the mean of all RSSI values for each address.
	u32 meanRSSIsPerAddress[addressPointer];
   1ea56:	466a      	mov	r2, sp
   1ea58:	00ab      	lsls	r3, r5, #2
   1ea5a:	60bb      	str	r3, [r7, #8]
   1ea5c:	330a      	adds	r3, #10
   1ea5e:	08db      	lsrs	r3, r3, #3
   1ea60:	00db      	lsls	r3, r3, #3
   1ea62:	1ad3      	subs	r3, r2, r3
   1ea64:	469d      	mov	sp, r3
   1ea66:	60fb      	str	r3, [r7, #12]
   1ea68:	22b3      	movs	r2, #179	; 0xb3
   1ea6a:	21e5      	movs	r1, #229	; 0xe5
   1ea6c:	1933      	adds	r3, r6, r4
   1ea6e:	0089      	lsls	r1, r1, #2
   1ea70:	0092      	lsls	r2, r2, #2
   1ea72:	189a      	adds	r2, r3, r2
   1ea74:	185b      	adds	r3, r3, r1
	for (int i = 0; i < addressPointer; i++)
	{
		meanRSSIsPerAddress[i] = totalRSSIsPerAddress[i] / totalMessagesPerAdress[i];
   1ea76:	6819      	ldr	r1, [r3, #0]
   1ea78:	6810      	ldr	r0, [r2, #0]
   1ea7a:	f003 fafd 	bl	22078 <__aeabi_uidiv>
   1ea7e:	68fb      	ldr	r3, [r7, #12]
   1ea80:	5118      	str	r0, [r3, r4]
		return 0;
	}

	// Compute the mean of all RSSI values for each address.
	u32 meanRSSIsPerAddress[addressPointer];
	for (int i = 0; i < addressPointer; i++)
   1ea82:	68bb      	ldr	r3, [r7, #8]
   1ea84:	3404      	adds	r4, #4
   1ea86:	429c      	cmp	r4, r3
   1ea88:	d1ee      	bne.n	1ea68 <_ZN14ScanningModule17TimerEventHandlerEtm+0x48>
   1ea8a:	2400      	movs	r4, #0
   1ea8c:	1c23      	adds	r3, r4, #0
	// Sum up all the RSSI values to get a value that
	// indicates the mobile device density around the node.
	u32 totalRSSI = 0;
	for (int i = 0; i < addressPointer; i++)
	{
		totalRSSI += meanRSSIsPerAddress[i];
   1ea8e:	68f9      	ldr	r1, [r7, #12]
   1ea90:	009a      	lsls	r2, r3, #2
   1ea92:	588a      	ldr	r2, [r1, r2]
	}

	// Sum up all the RSSI values to get a value that
	// indicates the mobile device density around the node.
	u32 totalRSSI = 0;
	for (int i = 0; i < addressPointer; i++)
   1ea94:	3301      	adds	r3, #1
	{
		totalRSSI += meanRSSIsPerAddress[i];
   1ea96:	18a4      	adds	r4, r4, r2
	}

	// Sum up all the RSSI values to get a value that
	// indicates the mobile device density around the node.
	u32 totalRSSI = 0;
	for (int i = 0; i < addressPointer; i++)
   1ea98:	42ab      	cmp	r3, r5
   1ea9a:	dbf8      	blt.n	1ea8e <_ZN14ScanningModule17TimerEventHandlerEtm+0x6e>
   1ea9c:	687b      	ldr	r3, [r7, #4]
   1ea9e:	469d      	mov	sp, r3
		u32 totalMessages = totalMessagesPerAdress[i];
		logt("SCANMOD", "0x%x  |  %d  |  %d", address, meanRSSI, totalMessages);
	}

	logt("SCANMOD", "Total devices:%d, avgRSSI:%d", totalDevices, totalRSSI);
	if (totalDevices > 0)
   1eaa0:	2d00      	cmp	r5, #0
   1eaa2:	d02c      	beq.n	1eafe <_ZN14ScanningModule17TimerEventHandlerEtm+0xde>
	{
		connPacketModule data;
		data.header.messageType = MESSAGE_TYPE_MODULE_TRIGGER_ACTION;
   1eaa4:	2324      	movs	r3, #36	; 0x24
   1eaa6:	18fb      	adds	r3, r7, r3
   1eaa8:	781a      	ldrb	r2, [r3, #0]
   1eaaa:	2301      	movs	r3, #1
   1eaac:	4013      	ands	r3, r2
   1eaae:	2266      	movs	r2, #102	; 0x66
		data.header.sender = node->persistentConfig.nodeId;
   1eab0:	2025      	movs	r0, #37	; 0x25

	logt("SCANMOD", "Total devices:%d, avgRSSI:%d", totalDevices, totalRSSI);
	if (totalDevices > 0)
	{
		connPacketModule data;
		data.header.messageType = MESSAGE_TYPE_MODULE_TRIGGER_ACTION;
   1eab2:	4313      	orrs	r3, r2
   1eab4:	3a42      	subs	r2, #66	; 0x42
   1eab6:	18ba      	adds	r2, r7, r2
   1eab8:	7013      	strb	r3, [r2, #0]
		data.header.sender = node->persistentConfig.nodeId;
   1eaba:	68b2      	ldr	r2, [r6, #8]
   1eabc:	1838      	adds	r0, r7, r0
   1eabe:	1dd3      	adds	r3, r2, #7
   1eac0:	7fd9      	ldrb	r1, [r3, #31]
   1eac2:	3208      	adds	r2, #8
   1eac4:	7001      	strb	r1, [r0, #0]
   1eac6:	2126      	movs	r1, #38	; 0x26
   1eac8:	7fd2      	ldrb	r2, [r2, #31]
   1eaca:	1879      	adds	r1, r7, r1
   1eacc:	700a      	strb	r2, [r1, #0]
		data.header.receiver = NODE_ID_BROADCAST; //Only send if sink available
   1eace:	2227      	movs	r2, #39	; 0x27
	logt("SCANMOD", "Total devices:%d, avgRSSI:%d", totalDevices, totalRSSI);
	if (totalDevices > 0)
	{
		connPacketModule data;
		data.header.messageType = MESSAGE_TYPE_MODULE_TRIGGER_ACTION;
		data.header.sender = node->persistentConfig.nodeId;
   1ead0:	2300      	movs	r3, #0
		data.header.receiver = NODE_ID_BROADCAST; //Only send if sink available
   1ead2:	18ba      	adds	r2, r7, r2
   1ead4:	7013      	strb	r3, [r2, #0]
   1ead6:	2228      	movs	r2, #40	; 0x28

		data.moduleId = moduleId;
   1ead8:	2129      	movs	r1, #41	; 0x29
	if (totalDevices > 0)
	{
		connPacketModule data;
		data.header.messageType = MESSAGE_TYPE_MODULE_TRIGGER_ACTION;
		data.header.sender = node->persistentConfig.nodeId;
		data.header.receiver = NODE_ID_BROADCAST; //Only send if sink available
   1eada:	18ba      	adds	r2, r7, r2
   1eadc:	7013      	strb	r3, [r2, #0]

		data.moduleId = moduleId;
   1eade:	7c32      	ldrb	r2, [r6, #16]
   1eae0:	1879      	adds	r1, r7, r1
   1eae2:	700a      	strb	r2, [r1, #0]
		data.actionType = ScanModuleMessages::TOTAL_SCANNED_PACKETS;
   1eae4:	222b      	movs	r2, #43	; 0x2b

		//Insert total messages and totalRSSI
		memcpy(data.data + 0, &totalDevices, 4);
		memcpy(data.data + 4, &totalRSSI, 4);

		cm->SendMessageToReceiver(NULL, (u8*) &data, SIZEOF_CONN_PACKET_MODULE + 8, false);
   1eae6:	2118      	movs	r1, #24
		data.header.messageType = MESSAGE_TYPE_MODULE_TRIGGER_ACTION;
		data.header.sender = node->persistentConfig.nodeId;
		data.header.receiver = NODE_ID_BROADCAST; //Only send if sink available

		data.moduleId = moduleId;
		data.actionType = ScanModuleMessages::TOTAL_SCANNED_PACKETS;
   1eae8:	18ba      	adds	r2, r7, r2
   1eaea:	7013      	strb	r3, [r2, #0]

		//Insert total messages and totalRSSI
		memcpy(data.data + 0, &totalDevices, 4);
		memcpy(data.data + 4, &totalRSSI, 4);

		cm->SendMessageToReceiver(NULL, (u8*) &data, SIZEOF_CONN_PACKET_MODULE + 8, false);
   1eaec:	220c      	movs	r2, #12
   1eaee:	1879      	adds	r1, r7, r1
   1eaf0:	1889      	adds	r1, r1, r2
   1eaf2:	68f0      	ldr	r0, [r6, #12]
   1eaf4:	3204      	adds	r2, #4

		data.moduleId = moduleId;
		data.actionType = ScanModuleMessages::TOTAL_SCANNED_PACKETS;

		//Insert total messages and totalRSSI
		memcpy(data.data + 0, &totalDevices, 4);
   1eaf6:	62fd      	str	r5, [r7, #44]	; 0x2c
		memcpy(data.data + 4, &totalRSSI, 4);
   1eaf8:	633c      	str	r4, [r7, #48]	; 0x30

		cm->SendMessageToReceiver(NULL, (u8*) &data, SIZEOF_CONN_PACKET_MODULE + 8, false);
   1eafa:	f000 fb4f 	bl	1f19c <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10>
	return false;
}

void ScanningModule::resetAddressTable()
{
	addressPointer = 0;
   1eafe:	23ce      	movs	r3, #206	; 0xce
   1eb00:	2200      	movs	r2, #0
   1eb02:	005b      	lsls	r3, r3, #1
   1eb04:	54f2      	strb	r2, [r6, r3]
   1eb06:	3331      	adds	r3, #49	; 0x31
   1eb08:	33ff      	adds	r3, #255	; 0xff
   1eb0a:	18f2      	adds	r2, r6, r3
   1eb0c:	33c8      	adds	r3, #200	; 0xc8
   1eb0e:	18f3      	adds	r3, r6, r3

void ScanningModule::resetTotalRSSIsPerAddress()
{
	for (int i = 0; i < NUM_ADDRESSES_TRACKED; i++)
	{
		totalRSSIsPerAddress[i] = 0;
   1eb10:	2100      	movs	r1, #0
   1eb12:	c202      	stmia	r2!, {r1}
	addressPointer = 0;
}

void ScanningModule::resetTotalRSSIsPerAddress()
{
	for (int i = 0; i < NUM_ADDRESSES_TRACKED; i++)
   1eb14:	429a      	cmp	r2, r3
   1eb16:	d1fb      	bne.n	1eb10 <_ZN14ScanningModule17TimerEventHandlerEtm+0xf0>
   1eb18:	4a39      	ldr	r2, [pc, #228]	; (1ec00 <_ZN14ScanningModule17TimerEventHandlerEtm+0x1e0>)
   1eb1a:	18b1      	adds	r1, r6, r2

void ScanningModule::resetTotalMessagesPerAdress()
{
	for (int i = 0; i < NUM_ADDRESSES_TRACKED; i++)
	{
		totalMessagesPerAdress[i] = 0;
   1eb1c:	2200      	movs	r2, #0
   1eb1e:	c304      	stmia	r3!, {r2}
	}
}

void ScanningModule::resetTotalMessagesPerAdress()
{
	for (int i = 0; i < NUM_ADDRESSES_TRACKED; i++)
   1eb20:	428b      	cmp	r3, r1
   1eb22:	d1fb      	bne.n	1eb1c <_ZN14ScanningModule17TimerEventHandlerEtm+0xfc>

		resetAddressTable();
		resetTotalRSSIsPerAddress();
		resetTotalMessagesPerAdress();

		totalMessages = 0;
   1eb24:	4b36      	ldr	r3, [pc, #216]	; (1ec00 <_ZN14ScanningModule17TimerEventHandlerEtm+0x1e0>)
   1eb26:	50f2      	str	r2, [r6, r3]
		totalRSSI = 0;
   1eb28:	3304      	adds	r3, #4
   1eb2a:	50f2      	str	r2, [r6, r3]
	}

	if(SHOULD_IV_TRIGGER(appTimerDs, passedTimeDs, configuration.assetReportingIntervalDs)){
   1eb2c:	8df4      	ldrh	r4, [r6, #46]	; 0x2e
   1eb2e:	6938      	ldr	r0, [r7, #16]
   1eb30:	1c21      	adds	r1, r4, #0
   1eb32:	f003 fb27 	bl	22184 <__aeabi_uidivmod>
   1eb36:	6978      	ldr	r0, [r7, #20]
   1eb38:	1c0d      	adds	r5, r1, #0
   1eb3a:	1c21      	adds	r1, r4, #0
   1eb3c:	f003 fb22 	bl	22184 <__aeabi_uidivmod>
   1eb40:	428d      	cmp	r5, r1
   1eb42:	d35a      	bcc.n	1ebfa <_ZN14ScanningModule17TimerEventHandlerEtm+0x1da>
}

void ScanningModule::SendTrackedAssets()
{
	//Do not send a packet if no assets have been tracked
	if(assetPackets[0].assetId == 0){
   1eb44:	1c33      	adds	r3, r6, #0
   1eb46:	1c32      	adds	r2, r6, #0
   1eb48:	33fe      	adds	r3, #254	; 0xfe
   1eb4a:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
   1eb4c:	3225      	adds	r2, #37	; 0x25
   1eb4e:	32ff      	adds	r2, #255	; 0xff
   1eb50:	613a      	str	r2, [r7, #16]
   1eb52:	2b00      	cmp	r3, #0
   1eb54:	d04c      	beq.n	1ebf0 <_ZN14ScanningModule17TimerEventHandlerEtm+0x1d0>
   1eb56:	231a      	movs	r3, #26
   1eb58:	18fd      	adds	r5, r7, r3
   1eb5a:	1c33      	adds	r3, r6, #0
   1eb5c:	1c14      	adds	r4, r2, #0
   1eb5e:	3349      	adds	r3, #73	; 0x49
   1eb60:	33ff      	adds	r3, #255	; 0xff
   1eb62:	60fb      	str	r3, [r7, #12]
	}

	//FIXME: only send best three trackings
	ScanModuleTrackedAssetsMessage message;
	for(int i=0; i<3; i++){
		message.trackedAssets[i].assetId = assetPackets[i].assetId;
   1eb64:	8822      	ldrh	r2, [r4, #0]
   1eb66:	1eab      	subs	r3, r5, #2
   1eb68:	801a      	strh	r2, [r3, #0]
		message.trackedAssets[i].rssiAvg = -(assetPackets[i].rssiSum / assetPackets[i].count);
   1eb6a:	8923      	ldrh	r3, [r4, #8]
   1eb6c:	6860      	ldr	r0, [r4, #4]
   1eb6e:	1c19      	adds	r1, r3, #0
   1eb70:	617b      	str	r3, [r7, #20]
   1eb72:	f003 fa81 	bl	22078 <__aeabi_uidiv>
		message.trackedAssets[i].packetCount = assetPackets[i].count;
   1eb76:	7d3b      	ldrb	r3, [r7, #20]

	//FIXME: only send best three trackings
	ScanModuleTrackedAssetsMessage message;
	for(int i=0; i<3; i++){
		message.trackedAssets[i].assetId = assetPackets[i].assetId;
		message.trackedAssets[i].rssiAvg = -(assetPackets[i].rssiSum / assetPackets[i].count);
   1eb78:	4240      	negs	r0, r0
		message.trackedAssets[i].packetCount = assetPackets[i].count;
   1eb7a:	706b      	strb	r3, [r5, #1]
		return;
	}

	//FIXME: only send best three trackings
	ScanModuleTrackedAssetsMessage message;
	for(int i=0; i<3; i++){
   1eb7c:	68fb      	ldr	r3, [r7, #12]
   1eb7e:	340c      	adds	r4, #12
		message.trackedAssets[i].assetId = assetPackets[i].assetId;
		message.trackedAssets[i].rssiAvg = -(assetPackets[i].rssiSum / assetPackets[i].count);
   1eb80:	7028      	strb	r0, [r5, #0]
   1eb82:	3504      	adds	r5, #4
		return;
	}

	//FIXME: only send best three trackings
	ScanModuleTrackedAssetsMessage message;
	for(int i=0; i<3; i++){
   1eb84:	429c      	cmp	r4, r3
   1eb86:	d1ed      	bne.n	1eb64 <_ZN14ScanningModule17TimerEventHandlerEtm+0x144>
void Module::SendModuleActionMessage(u8 messageType, nodeID toNode, u8 actionType, u8 requestHandle, u8* additionalData, u16 additionalDataSize, bool reliable)
{
	u8 buffer[SIZEOF_CONN_PACKET_MODULE + additionalDataSize];

	connPacketModule* outPacket = (connPacketModule*)buffer;
	outPacket->header.messageType = messageType;
   1eb88:	2324      	movs	r3, #36	; 0x24
   1eb8a:	2101      	movs	r1, #1
   1eb8c:	226a      	movs	r2, #106	; 0x6a
	outPacket->header.sender = node->persistentConfig.nodeId;
   1eb8e:	2425      	movs	r4, #37	; 0x25
void Module::SendModuleActionMessage(u8 messageType, nodeID toNode, u8 actionType, u8 requestHandle, u8* additionalData, u16 additionalDataSize, bool reliable)
{
	u8 buffer[SIZEOF_CONN_PACKET_MODULE + additionalDataSize];

	connPacketModule* outPacket = (connPacketModule*)buffer;
	outPacket->header.messageType = messageType;
   1eb90:	18fb      	adds	r3, r7, r3
   1eb92:	781b      	ldrb	r3, [r3, #0]
	outPacket->header.sender = node->persistentConfig.nodeId;
   1eb94:	193c      	adds	r4, r7, r4
void Module::SendModuleActionMessage(u8 messageType, nodeID toNode, u8 actionType, u8 requestHandle, u8* additionalData, u16 additionalDataSize, bool reliable)
{
	u8 buffer[SIZEOF_CONN_PACKET_MODULE + additionalDataSize];

	connPacketModule* outPacket = (connPacketModule*)buffer;
	outPacket->header.messageType = messageType;
   1eb96:	400b      	ands	r3, r1
   1eb98:	4313      	orrs	r3, r2
   1eb9a:	3a46      	subs	r2, #70	; 0x46
   1eb9c:	18ba      	adds	r2, r7, r2
   1eb9e:	7013      	strb	r3, [r2, #0]
	outPacket->header.sender = node->persistentConfig.nodeId;
   1eba0:	68b2      	ldr	r2, [r6, #8]
   1eba2:	1dd3      	adds	r3, r2, #7
   1eba4:	7fd8      	ldrb	r0, [r3, #31]
   1eba6:	3208      	adds	r2, #8
   1eba8:	7020      	strb	r0, [r4, #0]
   1ebaa:	2026      	movs	r0, #38	; 0x26
   1ebac:	7fd2      	ldrb	r2, [r2, #31]
   1ebae:	1838      	adds	r0, r7, r0
   1ebb0:	7002      	strb	r2, [r0, #0]
	outPacket->header.receiver = toNode;
   1ebb2:	2227      	movs	r2, #39	; 0x27
{
	u8 buffer[SIZEOF_CONN_PACKET_MODULE + additionalDataSize];

	connPacketModule* outPacket = (connPacketModule*)buffer;
	outPacket->header.messageType = messageType;
	outPacket->header.sender = node->persistentConfig.nodeId;
   1ebb4:	2300      	movs	r3, #0
	outPacket->header.receiver = toNode;
   1ebb6:	18ba      	adds	r2, r7, r2
   1ebb8:	7013      	strb	r3, [r2, #0]
   1ebba:	2228      	movs	r2, #40	; 0x28

	outPacket->moduleId = moduleId;
   1ebbc:	2029      	movs	r0, #41	; 0x29
	u8 buffer[SIZEOF_CONN_PACKET_MODULE + additionalDataSize];

	connPacketModule* outPacket = (connPacketModule*)buffer;
	outPacket->header.messageType = messageType;
	outPacket->header.sender = node->persistentConfig.nodeId;
	outPacket->header.receiver = toNode;
   1ebbe:	18ba      	adds	r2, r7, r2
   1ebc0:	7013      	strb	r3, [r2, #0]

	outPacket->moduleId = moduleId;
   1ebc2:	7c32      	ldrb	r2, [r6, #16]
   1ebc4:	1838      	adds	r0, r7, r0
   1ebc6:	7002      	strb	r2, [r0, #0]
	outPacket->requestHandle = requestHandle;
   1ebc8:	222a      	movs	r2, #42	; 0x2a
   1ebca:	18ba      	adds	r2, r7, r2
   1ebcc:	7013      	strb	r3, [r2, #0]
	outPacket->actionType = actionType;
   1ebce:	222b      	movs	r2, #43	; 0x2b
   1ebd0:	18ba      	adds	r2, r7, r2
   1ebd2:	7011      	strb	r1, [r2, #0]

	if(additionalData != NULL && additionalDataSize > 0)
	{
		memcpy(&outPacket->data, additionalData, additionalDataSize);
   1ebd4:	2218      	movs	r2, #24
   1ebd6:	18b9      	adds	r1, r7, r2
   1ebd8:	3a04      	subs	r2, #4
   1ebda:	188a      	adds	r2, r1, r2
   1ebdc:	c931      	ldmia	r1!, {r0, r4, r5}
   1ebde:	c231      	stmia	r2!, {r0, r4, r5}
	}

	cm->SendMessageToReceiver(NULL, buffer, SIZEOF_CONN_PACKET_MODULE + additionalDataSize, reliable);
   1ebe0:	2118      	movs	r1, #24
   1ebe2:	220c      	movs	r2, #12
   1ebe4:	1879      	adds	r1, r7, r1
   1ebe6:	1889      	adds	r1, r1, r2
   1ebe8:	68f0      	ldr	r0, [r6, #12]
   1ebea:	3208      	adds	r2, #8
   1ebec:	f000 fad6 	bl	1f19c <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10>
		return false;
	}
}

void ScanningModule::resetAssetTrackingTable(){
	memset(assetPackets, 0x00, sizeof(assetPackets));
   1ebf0:	6938      	ldr	r0, [r7, #16]
   1ebf2:	2100      	movs	r1, #0
   1ebf4:	2278      	movs	r2, #120	; 0x78
   1ebf6:	f002 fd2a 	bl	2164e <memset>
	if(SHOULD_IV_TRIGGER(appTimerDs, passedTimeDs, configuration.assetReportingIntervalDs)){
		//Send asset tracking packets
		SendTrackedAssets();
		resetAssetTrackingTable();
	}
}
   1ebfa:	46bd      	mov	sp, r7
   1ebfc:	b00f      	add	sp, #60	; 0x3c
   1ebfe:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1ec00:	0000045c 	.word	0x0000045c

0001ec04 <_ZN14ScanningModuleD0Ev.lto_priv.102>:
   1ec04:	b510      	push	{r4, lr}
   1ec06:	1c04      	adds	r4, r0, #0
   1ec08:	f002 fb1c 	bl	21244 <_ZdlPv>
   1ec0c:	1c20      	adds	r0, r4, #0
   1ec0e:	bd10      	pop	{r4, pc}

0001ec10 <_ZThn4_N14ScanningModuleD0Ev>:
   1ec10:	b408      	push	{r3}
   1ec12:	4b02      	ldr	r3, [pc, #8]	; (1ec1c <_ZThn4_N14ScanningModuleD0Ev+0xc>)
   1ec14:	469c      	mov	ip, r3
   1ec16:	3804      	subs	r0, #4
   1ec18:	bc08      	pop	{r3}
   1ec1a:	4760      	bx	ip
   1ec1c:	0001ec05 	.word	0x0001ec05

0001ec20 <_ZN14ScanningModule23NodeStateChangedHandlerE14discoveryState>:
	}
	return false;
}

void ScanningModule::NodeStateChangedHandler(discoveryState newState)
{
   1ec20:	b508      	push	{r3, lr}
	if (newState == discoveryState::BACK_OFF)
   1ec22:	2909      	cmp	r1, #9
   1ec24:	d103      	bne.n	1ec2e <_ZN14ScanningModule23NodeStateChangedHandlerE14discoveryState+0xe>
	{
		ScanController::SetScanState(scanState::SCAN_STATE_LOW);
   1ec26:	20f0      	movs	r0, #240	; 0xf0
   1ec28:	0100      	lsls	r0, r0, #4
   1ec2a:	f7fe fb9d 	bl	1d368 <_ZN14ScanController12SetScanStateE9scanState>
	}
	else
	{
		//TODO: disable scanning before node is active again
	}
}
   1ec2e:	bd08      	pop	{r3, pc}

0001ec30 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t>:
	}
}

void ScanningModule::BleEventHandler(ble_evt_t* bleEvent)
{
	if (!configuration.moduleActive) return;
   1ec30:	1c03      	adds	r3, r0, #0
		}
	}
}

void ScanningModule::BleEventHandler(ble_evt_t* bleEvent)
{
   1ec32:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (!configuration.moduleActive) return;
   1ec34:	332a      	adds	r3, #42	; 0x2a
   1ec36:	781b      	ldrb	r3, [r3, #0]
		}
	}
}

void ScanningModule::BleEventHandler(ble_evt_t* bleEvent)
{
   1ec38:	b08f      	sub	sp, #60	; 0x3c
	if (!configuration.moduleActive) return;
   1ec3a:	2b00      	cmp	r3, #0
   1ec3c:	d100      	bne.n	1ec40 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x10>
   1ec3e:	e19d      	b.n	1ef7c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x34c>

	switch (bleEvent->header.evt_id)
   1ec40:	880b      	ldrh	r3, [r1, #0]
   1ec42:	2b1d      	cmp	r3, #29
   1ec44:	d000      	beq.n	1ec48 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x18>
   1ec46:	e199      	b.n	1ef7c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x34c>
		case BLE_GAP_EVT_ADV_REPORT:
		{

			//Do not handle mesh packets...
			advPacketHeader* packetHeader = (advPacketHeader*) bleEvent->evt.gap_evt.params.adv_report.data;
			if (bleEvent->evt.gap_evt.params.adv_report.dlen >= SIZEOF_ADV_PACKET_HEADER && packetHeader->manufacturer.companyIdentifier == COMPANY_IDENTIFIER && packetHeader->meshIdentifier == MESH_IDENTIFIER && packetHeader->networkId == Node::getInstance()->persistentConfig.networkId)
   1ec48:	7c0b      	ldrb	r3, [r1, #16]
   1ec4a:	08da      	lsrs	r2, r3, #3
   1ec4c:	9202      	str	r2, [sp, #8]
   1ec4e:	2a0a      	cmp	r2, #10
   1ec50:	dd15      	ble.n	1ec7e <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x4e>
   1ec52:	1c0a      	adds	r2, r1, #0
   1ec54:	7dcc      	ldrb	r4, [r1, #23]
   1ec56:	7d8d      	ldrb	r5, [r1, #22]
   1ec58:	0224      	lsls	r4, r4, #8
   1ec5a:	432c      	orrs	r4, r5
   1ec5c:	4dc4      	ldr	r5, [pc, #784]	; (1ef70 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x340>)
   1ec5e:	3211      	adds	r2, #17
   1ec60:	42ac      	cmp	r4, r5
   1ec62:	d10c      	bne.n	1ec7e <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x4e>
   1ec64:	79d4      	ldrb	r4, [r2, #7]
   1ec66:	2cf0      	cmp	r4, #240	; 0xf0
   1ec68:	d109      	bne.n	1ec7e <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x4e>
   1ec6a:	4dc2      	ldr	r5, [pc, #776]	; (1ef74 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x344>)
   1ec6c:	7a14      	ldrb	r4, [r2, #8]
   1ec6e:	682d      	ldr	r5, [r5, #0]
   1ec70:	7a52      	ldrb	r2, [r2, #9]
   1ec72:	8cad      	ldrh	r5, [r5, #36]	; 0x24
   1ec74:	0212      	lsls	r2, r2, #8
   1ec76:	4322      	orrs	r2, r4
   1ec78:	4295      	cmp	r5, r2
   1ec7a:	d100      	bne.n	1ec7e <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x4e>
   1ec7c:	e17e      	b.n	1ef7c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x34c>
			{
				break;
			}

			//Only parse advertising packets and not scan response packets
			if (bleEvent->evt.gap_evt.params.adv_report.scan_rsp != 1)
   1ec7e:	07da      	lsls	r2, r3, #31
   1ec80:	d500      	bpl.n	1ec84 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x54>
   1ec82:	e17b      	b.n	1ef7c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x34c>
			{
				u8 advertisingType = bleEvent->evt.gap_evt.params.adv_report.type;
   1ec84:	075b      	lsls	r3, r3, #29
   1ec86:	0f9b      	lsrs	r3, r3, #30
   1ec88:	9307      	str	r3, [sp, #28]
				u8* data = bleEvent->evt.gap_evt.params.adv_report.data;
   1ec8a:	1c0b      	adds	r3, r1, #0
   1ec8c:	3311      	adds	r3, #17
   1ec8e:	9301      	str	r3, [sp, #4]
				u8 dataLength = bleEvent->evt.gap_evt.params.adv_report.dlen;
				ble_gap_addr_t* address = &bleEvent->evt.gap_evt.params.adv_report.peer_addr;
				i8 rssi = bleEvent->evt.gap_evt.params.adv_report.rssi;
   1ec90:	7bcb      	ldrb	r3, [r1, #15]
   1ec92:	1c0e      	adds	r6, r1, #0

bool ScanningModule::advertiseDataFromAndroidDevice(u8* data, u8 dataLength)
{
	// advertising data -> manufacturer specific data
	// = "41 6E 64 72 6F 69 64" = "Android"
	if (data[7] == 0x41 && 	// A
   1ec94:	7e09      	ldrb	r1, [r1, #24]
   1ec96:	1c07      	adds	r7, r0, #0
			{
				u8 advertisingType = bleEvent->evt.gap_evt.params.adv_report.type;
				u8* data = bleEvent->evt.gap_evt.params.adv_report.data;
				u8 dataLength = bleEvent->evt.gap_evt.params.adv_report.dlen;
				ble_gap_addr_t* address = &bleEvent->evt.gap_evt.params.adv_report.peer_addr;
				i8 rssi = bleEvent->evt.gap_evt.params.adv_report.rssi;
   1ec98:	9303      	str	r3, [sp, #12]

bool ScanningModule::advertiseDataFromAndroidDevice(u8* data, u8 dataLength)
{
	// advertising data -> manufacturer specific data
	// = "41 6E 64 72 6F 69 64" = "Android"
	if (data[7] == 0x41 && 	// A
   1ec9a:	2941      	cmp	r1, #65	; 0x41
   1ec9c:	d112      	bne.n	1ecc4 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x94>
   1ec9e:	7e73      	ldrb	r3, [r6, #25]
   1eca0:	2b6e      	cmp	r3, #110	; 0x6e
   1eca2:	d10f      	bne.n	1ecc4 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x94>
			data[8] == 0x6e && 	// n
   1eca4:	7eb3      	ldrb	r3, [r6, #26]
   1eca6:	2b64      	cmp	r3, #100	; 0x64
   1eca8:	d10c      	bne.n	1ecc4 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x94>
			data[9] == 0x64 && 	// d
   1ecaa:	7ef3      	ldrb	r3, [r6, #27]
   1ecac:	2b72      	cmp	r3, #114	; 0x72
   1ecae:	d109      	bne.n	1ecc4 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x94>
			data[10] == 0x72 && 	// r
   1ecb0:	7f33      	ldrb	r3, [r6, #28]
   1ecb2:	2b6f      	cmp	r3, #111	; 0x6f
   1ecb4:	d106      	bne.n	1ecc4 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x94>
			data[11] == 0x6f && 	// o
   1ecb6:	7f73      	ldrb	r3, [r6, #29]
   1ecb8:	2b69      	cmp	r3, #105	; 0x69
   1ecba:	d103      	bne.n	1ecc4 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x94>
			data[12] == 0x69 && 	// i
   1ecbc:	7fb3      	ldrb	r3, [r6, #30]
   1ecbe:	2b64      	cmp	r3, #100	; 0x64
   1ecc0:	d100      	bne.n	1ecc4 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x94>
   1ecc2:	e0ed      	b.n	1eea0 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x270>

bool ScanningModule::advertiseDataFromiOSDeviceInBackgroundMode(u8* data, u8 dataLength)
{
	// advertising data -> manufacturer specific data
	// starts with "4c 00 01"
	if (data[5] == 0x4c && data[6] == 0x00 && data[7] == 0x01)
   1ecc4:	7db0      	ldrb	r0, [r6, #22]
   1ecc6:	284c      	cmp	r0, #76	; 0x4c
   1ecc8:	d105      	bne.n	1ecd6 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0xa6>
   1ecca:	7df3      	ldrb	r3, [r6, #23]
   1eccc:	2b00      	cmp	r3, #0
   1ecce:	d102      	bne.n	1ecd6 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0xa6>
   1ecd0:	2901      	cmp	r1, #1
   1ecd2:	d101      	bne.n	1ecd8 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0xa8>
   1ecd4:	e0e4      	b.n	1eea0 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x270>
   1ecd6:	2300      	movs	r3, #0
{
	// https://devzone.nordicsemi.com/documentation/nrf51/4.3.0/html/group___b_l_e___g_a_p___a_d___t_y_p_e___d_e_f_i_n_i_t_i_o_n_s.html
	// advertising data -> local name
	// = "iOS" = "69 4F 53"
	int i = 0;
	while (i < dataLength)
   1ecd8:	9a02      	ldr	r2, [sp, #8]
   1ecda:	4293      	cmp	r3, r2
   1ecdc:	da13      	bge.n	1ed06 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0xd6>
	{
		if (data[i + 1] == BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME)
   1ecde:	9a01      	ldr	r2, [sp, #4]
   1ece0:	18d2      	adds	r2, r2, r3
   1ece2:	7854      	ldrb	r4, [r2, #1]
   1ece4:	2c09      	cmp	r4, #9
   1ece6:	d109      	bne.n	1ecfc <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0xcc>
		{
			if (data[i + 2] == 0x69 &&	// i
   1ece8:	7894      	ldrb	r4, [r2, #2]
   1ecea:	2c69      	cmp	r4, #105	; 0x69
   1ecec:	d106      	bne.n	1ecfc <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0xcc>
   1ecee:	78d4      	ldrb	r4, [r2, #3]
   1ecf0:	2c4f      	cmp	r4, #79	; 0x4f
   1ecf2:	d103      	bne.n	1ecfc <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0xcc>
					data[i + 3] == 0x4f &&	// O
   1ecf4:	7912      	ldrb	r2, [r2, #4]
   1ecf6:	2a53      	cmp	r2, #83	; 0x53
   1ecf8:	d100      	bne.n	1ecfc <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0xcc>
   1ecfa:	e0d1      	b.n	1eea0 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x270>
			{
				//logt("SCANMOD", "iOS device advertising (foreground).");
				return true;
			}
		}
		i += data[i] + 1;
   1ecfc:	9a01      	ldr	r2, [sp, #4]
   1ecfe:	5cd2      	ldrb	r2, [r2, r3]
   1ed00:	3201      	adds	r2, #1
   1ed02:	189b      	adds	r3, r3, r2
   1ed04:	e7e8      	b.n	1ecd8 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0xa8>

bool ScanningModule::advertiseDataFromBeaconWithDifferentNetworkId(u8 *data, u8 dataLength)
{
	// advertising data -> manufacturer specific data
	// starts with "42 63 6e" = "Bcn"
	if (data[5] == 0x42 && data[6] == 0x63 && data[7] == 0x6e)
   1ed06:	2842      	cmp	r0, #66	; 0x42
   1ed08:	d102      	bne.n	1ed10 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0xe0>
   1ed0a:	7df3      	ldrb	r3, [r6, #23]
   1ed0c:	2b63      	cmp	r3, #99	; 0x63
   1ed0e:	d007      	beq.n	1ed20 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0xf0>
						// Update RSSI for the mobile device
						updateTotalRssiAndTotalMessagesForDevice(rssi, address->addr);
					}
				}

				u16 assetId = 0;
   1ed10:	ab08      	add	r3, sp, #32
   1ed12:	1d9c      	adds	r4, r3, #6
   1ed14:	2300      	movs	r3, #0
	}
}

bool ScanningModule::isAssetTrackingData(u8* data, u8 dataLength){
	//02 01 06 XX FF 4D 02 02
	if(data[4] == 0xFF && data[5] == 0x4D && data[6] == 0x02){
   1ed16:	7d72      	ldrb	r2, [r6, #21]
						// Update RSSI for the mobile device
						updateTotalRssiAndTotalMessagesForDevice(rssi, address->addr);
					}
				}

				u16 assetId = 0;
   1ed18:	8023      	strh	r3, [r4, #0]
	}
}

bool ScanningModule::isAssetTrackingData(u8* data, u8 dataLength){
	//02 01 06 XX FF 4D 02 02
	if(data[4] == 0xFF && data[5] == 0x4D && data[6] == 0x02){
   1ed1a:	2aff      	cmp	r2, #255	; 0xff
   1ed1c:	d122      	bne.n	1ed64 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x134>
   1ed1e:	e002      	b.n	1ed26 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0xf6>

bool ScanningModule::advertiseDataFromBeaconWithDifferentNetworkId(u8 *data, u8 dataLength)
{
	// advertising data -> manufacturer specific data
	// starts with "42 63 6e" = "Bcn"
	if (data[5] == 0x42 && data[6] == 0x63 && data[7] == 0x6e)
   1ed20:	296e      	cmp	r1, #110	; 0x6e
   1ed22:	d1f5      	bne.n	1ed10 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0xe0>
   1ed24:	e0bc      	b.n	1eea0 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x270>
	}
}

bool ScanningModule::isAssetTrackingData(u8* data, u8 dataLength){
	//02 01 06 XX FF 4D 02 02
	if(data[4] == 0xFF && data[5] == 0x4D && data[6] == 0x02){
   1ed26:	7db2      	ldrb	r2, [r6, #22]
   1ed28:	2a4d      	cmp	r2, #77	; 0x4d
   1ed2a:	d11b      	bne.n	1ed64 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x134>
   1ed2c:	7df2      	ldrb	r2, [r6, #23]
   1ed2e:	2a02      	cmp	r2, #2
   1ed30:	d118      	bne.n	1ed64 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x134>
		//Identifier for telemetry packet v1
		if(data[7] == 0x02){
   1ed32:	7e32      	ldrb	r2, [r6, #24]
   1ed34:	2a02      	cmp	r2, #2
   1ed36:	d115      	bne.n	1ed64 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x134>
			if(!(data[8] == 0 && data[9] == 0 && data[10] == 0 && data[11] == 0)){
   1ed38:	7e72      	ldrb	r2, [r6, #25]
   1ed3a:	2a00      	cmp	r2, #0
   1ed3c:	d126      	bne.n	1ed8c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x15c>
   1ed3e:	7eb2      	ldrb	r2, [r6, #26]
   1ed40:	2a00      	cmp	r2, #0
   1ed42:	d123      	bne.n	1ed8c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x15c>
   1ed44:	7ef2      	ldrb	r2, [r6, #27]
   1ed46:	2a00      	cmp	r2, #0
   1ed48:	d120      	bne.n	1ed8c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x15c>
   1ed4a:	7f32      	ldrb	r2, [r6, #28]
   1ed4c:	2a00      	cmp	r2, #0
   1ed4e:	d009      	beq.n	1ed64 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x134>
   1ed50:	e01c      	b.n	1ed8c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x15c>
	// advertising data -> local name
	// = "iOS" = "69 4F 53"
	int i = 0;
	while (i < dataLength)
	{
		if (data[i + 1] == BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME)
   1ed52:	9a01      	ldr	r2, [sp, #4]
   1ed54:	18d2      	adds	r2, r2, r3
   1ed56:	7851      	ldrb	r1, [r2, #1]
   1ed58:	2909      	cmp	r1, #9
   1ed5a:	d007      	beq.n	1ed6c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x13c>
			{
				//logt("SCANMOD", "iOS device advertising (foreground).");
				return true;
			}
		}
		i += data[i] + 1;
   1ed5c:	9a01      	ldr	r2, [sp, #4]
   1ed5e:	5cd2      	ldrb	r2, [r2, r3]
   1ed60:	3201      	adds	r2, #1
   1ed62:	189b      	adds	r3, r3, r2
{
	// https://devzone.nordicsemi.com/documentation/nrf51/4.3.0/html/group___b_l_e___g_a_p___a_d___t_y_p_e___d_e_f_i_n_i_t_i_o_n_s.html
	// advertising data -> local name
	// = "iOS" = "69 4F 53"
	int i = 0;
	while (i < dataLength)
   1ed64:	9a02      	ldr	r2, [sp, #8]
   1ed66:	4293      	cmp	r3, r2
   1ed68:	dbf3      	blt.n	1ed52 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x122>
   1ed6a:	e015      	b.n	1ed98 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x168>
	{
		if (data[i + 1] == BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME)
		{
			if (data[i + 2] == 0x61 &&	// a
   1ed6c:	7891      	ldrb	r1, [r2, #2]
   1ed6e:	2961      	cmp	r1, #97	; 0x61
   1ed70:	d1f4      	bne.n	1ed5c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x12c>
   1ed72:	78d1      	ldrb	r1, [r2, #3]
   1ed74:	2974      	cmp	r1, #116	; 0x74
   1ed76:	d1f1      	bne.n	1ed5c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x12c>
					data[i + 3] == 0x74 &&	// t
   1ed78:	7911      	ldrb	r1, [r2, #4]
   1ed7a:	2969      	cmp	r1, #105	; 0x69
   1ed7c:	d1ee      	bne.n	1ed5c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x12c>
					data[i + 4] == 0x69	&&	// i
   1ed7e:	7951      	ldrb	r1, [r2, #5]
   1ed80:	294f      	cmp	r1, #79	; 0x4f
   1ed82:	d1eb      	bne.n	1ed5c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x12c>
					data[i + 5] == 0x4f	&&	// O
   1ed84:	7992      	ldrb	r2, [r2, #6]
   1ed86:	2a53      	cmp	r2, #83	; 0x53
   1ed88:	d1e8      	bne.n	1ed5c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x12c>
   1ed8a:	e085      	b.n	1ee98 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x268>

				u16 assetId = 0;

				if(isAssetTrackingData(data, dataLength)){
					//Extract the id from the packet
					memcpy(&assetId, data + 8, 2);
   1ed8c:	1c31      	adds	r1, r6, #0
   1ed8e:	1c20      	adds	r0, r4, #0
   1ed90:	3119      	adds	r1, #25
   1ed92:	2202      	movs	r2, #2
   1ed94:	f002 fc3e 	bl	21614 <memcpy>
				{
					logt("SCANMOD", "ios AT");
					//Use id 7 for all iOS packets, just because
					assetId = 7;
				}
				if(assetId != 0){
   1ed98:	8821      	ldrh	r1, [r4, #0]
   1ed9a:	2900      	cmp	r1, #0
   1ed9c:	d01d      	beq.n	1edda <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x1aa>
   1ed9e:	1c3b      	adds	r3, r7, #0
   1eda0:	2200      	movs	r2, #0
   1eda2:	3325      	adds	r3, #37	; 0x25
   1eda4:	33ff      	adds	r3, #255	; 0xff
					//Fill info into assetTracking table
					for(int i = 0; i<NUM_ASSET_PACKETS; i++){
						if(assetPackets[i].assetId == assetId || assetPackets[i].assetId == 0){
   1eda6:	8818      	ldrh	r0, [r3, #0]
   1eda8:	4288      	cmp	r0, r1
   1edaa:	d110      	bne.n	1edce <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x19e>

							logt("SCANMOD", "Tracked packet %u in slot %u", assetId, i);
							assetPackets[i].assetId = assetId;
   1edac:	230c      	movs	r3, #12
   1edae:	4353      	muls	r3, r2
   1edb0:	18fb      	adds	r3, r7, r3
   1edb2:	1c1a      	adds	r2, r3, #0
   1edb4:	32fe      	adds	r2, #254	; 0xfe
   1edb6:	84d1      	strh	r1, [r2, #38]	; 0x26
							assetPackets[i].count++;
   1edb8:	8dd1      	ldrh	r1, [r2, #46]	; 0x2e
							assetPackets[i].rssiSum += (u32) (-rssi);
   1edba:	33fc      	adds	r3, #252	; 0xfc
					for(int i = 0; i<NUM_ASSET_PACKETS; i++){
						if(assetPackets[i].assetId == assetId || assetPackets[i].assetId == 0){

							logt("SCANMOD", "Tracked packet %u in slot %u", assetId, i);
							assetPackets[i].assetId = assetId;
							assetPackets[i].count++;
   1edbc:	3101      	adds	r1, #1
   1edbe:	85d1      	strh	r1, [r2, #46]	; 0x2e
							assetPackets[i].rssiSum += (u32) (-rssi);
   1edc0:	466a      	mov	r2, sp
   1edc2:	7b12      	ldrb	r2, [r2, #12]
   1edc4:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
   1edc6:	b252      	sxtb	r2, r2
   1edc8:	1a8a      	subs	r2, r1, r2
   1edca:	62da      	str	r2, [r3, #44]	; 0x2c
   1edcc:	e005      	b.n	1edda <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x1aa>
					assetId = 7;
				}
				if(assetId != 0){
					//Fill info into assetTracking table
					for(int i = 0; i<NUM_ASSET_PACKETS; i++){
						if(assetPackets[i].assetId == assetId || assetPackets[i].assetId == 0){
   1edce:	2800      	cmp	r0, #0
   1edd0:	d0ec      	beq.n	1edac <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x17c>
					//Use id 7 for all iOS packets, just because
					assetId = 7;
				}
				if(assetId != 0){
					//Fill info into assetTracking table
					for(int i = 0; i<NUM_ASSET_PACKETS; i++){
   1edd2:	3201      	adds	r2, #1
   1edd4:	330c      	adds	r3, #12
   1edd6:	2a0a      	cmp	r2, #10
   1edd8:	d1e5      	bne.n	1eda6 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x176>

				//logt("SCAN", "Other packet, rssi:%d, dataLength:%d", rssi, dataLength);

				for (int i = 0; i < SCAN_FILTER_NUMBER; i++)
				{
					if (scanFilters[i].active)
   1edda:	1c3b      	adds	r3, r7, #0
   1eddc:	3338      	adds	r3, #56	; 0x38
   1edde:	781b      	ldrb	r3, [r3, #0]
   1ede0:	2b00      	cmp	r3, #0
   1ede2:	d100      	bne.n	1ede6 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x1b6>
   1ede4:	e0ca      	b.n	1ef7c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x34c>
					{
						//If address type is
						if (scanFilters[i].address.addr_type == 0xFF || scanFilters[i].address.addr_type == address->addr_type)
   1ede6:	1c3b      	adds	r3, r7, #0
   1ede8:	333a      	adds	r3, #58	; 0x3a
   1edea:	781b      	ldrb	r3, [r3, #0]
   1edec:	2bff      	cmp	r3, #255	; 0xff
   1edee:	d003      	beq.n	1edf8 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x1c8>
   1edf0:	7a32      	ldrb	r2, [r6, #8]
   1edf2:	429a      	cmp	r2, r3
   1edf4:	d000      	beq.n	1edf8 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x1c8>
   1edf6:	e0c1      	b.n	1ef7c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x34c>
						{
							if (scanFilters[i].advertisingType == 0xFF || scanFilters[i].advertisingType == advertisingType)
   1edf8:	1c3b      	adds	r3, r7, #0
   1edfa:	3343      	adds	r3, #67	; 0x43
   1edfc:	781b      	ldrb	r3, [r3, #0]
   1edfe:	2bff      	cmp	r3, #255	; 0xff
   1ee00:	d003      	beq.n	1ee0a <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x1da>
   1ee02:	9a07      	ldr	r2, [sp, #28]
   1ee04:	4293      	cmp	r3, r2
   1ee06:	d000      	beq.n	1ee0a <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x1da>
   1ee08:	e0b8      	b.n	1ef7c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x34c>
							{
								if (scanFilters[i].minRSSI <= rssi && scanFilters[i].maxRSSI >= rssi)
   1ee0a:	1c3b      	adds	r3, r7, #0
   1ee0c:	466a      	mov	r2, sp
   1ee0e:	240c      	movs	r4, #12
   1ee10:	3341      	adds	r3, #65	; 0x41
   1ee12:	781b      	ldrb	r3, [r3, #0]
   1ee14:	5714      	ldrsb	r4, [r2, r4]
   1ee16:	b25b      	sxtb	r3, r3
   1ee18:	42a3      	cmp	r3, r4
   1ee1a:	dd00      	ble.n	1ee1e <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x1ee>
   1ee1c:	e0ae      	b.n	1ef7c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x34c>
   1ee1e:	1c3b      	adds	r3, r7, #0
   1ee20:	3342      	adds	r3, #66	; 0x42
   1ee22:	781b      	ldrb	r3, [r3, #0]
   1ee24:	b25b      	sxtb	r3, r3
   1ee26:	42a3      	cmp	r3, r4
   1ee28:	da00      	bge.n	1ee2c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x1fc>
   1ee2a:	e0a7      	b.n	1ef7c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x34c>
								{

									if (scanFilters[i].grouping == GROUP_BY_ADDRESS)
   1ee2c:	1c3b      	adds	r3, r7, #0
   1ee2e:	3339      	adds	r3, #57	; 0x39
										for (int i = 0; i < SCAN_BUFFERS_SIZE; i++)
										{

										}
									}
									else if (scanFilters[i].grouping == NO_GROUPING)
   1ee30:	781b      	ldrb	r3, [r3, #0]
   1ee32:	2b02      	cmp	r3, #2
   1ee34:	d000      	beq.n	1ee38 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x208>
   1ee36:	e0a1      	b.n	1ef7c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x34c>
									{
										logt("SCAN", "sending");

										//FIXME: Legacy packet structure, should use module message
										connPacketAdvInfo data;
										data.header.messageType = MESSAGE_TYPE_ADVINFO;
   1ee38:	2201      	movs	r2, #1
   1ee3a:	ad0a      	add	r5, sp, #40	; 0x28
   1ee3c:	782b      	ldrb	r3, [r5, #0]
										data.header.sender = node->persistentConfig.nodeId;
   1ee3e:	a908      	add	r1, sp, #32
									{
										logt("SCAN", "sending");

										//FIXME: Legacy packet structure, should use module message
										connPacketAdvInfo data;
										data.header.messageType = MESSAGE_TYPE_ADVINFO;
   1ee40:	4013      	ands	r3, r2
   1ee42:	3277      	adds	r2, #119	; 0x77
   1ee44:	4313      	orrs	r3, r2
   1ee46:	702b      	strb	r3, [r5, #0]
										data.header.sender = node->persistentConfig.nodeId;
   1ee48:	68bb      	ldr	r3, [r7, #8]
   1ee4a:	3a6f      	subs	r2, #111	; 0x6f
   1ee4c:	1852      	adds	r2, r2, r1
   1ee4e:	1dd9      	adds	r1, r3, #7
   1ee50:	7fc9      	ldrb	r1, [r1, #31]
   1ee52:	3308      	adds	r3, #8
   1ee54:	7011      	strb	r1, [r2, #0]
   1ee56:	7fdb      	ldrb	r3, [r3, #31]
										data.header.receiver = NODE_ID_BROADCAST; //Only send if sink available

										memcpy(&data.payload.peerAddress, address->addr, 6);
   1ee58:	1c31      	adds	r1, r6, #0
										logt("SCAN", "sending");

										//FIXME: Legacy packet structure, should use module message
										connPacketAdvInfo data;
										data.header.messageType = MESSAGE_TYPE_ADVINFO;
										data.header.sender = node->persistentConfig.nodeId;
   1ee5a:	7053      	strb	r3, [r2, #1]
										data.header.receiver = NODE_ID_BROADCAST; //Only send if sink available
   1ee5c:	230b      	movs	r3, #11
   1ee5e:	aa08      	add	r2, sp, #32
   1ee60:	189b      	adds	r3, r3, r2
   1ee62:	2200      	movs	r2, #0

										memcpy(&data.payload.peerAddress, address->addr, 6);
   1ee64:	200d      	movs	r0, #13

										//FIXME: Legacy packet structure, should use module message
										connPacketAdvInfo data;
										data.header.messageType = MESSAGE_TYPE_ADVINFO;
										data.header.sender = node->persistentConfig.nodeId;
										data.header.receiver = NODE_ID_BROADCAST; //Only send if sink available
   1ee66:	701a      	strb	r2, [r3, #0]
   1ee68:	705a      	strb	r2, [r3, #1]

										memcpy(&data.payload.peerAddress, address->addr, 6);
   1ee6a:	ab08      	add	r3, sp, #32
   1ee6c:	3109      	adds	r1, #9
   1ee6e:	18c0      	adds	r0, r0, r3
   1ee70:	3206      	adds	r2, #6
   1ee72:	f002 fbcf 	bl	21614 <memcpy>
										data.payload.packetCount = 1;
   1ee76:	2301      	movs	r3, #1
										data.payload.inverseRssiSum = -rssi;
   1ee78:	aa08      	add	r2, sp, #32
										data.header.messageType = MESSAGE_TYPE_ADVINFO;
										data.header.sender = node->persistentConfig.nodeId;
										data.header.receiver = NODE_ID_BROADCAST; //Only send if sink available

										memcpy(&data.payload.peerAddress, address->addr, 6);
										data.payload.packetCount = 1;
   1ee7a:	736b      	strb	r3, [r5, #13]
										data.payload.inverseRssiSum = -rssi;
   1ee7c:	4264      	negs	r4, r4
   1ee7e:	3312      	adds	r3, #18
   1ee80:	189b      	adds	r3, r3, r2
   1ee82:	b2a4      	uxth	r4, r4
   1ee84:	701c      	strb	r4, [r3, #0]
   1ee86:	0a24      	lsrs	r4, r4, #8
   1ee88:	705c      	strb	r4, [r3, #1]

										cm->SendMessageToReceiver(NULL, (u8*) &data, SIZEOF_CONN_PACKET_ADV_INFO, false);
   1ee8a:	68f8      	ldr	r0, [r7, #12]
   1ee8c:	1c29      	adds	r1, r5, #0
   1ee8e:	220e      	movs	r2, #14
   1ee90:	2300      	movs	r3, #0
   1ee92:	f000 f983 	bl	1f19c <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10>
   1ee96:	e071      	b.n	1ef7c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x34c>
				}
				else if(isAssetTrackingDataFromiOSDeviceInForegroundMode(data, dataLength))
				{
					logt("SCANMOD", "ios AT");
					//Use id 7 for all iOS packets, just because
					assetId = 7;
   1ee98:	2207      	movs	r2, #7
   1ee9a:	ab08      	add	r3, sp, #32
   1ee9c:	80da      	strh	r2, [r3, #6]
   1ee9e:	e77b      	b.n	1ed98 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x168>

				// If advertise data is sent by a mobile device
				if (advertiseDataWasSentFromMobileDevice(data, dataLength))
				{
					// Only consider mobile devices that are within a certain range...
					if (rssi > configuration.groupedPacketRssiThreshold)
   1eea0:	1c3b      	adds	r3, r7, #0
   1eea2:	466a      	mov	r2, sp
   1eea4:	3330      	adds	r3, #48	; 0x30
   1eea6:	781b      	ldrb	r3, [r3, #0]
   1eea8:	7b12      	ldrb	r2, [r2, #12]
   1eeaa:	b25b      	sxtb	r3, r3
   1eeac:	b252      	sxtb	r2, r2
   1eeae:	9206      	str	r2, [sp, #24]
   1eeb0:	4293      	cmp	r3, r2
   1eeb2:	db00      	blt.n	1eeb6 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x286>
   1eeb4:	e72c      	b.n	1ed10 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0xe0>
					{
						totalMessages++;
   1eeb6:	4a30      	ldr	r2, [pc, #192]	; (1ef78 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x348>)
   1eeb8:	2406      	movs	r4, #6
   1eeba:	58bb      	ldr	r3, [r7, r2]
   1eebc:	3301      	adds	r3, #1
   1eebe:	50bb      	str	r3, [r7, r2]
						totalRSSI += rssi;
   1eec0:	3204      	adds	r2, #4
   1eec2:	58b9      	ldr	r1, [r7, r2]
   1eec4:	9b06      	ldr	r3, [sp, #24]
   1eec6:	185b      	adds	r3, r3, r1
   1eec8:	50bb      	str	r3, [r7, r2]
						//logt("SCANMOD", "RSSI: %d", rssi);
						// Save address in addressTable if address has not already been tracked before.
						if (!addressAlreadyTracked(address->addr))
   1eeca:	1c33      	adds	r3, r6, #0
   1eecc:	3309      	adds	r3, #9
   1eece:	9304      	str	r3, [sp, #16]
	memset(assetPackets, 0x00, sizeof(assetPackets));
}

bool ScanningModule::addressAlreadyTracked(uint8_t* address)
{
	for (int i = 0; i < addressPointer; i++)
   1eed0:	23ce      	movs	r3, #206	; 0xce
   1eed2:	005b      	lsls	r3, r3, #1
   1eed4:	5cfb      	ldrb	r3, [r7, r3]
   1eed6:	9305      	str	r3, [sp, #20]
   1eed8:	1c3b      	adds	r3, r7, #0
   1eeda:	339e      	adds	r3, #158	; 0x9e
   1eedc:	33ff      	adds	r3, #255	; 0xff
   1eede:	9300      	str	r3, [sp, #0]
   1eee0:	9b05      	ldr	r3, [sp, #20]
   1eee2:	9d00      	ldr	r5, [sp, #0]
   1eee4:	435c      	muls	r4, r3
   1eee6:	349e      	adds	r4, #158	; 0x9e
   1eee8:	34ff      	adds	r4, #255	; 0xff
   1eeea:	193c      	adds	r4, r7, r4
   1eeec:	42a5      	cmp	r5, r4
   1eeee:	d008      	beq.n	1ef02 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x2d2>
	{
		if (memcmp(&(addresses[i]), address, BLE_GAP_ADDR_LEN) == 0)
   1eef0:	1c28      	adds	r0, r5, #0
   1eef2:	9904      	ldr	r1, [sp, #16]
   1eef4:	2206      	movs	r2, #6
   1eef6:	f002 fb7e 	bl	215f6 <memcmp>
   1eefa:	3506      	adds	r5, #6
   1eefc:	2800      	cmp	r0, #0
   1eefe:	d1f5      	bne.n	1eeec <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x2bc>
   1ef00:	e010      	b.n	1ef24 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x2f4>
						// Save address in addressTable if address has not already been tracked before.
						if (!addressAlreadyTracked(address->addr))
						{
							// if more than NUM_ADDRESSES_TRACKED have already been tracked
							// do not track this address
							if (addressPointer < NUM_ADDRESSES_TRACKED)
   1ef02:	9b05      	ldr	r3, [sp, #20]
   1ef04:	2b31      	cmp	r3, #49	; 0x31
   1ef06:	d80d      	bhi.n	1ef24 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x2f4>
							{
								memcpy(&addresses[addressPointer], &(address->addr), BLE_GAP_ADDR_LEN);
   1ef08:	2206      	movs	r2, #6
   1ef0a:	9b05      	ldr	r3, [sp, #20]
   1ef0c:	9904      	ldr	r1, [sp, #16]
   1ef0e:	4353      	muls	r3, r2
   1ef10:	18f8      	adds	r0, r7, r3
   1ef12:	309e      	adds	r0, #158	; 0x9e
   1ef14:	30ff      	adds	r0, #255	; 0xff
   1ef16:	f002 fb7d 	bl	21614 <memcpy>
								addressPointer++;
   1ef1a:	22ce      	movs	r2, #206	; 0xce
   1ef1c:	0052      	lsls	r2, r2, #1
   1ef1e:	5cbb      	ldrb	r3, [r7, r2]
   1ef20:	3301      	adds	r3, #1
   1ef22:	54bb      	strb	r3, [r7, r2]
   1ef24:	23b3      	movs	r3, #179	; 0xb3
   1ef26:	009b      	lsls	r3, r3, #2
   1ef28:	18fc      	adds	r4, r7, r3
	}
}

void ScanningModule::updateTotalRssiAndTotalMessagesForDevice(i8 rssi, uint8_t* address)
{
	for (int i = 0; i < addressPointer; i++)
   1ef2a:	3b31      	subs	r3, #49	; 0x31
   1ef2c:	3bff      	subs	r3, #255	; 0xff
   1ef2e:	5cfd      	ldrb	r5, [r7, r3]
   1ef30:	3b97      	subs	r3, #151	; 0x97
   1ef32:	3bff      	subs	r3, #255	; 0xff
   1ef34:	435d      	muls	r5, r3
   1ef36:	359e      	adds	r5, #158	; 0x9e
   1ef38:	35ff      	adds	r5, #255	; 0xff
   1ef3a:	197d      	adds	r5, r7, r5
   1ef3c:	9b00      	ldr	r3, [sp, #0]
   1ef3e:	42ab      	cmp	r3, r5
   1ef40:	d100      	bne.n	1ef44 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x314>
   1ef42:	e6e5      	b.n	1ed10 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0xe0>
	{
		if (memcmp(&(addresses[i]), address, BLE_GAP_ADDR_LEN) == 0)
   1ef44:	9800      	ldr	r0, [sp, #0]
   1ef46:	9904      	ldr	r1, [sp, #16]
   1ef48:	2206      	movs	r2, #6
   1ef4a:	f002 fb54 	bl	215f6 <memcmp>
   1ef4e:	2800      	cmp	r0, #0
   1ef50:	d108      	bne.n	1ef64 <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x334>
		{
			totalRSSIsPerAddress[i] += (u32) (-rssi);
   1ef52:	6823      	ldr	r3, [r4, #0]
   1ef54:	9a06      	ldr	r2, [sp, #24]
   1ef56:	1a9b      	subs	r3, r3, r2
   1ef58:	1c22      	adds	r2, r4, #0
   1ef5a:	6023      	str	r3, [r4, #0]
   1ef5c:	32c8      	adds	r2, #200	; 0xc8
			totalMessagesPerAdress[i]++;
   1ef5e:	6813      	ldr	r3, [r2, #0]
   1ef60:	3301      	adds	r3, #1
   1ef62:	6013      	str	r3, [r2, #0]
   1ef64:	9b00      	ldr	r3, [sp, #0]
   1ef66:	3404      	adds	r4, #4
   1ef68:	3306      	adds	r3, #6
   1ef6a:	9300      	str	r3, [sp, #0]
   1ef6c:	e7e6      	b.n	1ef3c <_ZN14ScanningModule15BleEventHandlerEP9ble_evt_t+0x30c>
   1ef6e:	46c0      	nop			; (mov r8, r8)
   1ef70:	0000024d 	.word	0x0000024d
   1ef74:	200033d8 	.word	0x200033d8
   1ef78:	0000045c 	.word	0x0000045c
					}
				}
			}
		}
	}
}
   1ef7c:	b00f      	add	sp, #60	; 0x3c
   1ef7e:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001ef80 <sd_ble_gap_address_get.lto_priv.64>:
 * @param[out] p_addr Pointer to address structure to be filled in.
 *
 * @retval ::NRF_SUCCESS Address successfully retrieved.
 * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
 */
SVCALL(SD_BLE_GAP_ADDRESS_GET, uint32_t, sd_ble_gap_address_get(ble_gap_addr_t *p_addr));
   1ef80:	df71      	svc	113	; 0x71
   1ef82:	4770      	bx	lr

0001ef84 <sd_flash_page_erase>:
* @retval ::NRF_ERROR_INVALID_ADDR  Tried to erase to a non existing flash page.
* @retval ::NRF_ERROR_BUSY          The previous command has not yet completed.
* @retval ::NRF_ERROR_FORBIDDEN     Tried to erase a protected page.
* @retval ::NRF_SUCCESS             The command was accepted.
*/
SVCALL(SD_FLASH_PAGE_ERASE, uint32_t, sd_flash_page_erase(uint32_t page_number));
   1ef84:	df28      	svc	40	; 0x28
   1ef86:	4770      	bx	lr

0001ef88 <sd_flash_write>:
* @retval ::NRF_ERROR_BUSY           The previous command has not yet completed.
* @retval ::NRF_ERROR_INVALID_LENGTH Size was 0, or higher than the maximum allowed size.
* @retval ::NRF_ERROR_FORBIDDEN      Tried to write to or read from protected location.
* @retval ::NRF_SUCCESS              The command was accepted.
*/
SVCALL(SD_FLASH_WRITE, uint32_t, sd_flash_write(uint32_t * const p_dst, uint32_t const * const p_src, uint32_t size));
   1ef88:	df29      	svc	41	; 0x29
   1ef8a:	4770      	bx	lr

0001ef8c <sd_rand_application_vector_get>:
 * @param[in]   length  Number of bytes to take from pool and place in p_buff.
 *
 * @retval ::NRF_SUCCESS The requested bytes were written to p_buff.
 * @retval ::NRF_ERROR_SOC_RAND_NOT_ENOUGH_VALUES No bytes were written to the buffer, because there were not enough bytes available.
*/
SVCALL(SD_RAND_APPLICATION_VECTOR_GET, uint32_t, sd_rand_application_vector_get(uint8_t * p_buff, uint8_t length));
   1ef8c:	df3a      	svc	58	; 0x3a
   1ef8e:	4770      	bx	lr

0001ef90 <cmd_queue_enqueue.constprop.51>:
 * @param[in] offset         Offset within the flash memory block at which operation is requested.
 *
 * @retval    NRF_SUCCESS      Upon success.
 * @retval    NRF_ERROR_NO_MEM Upon failure, when no space is available in the command queue. 
 */
static uint32_t cmd_queue_enqueue(uint8_t             opcode,
   1ef90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
                                  pstorage_size_t     size,
                                  pstorage_size_t     offset)
{
    uint32_t err_code;

    if (m_cmd_queue.count != PSTORAGE_CMD_QUEUE_SIZE)
   1ef92:	4d10      	ldr	r5, [pc, #64]	; (1efd4 <cmd_queue_enqueue.constprop.51+0x44>)
        
        err_code = NRF_SUCCESS;        
    }
    else
    {
        err_code = NRF_ERROR_NO_MEM;
   1ef94:	2404      	movs	r4, #4
                                  pstorage_size_t     size,
                                  pstorage_size_t     offset)
{
    uint32_t err_code;

    if (m_cmd_queue.count != PSTORAGE_CMD_QUEUE_SIZE)
   1ef96:	786e      	ldrb	r6, [r5, #1]
   1ef98:	2e0a      	cmp	r6, #10
   1ef9a:	d019      	beq.n	1efd0 <cmd_queue_enqueue.constprop.51+0x40>
    {
        // Enqueue the command if it the queue is not full.
        uint32_t write_index = m_cmd_queue.rp + m_cmd_queue.count;
   1ef9c:	782c      	ldrb	r4, [r5, #0]
   1ef9e:	19a4      	adds	r4, r4, r6

        if (write_index >= PSTORAGE_CMD_QUEUE_SIZE) 
   1efa0:	2c09      	cmp	r4, #9
   1efa2:	dd00      	ble.n	1efa6 <cmd_queue_enqueue.constprop.51+0x16>
        {
            write_index -= PSTORAGE_CMD_QUEUE_SIZE;
   1efa4:	3c0a      	subs	r4, #10
        }

        m_cmd_queue.cmd[write_index].op_code      = opcode;
   1efa6:	2714      	movs	r7, #20
   1efa8:	437c      	muls	r4, r7
   1efaa:	192c      	adds	r4, r5, r4
        m_cmd_queue.cmd[write_index].p_data_addr  = p_data_addr;
   1efac:	6162      	str	r2, [r4, #20]
        m_cmd_queue.cmd[write_index].storage_addr = (*p_storage_addr);
   1efae:	1c22      	adds	r2, r4, #0
        if (write_index >= PSTORAGE_CMD_QUEUE_SIZE) 
        {
            write_index -= PSTORAGE_CMD_QUEUE_SIZE;
        }

        m_cmd_queue.cmd[write_index].op_code      = opcode;
   1efb0:	7120      	strb	r0, [r4, #4]
        m_cmd_queue.cmd[write_index].p_data_addr  = p_data_addr;
        m_cmd_queue.cmd[write_index].storage_addr = (*p_storage_addr);
   1efb2:	320c      	adds	r2, #12
   1efb4:	c981      	ldmia	r1!, {r0, r7}
   1efb6:	c281      	stmia	r2!, {r0, r7}
        m_cmd_queue.cmd[write_index].size         = size;
   1efb8:	80e3      	strh	r3, [r4, #6]
        m_cmd_queue.cmd[write_index].offset       = offset;
   1efba:	2300      	movs	r3, #0
               
        m_cmd_queue.count++;
                                
        if (m_state == STATE_IDLE)
   1efbc:	4a06      	ldr	r2, [pc, #24]	; (1efd8 <cmd_queue_enqueue.constprop.51+0x48>)
        m_cmd_queue.cmd[write_index].p_data_addr  = p_data_addr;
        m_cmd_queue.cmd[write_index].storage_addr = (*p_storage_addr);
        m_cmd_queue.cmd[write_index].size         = size;
        m_cmd_queue.cmd[write_index].offset       = offset;
               
        m_cmd_queue.count++;
   1efbe:	3601      	adds	r6, #1
                                
        if (m_state == STATE_IDLE)
   1efc0:	7812      	ldrb	r2, [r2, #0]

        m_cmd_queue.cmd[write_index].op_code      = opcode;
        m_cmd_queue.cmd[write_index].p_data_addr  = p_data_addr;
        m_cmd_queue.cmd[write_index].storage_addr = (*p_storage_addr);
        m_cmd_queue.cmd[write_index].size         = size;
        m_cmd_queue.cmd[write_index].offset       = offset;
   1efc2:	8123      	strh	r3, [r4, #8]
               
        m_cmd_queue.count++;
   1efc4:	706e      	strb	r6, [r5, #1]
        if (m_state == STATE_IDLE)
        {
            cmd_process(); 
        }            
        
        err_code = NRF_SUCCESS;        
   1efc6:	1c1c      	adds	r4, r3, #0
        m_cmd_queue.cmd[write_index].size         = size;
        m_cmd_queue.cmd[write_index].offset       = offset;
               
        m_cmd_queue.count++;
                                
        if (m_state == STATE_IDLE)
   1efc8:	429a      	cmp	r2, r3
   1efca:	d101      	bne.n	1efd0 <cmd_queue_enqueue.constprop.51+0x40>
        {
            cmd_process(); 
   1efcc:	f7fd fc98 	bl	1c900 <cmd_process.lto_priv.62>
    {
        err_code = NRF_ERROR_NO_MEM;
    }

    return err_code;
}
   1efd0:	1c20      	adds	r0, r4, #0
   1efd2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1efd4:	200033e0 	.word	0x200033e0
   1efd8:	2000357e 	.word	0x2000357e

0001efdc <_ZN11SimpleQueue11DiscardNextEv>:
}



void SimpleQueue::DiscardNext(void)
{
   1efdc:	b573      	push	{r0, r1, r4, r5, r6, lr}
	//If queue has been fully read, return empty data
	if(_numElements == 0){
   1efde:	8a85      	ldrh	r5, [r0, #20]
   1efe0:	2d00      	cmp	r5, #0
   1efe2:	d01a      	beq.n	1f01a <_ZN11SimpleQueue11DiscardNextEv+0x3e>
		return;
	}

	//Check if we reached the end and wrap
	u32 size;
	memcpy(&size, readPointer, 4);
   1efe4:	68c6      	ldr	r6, [r0, #12]
   1efe6:	1c04      	adds	r4, r0, #0
   1efe8:	1c31      	adds	r1, r6, #0
   1efea:	a801      	add	r0, sp, #4
   1efec:	2204      	movs	r2, #4
   1efee:	f002 fb11 	bl	21614 <memcpy>
	if(size == 0 && writePointer < readPointer) readPointer = bufferStart;
   1eff2:	9b01      	ldr	r3, [sp, #4]
   1eff4:	2b00      	cmp	r3, #0
   1eff6:	d104      	bne.n	1f002 <_ZN11SimpleQueue11DiscardNextEv+0x26>
   1eff8:	6923      	ldr	r3, [r4, #16]
   1effa:	42b3      	cmp	r3, r6
   1effc:	d201      	bcs.n	1f002 <_ZN11SimpleQueue11DiscardNextEv+0x26>
   1effe:	6823      	ldr	r3, [r4, #0]
   1f000:	60e3      	str	r3, [r4, #12]


	memcpy(&size, readPointer, 4);
   1f002:	68e6      	ldr	r6, [r4, #12]
   1f004:	a801      	add	r0, sp, #4
   1f006:	1c31      	adds	r1, r6, #0
   1f008:	2204      	movs	r2, #4
   1f00a:	f002 fb03 	bl	21614 <memcpy>
	this->readPointer += size + 4;
   1f00e:	9b01      	ldr	r3, [sp, #4]

	_numElements--;
   1f010:	3d01      	subs	r5, #1
	memcpy(&size, readPointer, 4);
	if(size == 0 && writePointer < readPointer) readPointer = bufferStart;


	memcpy(&size, readPointer, 4);
	this->readPointer += size + 4;
   1f012:	1d19      	adds	r1, r3, #4
   1f014:	1871      	adds	r1, r6, r1
   1f016:	60e1      	str	r1, [r4, #12]

	_numElements--;
   1f018:	82a5      	strh	r5, [r4, #20]
}
   1f01a:	bd73      	pop	{r0, r1, r4, r5, r6, pc}

0001f01c <_ZN11SimpleQueue8PeekNextEv>:
}



sizedData SimpleQueue::PeekNext(void)
{
   1f01c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   sizedData data;
	//If queue has been fully read, return empty data
	if(_numElements == 0){
   1f01e:	8a8b      	ldrh	r3, [r1, #20]
}



sizedData SimpleQueue::PeekNext(void)
{
   1f020:	1c05      	adds	r5, r0, #0
   1f022:	1c0e      	adds	r6, r1, #0
   sizedData data;
	//If queue has been fully read, return empty data
	if(_numElements == 0){
   1f024:	2b00      	cmp	r3, #0
   1f026:	d101      	bne.n	1f02c <_ZN11SimpleQueue8PeekNextEv+0x10>
		data.length = 0;
   1f028:	8083      	strh	r3, [r0, #4]
   1f02a:	e013      	b.n	1f054 <_ZN11SimpleQueue8PeekNextEv+0x38>
		return data;
	}

	//Check if we reached the end and wrap
	u32 size;
	memcpy(&size, readPointer, 4);
   1f02c:	68cc      	ldr	r4, [r1, #12]
   1f02e:	a801      	add	r0, sp, #4
   1f030:	1c21      	adds	r1, r4, #0
   1f032:	2204      	movs	r2, #4
   1f034:	f002 faee 	bl	21614 <memcpy>
	if(size == 0 && writePointer < readPointer){
   1f038:	9b01      	ldr	r3, [sp, #4]
   1f03a:	1d28      	adds	r0, r5, #4
   1f03c:	2b00      	cmp	r3, #0
   1f03e:	d103      	bne.n	1f048 <_ZN11SimpleQueue8PeekNextEv+0x2c>
   1f040:	6933      	ldr	r3, [r6, #16]
   1f042:	42a3      	cmp	r3, r4
   1f044:	d200      	bcs.n	1f048 <_ZN11SimpleQueue8PeekNextEv+0x2c>
		memcpy(&data.length, bufferStart, 4);
   1f046:	6834      	ldr	r4, [r6, #0]

		return data;
	}
	else
	{
		memcpy(&data.length, readPointer, 4);
   1f048:	1c21      	adds	r1, r4, #0
   1f04a:	2204      	movs	r2, #4
		data.data = this->readPointer + 4;
   1f04c:	3404      	adds	r4, #4

		return data;
	}
	else
	{
		memcpy(&data.length, readPointer, 4);
   1f04e:	f002 fae1 	bl	21614 <memcpy>
		data.data = this->readPointer + 4;
   1f052:	602c      	str	r4, [r5, #0]

		return data;
	}

}
   1f054:	1c28      	adds	r0, r5, #0
   1f056:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

0001f058 <_ZN21AdvertisingController21UpdateAdvertisingDataEhP9sizedDatab.constprop.16>:
void AdvertisingController::SetNonConnectable()
{
	currentAdvertisingParams.type = BLE_GAP_ADV_TYPE_ADV_NONCONN_IND;
}

u32 AdvertisingController::UpdateAdvertisingData(u8 messageType, sizedData* payload, bool connectable)
   1f058:	b570      	push	{r4, r5, r6, lr}
   1f05a:	4b1d      	ldr	r3, [pc, #116]	; (1f0d0 <_ZN21AdvertisingController21UpdateAdvertisingDataEhP9sizedDatab.constprop.16+0x78>)
   1f05c:	1c06      	adds	r6, r0, #0
{
	u32 err = NRF_SUCCESS;

	//Check if we  are switching to connectable / non-connectable
	bool mustRestartAdvertising = false;
	if (connectable && currentAdvertisingParams.type != BLE_GAP_ADV_TYPE_ADV_IND)
   1f05e:	781a      	ldrb	r2, [r3, #0]
   1f060:	2900      	cmp	r1, #0
   1f062:	d005      	beq.n	1f070 <_ZN21AdvertisingController21UpdateAdvertisingDataEhP9sizedDatab.constprop.16+0x18>
   1f064:	2400      	movs	r4, #0
   1f066:	42a2      	cmp	r2, r4
   1f068:	d008      	beq.n	1f07c <_ZN21AdvertisingController21UpdateAdvertisingDataEhP9sizedDatab.constprop.16+0x24>
	{

		logt("ADV", "Switching to connectable Advertising");
		currentAdvertisingParams.type = BLE_GAP_ADV_TYPE_ADV_IND;
   1f06a:	701c      	strb	r4, [r3, #0]
		mustRestartAdvertising = true;
   1f06c:	3401      	adds	r4, #1
   1f06e:	e005      	b.n	1f07c <_ZN21AdvertisingController21UpdateAdvertisingDataEhP9sizedDatab.constprop.16+0x24>
u32 AdvertisingController::UpdateAdvertisingData(u8 messageType, sizedData* payload, bool connectable)
{
	u32 err = NRF_SUCCESS;

	//Check if we  are switching to connectable / non-connectable
	bool mustRestartAdvertising = false;
   1f070:	1c0c      	adds	r4, r1, #0

		logt("ADV", "Switching to connectable Advertising");
		currentAdvertisingParams.type = BLE_GAP_ADV_TYPE_ADV_IND;
		mustRestartAdvertising = true;
	}
	else if (!connectable && currentAdvertisingParams.type != BLE_GAP_ADV_TYPE_ADV_SCAN_IND)
   1f072:	2a02      	cmp	r2, #2
   1f074:	d002      	beq.n	1f07c <_ZN21AdvertisingController21UpdateAdvertisingDataEhP9sizedDatab.constprop.16+0x24>
	{
		logt("ADV", "Switching to non-connectable Advertising");
		currentAdvertisingParams.type = BLE_GAP_ADV_TYPE_ADV_SCAN_IND;
   1f076:	2202      	movs	r2, #2
		mustRestartAdvertising = true;
   1f078:	2401      	movs	r4, #1
		mustRestartAdvertising = true;
	}
	else if (!connectable && currentAdvertisingParams.type != BLE_GAP_ADV_TYPE_ADV_SCAN_IND)
	{
		logt("ADV", "Switching to non-connectable Advertising");
		currentAdvertisingParams.type = BLE_GAP_ADV_TYPE_ADV_SCAN_IND;
   1f07a:	701a      	strb	r2, [r3, #0]
	}

	currentAdvertisementPacketLength = SIZEOF_ADV_PACKET_HEADER + payload->length;

	//Set the data payload
	header->messageType = messageType;
   1f07c:	2501      	movs	r5, #1
		logt("ADV", "Switching to non-connectable Advertising");
		currentAdvertisingParams.type = BLE_GAP_ADV_TYPE_ADV_SCAN_IND;
		mustRestartAdvertising = true;
	}

	currentAdvertisementPacketLength = SIZEOF_ADV_PACKET_HEADER + payload->length;
   1f07e:	88b3      	ldrh	r3, [r6, #4]
   1f080:	4a14      	ldr	r2, [pc, #80]	; (1f0d4 <_ZN21AdvertisingController21UpdateAdvertisingDataEhP9sizedDatab.constprop.16+0x7c>)
   1f082:	330b      	adds	r3, #11
   1f084:	7013      	strb	r3, [r2, #0]

	//Set the data payload
	header->messageType = messageType;
   1f086:	4b14      	ldr	r3, [pc, #80]	; (1f0d8 <_ZN21AdvertisingController21UpdateAdvertisingDataEhP9sizedDatab.constprop.16+0x80>)
   1f088:	6818      	ldr	r0, [r3, #0]
   1f08a:	7285      	strb	r5, [r0, #10]
	header->manufacturer.len = payload->length + SIZEOF_ADV_PACKET_STUFF_AFTER_MANUFACTURER;
   1f08c:	88b3      	ldrh	r3, [r6, #4]
   1f08e:	3307      	adds	r3, #7
   1f090:	70c3      	strb	r3, [r0, #3]
	memcpy((u8*) header + SIZEOF_ADV_PACKET_HEADER, payload->data, payload->length);
   1f092:	88b2      	ldrh	r2, [r6, #4]
   1f094:	6831      	ldr	r1, [r6, #0]
   1f096:	300b      	adds	r0, #11
   1f098:	f002 fabc 	bl	21614 <memcpy>

	err = sd_ble_gap_adv_data_set(currentAdvertisementPacket, SIZEOF_ADV_PACKET_HEADER + payload->length, NULL, 0);
   1f09c:	2200      	movs	r2, #0
   1f09e:	88b1      	ldrh	r1, [r6, #4]
   1f0a0:	480e      	ldr	r0, [pc, #56]	; (1f0dc <_ZN21AdvertisingController21UpdateAdvertisingDataEhP9sizedDatab.constprop.16+0x84>)
   1f0a2:	310b      	adds	r1, #11
   1f0a4:	b2c9      	uxtb	r1, r1
   1f0a6:	1c13      	adds	r3, r2, #0
   1f0a8:	f7fe f8b6 	bl	1d218 <sd_ble_gap_adv_data_set.lto_priv.63>
	if(err != NRF_SUCCESS){
   1f0ac:	2800      	cmp	r0, #0
   1f0ae:	d003      	beq.n	1f0b8 <_ZN21AdvertisingController21UpdateAdvertisingDataEhP9sizedDatab.constprop.16+0x60>
		advertisingPacketAwaitingUpdate = true;
   1f0b0:	4b0b      	ldr	r3, [pc, #44]	; (1f0e0 <_ZN21AdvertisingController21UpdateAdvertisingDataEhP9sizedDatab.constprop.16+0x88>)
   1f0b2:	701d      	strb	r5, [r3, #0]
   1f0b4:	1c05      	adds	r5, r0, #0
   1f0b6:	e009      	b.n	1f0cc <_ZN21AdvertisingController21UpdateAdvertisingDataEhP9sizedDatab.constprop.16+0x74>
		advState backup = advertisingState;
		SetAdvertisingState(ADV_STATE_OFF);
		SetAdvertisingState(backup);
	}

	return NRF_SUCCESS;
   1f0b8:	1c05      	adds	r5, r0, #0
		advertisingPacketAwaitingUpdate = true;
		return err;
	}

	//Now we check if we need to restart advertising
	if (mustRestartAdvertising)
   1f0ba:	2c00      	cmp	r4, #0
   1f0bc:	d006      	beq.n	1f0cc <_ZN21AdvertisingController21UpdateAdvertisingDataEhP9sizedDatab.constprop.16+0x74>
	{
		advState backup = advertisingState;
   1f0be:	4b09      	ldr	r3, [pc, #36]	; (1f0e4 <_ZN21AdvertisingController21UpdateAdvertisingDataEhP9sizedDatab.constprop.16+0x8c>)
   1f0c0:	881c      	ldrh	r4, [r3, #0]
		SetAdvertisingState(ADV_STATE_OFF);
   1f0c2:	f7fe f8ab 	bl	1d21c <_ZN21AdvertisingController19SetAdvertisingStateE8advState>
		SetAdvertisingState(backup);
   1f0c6:	1c20      	adds	r0, r4, #0
   1f0c8:	f7fe f8a8 	bl	1d21c <_ZN21AdvertisingController19SetAdvertisingStateE8advState>
	}

	return NRF_SUCCESS;
}
   1f0cc:	1c28      	adds	r0, r5, #0
   1f0ce:	bd70      	pop	{r4, r5, r6, pc}
   1f0d0:	20003524 	.word	0x20003524
   1f0d4:	2000357c 	.word	0x2000357c
   1f0d8:	20003580 	.word	0x20003580
   1f0dc:	20003540 	.word	0x20003540
   1f0e0:	200033dc 	.word	0x200033dc
   1f0e4:	20003588 	.word	0x20003588

0001f0e8 <_ZN11SimpleQueue3PutEPhm.constprop.15>:

}

//IF READ AND WRITE ARE EQUAL, THE QUEUE IS EMPTY

bool SimpleQueue::Put(u8* data, u32 dataLength)
   1f0e8:	2310      	movs	r3, #16
   1f0ea:	b537      	push	{r0, r1, r2, r4, r5, lr}
	//Keep two byte for sizeField and one byte to not let read and write pointers overlap
	u32 elementSize = dataLength + 4 + 1;
	
	//If the writePointer is ahead (or at the same point) of the read pointer && bufferSpace
	//at the end is not enough && dataSize at the beginning is enough
	if(writePointer >= readPointer && (u32)(bufferEnd - writePointer) <= elementSize && (u32)(readPointer - bufferStart) >= elementSize){
   1f0ec:	6902      	ldr	r2, [r0, #16]
   1f0ee:	9301      	str	r3, [sp, #4]
   1f0f0:	68c3      	ldr	r3, [r0, #12]

}

//IF READ AND WRITE ARE EQUAL, THE QUEUE IS EMPTY

bool SimpleQueue::Put(u8* data, u32 dataLength)
   1f0f2:	1c04      	adds	r4, r0, #0
   1f0f4:	1c0d      	adds	r5, r1, #0
	//Keep two byte for sizeField and one byte to not let read and write pointers overlap
	u32 elementSize = dataLength + 4 + 1;
	
	//If the writePointer is ahead (or at the same point) of the read pointer && bufferSpace
	//at the end is not enough && dataSize at the beginning is enough
	if(writePointer >= readPointer && (u32)(bufferEnd - writePointer) <= elementSize && (u32)(readPointer - bufferStart) >= elementSize){
   1f0f6:	429a      	cmp	r2, r3
   1f0f8:	d30d      	bcc.n	1f116 <_ZN11SimpleQueue3PutEPhm.constprop.15+0x2e>
   1f0fa:	6841      	ldr	r1, [r0, #4]
   1f0fc:	1a89      	subs	r1, r1, r2
   1f0fe:	2915      	cmp	r1, #21
   1f100:	d809      	bhi.n	1f116 <_ZN11SimpleQueue3PutEPhm.constprop.15+0x2e>
   1f102:	6800      	ldr	r0, [r0, #0]
   1f104:	1a19      	subs	r1, r3, r0
   1f106:	2914      	cmp	r1, #20
   1f108:	d905      	bls.n	1f116 <_ZN11SimpleQueue3PutEPhm.constprop.15+0x2e>
		writePointer = bufferStart;
   1f10a:	6120      	str	r0, [r4, #16]
		memset(writePointer, 0, 4);
   1f10c:	2100      	movs	r1, #0
   1f10e:	2204      	movs	r2, #4
   1f110:	f002 fa9d 	bl	2164e <memset>
   1f114:	e007      	b.n	1f126 <_ZN11SimpleQueue3PutEPhm.constprop.15+0x3e>
   1f116:	1c11      	adds	r1, r2, #0
	}
	
	//Check if Buffer can hold the item
	else if(readPointer <= writePointer && writePointer + elementSize >= bufferEnd){

	    return false;
   1f118:	2000      	movs	r0, #0
   1f11a:	3115      	adds	r1, #21
		writePointer = bufferStart;
		memset(writePointer, 0, 4);
	}
	
	//Check if Buffer can hold the item
	else if(readPointer <= writePointer && writePointer + elementSize >= bufferEnd){
   1f11c:	4293      	cmp	r3, r2
   1f11e:	d800      	bhi.n	1f122 <_ZN11SimpleQueue3PutEPhm.constprop.15+0x3a>
   1f120:	6863      	ldr	r3, [r4, #4]

	    return false;
	}
	else if(readPointer > writePointer && writePointer + elementSize >= readPointer){
   1f122:	428b      	cmp	r3, r1
   1f124:	d915      	bls.n	1f152 <_ZN11SimpleQueue3PutEPhm.constprop.15+0x6a>
	    return false;
	}
	
	memcpy(writePointer, &dataLength, 4);
   1f126:	a901      	add	r1, sp, #4
   1f128:	2204      	movs	r2, #4
   1f12a:	6920      	ldr	r0, [r4, #16]
   1f12c:	f002 fa72 	bl	21614 <memcpy>
	memcpy(writePointer + 4, data, dataLength);
   1f130:	6923      	ldr	r3, [r4, #16]
   1f132:	1c29      	adds	r1, r5, #0
   1f134:	1d18      	adds	r0, r3, #4
   1f136:	2210      	movs	r2, #16
   1f138:	f002 fa6c 	bl	21614 <memcpy>
	
	writePointer += dataLength + 4; //+two for size field
   1f13c:	6920      	ldr	r0, [r4, #16]
	//Set length to 0 for next datafield
	memset(writePointer, 0, 4);
   1f13e:	2100      	movs	r1, #0
	}
	
	memcpy(writePointer, &dataLength, 4);
	memcpy(writePointer + 4, data, dataLength);
	
	writePointer += dataLength + 4; //+two for size field
   1f140:	3014      	adds	r0, #20
   1f142:	6120      	str	r0, [r4, #16]
	//Set length to 0 for next datafield
	memset(writePointer, 0, 4);
   1f144:	2204      	movs	r2, #4
   1f146:	f002 fa82 	bl	2164e <memset>
	
	_numElements++;

	return true;
   1f14a:	2001      	movs	r0, #1
	
	writePointer += dataLength + 4; //+two for size field
	//Set length to 0 for next datafield
	memset(writePointer, 0, 4);
	
	_numElements++;
   1f14c:	8aa3      	ldrh	r3, [r4, #20]
   1f14e:	3301      	adds	r3, #1
   1f150:	82a3      	strh	r3, [r4, #20]

	return true;
}
   1f152:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

0001f154 <_ZN17ConnectionManager27GetConnectionToShortestSinkEP10Connection.constprop.11>:
void ConnectionManager::setConnectionManagerCallback(ConnectionManagerCallback* cb)
{
	connectionManagerCallback = cb;
}

Connection* ConnectionManager::GetConnectionToShortestSink(Connection* excludeConnection)
   1f154:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
{
	clusterSIZE min = INT16_MAX;
	Connection* c = NULL;
	for(int i=0; i<Config->meshMaxConnections; i++){
   1f156:	2400      	movs	r4, #0
void ConnectionManager::setConnectionManagerCallback(ConnectionManagerCallback* cb)
{
	connectionManagerCallback = cb;
}

Connection* ConnectionManager::GetConnectionToShortestSink(Connection* excludeConnection)
   1f158:	1c07      	adds	r7, r0, #0
{
	clusterSIZE min = INT16_MAX;
	Connection* c = NULL;
   1f15a:	1c25      	adds	r5, r4, #0
	connectionManagerCallback = cb;
}

Connection* ConnectionManager::GetConnectionToShortestSink(Connection* excludeConnection)
{
	clusterSIZE min = INT16_MAX;
   1f15c:	4e0d      	ldr	r6, [pc, #52]	; (1f194 <_ZN17ConnectionManager27GetConnectionToShortestSinkEP10Connection.constprop.11+0x40>)
	Connection* c = NULL;
	for(int i=0; i<Config->meshMaxConnections; i++){
   1f15e:	f001 fe63 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1f162:	3035      	adds	r0, #53	; 0x35
   1f164:	7803      	ldrb	r3, [r0, #0]
   1f166:	429c      	cmp	r4, r3
   1f168:	da11      	bge.n	1f18e <_ZN17ConnectionManager27GetConnectionToShortestSinkEP10Connection.constprop.11+0x3a>
   1f16a:	00a3      	lsls	r3, r4, #2
   1f16c:	18fb      	adds	r3, r7, r3
		if(excludeConnection != NULL && connections[i] == excludeConnection) continue;
		if(connections[i]->handshakeDone() && connections[i]->hopsToSink > -1 && connections[i]->hopsToSink < min){
   1f16e:	6a1b      	ldr	r3, [r3, #32]
   1f170:	7a1a      	ldrb	r2, [r3, #8]
   1f172:	2a03      	cmp	r2, #3
   1f174:	d909      	bls.n	1f18a <_ZN17ConnectionManager27GetConnectionToShortestSinkEP10Connection.constprop.11+0x36>
   1f176:	4a08      	ldr	r2, [pc, #32]	; (1f198 <_ZN17ConnectionManager27GetConnectionToShortestSinkEP10Connection.constprop.11+0x44>)
   1f178:	5a9a      	ldrh	r2, [r3, r2]
   1f17a:	b211      	sxth	r1, r2
   1f17c:	2900      	cmp	r1, #0
   1f17e:	db04      	blt.n	1f18a <_ZN17ConnectionManager27GetConnectionToShortestSinkEP10Connection.constprop.11+0x36>
   1f180:	b230      	sxth	r0, r6
   1f182:	4281      	cmp	r1, r0
   1f184:	da01      	bge.n	1f18a <_ZN17ConnectionManager27GetConnectionToShortestSinkEP10Connection.constprop.11+0x36>
   1f186:	1c1d      	adds	r5, r3, #0
   1f188:	1c16      	adds	r6, r2, #0

Connection* ConnectionManager::GetConnectionToShortestSink(Connection* excludeConnection)
{
	clusterSIZE min = INT16_MAX;
	Connection* c = NULL;
	for(int i=0; i<Config->meshMaxConnections; i++){
   1f18a:	3401      	adds	r4, #1
   1f18c:	e7e7      	b.n	1f15e <_ZN17ConnectionManager27GetConnectionToShortestSinkEP10Connection.constprop.11+0xa>
			min = connections[i]->hopsToSink;
			c = connections[i];
		}
	}
	return c;
}
   1f18e:	1c28      	adds	r0, r5, #0
   1f190:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1f192:	46c0      	nop			; (mov r8, r8)
   1f194:	00007fff 	.word	0x00007fff
   1f198:	00000212 	.word	0x00000212

0001f19c <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10>:

	fillTransmitBuffers();
}

//Checks the receiver of the message first and routes it in the right direction
void ConnectionManager::SendMessageToReceiver(Connection* originConnection, u8* data, u16 dataLength, bool reliable)
   1f19c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1f19e:	1c1f      	adds	r7, r3, #0
	connPacketHeader* packetHeader = (connPacketHeader*) data;

	//This packet was only meant for us, sth. like a packet to localhost
	//Or if we sent this as a broadcast, we want to handle it ourself as well
	if(
			packetHeader->receiver == node->persistentConfig.nodeId
   1f1a0:	790b      	ldrb	r3, [r1, #4]

	fillTransmitBuffers();
}

//Checks the receiver of the message first and routes it in the right direction
void ConnectionManager::SendMessageToReceiver(Connection* originConnection, u8* data, u16 dataLength, bool reliable)
   1f1a2:	1c05      	adds	r5, r0, #0
   1f1a4:	1c16      	adds	r6, r2, #0
	connPacketHeader* packetHeader = (connPacketHeader*) data;

	//This packet was only meant for us, sth. like a packet to localhost
	//Or if we sent this as a broadcast, we want to handle it ourself as well
	if(
			packetHeader->receiver == node->persistentConfig.nodeId
   1f1a6:	6840      	ldr	r0, [r0, #4]
   1f1a8:	78ca      	ldrb	r2, [r1, #3]
   1f1aa:	021b      	lsls	r3, r3, #8
   1f1ac:	4313      	orrs	r3, r2
{
	connPacketHeader* packetHeader = (connPacketHeader*) data;

	//This packet was only meant for us, sth. like a packet to localhost
	//Or if we sent this as a broadcast, we want to handle it ourself as well
	if(
   1f1ae:	8cc2      	ldrh	r2, [r0, #38]	; 0x26

	fillTransmitBuffers();
}

//Checks the receiver of the message first and routes it in the right direction
void ConnectionManager::SendMessageToReceiver(Connection* originConnection, u8* data, u16 dataLength, bool reliable)
   1f1b0:	b087      	sub	sp, #28
   1f1b2:	1c0c      	adds	r4, r1, #0
{
	connPacketHeader* packetHeader = (connPacketHeader*) data;

	//This packet was only meant for us, sth. like a packet to localhost
	//Or if we sent this as a broadcast, we want to handle it ourself as well
	if(
   1f1b4:	429a      	cmp	r2, r3
   1f1b6:	d001      	beq.n	1f1bc <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10+0x20>
			packetHeader->receiver == node->persistentConfig.nodeId
			|| (originConnection == NULL && packetHeader->receiver == NODE_ID_BROADCAST)
   1f1b8:	2b00      	cmp	r3, #0
   1f1ba:	d108      	bne.n	1f1ce <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10+0x32>
	)
	{
		connectionPacket packet;
		packet.connectionHandle = 0; //Not needed
   1f1bc:	2300      	movs	r3, #0
   1f1be:	a903      	add	r1, sp, #12
   1f1c0:	800b      	strh	r3, [r1, #0]
		packet.data = data;
		packet.dataLength = dataLength;
		packet.reliable = reliable;

		//Send directly to our message handler in the node for processing
		node->messageReceivedCallback(&packet);
   1f1c2:	6803      	ldr	r3, [r0, #0]
			|| (originConnection == NULL && packetHeader->receiver == NODE_ID_BROADCAST)
	)
	{
		connectionPacket packet;
		packet.connectionHandle = 0; //Not needed
		packet.data = data;
   1f1c4:	604c      	str	r4, [r1, #4]
		packet.dataLength = dataLength;
   1f1c6:	810e      	strh	r6, [r1, #8]
		packet.reliable = reliable;
   1f1c8:	708f      	strb	r7, [r1, #2]

		//Send directly to our message handler in the node for processing
		node->messageReceivedCallback(&packet);
   1f1ca:	699b      	ldr	r3, [r3, #24]
   1f1cc:	4798      	blx	r3
	}


	//Packets to the shortest sink
	if(packetHeader->receiver == NODE_ID_SHORTEST_SINK)
   1f1ce:	7923      	ldrb	r3, [r4, #4]
   1f1d0:	78e2      	ldrb	r2, [r4, #3]
   1f1d2:	021b      	lsls	r3, r3, #8
   1f1d4:	4313      	orrs	r3, r2
   1f1d6:	4a11      	ldr	r2, [pc, #68]	; (1f21c <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10+0x80>)
   1f1d8:	4293      	cmp	r3, r2
   1f1da:	d111      	bne.n	1f200 <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10+0x64>
	{
		Connection* dest = GetConnectionToShortestSink(NULL);
   1f1dc:	1c28      	adds	r0, r5, #0
   1f1de:	f7ff ffb9 	bl	1f154 <_ZN17ConnectionManager27GetConnectionToShortestSinkEP10Connection.constprop.11>
   1f1e2:	1e01      	subs	r1, r0, #0

		//Packets are currently only delivered if a sink is known
		if(dest) SendMessage(dest, data, dataLength, reliable);
   1f1e4:	d017      	beq.n	1f216 <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10+0x7a>


//Send message to a single connection (Will not send packet if connection has not finished handshake)
bool ConnectionManager::SendMessage(Connection* connection, u8* data, u16 dataLength, bool reliable)
{
	if(connection->handshakeDone()){
   1f1e6:	7a03      	ldrb	r3, [r0, #8]
   1f1e8:	2b03      	cmp	r3, #3
   1f1ea:	d914      	bls.n	1f216 <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10+0x7a>
		QueuePacket(connection, data, dataLength, reliable);
   1f1ec:	1c28      	adds	r0, r5, #0
   1f1ee:	9700      	str	r7, [sp, #0]
   1f1f0:	1c22      	adds	r2, r4, #0
   1f1f2:	1c33      	adds	r3, r6, #0
   1f1f4:	f7fe fd2d 	bl	1dc52 <_ZN17ConnectionManager11QueuePacketEP10ConnectionPhtb>

		fillTransmitBuffers();
   1f1f8:	1c28      	adds	r0, r5, #0
   1f1fa:	f000 fd75 	bl	1fce8 <_ZN17ConnectionManager19fillTransmitBuffersEv>
   1f1fe:	e00a      	b.n	1f216 <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10+0x7a>

		//Packets are currently only delivered if a sink is known
		if(dest) SendMessage(dest, data, dataLength, reliable);
	}
	//All other packets will be broadcasted, but we could and should check if the receiver is connected to us
	else if(packetHeader->receiver != node->persistentConfig.nodeId)
   1f200:	686a      	ldr	r2, [r5, #4]
   1f202:	8cd2      	ldrh	r2, [r2, #38]	; 0x26
   1f204:	429a      	cmp	r2, r3
   1f206:	d006      	beq.n	1f216 <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10+0x7a>
	{
		SendMessageOverConnections(originConnection, data, dataLength, reliable);
   1f208:	9700      	str	r7, [sp, #0]
   1f20a:	1c28      	adds	r0, r5, #0
   1f20c:	2100      	movs	r1, #0
   1f20e:	1c22      	adds	r2, r4, #0
   1f210:	1c33      	adds	r3, r6, #0
   1f212:	f7fe fd6a 	bl	1dcea <_ZN17ConnectionManager26SendMessageOverConnectionsEP10ConnectionPhtb>
	}
}
   1f216:	b007      	add	sp, #28
   1f218:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f21a:	46c0      	nop			; (mov r8, r8)
   1f21c:	00007919 	.word	0x00007919

0001f220 <_ZN17ConnectionManager20SendHandshakeMessageEP10ConnectionPhtb.constprop.7>:
	GATTController::setDataTransmittedCallback(dataTransmittedCallback);

}

//This method queues a packet no matter if the connection is currently in handshaking or not
bool ConnectionManager::SendHandshakeMessage(Connection* connection, u8* data, u16 dataLength, bool reliable)
   1f220:	b537      	push	{r0, r1, r2, r4, r5, lr}
{
	if(connection->isConnected()){
   1f222:	7a0d      	ldrb	r5, [r1, #8]

		fillTransmitBuffers();

		return true;
	} else {
		return false;
   1f224:	2400      	movs	r4, #0
}

//This method queues a packet no matter if the connection is currently in handshaking or not
bool ConnectionManager::SendHandshakeMessage(Connection* connection, u8* data, u16 dataLength, bool reliable)
{
	if(connection->isConnected()){
   1f226:	2d01      	cmp	r5, #1
   1f228:	d907      	bls.n	1f23a <_ZN17ConnectionManager20SendHandshakeMessageEP10ConnectionPhtb.constprop.7+0x1a>
   1f22a:	1c05      	adds	r5, r0, #0
		QueuePacket(connection, data, dataLength, reliable);
   1f22c:	3401      	adds	r4, #1
   1f22e:	9400      	str	r4, [sp, #0]
   1f230:	f7fe fd0f 	bl	1dc52 <_ZN17ConnectionManager11QueuePacketEP10ConnectionPhtb>

		fillTransmitBuffers();
   1f234:	1c28      	adds	r0, r5, #0
   1f236:	f000 fd57 	bl	1fce8 <_ZN17ConnectionManager19fillTransmitBuffersEv>

		return true;
	} else {
		return false;
	}
}
   1f23a:	1c20      	adds	r0, r4, #0
   1f23c:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

0001f23e <_ZN20StatusReporterModule10SendStatusEth.constprop.3>:
	}
}


//This method sends the node's status over the network
void StatusReporterModule::SendStatus(nodeID toNode, u8 messageType)
   1f23e:	b570      	push	{r4, r5, r6, lr}
{
	u16 packetSize = SIZEOF_CONN_PACKET_MODULE + SIZEOF_STATUS_REPORTER_MODULE_STATUS_MESSAGE;
		u8 buffer[packetSize];
		connPacketModule* outPacket = (connPacketModule*)buffer;
		outPacket->header.messageType = messageType;
   1f240:	2501      	movs	r5, #1
   1f242:	2468      	movs	r4, #104	; 0x68
	}
}


//This method sends the node's status over the network
void StatusReporterModule::SendStatus(nodeID toNode, u8 messageType)
   1f244:	b086      	sub	sp, #24
{
	u16 packetSize = SIZEOF_CONN_PACKET_MODULE + SIZEOF_STATUS_REPORTER_MODULE_STATUS_MESSAGE;
		u8 buffer[packetSize];
		connPacketModule* outPacket = (connPacketModule*)buffer;
		outPacket->header.messageType = messageType;
   1f246:	ab01      	add	r3, sp, #4
   1f248:	781a      	ldrb	r2, [r3, #0]
   1f24a:	402a      	ands	r2, r5
   1f24c:	4322      	orrs	r2, r4
   1f24e:	701a      	strb	r2, [r3, #0]
		outPacket->header.receiver = toNode;
   1f250:	466a      	mov	r2, sp
   1f252:	71d1      	strb	r1, [r2, #7]
   1f254:	0a09      	lsrs	r1, r1, #8
   1f256:	7211      	strb	r1, [r2, #8]
		outPacket->header.sender = node->persistentConfig.nodeId;
   1f258:	4669      	mov	r1, sp
   1f25a:	6882      	ldr	r2, [r0, #8]
   1f25c:	1dd4      	adds	r4, r2, #7
   1f25e:	7fe4      	ldrb	r4, [r4, #31]
   1f260:	714c      	strb	r4, [r1, #5]
   1f262:	1c14      	adds	r4, r2, #0
   1f264:	3408      	adds	r4, #8
   1f266:	7fe4      	ldrb	r4, [r4, #31]
   1f268:	718c      	strb	r4, [r1, #6]
		outPacket->moduleId = moduleId;
   1f26a:	7c01      	ldrb	r1, [r0, #16]
		outPacket->actionType = StatusModuleActionResponseMessages::STATUS;
   1f26c:	71dd      	strb	r5, [r3, #7]
		u8 buffer[packetSize];
		connPacketModule* outPacket = (connPacketModule*)buffer;
		outPacket->header.messageType = messageType;
		outPacket->header.receiver = toNode;
		outPacket->header.sender = node->persistentConfig.nodeId;
		outPacket->moduleId = moduleId;
   1f26e:	7159      	strb	r1, [r3, #5]
		outPacket->actionType = StatusModuleActionResponseMessages::STATUS;

		StatusReporterModuleStatusMessage* outPacketData = (StatusReporterModuleStatusMessage*)(outPacket->data);

		outPacketData->clusterSize = node->clusterSize;
   1f270:	1c11      	adds	r1, r2, #0
   1f272:	3178      	adds	r1, #120	; 0x78
   1f274:	8809      	ldrh	r1, [r1, #0]
		outPacketData->connectionLossCounter = node->persistentConfig.connectionLossCounter; //TODO: connectionlosscounter is random at the moment
		outPacketData->freeIn = cm->freeInConnections;
   1f276:	68c0      	ldr	r0, [r0, #12]
		outPacket->moduleId = moduleId;
		outPacket->actionType = StatusModuleActionResponseMessages::STATUS;

		StatusReporterModuleStatusMessage* outPacketData = (StatusReporterModuleStatusMessage*)(outPacket->data);

		outPacketData->clusterSize = node->clusterSize;
   1f278:	8119      	strh	r1, [r3, #8]
		outPacketData->connectionLossCounter = node->persistentConfig.connectionLossCounter; //TODO: connectionlosscounter is random at the moment
   1f27a:	8f11      	ldrh	r1, [r2, #56]	; 0x38
		outPacketData->freeIn = cm->freeInConnections;
		outPacketData->freeOut = cm->freeOutConnections;
		outPacketData->inConnectionPartner = cm->inConnection->partnerId;
		outPacketData->inConnectionRSSI = cm->inConnection->rssiAverage;
		outPacketData->initializedByGateway = node->initializedByGateway;
   1f27c:	3285      	adds	r2, #133	; 0x85
		outPacket->actionType = StatusModuleActionResponseMessages::STATUS;

		StatusReporterModuleStatusMessage* outPacketData = (StatusReporterModuleStatusMessage*)(outPacket->data);

		outPacketData->clusterSize = node->clusterSize;
		outPacketData->connectionLossCounter = node->persistentConfig.connectionLossCounter; //TODO: connectionlosscounter is random at the moment
   1f27e:	73d9      	strb	r1, [r3, #15]
		outPacketData->freeIn = cm->freeInConnections;
   1f280:	2103      	movs	r1, #3
   1f282:	7b44      	ldrb	r4, [r0, #13]
   1f284:	400c      	ands	r4, r1
   1f286:	1c26      	adds	r6, r4, #0
   1f288:	7b5c      	ldrb	r4, [r3, #13]
   1f28a:	438c      	bics	r4, r1
   1f28c:	4334      	orrs	r4, r6
   1f28e:	735c      	strb	r4, [r3, #13]
		outPacketData->freeOut = cm->freeOutConnections;
   1f290:	7b84      	ldrb	r4, [r0, #14]
   1f292:	7b5e      	ldrb	r6, [r3, #13]
   1f294:	00a4      	lsls	r4, r4, #2
   1f296:	4031      	ands	r1, r6
   1f298:	4321      	orrs	r1, r4
		outPacketData->inConnectionPartner = cm->inConnection->partnerId;
   1f29a:	24e8      	movs	r4, #232	; 0xe8
		StatusReporterModuleStatusMessage* outPacketData = (StatusReporterModuleStatusMessage*)(outPacket->data);

		outPacketData->clusterSize = node->clusterSize;
		outPacketData->connectionLossCounter = node->persistentConfig.connectionLossCounter; //TODO: connectionlosscounter is random at the moment
		outPacketData->freeIn = cm->freeInConnections;
		outPacketData->freeOut = cm->freeOutConnections;
   1f29c:	7359      	strb	r1, [r3, #13]
		outPacketData->inConnectionPartner = cm->inConnection->partnerId;
   1f29e:	6901      	ldr	r1, [r0, #16]
   1f2a0:	0064      	lsls	r4, r4, #1
   1f2a2:	5b0c      	ldrh	r4, [r1, r4]
   1f2a4:	815c      	strh	r4, [r3, #10]
		outPacketData->inConnectionRSSI = cm->inConnection->rssiAverage;
   1f2a6:	7c89      	ldrb	r1, [r1, #18]
   1f2a8:	7319      	strb	r1, [r3, #12]
		outPacketData->initializedByGateway = node->initializedByGateway;
   1f2aa:	7812      	ldrb	r2, [r2, #0]
   1f2ac:	402a      	ands	r2, r5
   1f2ae:	1c11      	adds	r1, r2, #0
   1f2b0:	7c1a      	ldrb	r2, [r3, #16]
   1f2b2:	43aa      	bics	r2, r5
   1f2b4:	430a      	orrs	r2, r1
   1f2b6:	741a      	strb	r2, [r3, #16]

		cm->SendMessageToReceiver(NULL, buffer, SIZEOF_CONN_PACKET_MODULE + SIZEOF_STATUS_REPORTER_MODULE_STATUS_MESSAGE, false);
   1f2b8:	1c19      	adds	r1, r3, #0
   1f2ba:	2211      	movs	r2, #17
   1f2bc:	2300      	movs	r3, #0
   1f2be:	f7ff ff6d 	bl	1f19c <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10>
}
   1f2c2:	b006      	add	sp, #24
   1f2c4:	bd70      	pop	{r4, r5, r6, pc}
	...

0001f2c8 <_ZN20StatusReporterModule14SendDeviceInfoEth.constprop.2>:

//Message type can be either MESSAGE_TYPE_MODULE_ACTION_RESPONSE or MESSAGE_TYPE_MODULE_GENERAL
void StatusReporterModule::SendDeviceInfo(nodeID toNode, u8 messageType)
   1f2c8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1f2ca:	af00      	add	r7, sp, #0
{
	u32 err;

	u16 packetSize = SIZEOF_CONN_PACKET_MODULE + SIZEOF_STATUS_REPORTER_MODULE_DEVICE_INFO_MESSAGE;
	u8 buffer[packetSize];
   1f2cc:	b08a      	sub	sp, #40	; 0x28
   1f2ce:	466c      	mov	r4, sp
	connPacketModule* outPacket = (connPacketModule*)buffer;
	outPacket->header.messageType = messageType;
   1f2d0:	2301      	movs	r3, #1
   1f2d2:	7822      	ldrb	r2, [r4, #0]

		cm->SendMessageToReceiver(NULL, buffer, SIZEOF_CONN_PACKET_MODULE + SIZEOF_STATUS_REPORTER_MODULE_STATUS_MESSAGE, false);
}

//Message type can be either MESSAGE_TYPE_MODULE_ACTION_RESPONSE or MESSAGE_TYPE_MODULE_GENERAL
void StatusReporterModule::SendDeviceInfo(nodeID toNode, u8 messageType)
   1f2d4:	1c05      	adds	r5, r0, #0
	u32 err;

	u16 packetSize = SIZEOF_CONN_PACKET_MODULE + SIZEOF_STATUS_REPORTER_MODULE_DEVICE_INFO_MESSAGE;
	u8 buffer[packetSize];
	connPacketModule* outPacket = (connPacketModule*)buffer;
	outPacket->header.messageType = messageType;
   1f2d6:	4013      	ands	r3, r2
   1f2d8:	2268      	movs	r2, #104	; 0x68
   1f2da:	4313      	orrs	r3, r2
   1f2dc:	7023      	strb	r3, [r4, #0]
	outPacket->header.receiver = toNode;
   1f2de:	2303      	movs	r3, #3
   1f2e0:	446b      	add	r3, sp
   1f2e2:	7019      	strb	r1, [r3, #0]
   1f2e4:	0a09      	lsrs	r1, r1, #8
   1f2e6:	7059      	strb	r1, [r3, #1]
   1f2e8:	607b      	str	r3, [r7, #4]
	outPacket->header.sender = node->persistentConfig.nodeId;
   1f2ea:	3a67      	subs	r2, #103	; 0x67
   1f2ec:	6883      	ldr	r3, [r0, #8]
   1f2ee:	446a      	add	r2, sp
   1f2f0:	603a      	str	r2, [r7, #0]
   1f2f2:	1dda      	adds	r2, r3, #7
   1f2f4:	7fd2      	ldrb	r2, [r2, #31]
   1f2f6:	6839      	ldr	r1, [r7, #0]
   1f2f8:	3308      	adds	r3, #8
   1f2fa:	700a      	strb	r2, [r1, #0]
   1f2fc:	7fdb      	ldrb	r3, [r3, #31]
   1f2fe:	704b      	strb	r3, [r1, #1]
	outPacket->moduleId = moduleId;
   1f300:	7c03      	ldrb	r3, [r0, #16]
   1f302:	7163      	strb	r3, [r4, #5]
	outPacket->actionType = StatusModuleActionResponseMessages::DEVICE_INFO;
   1f304:	2302      	movs	r3, #2
   1f306:	71e3      	strb	r3, [r4, #7]

	StatusReporterModuleDeviceInfoMessage* outPacketData = (StatusReporterModuleDeviceInfoMessage*)(outPacket->data);

	outPacketData->manufacturerId = Config->manufacturerId;
   1f308:	f001 fd8e 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1f30c:	3054      	adds	r0, #84	; 0x54
   1f30e:	7803      	ldrb	r3, [r0, #0]
	outPacketData->deviceType = node->persistentConfig.deviceType;
	memcpy(outPacketData->chipId, (u8*)NRF_FICR->DEVICEADDR, 8);
   1f310:	4928      	ldr	r1, [pc, #160]	; (1f3b4 <_ZN20StatusReporterModule14SendDeviceInfoEth.constprop.2+0xec>)
	outPacket->moduleId = moduleId;
	outPacket->actionType = StatusModuleActionResponseMessages::DEVICE_INFO;

	StatusReporterModuleDeviceInfoMessage* outPacketData = (StatusReporterModuleDeviceInfoMessage*)(outPacket->data);

	outPacketData->manufacturerId = Config->manufacturerId;
   1f312:	7223      	strb	r3, [r4, #8]
   1f314:	7843      	ldrb	r3, [r0, #1]
	outPacketData->deviceType = node->persistentConfig.deviceType;
	memcpy(outPacketData->chipId, (u8*)NRF_FICR->DEVICEADDR, 8);
   1f316:	200f      	movs	r0, #15
	outPacket->moduleId = moduleId;
	outPacket->actionType = StatusModuleActionResponseMessages::DEVICE_INFO;

	StatusReporterModuleDeviceInfoMessage* outPacketData = (StatusReporterModuleDeviceInfoMessage*)(outPacket->data);

	outPacketData->manufacturerId = Config->manufacturerId;
   1f318:	7263      	strb	r3, [r4, #9]
	outPacketData->deviceType = node->persistentConfig.deviceType;
   1f31a:	68ab      	ldr	r3, [r5, #8]
	memcpy(outPacketData->chipId, (u8*)NRF_FICR->DEVICEADDR, 8);
   1f31c:	4468      	add	r0, sp
	outPacket->actionType = StatusModuleActionResponseMessages::DEVICE_INFO;

	StatusReporterModuleDeviceInfoMessage* outPacketData = (StatusReporterModuleDeviceInfoMessage*)(outPacket->data);

	outPacketData->manufacturerId = Config->manufacturerId;
	outPacketData->deviceType = node->persistentConfig.deviceType;
   1f31e:	333a      	adds	r3, #58	; 0x3a
   1f320:	781a      	ldrb	r2, [r3, #0]
   1f322:	466b      	mov	r3, sp
   1f324:	3307      	adds	r3, #7
   1f326:	77da      	strb	r2, [r3, #31]
	memcpy(outPacketData->chipId, (u8*)NRF_FICR->DEVICEADDR, 8);
   1f328:	2208      	movs	r2, #8
   1f32a:	f002 f973 	bl	21614 <memcpy>
	memcpy(outPacketData->serialNumber, Config->serialNumber, SERIAL_NUMBER_LENGTH);
   1f32e:	f001 fd7b 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1f332:	1c01      	adds	r1, r0, #0
   1f334:	200a      	movs	r0, #10
   1f336:	3148      	adds	r1, #72	; 0x48
   1f338:	2205      	movs	r2, #5
   1f33a:	4468      	add	r0, sp
   1f33c:	f002 f96a 	bl	21614 <memcpy>
	err = sd_ble_gap_address_get(&outPacketData->accessAddress);
   1f340:	2017      	movs	r0, #23
   1f342:	4468      	add	r0, sp
   1f344:	f7ff fe1c 	bl	1ef80 <sd_ble_gap_address_get.lto_priv.64>
   1f348:	1e06      	subs	r6, r0, #0
	APP_ERROR_CHECK(err); //OK
   1f34a:	d003      	beq.n	1f354 <_ZN20StatusReporterModule14SendDeviceInfoEth.constprop.2+0x8c>
   1f34c:	2197      	movs	r1, #151	; 0x97
   1f34e:	4a1a      	ldr	r2, [pc, #104]	; (1f3b8 <_ZN20StatusReporterModule14SendDeviceInfoEth.constprop.2+0xf0>)
   1f350:	f7fe f858 	bl	1d404 <app_error_handler>
	outPacketData->nodeVersion = Config->firmwareVersion;
   1f354:	f001 fd68 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1f358:	1c03      	adds	r3, r0, #0
   1f35a:	337c      	adds	r3, #124	; 0x7c
   1f35c:	781b      	ldrb	r3, [r3, #0]
   1f35e:	683a      	ldr	r2, [r7, #0]
   1f360:	77d3      	strb	r3, [r2, #31]
   1f362:	1c03      	adds	r3, r0, #0
   1f364:	337d      	adds	r3, #125	; 0x7d
   1f366:	781a      	ldrb	r2, [r3, #0]
   1f368:	466b      	mov	r3, sp
   1f36a:	3302      	adds	r3, #2
   1f36c:	77da      	strb	r2, [r3, #31]
   1f36e:	1c03      	adds	r3, r0, #0
   1f370:	337e      	adds	r3, #126	; 0x7e
   1f372:	781b      	ldrb	r3, [r3, #0]
   1f374:	687a      	ldr	r2, [r7, #4]
   1f376:	307f      	adds	r0, #127	; 0x7f
   1f378:	77d3      	strb	r3, [r2, #31]
   1f37a:	7802      	ldrb	r2, [r0, #0]
   1f37c:	ab01      	add	r3, sp, #4
   1f37e:	77da      	strb	r2, [r3, #31]
	outPacketData->networkId = node->persistentConfig.networkId;
   1f380:	68ab      	ldr	r3, [r5, #8]
	outPacketData->dBmRX = node->persistentConfig.dBmRX;
	outPacketData->dBmTX = node->persistentConfig.dBmTX;


	cm->SendMessageToReceiver(NULL, buffer, SIZEOF_CONN_PACKET_MODULE + SIZEOF_STATUS_REPORTER_MODULE_DEVICE_INFO_MESSAGE, false);
   1f382:	68e8      	ldr	r0, [r5, #12]
	memcpy(outPacketData->chipId, (u8*)NRF_FICR->DEVICEADDR, 8);
	memcpy(outPacketData->serialNumber, Config->serialNumber, SERIAL_NUMBER_LENGTH);
	err = sd_ble_gap_address_get(&outPacketData->accessAddress);
	APP_ERROR_CHECK(err); //OK
	outPacketData->nodeVersion = Config->firmwareVersion;
	outPacketData->networkId = node->persistentConfig.networkId;
   1f384:	1d5a      	adds	r2, r3, #5
   1f386:	7fd2      	ldrb	r2, [r2, #31]
   1f388:	77a2      	strb	r2, [r4, #30]
   1f38a:	1d9a      	adds	r2, r3, #6
   1f38c:	7fd2      	ldrb	r2, [r2, #31]
   1f38e:	77e2      	strb	r2, [r4, #31]
	outPacketData->dBmRX = node->persistentConfig.dBmRX;
   1f390:	1c1a      	adds	r2, r3, #0
   1f392:	323c      	adds	r2, #60	; 0x3c
   1f394:	7811      	ldrb	r1, [r2, #0]
   1f396:	466a      	mov	r2, sp
   1f398:	3205      	adds	r2, #5
   1f39a:	77d1      	strb	r1, [r2, #31]
	outPacketData->dBmTX = node->persistentConfig.dBmTX;
   1f39c:	333b      	adds	r3, #59	; 0x3b
   1f39e:	781a      	ldrb	r2, [r3, #0]
   1f3a0:	466b      	mov	r3, sp
   1f3a2:	3306      	adds	r3, #6
   1f3a4:	77da      	strb	r2, [r3, #31]


	cm->SendMessageToReceiver(NULL, buffer, SIZEOF_CONN_PACKET_MODULE + SIZEOF_STATUS_REPORTER_MODULE_DEVICE_INFO_MESSAGE, false);
   1f3a6:	4669      	mov	r1, sp
   1f3a8:	1c33      	adds	r3, r6, #0
   1f3aa:	2226      	movs	r2, #38	; 0x26
   1f3ac:	f7ff fef6 	bl	1f19c <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10>
}
   1f3b0:	46bd      	mov	sp, r7
   1f3b2:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   1f3b4:	100000a4 	.word	0x100000a4
   1f3b8:	00022a80 	.word	0x00022a80

0001f3bc <_ZN20StatusReporterModule15SendNearbyNodesEth.constprop.1>:

void StatusReporterModule::SendNearbyNodes(nodeID toNode, u8 messageType)
   1f3bc:	b5f0      	push	{r4, r5, r6, r7, lr}
   1f3be:	1c06      	adds	r6, r0, #0
   1f3c0:	363c      	adds	r6, #60	; 0x3c
   1f3c2:	1c32      	adds	r2, r6, #0
{
	u16 numMeasurements = 0;
   1f3c4:	2300      	movs	r3, #0


	cm->SendMessageToReceiver(NULL, buffer, SIZEOF_CONN_PACKET_MODULE + SIZEOF_STATUS_REPORTER_MODULE_DEVICE_INFO_MESSAGE, false);
}

void StatusReporterModule::SendNearbyNodes(nodeID toNode, u8 messageType)
   1f3c6:	b089      	sub	sp, #36	; 0x24
   1f3c8:	1c05      	adds	r5, r0, #0
   1f3ca:	af00      	add	r7, sp, #0
   1f3cc:	30dc      	adds	r0, #220	; 0xdc
{
	u16 numMeasurements = 0;
	for(int i=0; i<NUM_NODE_MEASUREMENTS; i++){
		if(nodeMeasurements[i].nodeId != 0) numMeasurements++;
   1f3ce:	8814      	ldrh	r4, [r2, #0]
   1f3d0:	2c00      	cmp	r4, #0
   1f3d2:	d001      	beq.n	1f3d8 <_ZN20StatusReporterModule15SendNearbyNodesEth.constprop.1+0x1c>
   1f3d4:	3301      	adds	r3, #1
   1f3d6:	b29b      	uxth	r3, r3
   1f3d8:	3208      	adds	r2, #8
}

void StatusReporterModule::SendNearbyNodes(nodeID toNode, u8 messageType)
{
	u16 numMeasurements = 0;
	for(int i=0; i<NUM_NODE_MEASUREMENTS; i++){
   1f3da:	4282      	cmp	r2, r0
   1f3dc:	d1f7      	bne.n	1f3ce <_ZN20StatusReporterModule15SendNearbyNodesEth.constprop.1+0x12>
		if(nodeMeasurements[i].nodeId != 0) numMeasurements++;
	}


	u16 packetSize = SIZEOF_CONN_PACKET_MODULE + numMeasurements * 3;
   1f3de:	2203      	movs	r2, #3
   1f3e0:	4353      	muls	r3, r2
   1f3e2:	3308      	adds	r3, #8
   1f3e4:	b29b      	uxth	r3, r3
   1f3e6:	60fb      	str	r3, [r7, #12]
	u8 buffer[packetSize];
   1f3e8:	3307      	adds	r3, #7
   1f3ea:	40d3      	lsrs	r3, r2
   1f3ec:	4093      	lsls	r3, r2
   1f3ee:	466a      	mov	r2, sp
   1f3f0:	1ad3      	subs	r3, r2, r3
   1f3f2:	469d      	mov	sp, r3
   1f3f4:	466c      	mov	r4, sp
	connPacketModule* outPacket = (connPacketModule*)buffer;
	outPacket->header.messageType = messageType;
   1f3f6:	2301      	movs	r3, #1
   1f3f8:	7822      	ldrb	r2, [r4, #0]
	outPacket->header.receiver = toNode;
   1f3fa:	70e1      	strb	r1, [r4, #3]


	u16 packetSize = SIZEOF_CONN_PACKET_MODULE + numMeasurements * 3;
	u8 buffer[packetSize];
	connPacketModule* outPacket = (connPacketModule*)buffer;
	outPacket->header.messageType = messageType;
   1f3fc:	4013      	ands	r3, r2
   1f3fe:	2268      	movs	r2, #104	; 0x68
   1f400:	4313      	orrs	r3, r2
   1f402:	7023      	strb	r3, [r4, #0]
	outPacket->header.receiver = toNode;
	outPacket->header.sender = node->persistentConfig.nodeId;
   1f404:	68ab      	ldr	r3, [r5, #8]

	u16 packetSize = SIZEOF_CONN_PACKET_MODULE + numMeasurements * 3;
	u8 buffer[packetSize];
	connPacketModule* outPacket = (connPacketModule*)buffer;
	outPacket->header.messageType = messageType;
	outPacket->header.receiver = toNode;
   1f406:	0a09      	lsrs	r1, r1, #8
   1f408:	7121      	strb	r1, [r4, #4]
	outPacket->header.sender = node->persistentConfig.nodeId;
   1f40a:	1dd9      	adds	r1, r3, #7
   1f40c:	7fc9      	ldrb	r1, [r1, #31]
   1f40e:	3308      	adds	r3, #8
   1f410:	7061      	strb	r1, [r4, #1]
   1f412:	7fdb      	ldrb	r3, [r3, #31]
   1f414:	70a3      	strb	r3, [r4, #2]
	outPacket->moduleId = moduleId;
   1f416:	7c2b      	ldrb	r3, [r5, #16]
   1f418:	7163      	strb	r3, [r4, #5]
	outPacket->actionType = StatusModuleActionResponseMessages::NEARBY_NODES;
   1f41a:	2304      	movs	r3, #4
   1f41c:	71e3      	strb	r3, [r4, #7]

	u16 j = 0;
   1f41e:	2300      	movs	r3, #0
   1f420:	613b      	str	r3, [r7, #16]
	for(int i=0; i<NUM_NODE_MEASUREMENTS; i++)
   1f422:	617b      	str	r3, [r7, #20]
	{
		if(nodeMeasurements[i].nodeId != 0){
   1f424:	8833      	ldrh	r3, [r6, #0]
   1f426:	2b00      	cmp	r3, #0
   1f428:	d021      	beq.n	1f46e <_ZN20StatusReporterModule15SendNearbyNodesEth.constprop.1+0xb2>
			nodeID sender = nodeMeasurements[i].nodeId;
   1f42a:	83fb      	strh	r3, [r7, #30]
			i8 rssi = (i8)(nodeMeasurements[i].rssiSum / nodeMeasurements[i].packetCount);
   1f42c:	697b      	ldr	r3, [r7, #20]
   1f42e:	88f1      	ldrh	r1, [r6, #6]
   1f430:	3307      	adds	r3, #7
   1f432:	00db      	lsls	r3, r3, #3
   1f434:	18eb      	adds	r3, r5, r3
   1f436:	8918      	ldrh	r0, [r3, #8]
   1f438:	88da      	ldrh	r2, [r3, #6]
   1f43a:	0400      	lsls	r0, r0, #16
   1f43c:	4310      	orrs	r0, r2
   1f43e:	f002 feab 	bl	22198 <__aeabi_idiv>
   1f442:	b2c3      	uxtb	r3, r0
   1f444:	607b      	str	r3, [r7, #4]

			memcpy(outPacket->data + j*3 + 0, &sender, 2);
   1f446:	2303      	movs	r3, #3
   1f448:	693a      	ldr	r2, [r7, #16]
   1f44a:	1c20      	adds	r0, r4, #0
   1f44c:	435a      	muls	r2, r3
   1f44e:	231e      	movs	r3, #30
   1f450:	3008      	adds	r0, #8
   1f452:	60ba      	str	r2, [r7, #8]
   1f454:	1880      	adds	r0, r0, r2
   1f456:	18f9      	adds	r1, r7, r3
   1f458:	2202      	movs	r2, #2
   1f45a:	f002 f8db 	bl	21614 <memcpy>
			memcpy(outPacket->data + j*3 + 2, &rssi, 1);
   1f45e:	68bb      	ldr	r3, [r7, #8]
   1f460:	793a      	ldrb	r2, [r7, #4]
   1f462:	330a      	adds	r3, #10
   1f464:	54e2      	strb	r2, [r4, r3]

			j++;
   1f466:	693b      	ldr	r3, [r7, #16]
   1f468:	3301      	adds	r3, #1
   1f46a:	b29b      	uxth	r3, r3
   1f46c:	613b      	str	r3, [r7, #16]
	outPacket->header.sender = node->persistentConfig.nodeId;
	outPacket->moduleId = moduleId;
	outPacket->actionType = StatusModuleActionResponseMessages::NEARBY_NODES;

	u16 j = 0;
	for(int i=0; i<NUM_NODE_MEASUREMENTS; i++)
   1f46e:	697b      	ldr	r3, [r7, #20]
   1f470:	3608      	adds	r6, #8
   1f472:	3301      	adds	r3, #1
   1f474:	617b      	str	r3, [r7, #20]
   1f476:	2b14      	cmp	r3, #20
   1f478:	d1d4      	bne.n	1f424 <_ZN20StatusReporterModule15SendNearbyNodesEth.constprop.1+0x68>
			j++;
		}
	}

	//Clear node measurements
	memset(nodeMeasurements, 0x00, sizeof(nodeMeasurements));
   1f47a:	1c28      	adds	r0, r5, #0
   1f47c:	2100      	movs	r1, #0
   1f47e:	22a0      	movs	r2, #160	; 0xa0
   1f480:	303c      	adds	r0, #60	; 0x3c
   1f482:	f002 f8e4 	bl	2164e <memset>

	cm->SendMessageToReceiver(NULL, buffer, packetSize, false);
   1f486:	68e8      	ldr	r0, [r5, #12]
   1f488:	1c21      	adds	r1, r4, #0
   1f48a:	68fa      	ldr	r2, [r7, #12]
   1f48c:	2300      	movs	r3, #0
   1f48e:	f7ff fe85 	bl	1f19c <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10>
}
   1f492:	46bd      	mov	sp, r7
   1f494:	b009      	add	sp, #36	; 0x24
   1f496:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001f498 <_ZN16EnrollmentModule22SendEnrollmentResponseEthhhPh.constprop.0>:
			}
		}
	}
}

void EnrollmentModule::SendEnrollmentResponse(nodeID receiver, u8 enrollmentMethod, u8 requestHandle, u8 result, u8* serialNumber)
   1f498:	b5f0      	push	{r4, r5, r6, r7, lr}
   1f49a:	b087      	sub	sp, #28
	//Inform the sender, that the enrollment was successful
	u8 buffer[SIZEOF_CONN_PACKET_MODULE + SIZEOF_ENROLLMENT_MODULE_SET_ENROLLMENT_RESPONSE];
	connPacketModule* packet = (connPacketModule*)buffer;
	EnrollmentModuleEnrollmentResponse* data = (EnrollmentModuleEnrollmentResponse*)packet->data;

	packet->header.messageType = MESSAGE_TYPE_MODULE_ACTION_RESPONSE;
   1f49c:	466b      	mov	r3, sp
   1f49e:	2501      	movs	r5, #1
			}
		}
	}
}

void EnrollmentModule::SendEnrollmentResponse(nodeID receiver, u8 enrollmentMethod, u8 requestHandle, u8 result, u8* serialNumber)
   1f4a0:	1c04      	adds	r4, r0, #0
	//Inform the sender, that the enrollment was successful
	u8 buffer[SIZEOF_CONN_PACKET_MODULE + SIZEOF_ENROLLMENT_MODULE_SET_ENROLLMENT_RESPONSE];
	connPacketModule* packet = (connPacketModule*)buffer;
	EnrollmentModuleEnrollmentResponse* data = (EnrollmentModuleEnrollmentResponse*)packet->data;

	packet->header.messageType = MESSAGE_TYPE_MODULE_ACTION_RESPONSE;
   1f4a2:	2068      	movs	r0, #104	; 0x68
   1f4a4:	781b      	ldrb	r3, [r3, #0]
   1f4a6:	402b      	ands	r3, r5
   1f4a8:	4303      	orrs	r3, r0
   1f4aa:	4668      	mov	r0, sp
   1f4ac:	7003      	strb	r3, [r0, #0]
	packet->header.sender = node->persistentConfig.nodeId;
   1f4ae:	466b      	mov	r3, sp
   1f4b0:	68a0      	ldr	r0, [r4, #8]
   1f4b2:	195e      	adds	r6, r3, r5
   1f4b4:	1dc3      	adds	r3, r0, #7
   1f4b6:	7fdf      	ldrb	r7, [r3, #31]
   1f4b8:	3008      	adds	r0, #8
   1f4ba:	7037      	strb	r7, [r6, #0]
   1f4bc:	7fc0      	ldrb	r0, [r0, #31]
   1f4be:	2300      	movs	r3, #0
   1f4c0:	7070      	strb	r0, [r6, #1]
	packet->header.receiver = receiver;
   1f4c2:	4668      	mov	r0, sp

	packet->moduleId = moduleId;
   1f4c4:	466e      	mov	r6, sp
	connPacketModule* packet = (connPacketModule*)buffer;
	EnrollmentModuleEnrollmentResponse* data = (EnrollmentModuleEnrollmentResponse*)packet->data;

	packet->header.messageType = MESSAGE_TYPE_MODULE_ACTION_RESPONSE;
	packet->header.sender = node->persistentConfig.nodeId;
	packet->header.receiver = receiver;
   1f4c6:	70c3      	strb	r3, [r0, #3]
   1f4c8:	7103      	strb	r3, [r0, #4]

	packet->moduleId = moduleId;
   1f4ca:	7c20      	ldrb	r0, [r4, #16]
	packet->actionType = EnrollmentModuleActionResponseMessages::ENROLLMENT_SUCCESSFUL;
   1f4cc:	71f3      	strb	r3, [r6, #7]
	packet->requestHandle = requestHandle;

	data->result = result;
   1f4ce:	7273      	strb	r3, [r6, #9]
	packet->header.sender = node->persistentConfig.nodeId;
	packet->header.receiver = receiver;

	packet->moduleId = moduleId;
	packet->actionType = EnrollmentModuleActionResponseMessages::ENROLLMENT_SUCCESSFUL;
	packet->requestHandle = requestHandle;
   1f4d0:	71b2      	strb	r2, [r6, #6]

	data->result = result;
	data->enrollmentMethod = enrollmentMethod;
   1f4d2:	7231      	strb	r1, [r6, #8]

	packet->header.messageType = MESSAGE_TYPE_MODULE_ACTION_RESPONSE;
	packet->header.sender = node->persistentConfig.nodeId;
	packet->header.receiver = receiver;

	packet->moduleId = moduleId;
   1f4d4:	7170      	strb	r0, [r6, #5]
	packet->actionType = EnrollmentModuleActionResponseMessages::ENROLLMENT_SUCCESSFUL;
	packet->requestHandle = requestHandle;

	data->result = result;
	data->enrollmentMethod = enrollmentMethod;
	memcpy(data->serialNumber, Config->serialNumber, SERIAL_NUMBER_LENGTH);
   1f4d6:	f001 fca7 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1f4da:	1c01      	adds	r1, r0, #0
   1f4dc:	200a      	movs	r0, #10
   1f4de:	3148      	adds	r1, #72	; 0x48
   1f4e0:	4468      	add	r0, sp
   1f4e2:	2205      	movs	r2, #5
   1f4e4:	f002 f896 	bl	21614 <memcpy>


	cm->SendMessageToReceiver(NULL, buffer, SIZEOF_CONN_PACKET_MODULE + SIZEOF_ENROLLMENT_MODULE_SET_ENROLLMENT_RESPONSE, true);
   1f4e8:	68e0      	ldr	r0, [r4, #12]
   1f4ea:	4669      	mov	r1, sp
   1f4ec:	2217      	movs	r2, #23
   1f4ee:	1c2b      	adds	r3, r5, #0
   1f4f0:	f7ff fe54 	bl	1f19c <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10>

}
   1f4f4:	b007      	add	sp, #28
   1f4f6:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001f4f8 <_ZN11PacketQueue11DiscardNextEv>:
	return data;
}

void PacketQueue::DiscardNext()
{
	if(_numElements < 1) return;
   1f4f8:	8a82      	ldrh	r2, [r0, #20]
   1f4fa:	2a00      	cmp	r2, #0
   1f4fc:	d006      	beq.n	1f50c <_ZN11PacketQueue11DiscardNextEv+0x14>
	this->readPointer += (this->readPointer[0]+1);
   1f4fe:	68c1      	ldr	r1, [r0, #12]
	_numElements--;
   1f500:	3a01      	subs	r2, #1
}

void PacketQueue::DiscardNext()
{
	if(_numElements < 1) return;
	this->readPointer += (this->readPointer[0]+1);
   1f502:	780b      	ldrb	r3, [r1, #0]
	_numElements--;
   1f504:	8282      	strh	r2, [r0, #20]
}

void PacketQueue::DiscardNext()
{
	if(_numElements < 1) return;
	this->readPointer += (this->readPointer[0]+1);
   1f506:	3301      	adds	r3, #1
   1f508:	18cb      	adds	r3, r1, r3
   1f50a:	60c3      	str	r3, [r0, #12]
	_numElements--;
}
   1f50c:	4770      	bx	lr
	...

0001f510 <_ZN7Storage12ProcessQueueEv>:
	ProcessQueue();
}*/

void Storage::ProcessQueue()
{
	if(bufferedOperationInProgress || taskQueue->_numElements < 1){
   1f510:	1c03      	adds	r3, r0, #0

	ProcessQueue();
}*/

void Storage::ProcessQueue()
{
   1f512:	b5f0      	push	{r4, r5, r6, r7, lr}
	if(bufferedOperationInProgress || taskQueue->_numElements < 1){
   1f514:	33ff      	adds	r3, #255	; 0xff
   1f516:	785a      	ldrb	r2, [r3, #1]

	ProcessQueue();
}*/

void Storage::ProcessQueue()
{
   1f518:	b089      	sub	sp, #36	; 0x24
	if(bufferedOperationInProgress || taskQueue->_numElements < 1){
   1f51a:	2a00      	cmp	r2, #0
   1f51c:	d000      	beq.n	1f520 <_ZN7Storage12ProcessQueueEv+0x10>
   1f51e:	e09e      	b.n	1f65e <_ZN7Storage12ProcessQueueEv+0x14e>
   1f520:	1c02      	adds	r2, r0, #0
   1f522:	32a4      	adds	r2, #164	; 0xa4
   1f524:	6811      	ldr	r1, [r2, #0]
   1f526:	8a8a      	ldrh	r2, [r1, #20]
   1f528:	2a00      	cmp	r2, #0
   1f52a:	d100      	bne.n	1f52e <_ZN7Storage12ProcessQueueEv+0x1e>
   1f52c:	e097      	b.n	1f65e <_ZN7Storage12ProcessQueueEv+0x14e>
		return;
	} else {
		bufferedOperationInProgress = true;
   1f52e:	2201      	movs	r2, #1
   1f530:	9003      	str	r0, [sp, #12]
   1f532:	705a      	strb	r2, [r3, #1]
	}

	//Get one item from the queue and execute it
	sizedData data = taskQueue->PeekNext();
   1f534:	a806      	add	r0, sp, #24
   1f536:	f7ff fd71 	bl	1f01c <_ZN11SimpleQueue8PeekNextEv>
	taskitem* task = (taskitem*)data.data;
   1f53a:	9b06      	ldr	r3, [sp, #24]

	if(task->operation == operation::OPERATION_READ) BufferedRead(task->data, task->storageBlock, task->dataLength);
   1f53c:	881a      	ldrh	r2, [r3, #0]
   1f53e:	2a00      	cmp	r2, #0
   1f540:	d13f      	bne.n	1f5c2 <_ZN7Storage12ProcessQueueEv+0xb2>
   1f542:	685a      	ldr	r2, [r3, #4]
   1f544:	689e      	ldr	r6, [r3, #8]
   1f546:	9204      	str	r2, [sp, #16]
   1f548:	885d      	ldrh	r5, [r3, #2]
uint32_t pstorage_load(uint8_t           * p_dest,
                       pstorage_handle_t * p_src,
                       pstorage_size_t     size,
                       pstorage_size_t     offset)
{
    VERIFY_MODULE_INITIALIZED();
   1f54a:	4b46      	ldr	r3, [pc, #280]	; (1f664 <_ZN7Storage12ProcessQueueEv+0x154>)
   1f54c:	681b      	ldr	r3, [r3, #0]
   1f54e:	075b      	lsls	r3, r3, #29
   1f550:	d400      	bmi.n	1f554 <_ZN7Storage12ProcessQueueEv+0x44>
   1f552:	e084      	b.n	1f65e <_ZN7Storage12ProcessQueueEv+0x14e>
    NULL_PARAM_CHECK(p_src);
    NULL_PARAM_CHECK(p_dest);
   1f554:	2e00      	cmp	r6, #0
   1f556:	d100      	bne.n	1f55a <_ZN7Storage12ProcessQueueEv+0x4a>
   1f558:	e081      	b.n	1f65e <_ZN7Storage12ProcessQueueEv+0x14e>
   1f55a:	00d3      	lsls	r3, r2, #3
   1f55c:	9a03      	ldr	r2, [sp, #12]
   1f55e:	18d3      	adds	r3, r2, r3
    MODULE_ID_RANGE_CHECK(p_src);
   1f560:	1c1f      	adds	r7, r3, #0
   1f562:	37b0      	adds	r7, #176	; 0xb0
   1f564:	683a      	ldr	r2, [r7, #0]
   1f566:	2a00      	cmp	r2, #0
   1f568:	d000      	beq.n	1f56c <_ZN7Storage12ProcessQueueEv+0x5c>
   1f56a:	e078      	b.n	1f65e <_ZN7Storage12ProcessQueueEv+0x14e>
   1f56c:	4c3e      	ldr	r4, [pc, #248]	; (1f668 <_ZN7Storage12ProcessQueueEv+0x158>)
   1f56e:	6822      	ldr	r2, [r4, #0]
   1f570:	2a00      	cmp	r2, #0
   1f572:	d074      	beq.n	1f65e <_ZN7Storage12ProcessQueueEv+0x14e>
    BLOCK_ID_RANGE_CHECK(p_src);
   1f574:	33b4      	adds	r3, #180	; 0xb4
   1f576:	6819      	ldr	r1, [r3, #0]
   1f578:	8962      	ldrh	r2, [r4, #10]
   1f57a:	8923      	ldrh	r3, [r4, #8]
   1f57c:	6860      	ldr	r0, [r4, #4]
   1f57e:	435a      	muls	r2, r3
   1f580:	1812      	adds	r2, r2, r0
   1f582:	4291      	cmp	r1, r2
   1f584:	d26b      	bcs.n	1f65e <_ZN7Storage12ProcessQueueEv+0x14e>
    SIZE_CHECK(p_src, size);
   1f586:	2d00      	cmp	r5, #0
   1f588:	d069      	beq.n	1f65e <_ZN7Storage12ProcessQueueEv+0x14e>
   1f58a:	429d      	cmp	r5, r3
   1f58c:	d867      	bhi.n	1f65e <_ZN7Storage12ProcessQueueEv+0x14e>
    OFFSET_CHECK(p_src, offset, size);
   1f58e:	dc66      	bgt.n	1f65e <_ZN7Storage12ProcessQueueEv+0x14e>
   1f590:	1c32      	adds	r2, r6, #0
   1f592:	2303      	movs	r3, #3
   1f594:	430a      	orrs	r2, r1
   1f596:	401a      	ands	r2, r3
   1f598:	9205      	str	r2, [sp, #20]

    if ((!is_word_aligned(p_dest))                   || 
        (!is_word_aligned((void *)(uint32_t)offset)) || 
   1f59a:	d160      	bne.n	1f65e <_ZN7Storage12ProcessQueueEv+0x14e>
        (!is_word_aligned((uint32_t *)p_src->block_id)))
    {
        return NRF_ERROR_INVALID_ADDR;
    }

    memcpy(p_dest, (((uint8_t *)p_src->block_id) + offset), size);
   1f59c:	1c2a      	adds	r2, r5, #0
   1f59e:	1c30      	adds	r0, r6, #0
   1f5a0:	f002 f838 	bl	21614 <memcpy>

    m_app_table[p_src->module_id].cb(p_src, PSTORAGE_LOAD_OP_CODE, NRF_SUCCESS, p_dest, size);
   1f5a4:	230c      	movs	r3, #12
   1f5a6:	683a      	ldr	r2, [r7, #0]
//This involves problems when the data buffer has a different size
bool Storage::BufferedRead(u8* data, u32 block, u32 len)
{
	//logt("STORAGE", "Reading len:%u from block:%u", len, block);

	pstorage_load(data, &block_handles[block], len, 0);
   1f5a8:	9804      	ldr	r0, [sp, #16]
   1f5aa:	4353      	muls	r3, r2
   1f5ac:	3016      	adds	r0, #22
   1f5ae:	9a03      	ldr	r2, [sp, #12]
   1f5b0:	9500      	str	r5, [sp, #0]
   1f5b2:	00c0      	lsls	r0, r0, #3
   1f5b4:	1810      	adds	r0, r2, r0
   1f5b6:	58e4      	ldr	r4, [r4, r3]
   1f5b8:	2102      	movs	r1, #2
   1f5ba:	9a05      	ldr	r2, [sp, #20]
   1f5bc:	1c33      	adds	r3, r6, #0
   1f5be:	47a0      	blx	r4
   1f5c0:	e04d      	b.n	1f65e <_ZN7Storage12ProcessQueueEv+0x14e>
	//Get one item from the queue and execute it
	sizedData data = taskQueue->PeekNext();
	taskitem* task = (taskitem*)data.data;

	if(task->operation == operation::OPERATION_READ) BufferedRead(task->data, task->storageBlock, task->dataLength);
	else if(task->operation == operation::OPERATION_WRITE) BufferedWrite(task->data, task->storageBlock, task->dataLength);
   1f5c2:	2a01      	cmp	r2, #1
   1f5c4:	d14b      	bne.n	1f65e <_ZN7Storage12ProcessQueueEv+0x14e>
   1f5c6:	6859      	ldr	r1, [r3, #4]
   1f5c8:	689a      	ldr	r2, [r3, #8]
   1f5ca:	9104      	str	r1, [sp, #16]
}

bool Storage::BufferedWrite(u8* data, u32 block,u32 len)
{
	//Must be a multiple of 4 bytes and must be aligned
	if(len % 4 != 0 || (u32)data % 4 != 0){
   1f5cc:	8859      	ldrh	r1, [r3, #2]
   1f5ce:	2303      	movs	r3, #3
   1f5d0:	4219      	tst	r1, r3
   1f5d2:	d144      	bne.n	1f65e <_ZN7Storage12ProcessQueueEv+0x14e>
   1f5d4:	421a      	tst	r2, r3
   1f5d6:	d142      	bne.n	1f65e <_ZN7Storage12ProcessQueueEv+0x14e>
}


uint32_t pstorage_clear(pstorage_handle_t * p_dest, pstorage_size_t size)
{
    VERIFY_MODULE_INITIALIZED();
   1f5d8:	4b22      	ldr	r3, [pc, #136]	; (1f664 <_ZN7Storage12ProcessQueueEv+0x154>)
   1f5da:	2408      	movs	r4, #8
   1f5dc:	681b      	ldr	r3, [r3, #0]
   1f5de:	075b      	lsls	r3, r3, #29
   1f5e0:	d538      	bpl.n	1f654 <_ZN7Storage12ProcessQueueEv+0x144>
   1f5e2:	9b04      	ldr	r3, [sp, #16]
   1f5e4:	9a03      	ldr	r2, [sp, #12]
   1f5e6:	00db      	lsls	r3, r3, #3
   1f5e8:	18d3      	adds	r3, r2, r3
    NULL_PARAM_CHECK(p_dest);
    MODULE_ID_RANGE_CHECK(p_dest);
   1f5ea:	1c1a      	adds	r2, r3, #0
   1f5ec:	32b0      	adds	r2, #176	; 0xb0
   1f5ee:	6812      	ldr	r2, [r2, #0]
   1f5f0:	3c01      	subs	r4, #1
   1f5f2:	2a00      	cmp	r2, #0
   1f5f4:	d12e      	bne.n	1f654 <_ZN7Storage12ProcessQueueEv+0x144>
   1f5f6:	4a1c      	ldr	r2, [pc, #112]	; (1f668 <_ZN7Storage12ProcessQueueEv+0x158>)
   1f5f8:	6811      	ldr	r1, [r2, #0]
   1f5fa:	2900      	cmp	r1, #0
   1f5fc:	d02a      	beq.n	1f654 <_ZN7Storage12ProcessQueueEv+0x144>
    BLOCK_ID_RANGE_CHECK(p_dest);
   1f5fe:	33b4      	adds	r3, #180	; 0xb4
   1f600:	8916      	ldrh	r6, [r2, #8]
   1f602:	681d      	ldr	r5, [r3, #0]
   1f604:	8953      	ldrh	r3, [r2, #10]
   1f606:	6850      	ldr	r0, [r2, #4]
   1f608:	4373      	muls	r3, r6
   1f60a:	181b      	adds	r3, r3, r0
   1f60c:	9305      	str	r3, [sp, #20]
   1f60e:	429d      	cmp	r5, r3
   1f610:	d220      	bcs.n	1f654 <_ZN7Storage12ProcessQueueEv+0x144>
 *
 * @return      TRUE if pointer is aligned to a 4 byte boundary, FALSE otherwise.
 */
static __INLINE bool is_word_aligned(void const* p)
{
    return (((uintptr_t)p & 0x03) == 0);
   1f612:	2703      	movs	r7, #3

    if ((!is_word_aligned((uint32_t *)p_dest->block_id)))
    {
        return NRF_ERROR_INVALID_ADDR;
   1f614:	3409      	adds	r4, #9
    VERIFY_MODULE_INITIALIZED();
    NULL_PARAM_CHECK(p_dest);
    MODULE_ID_RANGE_CHECK(p_dest);
    BLOCK_ID_RANGE_CHECK(p_dest);

    if ((!is_word_aligned((uint32_t *)p_dest->block_id)))
   1f616:	423d      	tst	r5, r7
   1f618:	d11c      	bne.n	1f654 <_ZN7Storage12ProcessQueueEv+0x144>
    }

    // Check is the area starting from block_id multiple of block_size.
    if (
        !(
            ((p_dest->block_id - m_app_table[p_dest->module_id].base_id) %
   1f61a:	1a28      	subs	r0, r5, r0
   1f61c:	1c31      	adds	r1, r6, #0
   1f61e:	f002 fdb1 	bl	22184 <__aeabi_uidivmod>

uint32_t pstorage_clear(pstorage_handle_t * p_dest, pstorage_size_t size)
{
    VERIFY_MODULE_INITIALIZED();
    NULL_PARAM_CHECK(p_dest);
    MODULE_ID_RANGE_CHECK(p_dest);
   1f622:	3c09      	subs	r4, #9
    {
        return NRF_ERROR_INVALID_ADDR;
    }

    // Check is the area starting from block_id multiple of block_size.
    if (
   1f624:	2900      	cmp	r1, #0
   1f626:	d115      	bne.n	1f654 <_ZN7Storage12ProcessQueueEv+0x144>
    {
        return NRF_ERROR_INVALID_PARAM;
    }

    // Check is requested size multiple of registered block size or 0.
    if (((size % m_app_table[p_dest->module_id].block_size) != 0) || (size == 0))    
   1f628:	2080      	movs	r0, #128	; 0x80
   1f62a:	1c31      	adds	r1, r6, #0
   1f62c:	f002 fdaa 	bl	22184 <__aeabi_uidivmod>
   1f630:	b28a      	uxth	r2, r1
   1f632:	2a00      	cmp	r2, #0
   1f634:	d10e      	bne.n	1f654 <_ZN7Storage12ProcessQueueEv+0x144>
    
    const pstorage_block_t clear_request_end_address = p_dest->block_id + size;
    const pstorage_block_t allocation_end_address    = m_app_table[p_dest->module_id].base_id + 
                                                       registered_allocation_size;
    // Check if request would lead to a buffer overrun.                                                       
    if (clear_request_end_address > allocation_end_address)
   1f636:	9b05      	ldr	r3, [sp, #20]
    }

    const uint32_t registered_allocation_size = m_app_table[p_dest->module_id].block_size * 
                                                m_app_table[p_dest->module_id].block_count;
    
    const pstorage_block_t clear_request_end_address = p_dest->block_id + size;
   1f638:	3580      	adds	r5, #128	; 0x80
    const pstorage_block_t allocation_end_address    = m_app_table[p_dest->module_id].base_id + 
                                                       registered_allocation_size;
    // Check if request would lead to a buffer overrun.                                                       
    if (clear_request_end_address > allocation_end_address)
   1f63a:	429d      	cmp	r5, r3
   1f63c:	d80a      	bhi.n	1f654 <_ZN7Storage12ProcessQueueEv+0x144>
	}
//	logt("STORAGE", "Writing len:%u to block:%u", len, block);

	//Call clear first before writing to the flash
	//Clear will generate an event that is handeled in the PstorabeEventHandler
	u32 err = pstorage_clear(&block_handles[block], 128);
   1f63e:	9904      	ldr	r1, [sp, #16]
   1f640:	9b03      	ldr	r3, [sp, #12]
   1f642:	3116      	adds	r1, #22
   1f644:	40b9      	lsls	r1, r7
    {        
        return NRF_ERROR_INVALID_PARAM;            
    }
    
    return cmd_queue_enqueue(PSTORAGE_CLEAR_OP_CODE, p_dest, NULL, size, 0);
   1f646:	1c38      	adds	r0, r7, #0
   1f648:	1859      	adds	r1, r3, r1
   1f64a:	2380      	movs	r3, #128	; 0x80
   1f64c:	f7ff fca0 	bl	1ef90 <cmd_queue_enqueue.constprop.51>
   1f650:	1e04      	subs	r4, r0, #0
	APP_ERROR_CHECK(err);
   1f652:	d004      	beq.n	1f65e <_ZN7Storage12ProcessQueueEv+0x14e>
   1f654:	1c20      	adds	r0, r4, #0
   1f656:	2180      	movs	r1, #128	; 0x80
   1f658:	4a04      	ldr	r2, [pc, #16]	; (1f66c <_ZN7Storage12ProcessQueueEv+0x15c>)
   1f65a:	f7fd fed3 	bl	1d404 <app_error_handler>
	sizedData data = taskQueue->PeekNext();
	taskitem* task = (taskitem*)data.data;

	if(task->operation == operation::OPERATION_READ) BufferedRead(task->data, task->storageBlock, task->dataLength);
	else if(task->operation == operation::OPERATION_WRITE) BufferedWrite(task->data, task->storageBlock, task->dataLength);
}
   1f65e:	b009      	add	sp, #36	; 0x24
   1f660:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f662:	46c0      	nop			; (mov r8, r8)
   1f664:	2000353c 	.word	0x2000353c
   1f668:	20003568 	.word	0x20003568
   1f66c:	00022aab 	.word	0x00022aab

0001f670 <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm>:
		pstorage_block_identifier_get(&handle, i, &block_handles[i]);
	}
}

void Storage::PstorageEventHandler(pstorage_handle_t* handle, u8 opCode, u32 result, u8* data, u32 dataLength)
{
   1f670:	b5f0      	push	{r4, r5, r6, r7, lr}
   1f672:	b085      	sub	sp, #20
	//logt("STORAGE", "Event: %u, result:%d, len:%d", opCode, result, dataLength);
	if(result != NRF_SUCCESS) logt("STORAGE", "%s", Logger::getInstance().getPstorageStatusErrorString(opCode));


	//if it 's a clear, we do the write
	if(opCode == PSTORAGE_CLEAR_OP_CODE && result == NRF_SUCCESS){
   1f674:	2903      	cmp	r1, #3
   1f676:	d13b      	bne.n	1f6f0 <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0x80>
   1f678:	2a00      	cmp	r2, #0
   1f67a:	d139      	bne.n	1f6f0 <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0x80>

		taskitem* task = (taskitem*)Storage::getInstance().taskQueue->PeekNext().data;
   1f67c:	f001 faf2 	bl	20c64 <_ZN7Storage11getInstanceEv>
   1f680:	1c03      	adds	r3, r0, #0
   1f682:	33a4      	adds	r3, #164	; 0xa4
   1f684:	6819      	ldr	r1, [r3, #0]
   1f686:	a802      	add	r0, sp, #8
   1f688:	f7ff fcc8 	bl	1f01c <_ZN11SimpleQueue8PeekNextEv>
   1f68c:	9d02      	ldr	r5, [sp, #8]

		pstorage_store(&Storage::getInstance().block_handles[task->storageBlock], task->data, task->dataLength, 0);
   1f68e:	f001 fae9 	bl	20c64 <_ZN7Storage11getInstanceEv>
uint32_t pstorage_store(pstorage_handle_t * p_dest,
                        uint8_t           * p_src,
                        pstorage_size_t     size,
                        pstorage_size_t     offset)
{
    VERIFY_MODULE_INITIALIZED();
   1f692:	4937      	ldr	r1, [pc, #220]	; (1f770 <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0x100>)
   1f694:	686c      	ldr	r4, [r5, #4]
   1f696:	6809      	ldr	r1, [r1, #0]
   1f698:	68aa      	ldr	r2, [r5, #8]
   1f69a:	886b      	ldrh	r3, [r5, #2]
   1f69c:	0749      	lsls	r1, r1, #29
   1f69e:	d564      	bpl.n	1f76a <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0xfa>
    NULL_PARAM_CHECK(p_src);
   1f6a0:	2a00      	cmp	r2, #0
   1f6a2:	d062      	beq.n	1f76a <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0xfa>
   1f6a4:	1c21      	adds	r1, r4, #0
   1f6a6:	3116      	adds	r1, #22
   1f6a8:	00c9      	lsls	r1, r1, #3
   1f6aa:	1841      	adds	r1, r0, r1
    NULL_PARAM_CHECK(p_dest);
   1f6ac:	2900      	cmp	r1, #0
   1f6ae:	d05c      	beq.n	1f76a <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0xfa>
   1f6b0:	00e4      	lsls	r4, r4, #3
   1f6b2:	1900      	adds	r0, r0, r4
    MODULE_ID_RANGE_CHECK(p_dest);
   1f6b4:	1c04      	adds	r4, r0, #0
   1f6b6:	34b0      	adds	r4, #176	; 0xb0
   1f6b8:	6824      	ldr	r4, [r4, #0]
   1f6ba:	2c00      	cmp	r4, #0
   1f6bc:	d155      	bne.n	1f76a <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0xfa>
   1f6be:	4c2d      	ldr	r4, [pc, #180]	; (1f774 <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0x104>)
   1f6c0:	6825      	ldr	r5, [r4, #0]
   1f6c2:	2d00      	cmp	r5, #0
   1f6c4:	d051      	beq.n	1f76a <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0xfa>
    BLOCK_ID_RANGE_CHECK(p_dest);
   1f6c6:	8925      	ldrh	r5, [r4, #8]
   1f6c8:	8967      	ldrh	r7, [r4, #10]
   1f6ca:	30b4      	adds	r0, #180	; 0xb4
   1f6cc:	436f      	muls	r7, r5
   1f6ce:	6866      	ldr	r6, [r4, #4]
   1f6d0:	6800      	ldr	r0, [r0, #0]
   1f6d2:	19bc      	adds	r4, r7, r6
   1f6d4:	42a0      	cmp	r0, r4
   1f6d6:	d248      	bcs.n	1f76a <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0xfa>
    SIZE_CHECK(p_dest, size);    
   1f6d8:	2b00      	cmp	r3, #0
   1f6da:	d046      	beq.n	1f76a <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0xfa>
   1f6dc:	42ab      	cmp	r3, r5
   1f6de:	d844      	bhi.n	1f76a <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0xfa>
    OFFSET_CHECK(p_dest, offset, size);
   1f6e0:	dc43      	bgt.n	1f76a <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0xfa>
   1f6e2:	4310      	orrs	r0, r2
    
    if ((!is_word_aligned(p_src))                    || 
        (!is_word_aligned((void *)(uint32_t)offset)) || 
   1f6e4:	0780      	lsls	r0, r0, #30
   1f6e6:	d140      	bne.n	1f76a <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0xfa>
        (!is_word_aligned((uint32_t *)p_dest->block_id)))
    {
        return NRF_ERROR_INVALID_ADDR;
    }

    return cmd_queue_enqueue(PSTORAGE_STORE_OP_CODE, p_dest, p_src, size, offset);
   1f6e8:	2001      	movs	r0, #1
   1f6ea:	f7ff fc51 	bl	1ef90 <cmd_queue_enqueue.constprop.51>
   1f6ee:	e03c      	b.n	1f76a <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0xfa>

	}

	//If its a write or a read, we drop the last item and execute the next one
	else if((opCode == PSTORAGE_STORE_OP_CODE || opCode == PSTORAGE_LOAD_OP_CODE) && result == NRF_SUCCESS)
   1f6f0:	3901      	subs	r1, #1
   1f6f2:	2901      	cmp	r1, #1
   1f6f4:	d82e      	bhi.n	1f754 <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0xe4>
   1f6f6:	2a00      	cmp	r2, #0
   1f6f8:	d12e      	bne.n	1f758 <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0xe8>
	{
		//Remove item from queue because it was successful
		taskitem* task = (taskitem*)Storage::getInstance().taskQueue->GetNext().data;
   1f6fa:	f001 fab3 	bl	20c64 <_ZN7Storage11getInstanceEv>
   1f6fe:	30a4      	adds	r0, #164	; 0xa4
   1f700:	6804      	ldr	r4, [r0, #0]

sizedData SimpleQueue::GetNext(void)
{
   sizedData data;
	//If queue has been fully read, return empty data
	if(_numElements == 0){		
   1f702:	8aa5      	ldrh	r5, [r4, #20]
   1f704:	2d00      	cmp	r5, #0
   1f706:	d01c      	beq.n	1f742 <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0xd2>
		return data;
	}
	
	//Check if we reached the end and wrap
	u32 size;
	memcpy(&size, readPointer, 4);
   1f708:	68e6      	ldr	r6, [r4, #12]
   1f70a:	a801      	add	r0, sp, #4
   1f70c:	1c31      	adds	r1, r6, #0
   1f70e:	2204      	movs	r2, #4
   1f710:	f001 ff80 	bl	21614 <memcpy>
	if(size == 0 && writePointer < readPointer) readPointer = bufferStart;
   1f714:	9b01      	ldr	r3, [sp, #4]
   1f716:	2b00      	cmp	r3, #0
   1f718:	d104      	bne.n	1f724 <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0xb4>
   1f71a:	6923      	ldr	r3, [r4, #16]
   1f71c:	42b3      	cmp	r3, r6
   1f71e:	d201      	bcs.n	1f724 <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0xb4>
   1f720:	6823      	ldr	r3, [r4, #0]
   1f722:	60e3      	str	r3, [r4, #12]
	
	memcpy(&data.length, readPointer, 4);
   1f724:	68e6      	ldr	r6, [r4, #12]
   1f726:	a803      	add	r0, sp, #12
   1f728:	1c31      	adds	r1, r6, #0
   1f72a:	2204      	movs	r2, #4
   1f72c:	f001 ff72 	bl	21614 <memcpy>
	data.data = this->readPointer + 4;
   1f730:	1d33      	adds	r3, r6, #4
   1f732:	9302      	str	r3, [sp, #8]
	
	this->readPointer += data.length + 4;
   1f734:	ab02      	add	r3, sp, #8
   1f736:	8899      	ldrh	r1, [r3, #4]

	_numElements--;
   1f738:	3d01      	subs	r5, #1
	if(size == 0 && writePointer < readPointer) readPointer = bufferStart;
	
	memcpy(&data.length, readPointer, 4);
	data.data = this->readPointer + 4;
	
	this->readPointer += data.length + 4;
   1f73a:	3104      	adds	r1, #4
   1f73c:	1871      	adds	r1, r6, r1
   1f73e:	60e1      	str	r1, [r4, #12]

	_numElements--;
   1f740:	82a5      	strh	r5, [r4, #20]
   1f742:	9b02      	ldr	r3, [sp, #8]

		//Notify callback
		if(task->operation == OPERATION_READ){ task->callback->ConfigurationLoadedHandler(); }
   1f744:	881a      	ldrh	r2, [r3, #0]
   1f746:	2a00      	cmp	r2, #0
   1f748:	d106      	bne.n	1f758 <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0xe8>
   1f74a:	68d8      	ldr	r0, [r3, #12]
   1f74c:	6803      	ldr	r3, [r0, #0]
   1f74e:	689b      	ldr	r3, [r3, #8]
   1f750:	4798      	blx	r3
   1f752:	e001      	b.n	1f758 <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0xe8>
		else if(task->operation == OPERATION_WRITE){};

		Storage::getInstance().bufferedOperationInProgress = false;
		Storage::getInstance().ProcessQueue();
	}
	else if(result != NRF_SUCCESS){
   1f754:	2a00      	cmp	r2, #0
   1f756:	d008      	beq.n	1f76a <_ZN7Storage20PstorageEventHandlerEP17pstorage_handle_thmPhm+0xfa>
		Storage::getInstance().bufferedOperationInProgress = false;
   1f758:	f001 fa84 	bl	20c64 <_ZN7Storage11getInstanceEv>
   1f75c:	2300      	movs	r3, #0
   1f75e:	30ff      	adds	r0, #255	; 0xff
   1f760:	7043      	strb	r3, [r0, #1]
		Storage::getInstance().ProcessQueue();
   1f762:	f001 fa7f 	bl	20c64 <_ZN7Storage11getInstanceEv>
   1f766:	f7ff fed3 	bl	1f510 <_ZN7Storage12ProcessQueueEv>
	}
}
   1f76a:	b005      	add	sp, #20
   1f76c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f76e:	46c0      	nop			; (mov r8, r8)
   1f770:	2000353c 	.word	0x2000353c
   1f774:	20003568 	.word	0x20003568

0001f778 <_ZN10NewStorage18SystemEventHandlerEm>:
	}
}


void NewStorage::SystemEventHandler(u32 systemEvent)
{
   1f778:	b5f0      	push	{r4, r5, r6, r7, lr}
	//This happens if another class requested a flash operation => Avoid that!
	if(currentTask == NULL) return;
   1f77a:	4d55      	ldr	r5, [pc, #340]	; (1f8d0 <_ZN10NewStorage18SystemEventHandlerEm+0x158>)
	}
}


void NewStorage::SystemEventHandler(u32 systemEvent)
{
   1f77c:	b087      	sub	sp, #28
	//This happens if another class requested a flash operation => Avoid that!
	if(currentTask == NULL) return;
   1f77e:	682c      	ldr	r4, [r5, #0]
	}
}


void NewStorage::SystemEventHandler(u32 systemEvent)
{
   1f780:	1c06      	adds	r6, r0, #0
	//This happens if another class requested a flash operation => Avoid that!
	if(currentTask == NULL) return;
   1f782:	2c00      	cmp	r4, #0
   1f784:	d100      	bne.n	1f788 <_ZN10NewStorage18SystemEventHandlerEm+0x10>
   1f786:	e0a1      	b.n	1f8cc <_ZN10NewStorage18SystemEventHandlerEm+0x154>

	NewStorageTaskItem* taskReference = currentTask;

	if(systemEvent == NRF_EVT_FLASH_OPERATION_ERROR)
   1f788:	2803      	cmp	r0, #3
   1f78a:	d10f      	bne.n	1f7ac <_ZN10NewStorage18SystemEventHandlerEm+0x34>
	{
		logt("ERROR", "Flash operation error");
		if(retryCount > 0)
   1f78c:	4a51      	ldr	r2, [pc, #324]	; (1f8d4 <_ZN10NewStorage18SystemEventHandlerEm+0x15c>)
   1f78e:	7813      	ldrb	r3, [r2, #0]
   1f790:	b259      	sxtb	r1, r3
   1f792:	2900      	cmp	r1, #0
   1f794:	dd02      	ble.n	1f79c <_ZN10NewStorage18SystemEventHandlerEm+0x24>
		{
			retryCount--;
   1f796:	3b01      	subs	r3, #1
   1f798:	7013      	strb	r3, [r2, #0]
   1f79a:	e035      	b.n	1f808 <_ZN10NewStorage18SystemEventHandlerEm+0x90>
		}
		else {
			//Reset retryCount if the task was canceled
			retryCount = NEW_STORAGE_RETRY_COUNT;

			taskQueue->DiscardNext();
   1f79c:	4b4e      	ldr	r3, [pc, #312]	; (1f8d8 <_ZN10NewStorage18SystemEventHandlerEm+0x160>)
			ProcessQueue(true);
			return;
		}
		else {
			//Reset retryCount if the task was canceled
			retryCount = NEW_STORAGE_RETRY_COUNT;
   1f79e:	7010      	strb	r0, [r2, #0]

			taskQueue->DiscardNext();
   1f7a0:	6818      	ldr	r0, [r3, #0]
   1f7a2:	f7ff fc1b 	bl	1efdc <_ZN11SimpleQueue11DiscardNextEv>
			currentTask = NULL;
   1f7a6:	2300      	movs	r3, #0
   1f7a8:	602b      	str	r3, [r5, #0]
   1f7aa:	e034      	b.n	1f816 <_ZN10NewStorage18SystemEventHandlerEm+0x9e>
			if(taskReference->callback != NULL) taskReference->callback->NewStorageItemExecuted(*taskReference, NewStorageError::FLASH_OPERATION_TIMED_OUT);
		}
	}
	else if(systemEvent == NRF_EVT_FLASH_OPERATION_SUCCESS)
   1f7ac:	2802      	cmp	r0, #2
   1f7ae:	d000      	beq.n	1f7b2 <_ZN10NewStorage18SystemEventHandlerEm+0x3a>
   1f7b0:	e089      	b.n	1f8c6 <_ZN10NewStorage18SystemEventHandlerEm+0x14e>
	{
		//Reset retryCount if something succeeded
		retryCount = NEW_STORAGE_RETRY_COUNT;
   1f7b2:	2203      	movs	r2, #3
   1f7b4:	4b47      	ldr	r3, [pc, #284]	; (1f8d4 <_ZN10NewStorage18SystemEventHandlerEm+0x15c>)
   1f7b6:	701a      	strb	r2, [r3, #0]

		logt("NEWSTORAGE", "Flash operation success");
		if(
				taskReference->command == NewStorageCommand::ERASE_PAGE
   1f7b8:	7823      	ldrb	r3, [r4, #0]
				|| taskReference->command == NewStorageCommand::WRITE_DATA
   1f7ba:	1c1a      	adds	r2, r3, #0
   1f7bc:	4382      	bics	r2, r0
   1f7be:	2a01      	cmp	r2, #1
   1f7c0:	d116      	bne.n	1f7f0 <_ZN10NewStorage18SystemEventHandlerEm+0x78>
		){
			//Erase page command successful
			taskQueue->DiscardNext();
   1f7c2:	4b45      	ldr	r3, [pc, #276]	; (1f8d8 <_ZN10NewStorage18SystemEventHandlerEm+0x160>)
   1f7c4:	6818      	ldr	r0, [r3, #0]
   1f7c6:	f7ff fc09 	bl	1efdc <_ZN11SimpleQueue11DiscardNextEv>
			currentTask = NULL;
   1f7ca:	2000      	movs	r0, #0
			if(taskReference->callback != NULL) taskReference->callback->NewStorageItemExecuted(*taskReference, NewStorageError::SUCCESS);
   1f7cc:	78a3      	ldrb	r3, [r4, #2]
				taskReference->command == NewStorageCommand::ERASE_PAGE
				|| taskReference->command == NewStorageCommand::WRITE_DATA
		){
			//Erase page command successful
			taskQueue->DiscardNext();
			currentTask = NULL;
   1f7ce:	6028      	str	r0, [r5, #0]
			if(taskReference->callback != NULL) taskReference->callback->NewStorageItemExecuted(*taskReference, NewStorageError::SUCCESS);
   1f7d0:	7861      	ldrb	r1, [r4, #1]
   1f7d2:	78e5      	ldrb	r5, [r4, #3]
   1f7d4:	021b      	lsls	r3, r3, #8
   1f7d6:	430b      	orrs	r3, r1
   1f7d8:	042d      	lsls	r5, r5, #16
   1f7da:	1c1a      	adds	r2, r3, #0
   1f7dc:	1c2b      	adds	r3, r5, #0
   1f7de:	7925      	ldrb	r5, [r4, #4]
   1f7e0:	4313      	orrs	r3, r2
   1f7e2:	062d      	lsls	r5, r5, #24
   1f7e4:	431d      	orrs	r5, r3
   1f7e6:	4285      	cmp	r5, r0
   1f7e8:	d06d      	beq.n	1f8c6 <_ZN10NewStorage18SystemEventHandlerEm+0x14e>
   1f7ea:	682f      	ldr	r7, [r5, #0]
   1f7ec:	9002      	str	r0, [sp, #8]
   1f7ee:	e03a      	b.n	1f866 <_ZN10NewStorage18SystemEventHandlerEm+0xee>
		}
		else if(taskReference->command == NewStorageCommand::ERASE_PAGES){
   1f7f0:	2b04      	cmp	r3, #4
   1f7f2:	d11e      	bne.n	1f832 <_ZN10NewStorage18SystemEventHandlerEm+0xba>

			//We must still erase some pages
			if(taskReference->params.erasePages.numPages > 0){
   1f7f4:	7b26      	ldrb	r6, [r4, #12]
   1f7f6:	7ae3      	ldrb	r3, [r4, #11]
   1f7f8:	0236      	lsls	r6, r6, #8
   1f7fa:	431e      	orrs	r6, r3
   1f7fc:	d006      	beq.n	1f80c <_ZN10NewStorage18SystemEventHandlerEm+0x94>
				taskReference->params.erasePages.numPages--;
   1f7fe:	3e01      	subs	r6, #1
   1f800:	b2b6      	uxth	r6, r6
   1f802:	72e6      	strb	r6, [r4, #11]
   1f804:	0a36      	lsrs	r6, r6, #8
   1f806:	7326      	strb	r6, [r4, #12]
				ProcessQueue(true);
   1f808:	2001      	movs	r0, #1
   1f80a:	e05d      	b.n	1f8c8 <_ZN10NewStorage18SystemEventHandlerEm+0x150>
			}
			//All pages erased
			else
			{
				logt("NEWSTORAGE", "done");
				taskQueue->DiscardNext();
   1f80c:	4b32      	ldr	r3, [pc, #200]	; (1f8d8 <_ZN10NewStorage18SystemEventHandlerEm+0x160>)
   1f80e:	6818      	ldr	r0, [r3, #0]
   1f810:	f7ff fbe4 	bl	1efdc <_ZN11SimpleQueue11DiscardNextEv>
				currentTask = NULL;
   1f814:	602e      	str	r6, [r5, #0]
				if(taskReference->callback != NULL) taskReference->callback->NewStorageItemExecuted(*taskReference, NewStorageError::SUCCESS);
   1f816:	78a3      	ldrb	r3, [r4, #2]
   1f818:	7861      	ldrb	r1, [r4, #1]
   1f81a:	78e5      	ldrb	r5, [r4, #3]
   1f81c:	021b      	lsls	r3, r3, #8
   1f81e:	430b      	orrs	r3, r1
   1f820:	042d      	lsls	r5, r5, #16
   1f822:	1c1a      	adds	r2, r3, #0
   1f824:	1c2b      	adds	r3, r5, #0
   1f826:	7925      	ldrb	r5, [r4, #4]
   1f828:	4313      	orrs	r3, r2
   1f82a:	062d      	lsls	r5, r5, #24
   1f82c:	431d      	orrs	r5, r3
   1f82e:	d118      	bne.n	1f862 <_ZN10NewStorage18SystemEventHandlerEm+0xea>
   1f830:	e049      	b.n	1f8c6 <_ZN10NewStorage18SystemEventHandlerEm+0x14e>
			}
		}
		else if(currentTask->command == NewStorageCommand::WRITE_AND_CACHE_DATA)
   1f832:	2b02      	cmp	r3, #2
   1f834:	d147      	bne.n	1f8c6 <_ZN10NewStorage18SystemEventHandlerEm+0x14e>
		{
			dataBufferInUse = false;
   1f836:	2600      	movs	r6, #0
   1f838:	4b28      	ldr	r3, [pc, #160]	; (1f8dc <_ZN10NewStorage18SystemEventHandlerEm+0x164>)
   1f83a:	701e      	strb	r6, [r3, #0]
			taskQueue->DiscardNext();
   1f83c:	4b26      	ldr	r3, [pc, #152]	; (1f8d8 <_ZN10NewStorage18SystemEventHandlerEm+0x160>)
   1f83e:	6818      	ldr	r0, [r3, #0]
   1f840:	f7ff fbcc 	bl	1efdc <_ZN11SimpleQueue11DiscardNextEv>
			currentTask = NULL;
			if(taskReference->callback != NULL) taskReference->callback->NewStorageItemExecuted(*taskReference, NewStorageError::SUCCESS);
   1f844:	78a3      	ldrb	r3, [r4, #2]
		}
		else if(currentTask->command == NewStorageCommand::WRITE_AND_CACHE_DATA)
		{
			dataBufferInUse = false;
			taskQueue->DiscardNext();
			currentTask = NULL;
   1f846:	602e      	str	r6, [r5, #0]
			if(taskReference->callback != NULL) taskReference->callback->NewStorageItemExecuted(*taskReference, NewStorageError::SUCCESS);
   1f848:	7861      	ldrb	r1, [r4, #1]
   1f84a:	78e5      	ldrb	r5, [r4, #3]
   1f84c:	021b      	lsls	r3, r3, #8
   1f84e:	430b      	orrs	r3, r1
   1f850:	042d      	lsls	r5, r5, #16
   1f852:	1c1a      	adds	r2, r3, #0
   1f854:	1c2b      	adds	r3, r5, #0
   1f856:	7925      	ldrb	r5, [r4, #4]
   1f858:	4313      	orrs	r3, r2
   1f85a:	062d      	lsls	r5, r5, #24
   1f85c:	431d      	orrs	r5, r3
   1f85e:	42b5      	cmp	r5, r6
   1f860:	d031      	beq.n	1f8c6 <_ZN10NewStorage18SystemEventHandlerEm+0x14e>
   1f862:	682f      	ldr	r7, [r5, #0]
   1f864:	9602      	str	r6, [sp, #8]
   1f866:	7863      	ldrb	r3, [r4, #1]
   1f868:	7821      	ldrb	r1, [r4, #0]
   1f86a:	78a6      	ldrb	r6, [r4, #2]
   1f86c:	021b      	lsls	r3, r3, #8
   1f86e:	430b      	orrs	r3, r1
   1f870:	0436      	lsls	r6, r6, #16
   1f872:	1c1a      	adds	r2, r3, #0
   1f874:	1c33      	adds	r3, r6, #0
   1f876:	78e6      	ldrb	r6, [r4, #3]
   1f878:	4313      	orrs	r3, r2
   1f87a:	0636      	lsls	r6, r6, #24
   1f87c:	431e      	orrs	r6, r3
   1f87e:	7963      	ldrb	r3, [r4, #5]
   1f880:	7921      	ldrb	r1, [r4, #4]
   1f882:	021b      	lsls	r3, r3, #8
   1f884:	430b      	orrs	r3, r1
   1f886:	1c1a      	adds	r2, r3, #0
   1f888:	79a3      	ldrb	r3, [r4, #6]
   1f88a:	7a21      	ldrb	r1, [r4, #8]
   1f88c:	041b      	lsls	r3, r3, #16
   1f88e:	4313      	orrs	r3, r2
   1f890:	79e2      	ldrb	r2, [r4, #7]
   1f892:	4668      	mov	r0, sp
   1f894:	0612      	lsls	r2, r2, #24
   1f896:	431a      	orrs	r2, r3
   1f898:	7a63      	ldrb	r3, [r4, #9]
   1f89a:	9204      	str	r2, [sp, #16]
   1f89c:	021b      	lsls	r3, r3, #8
   1f89e:	430b      	orrs	r3, r1
   1f8a0:	1c1a      	adds	r2, r3, #0
   1f8a2:	1c21      	adds	r1, r4, #0
   1f8a4:	7aa3      	ldrb	r3, [r4, #10]
   1f8a6:	310c      	adds	r1, #12
   1f8a8:	041b      	lsls	r3, r3, #16
   1f8aa:	4313      	orrs	r3, r2
   1f8ac:	7ae2      	ldrb	r2, [r4, #11]
   1f8ae:	0612      	lsls	r2, r2, #24
   1f8b0:	431a      	orrs	r2, r3
   1f8b2:	9205      	str	r2, [sp, #20]
   1f8b4:	2207      	movs	r2, #7
   1f8b6:	f001 fead 	bl	21614 <memcpy>
   1f8ba:	68bc      	ldr	r4, [r7, #8]
   1f8bc:	1c28      	adds	r0, r5, #0
   1f8be:	1c31      	adds	r1, r6, #0
   1f8c0:	9a04      	ldr	r2, [sp, #16]
   1f8c2:	9b05      	ldr	r3, [sp, #20]
   1f8c4:	47a0      	blx	r4
		}
	}

	//Process either the next item or the current one again (if it has not been discarded)
	ProcessQueue(false);
   1f8c6:	2000      	movs	r0, #0
   1f8c8:	f000 f80a 	bl	1f8e0 <_ZN10NewStorage12ProcessQueueEb>
}
   1f8cc:	b007      	add	sp, #28
   1f8ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f8d0:	20003578 	.word	0x20003578
   1f8d4:	2000357d 	.word	0x2000357d
   1f8d8:	20003584 	.word	0x20003584
   1f8dc:	200033dd 	.word	0x200033dd

0001f8e0 <_ZN10NewStorage12ProcessQueueEb>:
void NewStorage::ProcessQueue(bool continueCurrentTask)
{
	u32 err = 0;

	//Do not execute next task if there is a task running or if there are no more tasks
	if((currentTask != NULL && !continueCurrentTask) || taskQueue->_numElements < 1) return;
   1f8e0:	4b38      	ldr	r3, [pc, #224]	; (1f9c4 <_ZN10NewStorage12ProcessQueueEb+0xe4>)
}



void NewStorage::ProcessQueue(bool continueCurrentTask)
{
   1f8e2:	b537      	push	{r0, r1, r2, r4, r5, lr}
	u32 err = 0;

	//Do not execute next task if there is a task running or if there are no more tasks
	if((currentTask != NULL && !continueCurrentTask) || taskQueue->_numElements < 1) return;
   1f8e4:	681a      	ldr	r2, [r3, #0]
   1f8e6:	1c1c      	adds	r4, r3, #0
   1f8e8:	2a00      	cmp	r2, #0
   1f8ea:	d001      	beq.n	1f8f0 <_ZN10NewStorage12ProcessQueueEb+0x10>
   1f8ec:	2800      	cmp	r0, #0
   1f8ee:	d067      	beq.n	1f9c0 <_ZN10NewStorage12ProcessQueueEb+0xe0>
   1f8f0:	4b35      	ldr	r3, [pc, #212]	; (1f9c8 <_ZN10NewStorage12ProcessQueueEb+0xe8>)
   1f8f2:	6819      	ldr	r1, [r3, #0]
   1f8f4:	8a8b      	ldrh	r3, [r1, #20]
   1f8f6:	2b00      	cmp	r3, #0
   1f8f8:	d062      	beq.n	1f9c0 <_ZN10NewStorage12ProcessQueueEb+0xe0>

	//Get one item from the queue and execute it
	sizedData data = taskQueue->PeekNext();
   1f8fa:	4668      	mov	r0, sp
   1f8fc:	f7ff fb8e 	bl	1f01c <_ZN11SimpleQueue8PeekNextEv>
	currentTask = (NewStorageTaskItem*)data.data;
   1f900:	9b00      	ldr	r3, [sp, #0]

	logt("NEWSTORAGE", "processing command %u", currentTask->command);

	if(currentTask->command == NewStorageCommand::ERASE_PAGE)
   1f902:	781a      	ldrb	r2, [r3, #0]
	//Do not execute next task if there is a task running or if there are no more tasks
	if((currentTask != NULL && !continueCurrentTask) || taskQueue->_numElements < 1) return;

	//Get one item from the queue and execute it
	sizedData data = taskQueue->PeekNext();
	currentTask = (NewStorageTaskItem*)data.data;
   1f904:	6023      	str	r3, [r4, #0]

	logt("NEWSTORAGE", "processing command %u", currentTask->command);

	if(currentTask->command == NewStorageCommand::ERASE_PAGE)
   1f906:	2a03      	cmp	r2, #3
   1f908:	d109      	bne.n	1f91e <_ZN10NewStorage12ProcessQueueEb+0x3e>
	{
		err = sd_flash_page_erase(currentTask->params.erasePage.page);
   1f90a:	7a98      	ldrb	r0, [r3, #10]
   1f90c:	7a5a      	ldrb	r2, [r3, #9]
   1f90e:	0200      	lsls	r0, r0, #8
   1f910:	4310      	orrs	r0, r2
   1f912:	f7ff fb37 	bl	1ef84 <sd_flash_page_erase>
		APP_ERROR_CHECK(err); //FIXME: NRF_ERROR_BUSY and others not handeled
   1f916:	2182      	movs	r1, #130	; 0x82
   1f918:	2800      	cmp	r0, #0
   1f91a:	d051      	beq.n	1f9c0 <_ZN10NewStorage12ProcessQueueEb+0xe0>
   1f91c:	e026      	b.n	1f96c <_ZN10NewStorage12ProcessQueueEb+0x8c>
	}
	else if(currentTask->command == NewStorageCommand::ERASE_PAGES)
   1f91e:	2a04      	cmp	r2, #4
   1f920:	d127      	bne.n	1f972 <_ZN10NewStorage12ProcessQueueEb+0x92>
	{
		u16 pageNum = currentTask->params.erasePages.startPage + currentTask->params.erasePages.numPages;
   1f922:	7b18      	ldrb	r0, [r3, #12]
   1f924:	7ada      	ldrb	r2, [r3, #11]
   1f926:	0200      	lsls	r0, r0, #8
   1f928:	1c01      	adds	r1, r0, #0
   1f92a:	7a98      	ldrb	r0, [r3, #10]
   1f92c:	4311      	orrs	r1, r2
   1f92e:	0200      	lsls	r0, r0, #8
   1f930:	7a5a      	ldrb	r2, [r3, #9]
   1f932:	1c03      	adds	r3, r0, #0
   1f934:	4313      	orrs	r3, r2

		//Erasing a flash page takes 22ms, reading a flash page takes 140 us, we will therefore do a read first
		//To see if we really must erase the page
		u32 buffer = 0xFFFFFFFF;
   1f936:	2201      	movs	r2, #1
		err = sd_flash_page_erase(currentTask->params.erasePage.page);
		APP_ERROR_CHECK(err); //FIXME: NRF_ERROR_BUSY and others not handeled
	}
	else if(currentTask->command == NewStorageCommand::ERASE_PAGES)
	{
		u16 pageNum = currentTask->params.erasePages.startPage + currentTask->params.erasePages.numPages;
   1f938:	18c8      	adds	r0, r1, r3

		//Erasing a flash page takes 22ms, reading a flash page takes 140 us, we will therefore do a read first
		//To see if we really must erase the page
		u32 buffer = 0xFFFFFFFF;
		for(u32 i=0; i<NRF_FICR->CODEPAGESIZE; i+=4){
   1f93a:	2300      	movs	r3, #0
		err = sd_flash_page_erase(currentTask->params.erasePage.page);
		APP_ERROR_CHECK(err); //FIXME: NRF_ERROR_BUSY and others not handeled
	}
	else if(currentTask->command == NewStorageCommand::ERASE_PAGES)
	{
		u16 pageNum = currentTask->params.erasePages.startPage + currentTask->params.erasePages.numPages;
   1f93c:	b280      	uxth	r0, r0

		//Erasing a flash page takes 22ms, reading a flash page takes 140 us, we will therefore do a read first
		//To see if we really must erase the page
		u32 buffer = 0xFFFFFFFF;
   1f93e:	4252      	negs	r2, r2
		for(u32 i=0; i<NRF_FICR->CODEPAGESIZE; i+=4){
   1f940:	2180      	movs	r1, #128	; 0x80
   1f942:	0549      	lsls	r1, r1, #21
   1f944:	690c      	ldr	r4, [r1, #16]
   1f946:	42a3      	cmp	r3, r4
   1f948:	d205      	bcs.n	1f956 <_ZN10NewStorage12ProcessQueueEb+0x76>
			buffer = buffer & *(u32*)(pageNum*NRF_FICR->CODEPAGESIZE+i);
   1f94a:	6909      	ldr	r1, [r1, #16]
   1f94c:	4341      	muls	r1, r0
   1f94e:	5859      	ldr	r1, [r3, r1]
		u16 pageNum = currentTask->params.erasePages.startPage + currentTask->params.erasePages.numPages;

		//Erasing a flash page takes 22ms, reading a flash page takes 140 us, we will therefore do a read first
		//To see if we really must erase the page
		u32 buffer = 0xFFFFFFFF;
		for(u32 i=0; i<NRF_FICR->CODEPAGESIZE; i+=4){
   1f950:	3304      	adds	r3, #4
			buffer = buffer & *(u32*)(pageNum*NRF_FICR->CODEPAGESIZE+i);
   1f952:	400a      	ands	r2, r1
   1f954:	e7f4      	b.n	1f940 <_ZN10NewStorage12ProcessQueueEb+0x60>
		}

		//Flash page is already empty
		if(buffer == 0xFFFFFFFF){
   1f956:	1c53      	adds	r3, r2, #1
   1f958:	d103      	bne.n	1f962 <_ZN10NewStorage12ProcessQueueEb+0x82>
			logt("NEWSTORAGE", "page %u already erased", pageNum);
			//Pretend that the flash operation has happened
			SystemEventHandler(NRF_EVT_FLASH_OPERATION_SUCCESS);
   1f95a:	2002      	movs	r0, #2
   1f95c:	f7ff ff0c 	bl	1f778 <_ZN10NewStorage18SystemEventHandlerEm>
   1f960:	e02e      	b.n	1f9c0 <_ZN10NewStorage12ProcessQueueEb+0xe0>
		} else {
			logt("NEWSTORAGE", "erasing page %u", pageNum);
			err = sd_flash_page_erase(pageNum);
   1f962:	f7ff fb0f 	bl	1ef84 <sd_flash_page_erase>
			APP_ERROR_CHECK(err); //FIXME: NRF_ERROR_BUSY and others not handeled
   1f966:	2800      	cmp	r0, #0
   1f968:	d02a      	beq.n	1f9c0 <_ZN10NewStorage12ProcessQueueEb+0xe0>
   1f96a:	2197      	movs	r1, #151	; 0x97
   1f96c:	4a17      	ldr	r2, [pc, #92]	; (1f9cc <_ZN10NewStorage12ProcessQueueEb+0xec>)
   1f96e:	f7fd fd49 	bl	1d404 <app_error_handler>
		}
	}
	else if(
   1f972:	3a01      	subs	r2, #1
   1f974:	2a01      	cmp	r2, #1
   1f976:	d823      	bhi.n	1f9c0 <_ZN10NewStorage12ProcessQueueEb+0xe0>
	){
		NewStorageTaskItemWriteData* params = &currentTask->params.writeData;

		logt("NEWSTORAGE", "copy from %u to %u, length %u", params->dataSource, params->dataDestination, params->dataLength/4);

		err = sd_flash_write(params->dataDestination, params->dataSource, params->dataLength / 4); //FIXME: NRF_ERROR_BUSY and others not handeled
   1f978:	1c1c      	adds	r4, r3, #0
   1f97a:	3409      	adds	r4, #9
   1f97c:	7962      	ldrb	r2, [r4, #5]
   1f97e:	7925      	ldrb	r5, [r4, #4]
   1f980:	79a0      	ldrb	r0, [r4, #6]
   1f982:	0212      	lsls	r2, r2, #8
   1f984:	432a      	orrs	r2, r5
   1f986:	0400      	lsls	r0, r0, #16
   1f988:	1c11      	adds	r1, r2, #0
   1f98a:	1c02      	adds	r2, r0, #0
   1f98c:	7a5d      	ldrb	r5, [r3, #9]
   1f98e:	7863      	ldrb	r3, [r4, #1]
   1f990:	430a      	orrs	r2, r1
   1f992:	79e0      	ldrb	r0, [r4, #7]
   1f994:	78a1      	ldrb	r1, [r4, #2]
   1f996:	021b      	lsls	r3, r3, #8
   1f998:	432b      	orrs	r3, r5
   1f99a:	0409      	lsls	r1, r1, #16
   1f99c:	0600      	lsls	r0, r0, #24
   1f99e:	4310      	orrs	r0, r2
   1f9a0:	1c1a      	adds	r2, r3, #0
   1f9a2:	1c0b      	adds	r3, r1, #0
   1f9a4:	78e1      	ldrb	r1, [r4, #3]
   1f9a6:	4313      	orrs	r3, r2
   1f9a8:	0609      	lsls	r1, r1, #24
   1f9aa:	7a62      	ldrb	r2, [r4, #9]
   1f9ac:	4319      	orrs	r1, r3
   1f9ae:	7a23      	ldrb	r3, [r4, #8]
   1f9b0:	0212      	lsls	r2, r2, #8
   1f9b2:	431a      	orrs	r2, r3
   1f9b4:	0892      	lsrs	r2, r2, #2
   1f9b6:	f7ff fae7 	bl	1ef88 <sd_flash_write>
		APP_ERROR_CHECK(err);
   1f9ba:	21a3      	movs	r1, #163	; 0xa3
   1f9bc:	2800      	cmp	r0, #0
   1f9be:	d1d5      	bne.n	1f96c <_ZN10NewStorage12ProcessQueueEb+0x8c>
	}
}
   1f9c0:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
   1f9c2:	46c0      	nop			; (mov r8, r8)
   1f9c4:	20003578 	.word	0x20003578
   1f9c8:	20003584 	.word	0x20003584
   1f9cc:	00022ac3 	.word	0x00022ac3

0001f9d0 <_ZN6Logger24convertBufferToHexStringEPhmPct>:
}

//FIXME: This method does not know the destination buffer length and could crash the system
//It also lets developers run into trouble while debugging....
void Logger::convertBufferToHexString(u8* srcBuffer, u32 srcLength, char* dstBuffer, u16 bufferLength)
{
   1f9d0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1f9d2:	1c1e      	adds	r6, r3, #0
   1f9d4:	ab08      	add	r3, sp, #32
   1f9d6:	881b      	ldrh	r3, [r3, #0]
   1f9d8:	9101      	str	r1, [sp, #4]
   1f9da:	1c17      	adds	r7, r2, #0
	memset(dstBuffer, 0x00, bufferLength);
   1f9dc:	1c30      	adds	r0, r6, #0
   1f9de:	2100      	movs	r1, #0
   1f9e0:	1c1a      	adds	r2, r3, #0
}

//FIXME: This method does not know the destination buffer length and could crash the system
//It also lets developers run into trouble while debugging....
void Logger::convertBufferToHexString(u8* srcBuffer, u32 srcLength, char* dstBuffer, u16 bufferLength)
{
   1f9e2:	9300      	str	r3, [sp, #0]
	memset(dstBuffer, 0x00, bufferLength);
   1f9e4:	1c34      	adds	r4, r6, #0
   1f9e6:	f001 fe32 	bl	2164e <memset>

	char* dstBufferStart = dstBuffer;
	for (u32 i = 0; i < srcLength; i++)
   1f9ea:	2500      	movs	r5, #0
   1f9ec:	42bd      	cmp	r5, r7
   1f9ee:	d016      	beq.n	1fa1e <_ZN6Logger24convertBufferToHexStringEPhmPct+0x4e>
	{
		dstBuffer += sprintf(dstBuffer, i < srcLength - 1 ? "%02X:" : "%02X\0", srcBuffer[i]);
   1f9f0:	1e7b      	subs	r3, r7, #1
   1f9f2:	490b      	ldr	r1, [pc, #44]	; (1fa20 <_ZN6Logger24convertBufferToHexStringEPhmPct+0x50>)
   1f9f4:	429d      	cmp	r5, r3
   1f9f6:	d300      	bcc.n	1f9fa <_ZN6Logger24convertBufferToHexStringEPhmPct+0x2a>
   1f9f8:	490a      	ldr	r1, [pc, #40]	; (1fa24 <_ZN6Logger24convertBufferToHexStringEPhmPct+0x54>)
   1f9fa:	9b01      	ldr	r3, [sp, #4]
   1f9fc:	1c20      	adds	r0, r4, #0
   1f9fe:	5d5a      	ldrb	r2, [r3, r5]
   1fa00:	f001 ff28 	bl	21854 <siprintf>
		if(dstBuffer - dstBufferStart > bufferLength - 7){
   1fa04:	9b00      	ldr	r3, [sp, #0]
	memset(dstBuffer, 0x00, bufferLength);

	char* dstBufferStart = dstBuffer;
	for (u32 i = 0; i < srcLength; i++)
	{
		dstBuffer += sprintf(dstBuffer, i < srcLength - 1 ? "%02X:" : "%02X\0", srcBuffer[i]);
   1fa06:	1824      	adds	r4, r4, r0
		if(dstBuffer - dstBufferStart > bufferLength - 7){
   1fa08:	3b06      	subs	r3, #6
   1fa0a:	1ba2      	subs	r2, r4, r6
   1fa0c:	4293      	cmp	r3, r2
   1fa0e:	dc04      	bgt.n	1fa1a <_ZN6Logger24convertBufferToHexStringEPhmPct+0x4a>
			dstBuffer[0] = '.';
   1fa10:	232e      	movs	r3, #46	; 0x2e
   1fa12:	7023      	strb	r3, [r4, #0]
			dstBuffer[1] = '.';
   1fa14:	7063      	strb	r3, [r4, #1]
			dstBuffer[2] = '.';
   1fa16:	70a3      	strb	r3, [r4, #2]
   1fa18:	e001      	b.n	1fa1e <_ZN6Logger24convertBufferToHexStringEPhmPct+0x4e>
void Logger::convertBufferToHexString(u8* srcBuffer, u32 srcLength, char* dstBuffer, u16 bufferLength)
{
	memset(dstBuffer, 0x00, bufferLength);

	char* dstBufferStart = dstBuffer;
	for (u32 i = 0; i < srcLength; i++)
   1fa1a:	3501      	adds	r5, #1
   1fa1c:	e7e6      	b.n	1f9ec <_ZN6Logger24convertBufferToHexStringEPhmPct+0x1c>
			dstBuffer[1] = '.';
			dstBuffer[2] = '.';
			break;
		}
	};
}
   1fa1e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   1fa20:	00022ade 	.word	0x00022ade
   1fa24:	00022aa5 	.word	0x00022aa5

0001fa28 <_ZN6Logger8logErrorENS_10errorTypesEmt>:
	}
}

void Logger::logError(errorTypes errorType, u32 errorCode, u16 extraInfo)
{
	errorLog[errorLogPosition].errorType = errorType;
   1fa28:	200c      	movs	r0, #12
		i += fieldSize + 1;
	}
}

void Logger::logError(errorTypes errorType, u32 errorCode, u16 extraInfo)
{
   1fa2a:	b570      	push	{r4, r5, r6, lr}
	errorLog[errorLogPosition].errorType = errorType;
   1fa2c:	4d08      	ldr	r5, [pc, #32]	; (1fa50 <_ZN6Logger8logErrorENS_10errorTypesEmt+0x28>)
   1fa2e:	4e09      	ldr	r6, [pc, #36]	; (1fa54 <_ZN6Logger8logErrorENS_10errorTypesEmt+0x2c>)
   1fa30:	782c      	ldrb	r4, [r5, #0]
   1fa32:	4360      	muls	r0, r4
   1fa34:	5581      	strb	r1, [r0, r6]
	errorLog[errorLogPosition].errorCode = errorCode;
   1fa36:	1831      	adds	r1, r6, r0
	errorLog[errorLogPosition].extraInfo = extraInfo;
   1fa38:	804b      	strh	r3, [r1, #2]


	public:
		static Node* getInstance()
		{
			return instance;
   1fa3a:	4b07      	ldr	r3, [pc, #28]	; (1fa58 <_ZN6Logger8logErrorENS_10errorTypesEmt+0x30>)
}

void Logger::logError(errorTypes errorType, u32 errorCode, u16 extraInfo)
{
	errorLog[errorLogPosition].errorType = errorType;
	errorLog[errorLogPosition].errorCode = errorCode;
   1fa3c:	604a      	str	r2, [r1, #4]
	errorLog[errorLogPosition].extraInfo = extraInfo;
	errorLog[errorLogPosition].timestamp = Node::getInstance()->globalTimeSec;
   1fa3e:	681b      	ldr	r3, [r3, #0]
   1fa40:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   1fa42:	608b      	str	r3, [r1, #8]

	//Will fill the error log until the last entry (last entry does get overwritten with latest value)
	if(errorLogPosition < NUM_ERROR_LOG_ENTRIES-1) errorLogPosition++;
   1fa44:	2c08      	cmp	r4, #8
   1fa46:	d801      	bhi.n	1fa4c <_ZN6Logger8logErrorENS_10errorTypesEmt+0x24>
   1fa48:	3401      	adds	r4, #1
   1fa4a:	702c      	strb	r4, [r5, #0]
}
   1fa4c:	bd70      	pop	{r4, r5, r6, pc}
   1fa4e:	46c0      	nop			; (mov r8, r8)
   1fa50:	20003574 	.word	0x20003574
   1fa54:	200034ac 	.word	0x200034ac
   1fa58:	200033d8 	.word	0x200033d8

0001fa5c <_ZN7Utility16GetRandomIntegerEv>:
#include <stdlib.h>
#include <malloc.h>
}

u32 Utility::GetRandomInteger(void)
{
   1fa5c:	b513      	push	{r0, r1, r4, lr}
   1fa5e:	4c07      	ldr	r4, [pc, #28]	; (1fa7c <_ZN7Utility16GetRandomIntegerEv+0x20>)
	u32 err = NRF_ERROR_BUSY;
	u32 counter = 0;
	u32 randomNumber;

	while(err != NRF_SUCCESS){
		err = sd_rand_application_vector_get((u8*) &randomNumber, 4);
   1fa60:	a801      	add	r0, sp, #4
   1fa62:	2104      	movs	r1, #4
   1fa64:	3c01      	subs	r4, #1
   1fa66:	f7ff fa91 	bl	1ef8c <sd_rand_application_vector_get>
		counter++;

		if(counter > 100000){
   1fa6a:	2c00      	cmp	r4, #0
   1fa6c:	d003      	beq.n	1fa76 <_ZN7Utility16GetRandomIntegerEv+0x1a>
{
	u32 err = NRF_ERROR_BUSY;
	u32 counter = 0;
	u32 randomNumber;

	while(err != NRF_SUCCESS){
   1fa6e:	2800      	cmp	r0, #0
   1fa70:	d1f6      	bne.n	1fa60 <_ZN7Utility16GetRandomIntegerEv+0x4>
			logt("ERROR", "Random number generator is pigheaded and does not deliver random numbers...");
			return 5;
		}
	}

	return randomNumber;
   1fa72:	9801      	ldr	r0, [sp, #4]
   1fa74:	e000      	b.n	1fa78 <_ZN7Utility16GetRandomIntegerEv+0x1c>
		err = sd_rand_application_vector_get((u8*) &randomNumber, 4);
		counter++;

		if(counter > 100000){
			logt("ERROR", "Random number generator is pigheaded and does not deliver random numbers...");
			return 5;
   1fa76:	2005      	movs	r0, #5
		}
	}

	return randomNumber;
}
   1fa78:	bd16      	pop	{r1, r2, r4, pc}
   1fa7a:	46c0      	nop			; (mov r8, r8)
   1fa7c:	000186a1 	.word	0x000186a1

0001fa80 <_ZN12SimpleBuffer10PeekItemAtEt>:
	
	return this->readPointer;
}

u8* SimpleBuffer::PeekItemAt(u16 position){
	if(position >= _numElements) return NULL;
   1fa80:	8a02      	ldrh	r2, [r0, #16]
   1fa82:	2300      	movs	r3, #0
   1fa84:	428a      	cmp	r2, r1
   1fa86:	d903      	bls.n	1fa90 <_ZN12SimpleBuffer10PeekItemAtEt+0x10>
	
	return this->buffer + itemLength * position;
   1fa88:	88c3      	ldrh	r3, [r0, #6]
   1fa8a:	6802      	ldr	r2, [r0, #0]
   1fa8c:	4359      	muls	r1, r3
   1fa8e:	1853      	adds	r3, r2, r1
}
   1fa90:	1c18      	adds	r0, r3, #0
   1fa92:	4770      	bx	lr

0001fa94 <_ZN10Connection14StartHandshakeEv>:

	//TODO: do we have to get the tx_packet_count or update any other variables?
}

void Connection::StartHandshake(void)
{
   1fa94:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	if (connectionState >= ConnectionState::HANDSHAKING)
   1fa96:	7a03      	ldrb	r3, [r0, #8]
   1fa98:	2b02      	cmp	r3, #2
   1fa9a:	d844      	bhi.n	1fb26 <_ZN10Connection14StartHandshakeEv+0x92>
	}


	logt("HANDSHAKE", "############ Handshake starting ###############");

	connectionState = ConnectionState::HANDSHAKING;
   1fa9c:	2303      	movs	r3, #3
   1fa9e:	7203      	strb	r3, [r0, #8]

	//After the Handles have been discovered, we start the Handshake
	connPacketClusterWelcome packet;
	packet.header.messageType = MESSAGE_TYPE_CLUSTER_WELCOME;
   1faa0:	466b      	mov	r3, sp
   1faa2:	781a      	ldrb	r2, [r3, #0]
   1faa4:	2301      	movs	r3, #1
   1faa6:	4013      	ands	r3, r2
   1faa8:	2228      	movs	r2, #40	; 0x28
   1faaa:	4313      	orrs	r3, r2
   1faac:	466a      	mov	r2, sp
   1faae:	7013      	strb	r3, [r2, #0]
	packet.header.sender = node->persistentConfig.nodeId;
   1fab0:	6803      	ldr	r3, [r0, #0]
   1fab2:	1c01      	adds	r1, r0, #0
   1fab4:	1dd8      	adds	r0, r3, #7
   1fab6:	7fc0      	ldrb	r0, [r0, #31]
   1fab8:	3308      	adds	r3, #8
   1faba:	7050      	strb	r0, [r2, #1]
   1fabc:	7fdb      	ldrb	r3, [r3, #31]
   1fabe:	7093      	strb	r3, [r2, #2]
	packet.header.receiver = NODE_ID_HOPS_BASE + 1; //Node id is unknown, but this allows us to send the packet only 1 hop
   1fac0:	466b      	mov	r3, sp
   1fac2:	2231      	movs	r2, #49	; 0x31
   1fac4:	70da      	strb	r2, [r3, #3]
   1fac6:	3244      	adds	r2, #68	; 0x44
   1fac8:	711a      	strb	r2, [r3, #4]

	packet.payload.clusterId = clusterIDBackup;
   1faca:	466b      	mov	r3, sp
   1facc:	328c      	adds	r2, #140	; 0x8c
   1face:	32ff      	adds	r2, #255	; 0xff
   1fad0:	5c8a      	ldrb	r2, [r1, r2]
   1fad2:	715a      	strb	r2, [r3, #5]
   1fad4:	2280      	movs	r2, #128	; 0x80
   1fad6:	0092      	lsls	r2, r2, #2
   1fad8:	188a      	adds	r2, r1, r2
   1fada:	7850      	ldrb	r0, [r2, #1]
   1fadc:	7198      	strb	r0, [r3, #6]
   1fade:	7890      	ldrb	r0, [r2, #2]
   1fae0:	78d2      	ldrb	r2, [r2, #3]
   1fae2:	71d8      	strb	r0, [r3, #7]
   1fae4:	721a      	strb	r2, [r3, #8]
	packet.payload.clusterSize = clusterSizeBackup;
   1fae6:	2281      	movs	r2, #129	; 0x81
   1fae8:	2309      	movs	r3, #9
   1faea:	0092      	lsls	r2, r2, #2
   1faec:	5c8a      	ldrb	r2, [r1, r2]
   1faee:	446b      	add	r3, sp
   1faf0:	701a      	strb	r2, [r3, #0]
   1faf2:	2281      	movs	r2, #129	; 0x81
   1faf4:	0092      	lsls	r2, r2, #2
   1faf6:	188a      	adds	r2, r1, r2
   1faf8:	7852      	ldrb	r2, [r2, #1]
   1fafa:	705a      	strb	r2, [r3, #1]
	packet.payload.meshWriteHandle = GATTController::getMeshWriteHandle(); //Our own write handle
   1fafc:	230b      	movs	r3, #11
   1fafe:	4a0b      	ldr	r2, [pc, #44]	; (1fb2c <_ZN10Connection14StartHandshakeEv+0x98>)
   1fb00:	446b      	add	r3, sp
   1fb02:	7a90      	ldrb	r0, [r2, #10]
   1fb04:	7018      	strb	r0, [r3, #0]
   1fb06:	7ad2      	ldrb	r2, [r2, #11]
	packet.payload.hopsToSink = hopsToSinkBackup;


	logt("HANDSHAKE", "OUT => conn(%u) CLUSTER_WELCOME, cID:%x, cSize:%d", connectionId, packet.payload.clusterId, packet.payload.clusterSize);

	cm->SendHandshakeMessage(this, (u8*) &packet, SIZEOF_CONN_PACKET_CLUSTER_WELCOME, true);
   1fb08:	6848      	ldr	r0, [r1, #4]
	packet.header.sender = node->persistentConfig.nodeId;
	packet.header.receiver = NODE_ID_HOPS_BASE + 1; //Node id is unknown, but this allows us to send the packet only 1 hop

	packet.payload.clusterId = clusterIDBackup;
	packet.payload.clusterSize = clusterSizeBackup;
	packet.payload.meshWriteHandle = GATTController::getMeshWriteHandle(); //Our own write handle
   1fb0a:	705a      	strb	r2, [r3, #1]

	//Now we set the hop counter to the closest sink
	//If we are sink ourself, we set it to 1, otherwise we use our
	//shortest path to reach a sink and increment it by one.
	//If there is no known sink, we set it to 0.
	packet.payload.hopsToSink = hopsToSinkBackup;
   1fb0c:	230d      	movs	r3, #13
   1fb0e:	4a08      	ldr	r2, [pc, #32]	; (1fb30 <_ZN10Connection14StartHandshakeEv+0x9c>)
   1fb10:	446b      	add	r3, sp
   1fb12:	5c8a      	ldrb	r2, [r1, r2]
   1fb14:	701a      	strb	r2, [r3, #0]
   1fb16:	4a06      	ldr	r2, [pc, #24]	; (1fb30 <_ZN10Connection14StartHandshakeEv+0x9c>)
   1fb18:	188a      	adds	r2, r1, r2
   1fb1a:	7852      	ldrb	r2, [r2, #1]
   1fb1c:	705a      	strb	r2, [r3, #1]


	logt("HANDSHAKE", "OUT => conn(%u) CLUSTER_WELCOME, cID:%x, cSize:%d", connectionId, packet.payload.clusterId, packet.payload.clusterSize);

	cm->SendHandshakeMessage(this, (u8*) &packet, SIZEOF_CONN_PACKET_CLUSTER_WELCOME, true);
   1fb1e:	466a      	mov	r2, sp
   1fb20:	2310      	movs	r3, #16
   1fb22:	f7ff fb7d 	bl	1f220 <_ZN17ConnectionManager20SendHandshakeMessageEP10ConnectionPhtb.constprop.7>

}
   1fb26:	b005      	add	sp, #20
   1fb28:	bd00      	pop	{pc}
   1fb2a:	46c0      	nop			; (mov r8, r8)
   1fb2c:	2000358a 	.word	0x2000358a
   1fb30:	00000206 	.word	0x00000206

0001fb34 <_ZN10Connection10DisconnectEv>:

void Connection::Disconnect()
{
	//Save connection state before disconnection
	connectionStateBeforeDisconnection = connectionState;
	connectionState = ConnectionState::DISCONNECTED;
   1fb34:	2200      	movs	r2, #0
{
	GATTController::bleDiscoverHandles(connectionHandle);
}

void Connection::Disconnect()
{
   1fb36:	b508      	push	{r3, lr}
	//Save connection state before disconnection
	connectionStateBeforeDisconnection = connectionState;
   1fb38:	7a03      	ldrb	r3, [r0, #8]
{
	GATTController::bleDiscoverHandles(connectionHandle);
}

void Connection::Disconnect()
{
   1fb3a:	1c01      	adds	r1, r0, #0
	//Save connection state before disconnection
	connectionStateBeforeDisconnection = connectionState;
   1fb3c:	7283      	strb	r3, [r0, #10]
	connectionState = ConnectionState::DISCONNECTED;
   1fb3e:	7202      	strb	r2, [r0, #8]
	//FIXME: This method should be able to disconnect an active connection and disconnect a connection that is in the CONNECTING state

	if(connectionStateBeforeDisconnection == ConnectionState::REESTABLISHING){
   1fb40:	2b05      	cmp	r3, #5
   1fb42:	d103      	bne.n	1fb4c <_ZN10Connection10DisconnectEv+0x18>
		//A disconnect on a reestablishing connection will kill it
		cm->FinalDisconnectionHandler(this);
   1fb44:	6840      	ldr	r0, [r0, #4]
   1fb46:	f7fd ff8f 	bl	1da68 <_ZN17ConnectionManager25FinalDisconnectionHandlerEP10Connection>
   1fb4a:	e005      	b.n	1fb58 <_ZN10Connection10DisconnectEv+0x24>
	} else {
		GAPController::disconnectFromPartner(connectionHandle);
   1fb4c:	23e9      	movs	r3, #233	; 0xe9
   1fb4e:	005b      	lsls	r3, r3, #1
//Disconnect from paired peripheral
void GAPController::disconnectFromPartner(u16 connectionHandle)
{
	u32 err = 0;

	err = sd_ble_gap_disconnect(connectionHandle, BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION);
   1fb50:	5ac0      	ldrh	r0, [r0, r3]
   1fb52:	2113      	movs	r1, #19
   1fb54:	f7fd fc06 	bl	1d364 <sd_ble_gap_disconnect.lto_priv.67>
	}
}
   1fb58:	bd08      	pop	{r3, pc}
	...

0001fb5c <_ZN10Connection11ResetValuesEv>:

	ResetValues();
}

void Connection::ResetValues(){
	connectedClusterId = 0;
   1fb5c:	2383      	movs	r3, #131	; 0x83
	this->packetSendQueue = new PacketQueue(packetSendBuffer, PACKET_SEND_BUFFER_SIZE);

	ResetValues();
}

void Connection::ResetValues(){
   1fb5e:	b570      	push	{r4, r5, r6, lr}
	connectedClusterId = 0;
   1fb60:	2500      	movs	r5, #0
   1fb62:	009b      	lsls	r3, r3, #2
   1fb64:	50c5      	str	r5, [r0, r3]
	unreliableBuffersFree = 0;
	reliableBuffersFree = 1;
   1fb66:	2301      	movs	r3, #1
	partnerId = 0;
	connectionHandle = BLE_CONN_HANDLE_INVALID;
   1fb68:	2601      	movs	r6, #1
}

void Connection::ResetValues(){
	connectedClusterId = 0;
	unreliableBuffersFree = 0;
	reliableBuffersFree = 1;
   1fb6a:	7503      	strb	r3, [r0, #20]
	partnerId = 0;
   1fb6c:	33d0      	adds	r3, #208	; 0xd0
   1fb6e:	33ff      	adds	r3, #255	; 0xff
	ResetValues();
}

void Connection::ResetValues(){
	connectedClusterId = 0;
	unreliableBuffersFree = 0;
   1fb70:	74c5      	strb	r5, [r0, #19]
	reliableBuffersFree = 1;
	partnerId = 0;
	connectionHandle = BLE_CONN_HANDLE_INVALID;
   1fb72:	4276      	negs	r6, r6

void Connection::ResetValues(){
	connectedClusterId = 0;
	unreliableBuffersFree = 0;
	reliableBuffersFree = 1;
	partnerId = 0;
   1fb74:	52c5      	strh	r5, [r0, r3]
	connectionHandle = BLE_CONN_HANDLE_INVALID;
   1fb76:	3302      	adds	r3, #2
   1fb78:	52c6      	strh	r6, [r0, r3]

	connectedClusterSize = 0;
   1fb7a:	333e      	adds	r3, #62	; 0x3e
   1fb7c:	52c5      	strh	r5, [r0, r3]
	packetReassemblyPosition = 0;
   1fb7e:	23d0      	movs	r3, #208	; 0xd0
   1fb80:	33ff      	adds	r3, #255	; 0xff
   1fb82:	54c5      	strb	r5, [r0, r3]
	packetSendPosition = 0;
   1fb84:	3b87      	subs	r3, #135	; 0x87
   1fb86:	54c5      	strb	r5, [r0, r3]
	currentConnectionIntervalMs = 0;
   1fb88:	3396      	adds	r3, #150	; 0x96
   1fb8a:	52c5      	strh	r5, [r0, r3]

	disconnectedTimestampDs = 0;
   1fb8c:	3306      	adds	r3, #6
   1fb8e:	50c5      	str	r5, [r0, r3]
	this->packetSendQueue = new PacketQueue(packetSendBuffer, PACKET_SEND_BUFFER_SIZE);

	ResetValues();
}

void Connection::ResetValues(){
   1fb90:	1c04      	adds	r4, r0, #0
	packetReassemblyPosition = 0;
	packetSendPosition = 0;
	currentConnectionIntervalMs = 0;

	disconnectedTimestampDs = 0;
	reestablishTimeSec = Config->meshExtendedConnectionTimeoutSec;
   1fb92:	f001 f949 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1fb96:	23f4      	movs	r3, #244	; 0xf4
   1fb98:	8a02      	ldrh	r2, [r0, #16]
	connectionState = ConnectionState::DISCONNECTED;
	encryptionState = EncryptionState::NOT_ENCRYPTED;

	connectionMasterBit = 0;

	memset(&clusterAck1Packet, 0x00, sizeof(connPacketClusterAck1));
   1fb9a:	1c20      	adds	r0, r4, #0
	packetReassemblyPosition = 0;
	packetSendPosition = 0;
	currentConnectionIntervalMs = 0;

	disconnectedTimestampDs = 0;
	reestablishTimeSec = Config->meshExtendedConnectionTimeoutSec;
   1fb9c:	005b      	lsls	r3, r3, #1
   1fb9e:	52e2      	strh	r2, [r4, r3]
	connectionState = ConnectionState::DISCONNECTED;
	encryptionState = EncryptionState::NOT_ENCRYPTED;

	connectionMasterBit = 0;

	memset(&clusterAck1Packet, 0x00, sizeof(connPacketClusterAck1));
   1fba0:	30eb      	adds	r0, #235	; 0xeb
	reestablishTimeSec = Config->meshExtendedConnectionTimeoutSec;

	connectionState = ConnectionState::DISCONNECTED;
	encryptionState = EncryptionState::NOT_ENCRYPTED;

	connectionMasterBit = 0;
   1fba2:	3320      	adds	r3, #32
	currentConnectionIntervalMs = 0;

	disconnectedTimestampDs = 0;
	reestablishTimeSec = Config->meshExtendedConnectionTimeoutSec;

	connectionState = ConnectionState::DISCONNECTED;
   1fba4:	7225      	strb	r5, [r4, #8]
	encryptionState = EncryptionState::NOT_ENCRYPTED;
   1fba6:	7265      	strb	r5, [r4, #9]

	connectionMasterBit = 0;

	memset(&clusterAck1Packet, 0x00, sizeof(connPacketClusterAck1));
   1fba8:	1c29      	adds	r1, r5, #0
	reestablishTimeSec = Config->meshExtendedConnectionTimeoutSec;

	connectionState = ConnectionState::DISCONNECTED;
	encryptionState = EncryptionState::NOT_ENCRYPTED;

	connectionMasterBit = 0;
   1fbaa:	54e5      	strb	r5, [r4, r3]

	memset(&clusterAck1Packet, 0x00, sizeof(connPacketClusterAck1));
   1fbac:	2208      	movs	r2, #8
   1fbae:	30ff      	adds	r0, #255	; 0xff
   1fbb0:	f001 fd4d 	bl	2164e <memset>
	memset(&clusterAck2Packet, 0x00, sizeof(connPacketClusterAck2));
   1fbb4:	1c20      	adds	r0, r4, #0
   1fbb6:	30f3      	adds	r0, #243	; 0xf3
   1fbb8:	1c29      	adds	r1, r5, #0
   1fbba:	220d      	movs	r2, #13
   1fbbc:	30ff      	adds	r0, #255	; 0xff
   1fbbe:	f001 fd46 	bl	2164e <memset>

	handshakeStartedDs = 0;
   1fbc2:	2385      	movs	r3, #133	; 0x85

	droppedPackets = 0;
	sentReliable = 0;
	sentUnreliable = 0;

	memset(&currentClusterInfoUpdatePacket, 0x00, sizeof(currentClusterInfoUpdatePacket));
   1fbc4:	1c20      	adds	r0, r4, #0
	connectionMasterBit = 0;

	memset(&clusterAck1Packet, 0x00, sizeof(connPacketClusterAck1));
	memset(&clusterAck2Packet, 0x00, sizeof(connPacketClusterAck2));

	handshakeStartedDs = 0;
   1fbc6:	009b      	lsls	r3, r3, #2
   1fbc8:	50e5      	str	r5, [r4, r3]
	writeCharacteristicHandle = BLE_GATT_HANDLE_INVALID;
   1fbca:	3b38      	subs	r3, #56	; 0x38
   1fbcc:	52e5      	strh	r5, [r4, r3]

	rssiSamplesNum = 0;
	rssiSamplesSum = 0;
	rssiAverage = 0;

	clusterIDBackup = 0;
   1fbce:	3324      	adds	r3, #36	; 0x24
	memset(&clusterAck2Packet, 0x00, sizeof(connPacketClusterAck2));

	handshakeStartedDs = 0;
	writeCharacteristicHandle = BLE_GATT_HANDLE_INVALID;

	rssiSamplesNum = 0;
   1fbd0:	8225      	strh	r5, [r4, #16]
	rssiSamplesSum = 0;
   1fbd2:	81e5      	strh	r5, [r4, #14]
	rssiAverage = 0;
   1fbd4:	74a5      	strb	r5, [r4, #18]

	clusterIDBackup = 0;
   1fbd6:	50e5      	str	r5, [r4, r3]
	clusterSizeBackup = 0;
   1fbd8:	3304      	adds	r3, #4
   1fbda:	52e5      	strh	r5, [r4, r3]
	hopsToSinkBackup = -1;
   1fbdc:	4b10      	ldr	r3, [pc, #64]	; (1fc20 <_ZN10Connection11ResetValuesEv+0xc4>)

	droppedPackets = 0;
	sentReliable = 0;
	sentUnreliable = 0;

	memset(&currentClusterInfoUpdatePacket, 0x00, sizeof(currentClusterInfoUpdatePacket));
   1fbde:	305e      	adds	r0, #94	; 0x5e
	rssiSamplesSum = 0;
	rssiAverage = 0;

	clusterIDBackup = 0;
	clusterSizeBackup = 0;
	hopsToSinkBackup = -1;
   1fbe0:	52e6      	strh	r6, [r4, r3]

	connectionStateBeforeDisconnection = ConnectionState::DISCONNECTED;
	disconnectionReason = BLE_HCI_STATUS_CODE_SUCCESS;

	hopsToSink = -1;
   1fbe2:	4b10      	ldr	r3, [pc, #64]	; (1fc24 <_ZN10Connection11ResetValuesEv+0xc8>)

	clusterIDBackup = 0;
	clusterSizeBackup = 0;
	hopsToSinkBackup = -1;

	connectionStateBeforeDisconnection = ConnectionState::DISCONNECTED;
   1fbe4:	72a5      	strb	r5, [r4, #10]
	disconnectionReason = BLE_HCI_STATUS_CODE_SUCCESS;
   1fbe6:	72e5      	strb	r5, [r4, #11]

	hopsToSink = -1;
   1fbe8:	52e6      	strh	r6, [r4, r3]

	droppedPackets = 0;
   1fbea:	3306      	adds	r3, #6
   1fbec:	52e5      	strh	r5, [r4, r3]
	sentReliable = 0;
   1fbee:	4b0e      	ldr	r3, [pc, #56]	; (1fc28 <_ZN10Connection11ResetValuesEv+0xcc>)
	sentUnreliable = 0;

	memset(&currentClusterInfoUpdatePacket, 0x00, sizeof(currentClusterInfoUpdatePacket));
   1fbf0:	1c29      	adds	r1, r5, #0
	disconnectionReason = BLE_HCI_STATUS_CODE_SUCCESS;

	hopsToSink = -1;

	droppedPackets = 0;
	sentReliable = 0;
   1fbf2:	52e5      	strh	r5, [r4, r3]
	sentUnreliable = 0;
   1fbf4:	3302      	adds	r3, #2
   1fbf6:	52e5      	strh	r5, [r4, r3]

	memset(&currentClusterInfoUpdatePacket, 0x00, sizeof(currentClusterInfoUpdatePacket));
   1fbf8:	220e      	movs	r2, #14
   1fbfa:	30ff      	adds	r0, #255	; 0xff
   1fbfc:	f001 fd27 	bl	2164e <memset>
	memset(&lastSentPacket, 0x00, MAX_DATA_SIZE_PER_WRITE);
   1fc00:	1c20      	adds	r0, r4, #0
   1fc02:	304a      	adds	r0, #74	; 0x4a
   1fc04:	1c29      	adds	r1, r5, #0
   1fc06:	2214      	movs	r2, #20

	this->packetSendQueue->Clean();
   1fc08:	34fc      	adds	r4, #252	; 0xfc
	droppedPackets = 0;
	sentReliable = 0;
	sentUnreliable = 0;

	memset(&currentClusterInfoUpdatePacket, 0x00, sizeof(currentClusterInfoUpdatePacket));
	memset(&lastSentPacket, 0x00, MAX_DATA_SIZE_PER_WRITE);
   1fc0a:	30ff      	adds	r0, #255	; 0xff
   1fc0c:	f001 fd1f 	bl	2164e <memset>

	this->packetSendQueue->Clean();
   1fc10:	6ca3      	ldr	r3, [r4, #72]	; 0x48

void PacketQueue::Clean(void)
{
	_numElements = 0;
	this->readPointer = this->bufferStart;
   1fc12:	681a      	ldr	r2, [r3, #0]
	_numElements--;
}

void PacketQueue::Clean(void)
{
	_numElements = 0;
   1fc14:	829d      	strh	r5, [r3, #20]
	this->readPointer = this->bufferStart;
   1fc16:	60da      	str	r2, [r3, #12]
	this->writePointer = this->bufferStart;
   1fc18:	611a      	str	r2, [r3, #16]
	this->writePointer[0] = 0;
   1fc1a:	7015      	strb	r5, [r2, #0]
}
   1fc1c:	bd70      	pop	{r4, r5, r6, pc}
   1fc1e:	46c0      	nop			; (mov r8, r8)
   1fc20:	00000206 	.word	0x00000206
   1fc24:	00000212 	.word	0x00000212
   1fc28:	0000021a 	.word	0x0000021a

0001fc2c <sd_ble_tx_packet_count_get.lto_priv.70>:
 *
 * @retval ::NRF_SUCCESS Number of application transmission packets retrieved successfully.
 * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
 * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
 */
SVCALL(SD_BLE_TX_PACKET_COUNT_GET, uint32_t, sd_ble_tx_packet_count_get(uint16_t conn_handle, uint8_t *p_count));
   1fc2c:	df62      	svc	98	; 0x62
   1fc2e:	4770      	bx	lr

0001fc30 <_ZN17ConnectionManager21GetHopsToShortestSinkEP10Connection>:
	}
	return c;
}

clusterSIZE ConnectionManager::GetHopsToShortestSink(Connection* excludeConnection)
{
   1fc30:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if(node->persistentConfig.deviceType == deviceTypes::DEVICE_TYPE_SINK){
   1fc32:	6843      	ldr	r3, [r0, #4]
   1fc34:	333a      	adds	r3, #58	; 0x3a
   1fc36:	781a      	ldrb	r2, [r3, #0]
		logt("SINK", "HOPS 0, clID:%x, clSize:%d", node->clusterId, node->clusterSize);
			return 0;
   1fc38:	2300      	movs	r3, #0
	return c;
}

clusterSIZE ConnectionManager::GetHopsToShortestSink(Connection* excludeConnection)
{
	if(node->persistentConfig.deviceType == deviceTypes::DEVICE_TYPE_SINK){
   1fc3a:	2a02      	cmp	r2, #2
   1fc3c:	d025      	beq.n	1fc8a <_ZN17ConnectionManager21GetHopsToShortestSinkEP10Connection+0x5a>
   1fc3e:	1c0e      	adds	r6, r1, #0
   1fc40:	1c1c      	adds	r4, r3, #0
   1fc42:	1c1d      	adds	r5, r3, #0
   1fc44:	4f12      	ldr	r7, [pc, #72]	; (1fc90 <_ZN17ConnectionManager21GetHopsToShortestSinkEP10Connection+0x60>)
   1fc46:	9001      	str	r0, [sp, #4]
			return 0;
		} else {

			clusterSIZE min = INT16_MAX;
			Connection* c = NULL;
			for(int i=0; i<Config->meshMaxConnections; i++){
   1fc48:	f001 f8ee 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1fc4c:	3035      	adds	r0, #53	; 0x35
   1fc4e:	7803      	ldrb	r3, [r0, #0]
   1fc50:	429c      	cmp	r4, r3
   1fc52:	da14      	bge.n	1fc7e <_ZN17ConnectionManager21GetHopsToShortestSinkEP10Connection+0x4e>
   1fc54:	9a01      	ldr	r2, [sp, #4]
   1fc56:	00a3      	lsls	r3, r4, #2
   1fc58:	18d3      	adds	r3, r2, r3
				if(connections[i] == excludeConnection || !connections[i]->isConnected()) continue;
   1fc5a:	6a1b      	ldr	r3, [r3, #32]
   1fc5c:	42b3      	cmp	r3, r6
   1fc5e:	d00c      	beq.n	1fc7a <_ZN17ConnectionManager21GetHopsToShortestSinkEP10Connection+0x4a>
   1fc60:	7a1a      	ldrb	r2, [r3, #8]
   1fc62:	2a01      	cmp	r2, #1
   1fc64:	d909      	bls.n	1fc7a <_ZN17ConnectionManager21GetHopsToShortestSinkEP10Connection+0x4a>
				if(connections[i]->hopsToSink > -1 && connections[i]->hopsToSink < min){
   1fc66:	4a0b      	ldr	r2, [pc, #44]	; (1fc94 <_ZN17ConnectionManager21GetHopsToShortestSinkEP10Connection+0x64>)
   1fc68:	5a99      	ldrh	r1, [r3, r2]
   1fc6a:	b20a      	sxth	r2, r1
   1fc6c:	2a00      	cmp	r2, #0
   1fc6e:	db04      	blt.n	1fc7a <_ZN17ConnectionManager21GetHopsToShortestSinkEP10Connection+0x4a>
   1fc70:	b238      	sxth	r0, r7
   1fc72:	4282      	cmp	r2, r0
   1fc74:	da01      	bge.n	1fc7a <_ZN17ConnectionManager21GetHopsToShortestSinkEP10Connection+0x4a>
   1fc76:	1c1d      	adds	r5, r3, #0
   1fc78:	1c0f      	adds	r7, r1, #0
			return 0;
		} else {

			clusterSIZE min = INT16_MAX;
			Connection* c = NULL;
			for(int i=0; i<Config->meshMaxConnections; i++){
   1fc7a:	3401      	adds	r4, #1
   1fc7c:	e7e4      	b.n	1fc48 <_ZN17ConnectionManager21GetHopsToShortestSinkEP10Connection+0x18>
					c = connections[i];
				}
			}

			logt("SINK", "HOPS %d, clID:%x, clSize:%d", (c == NULL) ? -1 : c->hopsToSink, node->clusterId, node->clusterSize);
			return (c == NULL) ? -1 : c->hopsToSink;
   1fc7e:	2d00      	cmp	r5, #0
   1fc80:	d002      	beq.n	1fc88 <_ZN17ConnectionManager21GetHopsToShortestSinkEP10Connection+0x58>
   1fc82:	4b04      	ldr	r3, [pc, #16]	; (1fc94 <_ZN17ConnectionManager21GetHopsToShortestSinkEP10Connection+0x64>)
   1fc84:	5aeb      	ldrh	r3, [r5, r3]
   1fc86:	e000      	b.n	1fc8a <_ZN17ConnectionManager21GetHopsToShortestSinkEP10Connection+0x5a>
   1fc88:	4b03      	ldr	r3, [pc, #12]	; (1fc98 <_ZN17ConnectionManager21GetHopsToShortestSinkEP10Connection+0x68>)
   1fc8a:	b218      	sxth	r0, r3
		}
}
   1fc8c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1fc8e:	46c0      	nop			; (mov r8, r8)
   1fc90:	00007fff 	.word	0x00007fff
   1fc94:	00000212 	.word	0x00000212
   1fc98:	0000ffff 	.word	0x0000ffff

0001fc9c <_ZN10Connection17PrepareConnectionEP14ble_gap_addr_tt>:

//Once a connection has been connected in the connection manager, these parameters
//Are passed to the connect function
bool Connection::PrepareConnection(ble_gap_addr_t* address, u16 writeCharacteristicHandle)
{
   1fc9c:	b570      	push	{r4, r5, r6, lr}
   1fc9e:	1c04      	adds	r4, r0, #0
   1fca0:	1c0e      	adds	r6, r1, #0
   1fca2:	1c15      	adds	r5, r2, #0
	ResetValues();
   1fca4:	f7ff ff5a 	bl	1fb5c <_ZN10Connection11ResetValuesEv>

	memcpy(&partnerAddress, address, sizeof(ble_gap_addr_t));
   1fca8:	1c20      	adds	r0, r4, #0
   1fcaa:	30d5      	adds	r0, #213	; 0xd5
   1fcac:	1c31      	adds	r1, r6, #0
   1fcae:	2207      	movs	r2, #7
   1fcb0:	30ff      	adds	r0, #255	; 0xff
   1fcb2:	f001 fcaf 	bl	21614 <memcpy>
	this->writeCharacteristicHandle = writeCharacteristicHandle;
   1fcb6:	23ee      	movs	r3, #238	; 0xee
	this->connectionState = ConnectionState::CONNECTING;

	//Save a snapshot of the current clustering values, these are used in the handshake
	//Changes to these values are only sent after the handshake has finished and the handshake
	//must not use values that are saved in the node because these might have changed in the meantime
	clusterIDBackup = node->clusterId;
   1fcb8:	2280      	movs	r2, #128	; 0x80
bool Connection::PrepareConnection(ble_gap_addr_t* address, u16 writeCharacteristicHandle)
{
	ResetValues();

	memcpy(&partnerAddress, address, sizeof(ble_gap_addr_t));
	this->writeCharacteristicHandle = writeCharacteristicHandle;
   1fcba:	005b      	lsls	r3, r3, #1
   1fcbc:	52e5      	strh	r5, [r4, r3]

	this->connectionState = ConnectionState::CONNECTING;
   1fcbe:	2501      	movs	r5, #1

	//Save a snapshot of the current clustering values, these are used in the handshake
	//Changes to these values are only sent after the handshake has finished and the handshake
	//must not use values that are saved in the node because these might have changed in the meantime
	clusterIDBackup = node->clusterId;
   1fcc0:	6823      	ldr	r3, [r4, #0]
   1fcc2:	0092      	lsls	r2, r2, #2
   1fcc4:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
	ResetValues();

	memcpy(&partnerAddress, address, sizeof(ble_gap_addr_t));
	this->writeCharacteristicHandle = writeCharacteristicHandle;

	this->connectionState = ConnectionState::CONNECTING;
   1fcc6:	7225      	strb	r5, [r4, #8]

	//Save a snapshot of the current clustering values, these are used in the handshake
	//Changes to these values are only sent after the handshake has finished and the handshake
	//must not use values that are saved in the node because these might have changed in the meantime
	clusterIDBackup = node->clusterId;
	clusterSizeBackup = node->clusterSize;
   1fcc8:	3378      	adds	r3, #120	; 0x78
	this->connectionState = ConnectionState::CONNECTING;

	//Save a snapshot of the current clustering values, these are used in the handshake
	//Changes to these values are only sent after the handshake has finished and the handshake
	//must not use values that are saved in the node because these might have changed in the meantime
	clusterIDBackup = node->clusterId;
   1fcca:	50a1      	str	r1, [r4, r2]
	clusterSizeBackup = node->clusterSize;
   1fccc:	881a      	ldrh	r2, [r3, #0]
   1fcce:	2381      	movs	r3, #129	; 0x81
   1fcd0:	009b      	lsls	r3, r3, #2
   1fcd2:	52e2      	strh	r2, [r4, r3]
	hopsToSinkBackup = cm->GetHopsToShortestSink(this);
   1fcd4:	6860      	ldr	r0, [r4, #4]
   1fcd6:	1c21      	adds	r1, r4, #0
   1fcd8:	f7ff ffaa 	bl	1fc30 <_ZN17ConnectionManager21GetHopsToShortestSinkEP10Connection>
   1fcdc:	4b01      	ldr	r3, [pc, #4]	; (1fce4 <_ZN10Connection17PrepareConnectionEP14ble_gap_addr_tt+0x48>)
   1fcde:	52e0      	strh	r0, [r4, r3]

	return true;
}
   1fce0:	1c28      	adds	r0, r5, #0
   1fce2:	bd70      	pop	{r4, r5, r6, pc}
   1fce4:	00000206 	.word	0x00000206

0001fce8 <_ZN17ConnectionManager19fillTransmitBuffersEv>:
			}
		}
	}
}

void ConnectionManager::fillTransmitBuffers(){
   1fce8:	b5f0      	push	{r4, r5, r6, r7, lr}

	u32 err;

	//Fill with unreliable packets
	for(int i=0; i<Config->meshMaxConnections; i++)
   1fcea:	2300      	movs	r3, #0
   1fcec:	1c05      	adds	r5, r0, #0
			}
		}
	}
}

void ConnectionManager::fillTransmitBuffers(){
   1fcee:	b0a5      	sub	sp, #148	; 0x94
   1fcf0:	9005      	str	r0, [sp, #20]
   1fcf2:	3520      	adds	r5, #32

	u32 err;

	//Fill with unreliable packets
	for(int i=0; i<Config->meshMaxConnections; i++)
   1fcf4:	9303      	str	r3, [sp, #12]
   1fcf6:	f001 f897 	bl	20e28 <_ZN4Conf11getInstanceEv>
   1fcfa:	3035      	adds	r0, #53	; 0x35
   1fcfc:	7803      	ldrb	r3, [r0, #0]
   1fcfe:	9a03      	ldr	r2, [sp, #12]
   1fd00:	429a      	cmp	r2, r3
   1fd02:	db00      	blt.n	1fd06 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x1e>
   1fd04:	e133      	b.n	1ff6e <_ZN17ConnectionManager19fillTransmitBuffersEv+0x286>
	{
		while( connections[i]->isConnected() && connections[i]->GetPendingPackets() > 0)
   1fd06:	682b      	ldr	r3, [r5, #0]
   1fd08:	7a1e      	ldrb	r6, [r3, #8]
   1fd0a:	2e01      	cmp	r6, #1
   1fd0c:	d913      	bls.n	1fd36 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x4e>
}

//Returns the number of packets that this connection has not yet sent
u16 Connection::GetPendingPackets(){
	return packetSendQueue->_numElements
			+ (currentClusterInfoUpdatePacket.header.messageType == MESSAGE_TYPE_CLUSTER_INFO_UPDATE ? 1 : 0);
   1fd0e:	215e      	movs	r1, #94	; 0x5e
   1fd10:	31ff      	adds	r1, #255	; 0xff
   1fd12:	5c58      	ldrb	r0, [r3, r1]
   1fd14:	395d      	subs	r1, #93	; 0x5d
   1fd16:	39ff      	subs	r1, #255	; 0xff
   1fd18:	1c1a      	adds	r2, r3, #0
   1fd1a:	4388      	bics	r0, r1
   1fd1c:	468c      	mov	ip, r1
   1fd1e:	1c01      	adds	r1, r0, #0
   1fd20:	32fc      	adds	r2, #252	; 0xfc
   1fd22:	6c92      	ldr	r2, [r2, #72]	; 0x48
   1fd24:	392e      	subs	r1, #46	; 0x2e
   1fd26:	8a94      	ldrh	r4, [r2, #20]
   1fd28:	9004      	str	r0, [sp, #16]
   1fd2a:	4248      	negs	r0, r1
   1fd2c:	4148      	adcs	r0, r1
   1fd2e:	1821      	adds	r1, r4, r0
   1fd30:	b289      	uxth	r1, r1
   1fd32:	2900      	cmp	r1, #0
   1fd34:	d104      	bne.n	1fd40 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x58>
void ConnectionManager::fillTransmitBuffers(){

	u32 err;

	//Fill with unreliable packets
	for(int i=0; i<Config->meshMaxConnections; i++)
   1fd36:	9b03      	ldr	r3, [sp, #12]
   1fd38:	3504      	adds	r5, #4
   1fd3a:	3301      	adds	r3, #1
   1fd3c:	9303      	str	r3, [sp, #12]
   1fd3e:	e7da      	b.n	1fcf6 <_ZN17ConnectionManager19fillTransmitBuffersEv+0xe>

			bool reliable = false;
			u8* data = NULL;
			u16 dataSize = 0;

			if(!connections[i]->handshakeDone() && connections[i]->packetSendQueue->_numElements < 1){
   1fd40:	2e03      	cmp	r6, #3
   1fd42:	d800      	bhi.n	1fd46 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x5e>
   1fd44:	e0f1      	b.n	1ff2a <_ZN17ConnectionManager19fillTransmitBuffersEv+0x242>
			}

			//A cluster info update is waiting, this is important to send first (but only if handshake is finished and if no split packet is eing sent)
			if(
					connections[i]->handshakeDone()
					&& connections[i]->currentClusterInfoUpdatePacket.header.messageType != 0
   1fd46:	9904      	ldr	r1, [sp, #16]
   1fd48:	2900      	cmp	r1, #0
   1fd4a:	d100      	bne.n	1fd4e <_ZN17ConnectionManager19fillTransmitBuffersEv+0x66>
   1fd4c:	e0ed      	b.n	1ff2a <_ZN17ConnectionManager19fillTransmitBuffersEv+0x242>
					&& connections[i]->packetSendPosition == 0
   1fd4e:	21a4      	movs	r1, #164	; 0xa4
   1fd50:	0049      	lsls	r1, r1, #1
   1fd52:	5c59      	ldrb	r1, [r3, r1]
   1fd54:	2900      	cmp	r1, #0
   1fd56:	d000      	beq.n	1fd5a <_ZN17ConnectionManager19fillTransmitBuffersEv+0x72>
   1fd58:	e0e7      	b.n	1ff2a <_ZN17ConnectionManager19fillTransmitBuffersEv+0x242>
			){
				//If a clusterUpdate is available we send it immediately
				reliable = true;
				data = (u8*)&(connections[i]->currentClusterInfoUpdatePacket);
   1fd5a:	1c1e      	adds	r6, r3, #0
				dataSize = SIZEOF_CONN_PACKET_CLUSTER_INFO_UPDATE;
   1fd5c:	270e      	movs	r7, #14
					connections[i]->handshakeDone()
					&& connections[i]->currentClusterInfoUpdatePacket.header.messageType != 0
					&& connections[i]->packetSendPosition == 0
			){
				//If a clusterUpdate is available we send it immediately
				reliable = true;
   1fd5e:	4662      	mov	r2, ip
				data = (u8*)&(connections[i]->currentClusterInfoUpdatePacket);
   1fd60:	365e      	adds	r6, #94	; 0x5e
   1fd62:	36ff      	adds	r6, #255	; 0xff
			}

			//Multi-part messages are only supported reliable
			//Switch packet to reliable if it is a multipart packet
			if(dataSize > MAX_DATA_SIZE_PER_WRITE) reliable = true;
			else ((connPacketHeader*) data)->hasMoreParts = 0;
   1fd64:	2101      	movs	r1, #1
			else
			{
				//Get one packet from the packet queue
				sizedData packet = connections[i]->packetSendQueue->PeekNext();
				if(packet.length > 0){
					reliable = packet.data[0];
   1fd66:	9204      	str	r2, [sp, #16]
			}

			//Multi-part messages are only supported reliable
			//Switch packet to reliable if it is a multipart packet
			if(dataSize > MAX_DATA_SIZE_PER_WRITE) reliable = true;
			else ((connPacketHeader*) data)->hasMoreParts = 0;
   1fd68:	7832      	ldrb	r2, [r6, #0]
   1fd6a:	438a      	bics	r2, r1
   1fd6c:	7032      	strb	r2, [r6, #0]

			//The Next packet should be sent reliably
			if(reliable){
   1fd6e:	9a04      	ldr	r2, [sp, #16]
   1fd70:	2a00      	cmp	r2, #0
   1fd72:	d100      	bne.n	1fd76 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x8e>
   1fd74:	e0a0      	b.n	1feb8 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x1d0>
				if(connections[i]->reliableBuffersFree > 0){
   1fd76:	6828      	ldr	r0, [r5, #0]
   1fd78:	7d03      	ldrb	r3, [r0, #20]
   1fd7a:	2b00      	cmp	r3, #0
   1fd7c:	d0db      	beq.n	1fd36 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x4e>
					//Check if the packet can be transmitted in one MTU
					//If not, it will be sent with message splitting and reliable
					if(dataSize > MAX_DATA_SIZE_PER_WRITE){
   1fd7e:	1c34      	adds	r4, r6, #0
   1fd80:	2f14      	cmp	r7, #20
   1fd82:	d925      	bls.n	1fdd0 <_ZN17ConnectionManager19fillTransmitBuffersEv+0xe8>

						//We might already have started to transmit the packet
						if(connections[i]->packetSendPosition != 0){
   1fd84:	23a4      	movs	r3, #164	; 0xa4
   1fd86:	005b      	lsls	r3, r3, #1
   1fd88:	5cc3      	ldrb	r3, [r0, r3]
   1fd8a:	2b00      	cmp	r3, #0
   1fd8c:	d01b      	beq.n	1fdc6 <_ZN17ConnectionManager19fillTransmitBuffersEv+0xde>
							//we need to modify the data a little and build our split
							//message header. This does overwrite some of the old data
							//but that's already been transmitted
							connPacketSplitHeader* newHeader = (connPacketSplitHeader*)(data + connections[i]->packetSendPosition);
   1fd8e:	18f4      	adds	r4, r6, r3
							newHeader->hasMoreParts = (dataSize - connections[i]->packetSendPosition > MAX_DATA_SIZE_PER_WRITE) ? 1: 0;
   1fd90:	2201      	movs	r2, #1
   1fd92:	1afb      	subs	r3, r7, r3
   1fd94:	2b14      	cmp	r3, #20
   1fd96:	dc00      	bgt.n	1fd9a <_ZN17ConnectionManager19fillTransmitBuffersEv+0xb2>
   1fd98:	2200      	movs	r2, #0
   1fd9a:	2101      	movs	r1, #1
   1fd9c:	1c13      	adds	r3, r2, #0
   1fd9e:	400b      	ands	r3, r1
   1fda0:	469c      	mov	ip, r3
							newHeader->messageType = ((connPacketHeader*) data)->messageType; //We take it from the start of our packet which should still be intact
   1fda2:	7833      	ldrb	r3, [r6, #0]
   1fda4:	4666      	mov	r6, ip
   1fda6:	40cb      	lsrs	r3, r1
   1fda8:	408b      	lsls	r3, r1
						if(connections[i]->packetSendPosition != 0){
							//we need to modify the data a little and build our split
							//message header. This does overwrite some of the old data
							//but that's already been transmitted
							connPacketSplitHeader* newHeader = (connPacketSplitHeader*)(data + connections[i]->packetSendPosition);
							newHeader->hasMoreParts = (dataSize - connections[i]->packetSendPosition > MAX_DATA_SIZE_PER_WRITE) ? 1: 0;
   1fdaa:	7822      	ldrb	r2, [r4, #0]
   1fdac:	438a      	bics	r2, r1
							newHeader->messageType = ((connPacketHeader*) data)->messageType; //We take it from the start of our packet which should still be intact
   1fdae:	4332      	orrs	r2, r6
   1fdb0:	400a      	ands	r2, r1
   1fdb2:	4313      	orrs	r3, r2
   1fdb4:	7023      	strb	r3, [r4, #0]

							//If the packet has more parts, we send a full packet, otherwise we send the remaining bits
							if(newHeader->hasMoreParts) dataSize = MAX_DATA_SIZE_PER_WRITE;
   1fdb6:	420b      	tst	r3, r1
   1fdb8:	d109      	bne.n	1fdce <_ZN17ConnectionManager19fillTransmitBuffersEv+0xe6>
							else dataSize = dataSize - connections[i]->packetSendPosition;
   1fdba:	23a4      	movs	r3, #164	; 0xa4
   1fdbc:	005b      	lsls	r3, r3, #1
   1fdbe:	5cc3      	ldrb	r3, [r0, r3]
   1fdc0:	1afb      	subs	r3, r7, r3
   1fdc2:	b29f      	uxth	r7, r3
   1fdc4:	e004      	b.n	1fdd0 <_ZN17ConnectionManager19fillTransmitBuffersEv+0xe8>

						}
						//Or maybe this is the start of the transmission
						else
						{
							((connPacketHeader*) data)->hasMoreParts = 1;
   1fdc6:	2201      	movs	r2, #1
   1fdc8:	7833      	ldrb	r3, [r6, #0]
   1fdca:	4313      	orrs	r3, r2
   1fdcc:	7033      	strb	r3, [r6, #0]
							connPacketSplitHeader* newHeader = (connPacketSplitHeader*)(data + connections[i]->packetSendPosition);
							newHeader->hasMoreParts = (dataSize - connections[i]->packetSendPosition > MAX_DATA_SIZE_PER_WRITE) ? 1: 0;
							newHeader->messageType = ((connPacketHeader*) data)->messageType; //We take it from the start of our packet which should still be intact

							//If the packet has more parts, we send a full packet, otherwise we send the remaining bits
							if(newHeader->hasMoreParts) dataSize = MAX_DATA_SIZE_PER_WRITE;
   1fdce:	2714      	movs	r7, #20
					//Update packet timestamp as close as possible before sending it
					//TODO: This could be done more accurate because we receive an event when the
					//Packet was sent, so we could calculate the time between sending and getting the event
					//And send a second packet with the time difference.
					//FIXME: Currently, half of the connection interval is added to make up for this
					if(((connPacketHeader*) data)->messageType == MESSAGE_TYPE_UPDATE_TIMESTAMP){
   1fdd0:	2201      	movs	r2, #1
   1fdd2:	7823      	ldrb	r3, [r4, #0]
   1fdd4:	4393      	bics	r3, r2
   1fdd6:	2b3c      	cmp	r3, #60	; 0x3c
   1fdd8:	d125      	bne.n	1fe26 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x13e>
						logt("NODE", "sending time");

						node->UpdateGlobalTime();
   1fdda:	9b05      	ldr	r3, [sp, #20]
   1fddc:	6858      	ldr	r0, [r3, #4]
   1fdde:	f7fd ffad 	bl	1dd3c <_ZN4Node16UpdateGlobalTimeEv>
						((connPacketUpdateTimestamp*) data)->timestampSec = node->globalTimeSec;
   1fde2:	9b05      	ldr	r3, [sp, #20]
						((connPacketUpdateTimestamp*) data)->remainderTicks = node->globalTimeRemainderTicks + (connections[i]->currentConnectionIntervalMs * APP_TIMER_CLOCK_FREQ / 1000 / 2);
   1fde4:	21fa      	movs	r1, #250	; 0xfa
					//FIXME: Currently, half of the connection interval is added to make up for this
					if(((connPacketHeader*) data)->messageType == MESSAGE_TYPE_UPDATE_TIMESTAMP){
						logt("NODE", "sending time");

						node->UpdateGlobalTime();
						((connPacketUpdateTimestamp*) data)->timestampSec = node->globalTimeSec;
   1fde6:	685e      	ldr	r6, [r3, #4]
						((connPacketUpdateTimestamp*) data)->remainderTicks = node->globalTimeRemainderTicks + (connections[i]->currentConnectionIntervalMs * APP_TIMER_CLOCK_FREQ / 1000 / 2);
   1fde8:	23ef      	movs	r3, #239	; 0xef
					//FIXME: Currently, half of the connection interval is added to make up for this
					if(((connPacketHeader*) data)->messageType == MESSAGE_TYPE_UPDATE_TIMESTAMP){
						logt("NODE", "sending time");

						node->UpdateGlobalTime();
						((connPacketUpdateTimestamp*) data)->timestampSec = node->globalTimeSec;
   1fdea:	1c32      	adds	r2, r6, #0
   1fdec:	3258      	adds	r2, #88	; 0x58
   1fdee:	7812      	ldrb	r2, [r2, #0]
						((connPacketUpdateTimestamp*) data)->remainderTicks = node->globalTimeRemainderTicks + (connections[i]->currentConnectionIntervalMs * APP_TIMER_CLOCK_FREQ / 1000 / 2);
   1fdf0:	005b      	lsls	r3, r3, #1
					//FIXME: Currently, half of the connection interval is added to make up for this
					if(((connPacketHeader*) data)->messageType == MESSAGE_TYPE_UPDATE_TIMESTAMP){
						logt("NODE", "sending time");

						node->UpdateGlobalTime();
						((connPacketUpdateTimestamp*) data)->timestampSec = node->globalTimeSec;
   1fdf2:	7162      	strb	r2, [r4, #5]
   1fdf4:	1c32      	adds	r2, r6, #0
   1fdf6:	3259      	adds	r2, #89	; 0x59
   1fdf8:	7812      	ldrb	r2, [r2, #0]
						((connPacketUpdateTimestamp*) data)->remainderTicks = node->globalTimeRemainderTicks + (connections[i]->currentConnectionIntervalMs * APP_TIMER_CLOCK_FREQ / 1000 / 2);
   1fdfa:	0089      	lsls	r1, r1, #2
					//FIXME: Currently, half of the connection interval is added to make up for this
					if(((connPacketHeader*) data)->messageType == MESSAGE_TYPE_UPDATE_TIMESTAMP){
						logt("NODE", "sending time");

						node->UpdateGlobalTime();
						((connPacketUpdateTimestamp*) data)->timestampSec = node->globalTimeSec;
   1fdfc:	71a2      	strb	r2, [r4, #6]
   1fdfe:	1c32      	adds	r2, r6, #0
   1fe00:	325a      	adds	r2, #90	; 0x5a
   1fe02:	7812      	ldrb	r2, [r2, #0]
   1fe04:	71e2      	strb	r2, [r4, #7]
   1fe06:	1c32      	adds	r2, r6, #0
   1fe08:	325b      	adds	r2, #91	; 0x5b
   1fe0a:	7812      	ldrb	r2, [r2, #0]
						((connPacketUpdateTimestamp*) data)->remainderTicks = node->globalTimeRemainderTicks + (connections[i]->currentConnectionIntervalMs * APP_TIMER_CLOCK_FREQ / 1000 / 2);
   1fe0c:	3660      	adds	r6, #96	; 0x60
					//FIXME: Currently, half of the connection interval is added to make up for this
					if(((connPacketHeader*) data)->messageType == MESSAGE_TYPE_UPDATE_TIMESTAMP){
						logt("NODE", "sending time");

						node->UpdateGlobalTime();
						((connPacketUpdateTimestamp*) data)->timestampSec = node->globalTimeSec;
   1fe0e:	7222      	strb	r2, [r4, #8]
						((connPacketUpdateTimestamp*) data)->remainderTicks = node->globalTimeRemainderTicks + (connections[i]->currentConnectionIntervalMs * APP_TIMER_CLOCK_FREQ / 1000 / 2);
   1fe10:	682a      	ldr	r2, [r5, #0]
   1fe12:	5ad0      	ldrh	r0, [r2, r3]
   1fe14:	0380      	lsls	r0, r0, #14
   1fe16:	f002 f9bf 	bl	22198 <__aeabi_idiv>
   1fe1a:	8833      	ldrh	r3, [r6, #0]
   1fe1c:	18c0      	adds	r0, r0, r3
   1fe1e:	b280      	uxth	r0, r0
   1fe20:	7260      	strb	r0, [r4, #9]
   1fe22:	0a00      	lsrs	r0, r0, #8
   1fe24:	72a0      	strb	r0, [r4, #10]
					}


					//Finally, send the packet to the SoftDevice
					err = GATTController::bleWriteCharacteristic(connections[i]->connectionHandle, connections[i]->writeCharacteristicHandle, data, dataSize, true);
   1fe26:	22e9      	movs	r2, #233	; 0xe9
   1fe28:	682b      	ldr	r3, [r5, #0]
   1fe2a:	0052      	lsls	r2, r2, #1
   1fe2c:	5a9a      	ldrh	r2, [r3, r2]
	logt("CONN_DATA", "%s", stringBuffer);


	//Configure the write parameters with reliable/unreliable, writehandle, etc...
	ble_gattc_write_params_t writeParameters;
	memset(&writeParameters, 0, sizeof(ble_gattc_write_params_t));
   1fe2e:	ae08      	add	r6, sp, #32
   1fe30:	9204      	str	r2, [sp, #16]
   1fe32:	22ee      	movs	r2, #238	; 0xee
   1fe34:	0052      	lsls	r2, r2, #1
   1fe36:	5a9b      	ldrh	r3, [r3, r2]
   1fe38:	9306      	str	r3, [sp, #24]
	}

	logt("CONN_DATA", "Data size is: %d, handles(%d, %d), reliable %d", dataLength, connectionHandle, characteristicHandle, reliable);

	char stringBuffer[100];
	Logger::getInstance().convertBufferToHexString(data, dataLength, stringBuffer, 100);
   1fe3a:	f7fd fa2d 	bl	1d298 <_ZN6Logger11getInstanceEv>
   1fe3e:	2364      	movs	r3, #100	; 0x64
   1fe40:	1c21      	adds	r1, r4, #0
   1fe42:	9300      	str	r3, [sp, #0]
   1fe44:	1c3a      	adds	r2, r7, #0
   1fe46:	ab0b      	add	r3, sp, #44	; 0x2c
   1fe48:	f7ff fdc2 	bl	1f9d0 <_ZN6Logger24convertBufferToHexStringEPhmPct>
	logt("CONN_DATA", "%s", stringBuffer);


	//Configure the write parameters with reliable/unreliable, writehandle, etc...
	ble_gattc_write_params_t writeParameters;
	memset(&writeParameters, 0, sizeof(ble_gattc_write_params_t));
   1fe4c:	220c      	movs	r2, #12
   1fe4e:	1c30      	adds	r0, r6, #0
   1fe50:	2100      	movs	r1, #0
   1fe52:	f001 fbfc 	bl	2164e <memset>
	writeParameters.handle = characteristicHandle;
   1fe56:	466b      	mov	r3, sp
   1fe58:	8b1b      	ldrh	r3, [r3, #24]

	if (reliable)
	{
		writeParameters.write_op = BLE_GATT_OP_WRITE_REQ;

		err = sd_ble_gattc_write(connectionHandle, &writeParameters);
   1fe5a:	1c31      	adds	r1, r6, #0


	//Configure the write parameters with reliable/unreliable, writehandle, etc...
	ble_gattc_write_params_t writeParameters;
	memset(&writeParameters, 0, sizeof(ble_gattc_write_params_t));
	writeParameters.handle = characteristicHandle;
   1fe5c:	8073      	strh	r3, [r6, #2]
	writeParameters.len = dataLength;
	writeParameters.p_value = data;

	if (reliable)
	{
		writeParameters.write_op = BLE_GATT_OP_WRITE_REQ;
   1fe5e:	2301      	movs	r3, #1

		err = sd_ble_gattc_write(connectionHandle, &writeParameters);
   1fe60:	9804      	ldr	r0, [sp, #16]
	//Configure the write parameters with reliable/unreliable, writehandle, etc...
	ble_gattc_write_params_t writeParameters;
	memset(&writeParameters, 0, sizeof(ble_gattc_write_params_t));
	writeParameters.handle = characteristicHandle;
	writeParameters.offset = 0;
	writeParameters.len = dataLength;
   1fe62:	80f7      	strh	r7, [r6, #6]
	writeParameters.p_value = data;
   1fe64:	60b4      	str	r4, [r6, #8]

	if (reliable)
	{
		writeParameters.write_op = BLE_GATT_OP_WRITE_REQ;
   1fe66:	7033      	strb	r3, [r6, #0]

		err = sd_ble_gattc_write(connectionHandle, &writeParameters);
   1fe68:	f7fd fa3a 	bl	1d2e0 <sd_ble_gattc_write.lto_priv.68>
   1fe6c:	2201      	movs	r2, #1
   1fe6e:	1e06      	subs	r6, r0, #0

					if(err != NRF_SUCCESS) logt("ERROR", "GATT WRITE ERROR %u", err);

					if(err == NRF_SUCCESS){
   1fe70:	d118      	bne.n	1fea4 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x1bc>
						//Consume a buffer because the packet was sent
						connections[i]->reliableBuffersFree--;
   1fe72:	682a      	ldr	r2, [r5, #0]

						memcpy(connections[i]->lastSentPacket, data, dataSize);
   1fe74:	1c21      	adds	r1, r4, #0

					if(err != NRF_SUCCESS) logt("ERROR", "GATT WRITE ERROR %u", err);

					if(err == NRF_SUCCESS){
						//Consume a buffer because the packet was sent
						connections[i]->reliableBuffersFree--;
   1fe76:	7d13      	ldrb	r3, [r2, #20]
   1fe78:	3b01      	subs	r3, #1
   1fe7a:	7513      	strb	r3, [r2, #20]

						memcpy(connections[i]->lastSentPacket, data, dataSize);
   1fe7c:	6828      	ldr	r0, [r5, #0]
   1fe7e:	1c3a      	adds	r2, r7, #0
   1fe80:	304a      	adds	r0, #74	; 0x4a
   1fe82:	30ff      	adds	r0, #255	; 0xff
   1fe84:	f001 fbc6 	bl	21614 <memcpy>

						//A special packet that is not from the packetqueue is emptied as soon as it is in the send buffer
						//If it can not be sent, the connection will be disconnected because of a timeout, so we must not await
						//A success event
						if(((connPacketHeader*)data)->messageType == MESSAGE_TYPE_CLUSTER_INFO_UPDATE){
   1fe88:	2201      	movs	r2, #1
   1fe8a:	7823      	ldrb	r3, [r4, #0]
   1fe8c:	4393      	bics	r3, r2
   1fe8e:	2b2e      	cmp	r3, #46	; 0x2e
   1fe90:	d000      	beq.n	1fe94 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x1ac>
   1fe92:	e738      	b.n	1fd06 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x1e>
}

void Connection::ClusterUpdateSentHandler()
{
	//The current cluster info update message has been sent, we can now clear the packet
	memset((u8*)&currentClusterInfoUpdatePacket, 0x00, sizeof(currentClusterInfoUpdatePacket));
   1fe94:	6828      	ldr	r0, [r5, #0]
   1fe96:	1c31      	adds	r1, r6, #0
   1fe98:	305e      	adds	r0, #94	; 0x5e
   1fe9a:	320d      	adds	r2, #13
   1fe9c:	30ff      	adds	r0, #255	; 0xff
   1fe9e:	f001 fbd6 	bl	2164e <memset>
   1fea2:	e730      	b.n	1fd06 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x1e>
							connections[i]->ClusterUpdateSentHandler();
						} else {

						}

					} else if(err == NRF_ERROR_DATA_SIZE || err == NRF_ERROR_INVALID_PARAM){
   1fea4:	280c      	cmp	r0, #12
   1fea6:	d002      	beq.n	1feae <_ZN17ConnectionManager19fillTransmitBuffersEv+0x1c6>
   1fea8:	2807      	cmp	r0, #7
   1feaa:	d000      	beq.n	1feae <_ZN17ConnectionManager19fillTransmitBuffersEv+0x1c6>
   1feac:	e743      	b.n	1fd36 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x4e>
						logt("ERROR", "NRF_ERROR sending %u!!!!!!!!!!!!!", err);
						//Drop the packet if it's faulty
						if(((connPacketHeader*)data)->messageType == MESSAGE_TYPE_CLUSTER_INFO_UPDATE){
   1feae:	7823      	ldrb	r3, [r4, #0]
   1feb0:	4393      	bics	r3, r2
   1feb2:	2b2e      	cmp	r3, #46	; 0x2e
   1feb4:	d133      	bne.n	1ff1e <_ZN17ConnectionManager19fillTransmitBuffersEv+0x236>
   1feb6:	e726      	b.n	1fd06 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x1e>
				}
			}

			//The next packet is to be sent unreliably
			if(!reliable){
				if(connections[i]->unreliableBuffersFree > 0)
   1feb8:	7cda      	ldrb	r2, [r3, #19]
   1feba:	2a00      	cmp	r2, #0
   1febc:	d100      	bne.n	1fec0 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x1d8>
   1febe:	e73a      	b.n	1fd36 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x4e>
				{
					err = GATTController::bleWriteCharacteristic(connections[i]->connectionHandle, connections[i]->writeCharacteristicHandle, data, dataSize, false);
   1fec0:	22e9      	movs	r2, #233	; 0xe9
   1fec2:	0052      	lsls	r2, r2, #1
   1fec4:	5a9a      	ldrh	r2, [r3, r2]
	logt("CONN_DATA", "%s", stringBuffer);


	//Configure the write parameters with reliable/unreliable, writehandle, etc...
	ble_gattc_write_params_t writeParameters;
	memset(&writeParameters, 0, sizeof(ble_gattc_write_params_t));
   1fec6:	ac08      	add	r4, sp, #32
   1fec8:	9206      	str	r2, [sp, #24]
   1feca:	22ee      	movs	r2, #238	; 0xee
   1fecc:	0052      	lsls	r2, r2, #1
   1fece:	5a9b      	ldrh	r3, [r3, r2]
   1fed0:	9307      	str	r3, [sp, #28]
	}

	logt("CONN_DATA", "Data size is: %d, handles(%d, %d), reliable %d", dataLength, connectionHandle, characteristicHandle, reliable);

	char stringBuffer[100];
	Logger::getInstance().convertBufferToHexString(data, dataLength, stringBuffer, 100);
   1fed2:	f7fd f9e1 	bl	1d298 <_ZN6Logger11getInstanceEv>
   1fed6:	2364      	movs	r3, #100	; 0x64
   1fed8:	1c31      	adds	r1, r6, #0
   1feda:	9300      	str	r3, [sp, #0]
   1fedc:	1c3a      	adds	r2, r7, #0
   1fede:	ab0b      	add	r3, sp, #44	; 0x2c
   1fee0:	f7ff fd76 	bl	1f9d0 <_ZN6Logger24convertBufferToHexStringEPhmPct>
	logt("CONN_DATA", "%s", stringBuffer);


	//Configure the write parameters with reliable/unreliable, writehandle, etc...
	ble_gattc_write_params_t writeParameters;
	memset(&writeParameters, 0, sizeof(ble_gattc_write_params_t));
   1fee4:	9904      	ldr	r1, [sp, #16]
   1fee6:	1c20      	adds	r0, r4, #0
   1fee8:	220c      	movs	r2, #12
   1feea:	f001 fbb0 	bl	2164e <memset>
	writeParameters.handle = characteristicHandle;
   1feee:	466b      	mov	r3, sp
   1fef0:	8b9b      	ldrh	r3, [r3, #28]
	}
	else
	{
		writeParameters.write_op = BLE_GATT_OP_WRITE_CMD;

		err = sd_ble_gattc_write(connectionHandle, &writeParameters);
   1fef2:	9806      	ldr	r0, [sp, #24]


	//Configure the write parameters with reliable/unreliable, writehandle, etc...
	ble_gattc_write_params_t writeParameters;
	memset(&writeParameters, 0, sizeof(ble_gattc_write_params_t));
	writeParameters.handle = characteristicHandle;
   1fef4:	8063      	strh	r3, [r4, #2]
		return err;

	}
	else
	{
		writeParameters.write_op = BLE_GATT_OP_WRITE_CMD;
   1fef6:	2302      	movs	r3, #2

		err = sd_ble_gattc_write(connectionHandle, &writeParameters);
   1fef8:	1c21      	adds	r1, r4, #0
	//Configure the write parameters with reliable/unreliable, writehandle, etc...
	ble_gattc_write_params_t writeParameters;
	memset(&writeParameters, 0, sizeof(ble_gattc_write_params_t));
	writeParameters.handle = characteristicHandle;
	writeParameters.offset = 0;
	writeParameters.len = dataLength;
   1fefa:	80e7      	strh	r7, [r4, #6]
	writeParameters.p_value = data;
   1fefc:	60a6      	str	r6, [r4, #8]
		return err;

	}
	else
	{
		writeParameters.write_op = BLE_GATT_OP_WRITE_CMD;
   1fefe:	7023      	strb	r3, [r4, #0]

		err = sd_ble_gattc_write(connectionHandle, &writeParameters);
   1ff00:	f7fd f9ee 	bl	1d2e0 <sd_ble_gattc_write.lto_priv.68>

					if(err != NRF_SUCCESS) logt("ERROR", "GATT WRITE ERROR %u", err);

					if(err == NRF_SUCCESS){
   1ff04:	2800      	cmp	r0, #0
   1ff06:	d12d      	bne.n	1ff64 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x27c>
						//Consumes a send Buffer
						connections[i]->unreliableBuffersFree--;
   1ff08:	682a      	ldr	r2, [r5, #0]
						logt("CONN", "packet to conn %u (txfree: %d)", i, connections[i]->unreliableBuffersFree);

						memcpy(connections[i]->lastSentPacket, data, dataSize);
   1ff0a:	1c31      	adds	r1, r6, #0

					if(err != NRF_SUCCESS) logt("ERROR", "GATT WRITE ERROR %u", err);

					if(err == NRF_SUCCESS){
						//Consumes a send Buffer
						connections[i]->unreliableBuffersFree--;
   1ff0c:	7cd3      	ldrb	r3, [r2, #19]
   1ff0e:	3b01      	subs	r3, #1
   1ff10:	74d3      	strb	r3, [r2, #19]
						logt("CONN", "packet to conn %u (txfree: %d)", i, connections[i]->unreliableBuffersFree);

						memcpy(connections[i]->lastSentPacket, data, dataSize);
   1ff12:	6828      	ldr	r0, [r5, #0]
   1ff14:	1c3a      	adds	r2, r7, #0
   1ff16:	304a      	adds	r0, #74	; 0x4a
   1ff18:	30ff      	adds	r0, #255	; 0xff
   1ff1a:	f001 fb7b 	bl	21614 <memcpy>
					}

					//In either case (success or faulty packet) we drop the packet
					if(err == NRF_SUCCESS || err == NRF_ERROR_DATA_SIZE || err == NRF_ERROR_INVALID_PARAM){

						connections[i]->packetSendQueue->DiscardNext();
   1ff1e:	682b      	ldr	r3, [r5, #0]
   1ff20:	33fc      	adds	r3, #252	; 0xfc
   1ff22:	6c98      	ldr	r0, [r3, #72]	; 0x48
   1ff24:	f7ff fae8 	bl	1f4f8 <_ZN11PacketQueue11DiscardNextEv>
   1ff28:	e6ed      	b.n	1fd06 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x1e>

sizedData PacketQueue::PeekNext()
{
	sizedData data;
	//If queue has been fully read, return empty data
	if (_numElements == 0)
   1ff2a:	2c00      	cmp	r4, #0
   1ff2c:	d100      	bne.n	1ff30 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x248>
   1ff2e:	e702      	b.n	1fd36 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x4e>

		return data;
	}

	//Check if we reached the end and wrap
	if (readPointer[0] == 0 && writePointer < readPointer)
   1ff30:	68d1      	ldr	r1, [r2, #12]
   1ff32:	7808      	ldrb	r0, [r1, #0]
   1ff34:	2800      	cmp	r0, #0
   1ff36:	d104      	bne.n	1ff42 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x25a>
   1ff38:	6910      	ldr	r0, [r2, #16]
   1ff3a:	4288      	cmp	r0, r1
   1ff3c:	d201      	bcs.n	1ff42 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x25a>
		readPointer = bufferStart;
   1ff3e:	6811      	ldr	r1, [r2, #0]
   1ff40:	60d1      	str	r1, [r2, #12]

	data.length = (this->readPointer[0]);
   1ff42:	68d6      	ldr	r6, [r2, #12]
   1ff44:	7832      	ldrb	r2, [r6, #0]
			//Pick the next packet from the packet queue
			else
			{
				//Get one packet from the packet queue
				sizedData packet = connections[i]->packetSendQueue->PeekNext();
				if(packet.length > 0){
   1ff46:	2a00      	cmp	r2, #0
   1ff48:	d100      	bne.n	1ff4c <_ZN17ConnectionManager19fillTransmitBuffersEv+0x264>
   1ff4a:	e6f4      	b.n	1fd36 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x4e>
					reliable = packet.data[0];
					data = packet.data + 1;
					dataSize = packet.length - 1;
   1ff4c:	3a01      	subs	r2, #1
   1ff4e:	b297      	uxth	r7, r2
			else
			{
				//Get one packet from the packet queue
				sizedData packet = connections[i]->packetSendQueue->PeekNext();
				if(packet.length > 0){
					reliable = packet.data[0];
   1ff50:	7871      	ldrb	r1, [r6, #1]
					data = packet.data + 1;
   1ff52:	3602      	adds	r6, #2
				}
			}

			//Multi-part messages are only supported reliable
			//Switch packet to reliable if it is a multipart packet
			if(dataSize > MAX_DATA_SIZE_PER_WRITE) reliable = true;
   1ff54:	2f14      	cmp	r7, #20
   1ff56:	d900      	bls.n	1ff5a <_ZN17ConnectionManager19fillTransmitBuffersEv+0x272>
   1ff58:	e70d      	b.n	1fd76 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x8e>
			else
			{
				//Get one packet from the packet queue
				sizedData packet = connections[i]->packetSendQueue->PeekNext();
				if(packet.length > 0){
					reliable = packet.data[0];
   1ff5a:	1c0a      	adds	r2, r1, #0
   1ff5c:	1e51      	subs	r1, r2, #1
   1ff5e:	418a      	sbcs	r2, r1
   1ff60:	b2d2      	uxtb	r2, r2
   1ff62:	e6ff      	b.n	1fd64 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x7c>

						memcpy(connections[i]->lastSentPacket, data, dataSize);
					}

					//In either case (success or faulty packet) we drop the packet
					if(err == NRF_SUCCESS || err == NRF_ERROR_DATA_SIZE || err == NRF_ERROR_INVALID_PARAM){
   1ff64:	280c      	cmp	r0, #12
   1ff66:	d0da      	beq.n	1ff1e <_ZN17ConnectionManager19fillTransmitBuffersEv+0x236>
   1ff68:	2807      	cmp	r0, #7
   1ff6a:	d0d8      	beq.n	1ff1e <_ZN17ConnectionManager19fillTransmitBuffersEv+0x236>
   1ff6c:	e6e3      	b.n	1fd36 <_ZN17ConnectionManager19fillTransmitBuffersEv+0x4e>
			//Go to next connection if a packet (either reliable or unreliable)
			//could not be sent because the corresponding buffers are full
			if(packetCouldNotBeSent) break;
		}
	}
}
   1ff6e:	b025      	add	sp, #148	; 0x94
   1ff70:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0001ff74 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2>:
	if(connectionState != ConnectionState::DISCONNECTED) connectionStateBeforeDisconnection = connectionState;
	connectionState = ConnectionState::DISCONNECTED;
}


void Connection::ReceivePacketHandler(connectionPacket* inPacket)
   1ff74:	b5f0      	push	{r4, r5, r6, r7, lr}
{
	if(connectionState == ConnectionState::DISCONNECTED) return;

	u8* data = inPacket->data;
	u16 dataLength = inPacket->dataLength;
	bool reliable = inPacket->reliable;
   1ff76:	788b      	ldrb	r3, [r1, #2]

void Connection::ReceivePacketHandler(connectionPacket* inPacket)
{
	if(connectionState == ConnectionState::DISCONNECTED) return;

	u8* data = inPacket->data;
   1ff78:	684d      	ldr	r5, [r1, #4]
	if(connectionState != ConnectionState::DISCONNECTED) connectionStateBeforeDisconnection = connectionState;
	connectionState = ConnectionState::DISCONNECTED;
}


void Connection::ReceivePacketHandler(connectionPacket* inPacket)
   1ff7a:	b089      	sub	sp, #36	; 0x24
{
	if(connectionState == ConnectionState::DISCONNECTED) return;

	u8* data = inPacket->data;
	u16 dataLength = inPacket->dataLength;
   1ff7c:	890e      	ldrh	r6, [r1, #8]
	bool reliable = inPacket->reliable;
   1ff7e:	9302      	str	r3, [sp, #8]

	/*#################### ROUTING ############################*/

	//We are the last receiver for this packet
	if(
			packetHeader->receiver == node->persistentConfig.nodeId //We are the receiver
   1ff80:	792b      	ldrb	r3, [r5, #4]
   1ff82:	78ea      	ldrb	r2, [r5, #3]
   1ff84:	021b      	lsls	r3, r3, #8
   1ff86:	4313      	orrs	r3, r2
   1ff88:	6802      	ldr	r2, [r0, #0]
	if(connectionState != ConnectionState::DISCONNECTED) connectionStateBeforeDisconnection = connectionState;
	connectionState = ConnectionState::DISCONNECTED;
}


void Connection::ReceivePacketHandler(connectionPacket* inPacket)
   1ff8a:	1c0f      	adds	r7, r1, #0
	logt("CONN", "Received packet type %d, len %d", packetHeader->messageType, dataLength);

	/*#################### ROUTING ############################*/

	//We are the last receiver for this packet
	if(
   1ff8c:	8cd1      	ldrh	r1, [r2, #38]	; 0x26
	if(connectionState != ConnectionState::DISCONNECTED) connectionStateBeforeDisconnection = connectionState;
	connectionState = ConnectionState::DISCONNECTED;
}


void Connection::ReceivePacketHandler(connectionPacket* inPacket)
   1ff8e:	1c04      	adds	r4, r0, #0
	logt("CONN", "Received packet type %d, len %d", packetHeader->messageType, dataLength);

	/*#################### ROUTING ############################*/

	//We are the last receiver for this packet
	if(
   1ff90:	4299      	cmp	r1, r3
   1ff92:	d036      	beq.n	20002 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x8e>
			packetHeader->receiver == node->persistentConfig.nodeId //We are the receiver
			|| packetHeader->receiver == NODE_ID_HOPS_BASE + 1 //The packet was meant to travel only one hop
   1ff94:	49b7      	ldr	r1, [pc, #732]	; (20274 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x300>)
   1ff96:	428b      	cmp	r3, r1
   1ff98:	d033      	beq.n	20002 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x8e>
			|| (packetHeader->receiver == NODE_ID_SHORTEST_SINK && node->persistentConfig.deviceType == deviceTypes::DEVICE_TYPE_SINK) //Packet was meant for the shortest sink and we are a sink
   1ff9a:	49b7      	ldr	r1, [pc, #732]	; (20278 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x304>)
   1ff9c:	428b      	cmp	r3, r1
   1ff9e:	d118      	bne.n	1ffd2 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x5e>
   1ffa0:	323a      	adds	r2, #58	; 0x3a
   1ffa2:	7813      	ldrb	r3, [r2, #0]
   1ffa4:	2b02      	cmp	r3, #2
   1ffa6:	d02c      	beq.n	20002 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x8e>
		//No packet forwarding needed here.
	}
	//The packet should continue to the shortest sink
	else if(packetHeader->receiver == NODE_ID_SHORTEST_SINK)
	{
		Connection* connection = cm->GetConnectionToShortestSink(NULL);
   1ffa8:	6840      	ldr	r0, [r0, #4]
   1ffaa:	f7ff f8d3 	bl	1f154 <_ZN17ConnectionManager27GetConnectionToShortestSinkEP10Connection.constprop.11>
   1ffae:	1e01      	subs	r1, r0, #0

		if(connection){
   1ffb0:	d027      	beq.n	20002 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x8e>
			cm->SendMessage(connection, data, dataLength, reliable);
   1ffb2:	6863      	ldr	r3, [r4, #4]
   1ffb4:	9303      	str	r3, [sp, #12]


//Send message to a single connection (Will not send packet if connection has not finished handshake)
bool ConnectionManager::SendMessage(Connection* connection, u8* data, u16 dataLength, bool reliable)
{
	if(connection->handshakeDone()){
   1ffb6:	7a03      	ldrb	r3, [r0, #8]
   1ffb8:	2b03      	cmp	r3, #3
   1ffba:	d922      	bls.n	20002 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x8e>
		QueuePacket(connection, data, dataLength, reliable);
   1ffbc:	9b02      	ldr	r3, [sp, #8]
   1ffbe:	9803      	ldr	r0, [sp, #12]
   1ffc0:	9300      	str	r3, [sp, #0]
   1ffc2:	1c2a      	adds	r2, r5, #0
   1ffc4:	1c33      	adds	r3, r6, #0
   1ffc6:	f7fd fe44 	bl	1dc52 <_ZN17ConnectionManager11QueuePacketEP10ConnectionPhtb>

		fillTransmitBuffers();
   1ffca:	9803      	ldr	r0, [sp, #12]
   1ffcc:	f7ff fe8c 	bl	1fce8 <_ZN17ConnectionManager19fillTransmitBuffersEv>
   1ffd0:	e017      	b.n	20002 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x8e>
	else
	{
		//Some packets need to be modified before relaying them

		//If the packet should travel a number of hops, we decrement that part
		if(packetHeader->receiver > NODE_ID_HOPS_BASE && packetHeader->receiver < NODE_ID_HOPS_BASE + 1000){
   1ffd2:	4aaa      	ldr	r2, [pc, #680]	; (2027c <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x308>)
   1ffd4:	49aa      	ldr	r1, [pc, #680]	; (20280 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x30c>)
   1ffd6:	189a      	adds	r2, r3, r2
   1ffd8:	b292      	uxth	r2, r2
   1ffda:	428a      	cmp	r2, r1
   1ffdc:	d804      	bhi.n	1ffe8 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x74>
			packetHeader->receiver--;
   1ffde:	3b01      	subs	r3, #1
   1ffe0:	b29b      	uxth	r3, r3
   1ffe2:	70eb      	strb	r3, [r5, #3]
   1ffe4:	0a1b      	lsrs	r3, r3, #8
   1ffe6:	712b      	strb	r3, [r5, #4]
		}

		//Send to all other connections
		if(packetHeader->messageType != MESSAGE_TYPE_CLUSTER_INFO_UPDATE){
   1ffe8:	2201      	movs	r2, #1
   1ffea:	782b      	ldrb	r3, [r5, #0]
   1ffec:	4393      	bics	r3, r2
   1ffee:	2b2e      	cmp	r3, #46	; 0x2e
   1fff0:	d007      	beq.n	20002 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x8e>
			//Do not forward cluster info update packets, these are handeled by the node
			cm->SendMessageOverConnections(this, data, dataLength, reliable);
   1fff2:	9b02      	ldr	r3, [sp, #8]
   1fff4:	6860      	ldr	r0, [r4, #4]
   1fff6:	9300      	str	r3, [sp, #0]
   1fff8:	1c21      	adds	r1, r4, #0
   1fffa:	1c2a      	adds	r2, r5, #0
   1fffc:	1c33      	adds	r3, r6, #0
   1fffe:	f7fd fe74 	bl	1dcea <_ZN17ConnectionManager26SendMessageOverConnectionsEP10ConnectionPhtb>


	/*#################### HANDSHAKE ############################*/

	/******* Cluster welcome *******/
	if (packetHeader->messageType == MESSAGE_TYPE_CLUSTER_WELCOME)
   20002:	2201      	movs	r2, #1
   20004:	782b      	ldrb	r3, [r5, #0]
   20006:	4393      	bics	r3, r2
   20008:	2b28      	cmp	r3, #40	; 0x28
   2000a:	d164      	bne.n	200d6 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x162>
	{
		if (dataLength == SIZEOF_CONN_PACKET_CLUSTER_WELCOME)
   2000c:	2e10      	cmp	r6, #16
   2000e:	d000      	beq.n	20012 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x9e>
   20010:	e12e      	b.n	20270 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x2fc>
		{
			//Now, compare that packet with our data and see if he should join our cluster
			connPacketClusterWelcome* packet = (connPacketClusterWelcome*) data;

			//Save mesh write handle
			writeCharacteristicHandle = packet->payload.meshWriteHandle;
   20012:	7b2b      	ldrb	r3, [r5, #12]
   20014:	7aea      	ldrb	r2, [r5, #11]
   20016:	021b      	lsls	r3, r3, #8
   20018:	4313      	orrs	r3, r2
   2001a:	22ee      	movs	r2, #238	; 0xee
   2001c:	0052      	lsls	r2, r2, #1
   2001e:	52a3      	strh	r3, [r4, r2]

			connectionState = ConnectionState::HANDSHAKING;
   20020:	2303      	movs	r3, #3
   20022:	7223      	strb	r3, [r4, #8]


			logt("HANDSHAKE", "IN <= %d CLUSTER_WELCOME clustID:%x, clustSize:%d, toSink:%d", packet->header.sender, packet->payload.clusterId, packet->payload.clusterSize, packet->payload.hopsToSink);

			//PART 1: We do have the same cluster ID. Ouuups, should not have happened, run Forest!
			if (packet->payload.clusterId == clusterIDBackup)
   20024:	79aa      	ldrb	r2, [r5, #6]
   20026:	7968      	ldrb	r0, [r5, #5]
   20028:	79eb      	ldrb	r3, [r5, #7]
   2002a:	0212      	lsls	r2, r2, #8
   2002c:	4302      	orrs	r2, r0
   2002e:	041b      	lsls	r3, r3, #16
   20030:	4313      	orrs	r3, r2
   20032:	1c1a      	adds	r2, r3, #0
   20034:	7a2b      	ldrb	r3, [r5, #8]
   20036:	061b      	lsls	r3, r3, #24
   20038:	4313      	orrs	r3, r2
   2003a:	2280      	movs	r2, #128	; 0x80
   2003c:	0092      	lsls	r2, r2, #2
   2003e:	58a0      	ldr	r0, [r4, r2]
   20040:	4283      	cmp	r3, r0
   20042:	d103      	bne.n	2004c <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0xd8>
			{
				logt("HANDSHAKE", "CONN %u disconnected because it had the same clusterId before handshake", connectionId);
				this->Disconnect();
   20044:	1c20      	adds	r0, r4, #0
   20046:	f7ff fd75 	bl	1fb34 <_ZN10Connection10DisconnectEv>
   2004a:	e111      	b.n	20270 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x2fc>
			}
			//PART 2: This is more probable, he's in a different cluster
			else if (packet->payload.clusterSize < clusterSizeBackup || (packet->payload.clusterSize == clusterSizeBackup && packet->payload.clusterId < clusterIDBackup))
   2004c:	7aaa      	ldrb	r2, [r5, #10]
   2004e:	7a69      	ldrb	r1, [r5, #9]
   20050:	0212      	lsls	r2, r2, #8
   20052:	430a      	orrs	r2, r1
   20054:	2181      	movs	r1, #129	; 0x81
   20056:	0089      	lsls	r1, r1, #2
   20058:	5e61      	ldrsh	r1, [r4, r1]
   2005a:	b212      	sxth	r2, r2
   2005c:	428a      	cmp	r2, r1
   2005e:	db02      	blt.n	20066 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0xf2>
   20060:	d109      	bne.n	20076 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x102>
   20062:	4283      	cmp	r3, r0
   20064:	d207      	bcs.n	20076 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x102>
			{
				//I am the bigger cluster
				logt("HANDSHAKE", "I am bigger");

				if(direction == CONNECTION_DIRECTION_IN){
   20066:	7b63      	ldrb	r3, [r4, #13]
   20068:	2b00      	cmp	r3, #0
   2006a:	d000      	beq.n	2006e <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0xfa>
   2006c:	e100      	b.n	20270 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x2fc>
					StartHandshake();
   2006e:	1c20      	adds	r0, r4, #0
   20070:	f7ff fd10 	bl	1fa94 <_ZN10Connection14StartHandshakeEv>
   20074:	e0fc      	b.n	20270 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x2fc>
				//I am the smaller cluster
				logt("HANDSHAKE", "I am smaller");

				//Kill other Connections
				//FIXME: what does the disconnect function do? it should just clear these connections!!!
				cm->ForceDisconnectOtherConnections(this);
   20076:	6860      	ldr	r0, [r4, #4]
   20078:	1c21      	adds	r1, r4, #0
   2007a:	f7fd fd48 	bl	1db0e <_ZN17ConnectionManager31ForceDisconnectOtherConnectionsEP10Connection>

				//Because we forcefully killed our connections, we are back at square 1
				//These values will be overwritten by the ACK2 packet that we receive from out partner
				//But if we do never receive an ACK2, this is our new starting point
				node->clusterSize = 1;
   2007e:	6823      	ldr	r3, [r4, #0]
   20080:	2601      	movs	r6, #1
   20082:	1c1a      	adds	r2, r3, #0
   20084:	3278      	adds	r2, #120	; 0x78
   20086:	8016      	strh	r6, [r2, #0]

//Generates a new clusterID by using connectionLoss and the unique id of the node
clusterID Node::GenerateClusterID(void)
{
	//Combine connection loss and nodeId to generate a unique cluster id
	clusterID newId = this->persistentConfig.nodeId + (this->persistentConfig.connectionLossCounter << 16);
   20088:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
   2008a:	8cd9      	ldrh	r1, [r3, #38]	; 0x26
   2008c:	0412      	lsls	r2, r2, #16
   2008e:	188a      	adds	r2, r1, r2
				node->clusterId = node->GenerateClusterID();
   20090:	67da      	str	r2, [r3, #124]	; 0x7c

				//Update my own information on the connection
				this->partnerId = packet->header.sender;
   20092:	78ab      	ldrb	r3, [r5, #2]
   20094:	7868      	ldrb	r0, [r5, #1]
   20096:	021b      	lsls	r3, r3, #8
   20098:	4318      	orrs	r0, r3
   2009a:	23e8      	movs	r3, #232	; 0xe8

				//Send an update to the connected cluster to increase the size by one
				//This is also the ACK message for our connecting node
				connPacketClusterAck1 packet;

				packet.header.messageType = MESSAGE_TYPE_CLUSTER_ACK_1;
   2009c:	252a      	movs	r5, #42	; 0x2a
				//But if we do never receive an ACK2, this is our new starting point
				node->clusterSize = 1;
				node->clusterId = node->GenerateClusterID();

				//Update my own information on the connection
				this->partnerId = packet->header.sender;
   2009e:	005b      	lsls	r3, r3, #1

				//Send an update to the connected cluster to increase the size by one
				//This is also the ACK message for our connecting node
				connPacketClusterAck1 packet;

				packet.header.messageType = MESSAGE_TYPE_CLUSTER_ACK_1;
   200a0:	aa04      	add	r2, sp, #16
				//But if we do never receive an ACK2, this is our new starting point
				node->clusterSize = 1;
				node->clusterId = node->GenerateClusterID();

				//Update my own information on the connection
				this->partnerId = packet->header.sender;
   200a2:	52e0      	strh	r0, [r4, r3]

				//Send an update to the connected cluster to increase the size by one
				//This is also the ACK message for our connecting node
				connPacketClusterAck1 packet;

				packet.header.messageType = MESSAGE_TYPE_CLUSTER_ACK_1;
   200a4:	7813      	ldrb	r3, [r2, #0]
   200a6:	4033      	ands	r3, r6
   200a8:	432b      	orrs	r3, r5
   200aa:	7013      	strb	r3, [r2, #0]
				packet.header.sender = node->persistentConfig.nodeId;
   200ac:	2309      	movs	r3, #9
   200ae:	ad02      	add	r5, sp, #8
   200b0:	195b      	adds	r3, r3, r5
   200b2:	7019      	strb	r1, [r3, #0]
   200b4:	0a09      	lsrs	r1, r1, #8
   200b6:	7059      	strb	r1, [r3, #1]
				packet.header.receiver = this->partnerId;
   200b8:	210b      	movs	r1, #11
   200ba:	0a03      	lsrs	r3, r0, #8
   200bc:	1949      	adds	r1, r1, r5
   200be:	7008      	strb	r0, [r1, #0]
   200c0:	704b      	strb	r3, [r1, #1]

				packet.payload.hopsToSink = -1;
   200c2:	230d      	movs	r3, #13
   200c4:	2101      	movs	r1, #1
   200c6:	195b      	adds	r3, r3, r5
   200c8:	4249      	negs	r1, r1
   200ca:	7019      	strb	r1, [r3, #0]
   200cc:	7059      	strb	r1, [r3, #1]

				logt("HANDSHAKE", "OUT => %d CLUSTER_ACK_1, hops:%d", packet.header.receiver, packet.payload.hopsToSink);

				cm->SendHandshakeMessage(this, (u8*) &packet, SIZEOF_CONN_PACKET_CLUSTER_ACK_1, true);
   200ce:	6860      	ldr	r0, [r4, #4]
   200d0:	1c21      	adds	r1, r4, #0
   200d2:	2308      	movs	r3, #8
   200d4:	e056      	b.n	20184 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x210>
		{
			logt("CONN", "wrong size for CLUSTER_WELCOME");
		}
		/******* Cluster ack 1 (another node confirms that it is joining our cluster, we are bigger) *******/
	}
	else if (packetHeader->messageType == MESSAGE_TYPE_CLUSTER_ACK_1)
   200d6:	2b2a      	cmp	r3, #42	; 0x2a
   200d8:	d157      	bne.n	2018a <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x216>
	{
		if (dataLength == SIZEOF_CONN_PACKET_CLUSTER_ACK_1)
   200da:	2e08      	cmp	r6, #8
   200dc:	d000      	beq.n	200e0 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x16c>
   200de:	e0c7      	b.n	20270 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x2fc>
				//TODO: disconnect
				logt("ERROR", "HANDSHAKE ERROR ACI1 duplicate");
			}

			//Save ACK1 packet for later
			memcpy(&clusterAck1Packet, data, sizeof(connPacketClusterAck1));
   200e0:	1c20      	adds	r0, r4, #0
   200e2:	30eb      	adds	r0, #235	; 0xeb
   200e4:	1c29      	adds	r1, r5, #0
   200e6:	1c32      	adds	r2, r6, #0
   200e8:	30ff      	adds	r0, #255	; 0xff
   200ea:	f001 fa93 	bl	21614 <memcpy>
			logt("HANDSHAKE", "IN <= %d  CLUSTER_ACK_1, hops:%d", clusterAck1Packet.header.sender, clusterAck1Packet.payload.hopsToSink);


			//Set the master bit for the connection. If the connection would disconnect
			//Then we could keep intact and the other one must dissolve
			this->partnerId = clusterAck1Packet.header.sender;
   200ee:	23ec      	movs	r3, #236	; 0xec
   200f0:	33ff      	adds	r3, #255	; 0xff
   200f2:	5ce1      	ldrb	r1, [r4, r3]
   200f4:	3301      	adds	r3, #1
   200f6:	5ce3      	ldrb	r3, [r4, r3]
			this->connectionMasterBit = 1;
   200f8:	2201      	movs	r2, #1
			logt("HANDSHAKE", "IN <= %d  CLUSTER_ACK_1, hops:%d", clusterAck1Packet.header.sender, clusterAck1Packet.payload.hopsToSink);


			//Set the master bit for the connection. If the connection would disconnect
			//Then we could keep intact and the other one must dissolve
			this->partnerId = clusterAck1Packet.header.sender;
   200fa:	021b      	lsls	r3, r3, #8
   200fc:	4319      	orrs	r1, r3
   200fe:	23e8      	movs	r3, #232	; 0xe8
			this->connectionMasterBit = 1;

			//Confirm to the new node that it just joined our cluster => send ACK2
			connPacketClusterAck2 outPacket2;
			outPacket2.header.messageType = MESSAGE_TYPE_CLUSTER_ACK_2;
   20100:	2001      	movs	r0, #1
			logt("HANDSHAKE", "IN <= %d  CLUSTER_ACK_1, hops:%d", clusterAck1Packet.header.sender, clusterAck1Packet.payload.hopsToSink);


			//Set the master bit for the connection. If the connection would disconnect
			//Then we could keep intact and the other one must dissolve
			this->partnerId = clusterAck1Packet.header.sender;
   20102:	005b      	lsls	r3, r3, #1
   20104:	52e1      	strh	r1, [r4, r3]
			this->connectionMasterBit = 1;
   20106:	3338      	adds	r3, #56	; 0x38
   20108:	54e2      	strb	r2, [r4, r3]

			//Confirm to the new node that it just joined our cluster => send ACK2
			connPacketClusterAck2 outPacket2;
			outPacket2.header.messageType = MESSAGE_TYPE_CLUSTER_ACK_2;
   2010a:	aa04      	add	r2, sp, #16
   2010c:	7813      	ldrb	r3, [r2, #0]
			outPacket2.header.sender = node->persistentConfig.nodeId;
   2010e:	ad02      	add	r5, sp, #8
			this->partnerId = clusterAck1Packet.header.sender;
			this->connectionMasterBit = 1;

			//Confirm to the new node that it just joined our cluster => send ACK2
			connPacketClusterAck2 outPacket2;
			outPacket2.header.messageType = MESSAGE_TYPE_CLUSTER_ACK_2;
   20110:	4003      	ands	r3, r0
   20112:	302b      	adds	r0, #43	; 0x2b
   20114:	4303      	orrs	r3, r0
   20116:	7013      	strb	r3, [r2, #0]
			outPacket2.header.sender = node->persistentConfig.nodeId;
   20118:	6823      	ldr	r3, [r4, #0]
   2011a:	3823      	subs	r0, #35	; 0x23
   2011c:	1940      	adds	r0, r0, r5
   2011e:	1ddd      	adds	r5, r3, #7
   20120:	7fed      	ldrb	r5, [r5, #31]
   20122:	3308      	adds	r3, #8
   20124:	7005      	strb	r5, [r0, #0]
   20126:	7fdb      	ldrb	r3, [r3, #31]
   20128:	7043      	strb	r3, [r0, #1]
			outPacket2.header.receiver = this->partnerId;
   2012a:	200b      	movs	r0, #11
   2012c:	ab02      	add	r3, sp, #8
   2012e:	18c0      	adds	r0, r0, r3
   20130:	0a0b      	lsrs	r3, r1, #8
   20132:	7043      	strb	r3, [r0, #1]

			outPacket2.payload.clusterId = clusterIDBackup;
   20134:	230d      	movs	r3, #13

			//Confirm to the new node that it just joined our cluster => send ACK2
			connPacketClusterAck2 outPacket2;
			outPacket2.header.messageType = MESSAGE_TYPE_CLUSTER_ACK_2;
			outPacket2.header.sender = node->persistentConfig.nodeId;
			outPacket2.header.receiver = this->partnerId;
   20136:	7001      	strb	r1, [r0, #0]

			outPacket2.payload.clusterId = clusterIDBackup;
   20138:	a902      	add	r1, sp, #8
   2013a:	185b      	adds	r3, r3, r1
   2013c:	2180      	movs	r1, #128	; 0x80
   2013e:	0089      	lsls	r1, r1, #2
   20140:	5c61      	ldrb	r1, [r4, r1]
   20142:	7019      	strb	r1, [r3, #0]
   20144:	2180      	movs	r1, #128	; 0x80
   20146:	0089      	lsls	r1, r1, #2
   20148:	1861      	adds	r1, r4, r1
   2014a:	7848      	ldrb	r0, [r1, #1]
   2014c:	7058      	strb	r0, [r3, #1]
   2014e:	7888      	ldrb	r0, [r1, #2]
   20150:	78c9      	ldrb	r1, [r1, #3]
   20152:	7098      	strb	r0, [r3, #2]
   20154:	70d9      	strb	r1, [r3, #3]
			outPacket2.payload.clusterSize = clusterSizeBackup + 1; // add +1 for the new node itself
   20156:	2381      	movs	r3, #129	; 0x81
   20158:	2111      	movs	r1, #17
   2015a:	009b      	lsls	r3, r3, #2
   2015c:	5ae3      	ldrh	r3, [r4, r3]
   2015e:	a802      	add	r0, sp, #8
   20160:	3301      	adds	r3, #1
   20162:	1809      	adds	r1, r1, r0
   20164:	b29b      	uxth	r3, r3
   20166:	700b      	strb	r3, [r1, #0]
   20168:	0a1b      	lsrs	r3, r3, #8
   2016a:	704b      	strb	r3, [r1, #1]
			outPacket2.payload.hopsToSink = hopsToSinkBackup;
   2016c:	2313      	movs	r3, #19
   2016e:	4945      	ldr	r1, [pc, #276]	; (20284 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x310>)
   20170:	181b      	adds	r3, r3, r0
   20172:	5c61      	ldrb	r1, [r4, r1]


			logt("HANDSHAKE", "OUT => %d CLUSTER_ACK_2 clustId:%x, clustSize:%d", this->partnerId, outPacket2.payload.clusterId, outPacket2.payload.clusterSize);

			cm->SendHandshakeMessage(this, (u8*) &outPacket2, SIZEOF_CONN_PACKET_CLUSTER_ACK_2, true);
   20174:	6860      	ldr	r0, [r4, #4]
			outPacket2.header.sender = node->persistentConfig.nodeId;
			outPacket2.header.receiver = this->partnerId;

			outPacket2.payload.clusterId = clusterIDBackup;
			outPacket2.payload.clusterSize = clusterSizeBackup + 1; // add +1 for the new node itself
			outPacket2.payload.hopsToSink = hopsToSinkBackup;
   20176:	7019      	strb	r1, [r3, #0]
   20178:	4942      	ldr	r1, [pc, #264]	; (20284 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x310>)
   2017a:	1861      	adds	r1, r4, r1
   2017c:	7849      	ldrb	r1, [r1, #1]
   2017e:	7059      	strb	r1, [r3, #1]


			logt("HANDSHAKE", "OUT => %d CLUSTER_ACK_2 clustId:%x, clustSize:%d", this->partnerId, outPacket2.payload.clusterId, outPacket2.payload.clusterSize);

			cm->SendHandshakeMessage(this, (u8*) &outPacket2, SIZEOF_CONN_PACKET_CLUSTER_ACK_2, true);
   20180:	1c21      	adds	r1, r4, #0
   20182:	230d      	movs	r3, #13
   20184:	f7ff f84c 	bl	1f220 <_ZN17ConnectionManager20SendHandshakeMessageEP10ConnectionPhtb.constprop.7>
   20188:	e072      	b.n	20270 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x2fc>
			logt("CONN", "wrong size for ACK1");
		}

		/******* Cluster ack 2 *******/
	}
	else if (packetHeader->messageType == MESSAGE_TYPE_CLUSTER_ACK_2)
   2018a:	2b2c      	cmp	r3, #44	; 0x2c
   2018c:	d153      	bne.n	20236 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x2c2>
	{
		if (dataLength == SIZEOF_CONN_PACKET_CLUSTER_ACK_2)
   2018e:	2e0d      	cmp	r6, #13
   20190:	d16e      	bne.n	20270 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x2fc>
				//TODO: disconnect
				logt("ERROR", "HANDSHAKE ERROR ACK2 duplicate");
			}

			//Save Ack2 packet for later
			memcpy(&clusterAck2Packet, data, sizeof(connPacketClusterAck2));
   20192:	1c20      	adds	r0, r4, #0
   20194:	30f3      	adds	r0, #243	; 0xf3
   20196:	1c29      	adds	r1, r5, #0
   20198:	1c32      	adds	r2, r6, #0
   2019a:	30ff      	adds	r0, #255	; 0xff
   2019c:	f001 fa3a 	bl	21614 <memcpy>
	//This node was the looser of the Handshake and is now part of a newer bigger cluster
	} else {

		//The node that receives this message can not be connected to any other node
		//This is why we can set absolute values for the clusterSize
		connection->connectedClusterId = connection->clusterAck2Packet.payload.clusterId;
   201a0:	22fc      	movs	r2, #252	; 0xfc
   201a2:	23f8      	movs	r3, #248	; 0xf8
   201a4:	0052      	lsls	r2, r2, #1
   201a6:	58a7      	ldr	r7, [r4, r2]
   201a8:	33ff      	adds	r3, #255	; 0xff
   201aa:	5ce3      	ldrb	r3, [r4, r3]
   201ac:	023f      	lsls	r7, r7, #8
   201ae:	431f      	orrs	r7, r3
   201b0:	2383      	movs	r3, #131	; 0x83
   201b2:	009b      	lsls	r3, r3, #2

			logt("HANDSHAKE", "IN <= %d CLUSTER_ACK_2 clusterID:%x, clusterSize:%d", clusterAck2Packet.header.sender, clusterAck2Packet.payload.clusterId, clusterAck2Packet.payload.clusterSize);

			//Notify Node of handshakeDone
			node->HandshakeDoneHandler(this, false);
   201b4:	6825      	ldr	r5, [r4, #0]
   201b6:	50e7      	str	r7, [r4, r3]
		connection->connectedClusterSize = connection->clusterAck2Packet.payload.clusterSize - 1; // minus myself
   201b8:	23fc      	movs	r3, #252	; 0xfc
   201ba:	3204      	adds	r2, #4
   201bc:	5ca6      	ldrb	r6, [r4, r2]
   201be:	33ff      	adds	r3, #255	; 0xff
   201c0:	5ce3      	ldrb	r3, [r4, r3]
   201c2:	0236      	lsls	r6, r6, #8
   201c4:	431e      	orrs	r6, r3

		//If any cluster updates are waiting, we delete them
		memset(&connection->currentClusterInfoUpdatePacket, 0x00, sizeof(connPacketClusterInfoUpdate));
   201c6:	1c20      	adds	r0, r4, #0
	} else {

		//The node that receives this message can not be connected to any other node
		//This is why we can set absolute values for the clusterSize
		connection->connectedClusterId = connection->clusterAck2Packet.payload.clusterId;
		connection->connectedClusterSize = connection->clusterAck2Packet.payload.clusterSize - 1; // minus myself
   201c8:	2384      	movs	r3, #132	; 0x84
   201ca:	1e72      	subs	r2, r6, #1
   201cc:	009b      	lsls	r3, r3, #2

		//If any cluster updates are waiting, we delete them
		memset(&connection->currentClusterInfoUpdatePacket, 0x00, sizeof(connPacketClusterInfoUpdate));
   201ce:	305e      	adds	r0, #94	; 0x5e
	} else {

		//The node that receives this message can not be connected to any other node
		//This is why we can set absolute values for the clusterSize
		connection->connectedClusterId = connection->clusterAck2Packet.payload.clusterId;
		connection->connectedClusterSize = connection->clusterAck2Packet.payload.clusterSize - 1; // minus myself
   201d0:	52e2      	strh	r2, [r4, r3]

		//If any cluster updates are waiting, we delete them
		memset(&connection->currentClusterInfoUpdatePacket, 0x00, sizeof(connPacketClusterInfoUpdate));
   201d2:	30ff      	adds	r0, #255	; 0xff
   201d4:	220e      	movs	r2, #14
   201d6:	2100      	movs	r1, #0
   201d8:	f001 fa39 	bl	2164e <memset>

		clusterId = connection->clusterAck2Packet.payload.clusterId;
		clusterSize = connection->clusterAck2Packet.payload.clusterSize; // The other node knows best
   201dc:	1c2b      	adds	r3, r5, #0
   201de:	3378      	adds	r3, #120	; 0x78
		connection->connectedClusterSize = connection->clusterAck2Packet.payload.clusterSize - 1; // minus myself

		//If any cluster updates are waiting, we delete them
		memset(&connection->currentClusterInfoUpdatePacket, 0x00, sizeof(connPacketClusterInfoUpdate));

		clusterId = connection->clusterAck2Packet.payload.clusterId;
   201e0:	67ef      	str	r7, [r5, #124]	; 0x7c
		clusterSize = connection->clusterAck2Packet.payload.clusterSize; // The other node knows best
   201e2:	801e      	strh	r6, [r3, #0]

		connection->hopsToSink = connection->clusterAck2Packet.payload.hopsToSink < 0 ? -1 : connection->clusterAck2Packet.payload.hopsToSink + 1;
   201e4:	23fe      	movs	r3, #254	; 0xfe
   201e6:	005b      	lsls	r3, r3, #1
   201e8:	58e2      	ldr	r2, [r4, r3]
   201ea:	0212      	lsls	r2, r2, #8
   201ec:	0c13      	lsrs	r3, r2, #16
   201ee:	2a00      	cmp	r2, #0
   201f0:	db02      	blt.n	201f8 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x284>
   201f2:	3301      	adds	r3, #1
   201f4:	b29b      	uxth	r3, r3
   201f6:	e000      	b.n	201fa <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x286>
   201f8:	4b23      	ldr	r3, [pc, #140]	; (20288 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x314>)
   201fa:	4a24      	ldr	r2, [pc, #144]	; (2028c <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x318>)
   201fc:	1c2e      	adds	r6, r5, #0
   201fe:	52a3      	strh	r3, [r4, r2]
//		logt("HANDSHAKE", "ClusterSize set to %d", clusterSize);
	}

//	uart("CLUSTER", "{\"type\":\"cluster_handshake\",\"winner\":%u,\"size\":%d}" SEP, completedAsWinner, clusterSize);

	connection->connectionState = Connection::ConnectionState::HANDSHAKE_DONE;
   20200:	2304      	movs	r3, #4
   20202:	1c2f      	adds	r7, r5, #0
   20204:	7223      	strb	r3, [r4, #8]
	connection->connectionHandshakedTimestampDs = appTimerDs;
   20206:	6e6a      	ldr	r2, [r5, #100]	; 0x64
   20208:	33dd      	adds	r3, #221	; 0xdd
   2020a:	33ff      	adds	r3, #255	; 0xff
   2020c:	50e2      	str	r2, [r4, r3]
   2020e:	3640      	adds	r6, #64	; 0x40
   20210:	3754      	adds	r7, #84	; 0x54

	//Call our lovely modules
	for(int i=0; i<MAX_MODULE_COUNT; i++){
		if(activeModules[i] != NULL){
   20212:	6830      	ldr	r0, [r6, #0]
   20214:	2800      	cmp	r0, #0
   20216:	d003      	beq.n	20220 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x2ac>
			activeModules[i]->MeshConnectionChangedHandler(connection);
   20218:	6803      	ldr	r3, [r0, #0]
   2021a:	1c21      	adds	r1, r4, #0
   2021c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2021e:	4798      	blx	r3
   20220:	3604      	adds	r6, #4

	connection->connectionState = Connection::ConnectionState::HANDSHAKE_DONE;
	connection->connectionHandshakedTimestampDs = appTimerDs;

	//Call our lovely modules
	for(int i=0; i<MAX_MODULE_COUNT; i++){
   20222:	42be      	cmp	r6, r7
   20224:	d1f5      	bne.n	20212 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x29e>
			activeModules[i]->MeshConnectionChangedHandler(connection);
		}
	}

	//Update our advertisement packet
	UpdateJoinMePacket();
   20226:	1c28      	adds	r0, r5, #0
   20228:	f7fd fdc0 	bl	1ddac <_ZN4Node18UpdateJoinMePacketEv>

	//Go back to Discovery
	ChangeState(discoveryState::DISCOVERY);
   2022c:	1c28      	adds	r0, r5, #0
   2022e:	2102      	movs	r1, #2
   20230:	f7fd fe08 	bl	1de44 <_ZN4Node11ChangeStateE14discoveryState>
   20234:	e01c      	b.n	20270 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x2fc>
	/*#################### MESSAGE PROCESSING ############################*/
	else
	{
		//Check wether we should care for this packet
		if(
				packetHeader->receiver == node->persistentConfig.nodeId //Directly addressed at us
   20236:	792b      	ldrb	r3, [r5, #4]
   20238:	78ea      	ldrb	r2, [r5, #3]
   2023a:	021b      	lsls	r3, r3, #8
   2023c:	4313      	orrs	r3, r2
   2023e:	6822      	ldr	r2, [r4, #0]

	/*#################### MESSAGE PROCESSING ############################*/
	else
	{
		//Check wether we should care for this packet
		if(
   20240:	8cd1      	ldrh	r1, [r2, #38]	; 0x26
   20242:	4299      	cmp	r1, r3
   20244:	d00e      	beq.n	20264 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x2f0>
				packetHeader->receiver == node->persistentConfig.nodeId //Directly addressed at us
				|| packetHeader->receiver == NODE_ID_BROADCAST //broadcast packet for all nodes
   20246:	2b00      	cmp	r3, #0
   20248:	d00c      	beq.n	20264 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x2f0>
				|| (packetHeader->receiver >= NODE_ID_HOPS_BASE && packetHeader->receiver < NODE_ID_HOPS_BASE + 1000) //Broadcasted for a number of hops
   2024a:	4911      	ldr	r1, [pc, #68]	; (20290 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x31c>)
   2024c:	4811      	ldr	r0, [pc, #68]	; (20294 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x320>)
   2024e:	1859      	adds	r1, r3, r1
   20250:	b289      	uxth	r1, r1
   20252:	4281      	cmp	r1, r0
   20254:	d906      	bls.n	20264 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x2f0>
				|| (packetHeader->receiver == NODE_ID_SHORTEST_SINK && node->persistentConfig.deviceType == deviceTypes::DEVICE_TYPE_SINK)
   20256:	4908      	ldr	r1, [pc, #32]	; (20278 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x304>)
   20258:	428b      	cmp	r3, r1
   2025a:	d109      	bne.n	20270 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x2fc>
   2025c:	323a      	adds	r2, #58	; 0x3a
   2025e:	7813      	ldrb	r3, [r2, #0]
   20260:	2b02      	cmp	r3, #2
   20262:	d105      	bne.n	20270 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2+0x2fc>
		){
			//Forward that Packet to the Node
			cm->connectionManagerCallback->messageReceivedCallback(inPacket);
   20264:	6863      	ldr	r3, [r4, #4]
   20266:	1c39      	adds	r1, r7, #0
   20268:	6898      	ldr	r0, [r3, #8]
   2026a:	6803      	ldr	r3, [r0, #0]
   2026c:	695b      	ldr	r3, [r3, #20]
   2026e:	4798      	blx	r3
		}
	}

}
   20270:	b009      	add	sp, #36	; 0x24
   20272:	bdf0      	pop	{r4, r5, r6, r7, pc}
   20274:	00007531 	.word	0x00007531
   20278:	00007919 	.word	0x00007919
   2027c:	ffff8acf 	.word	0xffff8acf
   20280:	000003e6 	.word	0x000003e6
   20284:	00000206 	.word	0x00000206
   20288:	0000ffff 	.word	0x0000ffff
   2028c:	00000212 	.word	0x00000212
   20290:	ffff8ad0 	.word	0xffff8ad0
   20294:	000003e7 	.word	0x000003e7

00020298 <_ZN17ConnectionManager23messageReceivedCallbackEP9ble_evt_t>:
	cm->connectionManagerCallback->ConnectingTimeoutHandler(bleEvent);

}

void ConnectionManager::messageReceivedCallback(ble_evt_t* bleEvent)
{
   20298:	b5f0      	push	{r4, r5, r6, r7, lr}
   2029a:	1c05      	adds	r5, r0, #0
   2029c:	b09f      	sub	sp, #124	; 0x7c
	ConnectionManager* cm = ConnectionManager::getInstance();
   2029e:	f7fd fa17 	bl	1d6d0 <_ZN17ConnectionManager11getInstanceEv>
	//Handles BLE_GATTS_EVT_WRITE


	//FIXME: must check for reassembly buffer size, if it is bigger, a stack overflow will occur

	Connection* connection = cm->GetConnectionFromHandle(bleEvent->evt.gatts_evt.conn_handle);
   202a2:	88a9      	ldrh	r1, [r5, #4]

}

void ConnectionManager::messageReceivedCallback(ble_evt_t* bleEvent)
{
	ConnectionManager* cm = ConnectionManager::getInstance();
   202a4:	1c07      	adds	r7, r0, #0
	//Handles BLE_GATTS_EVT_WRITE


	//FIXME: must check for reassembly buffer size, if it is bigger, a stack overflow will occur

	Connection* connection = cm->GetConnectionFromHandle(bleEvent->evt.gatts_evt.conn_handle);
   202a6:	f7fd fc4d 	bl	1db44 <_ZN17ConnectionManager23GetConnectionFromHandleEt>
   202aa:	1e04      	subs	r4, r0, #0
	if (connection != NULL)
   202ac:	d069      	beq.n	20382 <_ZN17ConnectionManager23messageReceivedCallbackEP9ble_evt_t+0xea>


		connPacketHeader* packet = (connPacketHeader*)bleEvent->evt.gatts_evt.params.write.data;

		//At first, some special treatment for out timestamp packet
		if(packet->messageType == MESSAGE_TYPE_UPDATE_TIMESTAMP)
   202ae:	1c2e      	adds	r6, r5, #0
   202b0:	2201      	movs	r2, #1
   202b2:	7cab      	ldrb	r3, [r5, #18]
   202b4:	3612      	adds	r6, #18
   202b6:	4393      	bics	r3, r2
   202b8:	2b3c      	cmp	r3, #60	; 0x3c
   202ba:	d112      	bne.n	202e2 <_ZN17ConnectionManager23messageReceivedCallbackEP9ble_evt_t+0x4a>
		{
			//Set our time to the received timestamp
			cm->node->globalTimeSec = ((connPacketUpdateTimestamp*)packet)->timestampSec;
   202bc:	79b2      	ldrb	r2, [r6, #6]
   202be:	7970      	ldrb	r0, [r6, #5]
   202c0:	79f3      	ldrb	r3, [r6, #7]
   202c2:	0212      	lsls	r2, r2, #8
   202c4:	4302      	orrs	r2, r0
   202c6:	041b      	lsls	r3, r3, #16
   202c8:	4313      	orrs	r3, r2
   202ca:	1c1a      	adds	r2, r3, #0
   202cc:	7a33      	ldrb	r3, [r6, #8]
   202ce:	687f      	ldr	r7, [r7, #4]
   202d0:	061b      	lsls	r3, r3, #24
   202d2:	4313      	orrs	r3, r2
   202d4:	65bb      	str	r3, [r7, #88]	; 0x58
			cm->node->globalTimeRemainderTicks = ((connPacketUpdateTimestamp*)packet)->remainderTicks;
   202d6:	7ab3      	ldrb	r3, [r6, #10]
   202d8:	7a72      	ldrb	r2, [r6, #9]
   202da:	021b      	lsls	r3, r3, #8
   202dc:	4313      	orrs	r3, r2
   202de:	3760      	adds	r7, #96	; 0x60
   202e0:	803b      	strh	r3, [r7, #0]
			logt("ERROR", "WAAAAAAAAAAAAAHHHHH, WRONG DATAAAAAAAAAAAAAAAAA!!!!!!!!!");
		}

		//Print packet as hex
		char stringBuffer[100];
		Logger::getInstance().convertBufferToHexString(bleEvent->evt.gatts_evt.params.write.data, bleEvent->evt.gatts_evt.params.write.len, stringBuffer, 100);
   202e2:	f7fc ffd9 	bl	1d298 <_ZN6Logger11getInstanceEv>
		logt("CONN_DATA", "Received type %d, hasMore %d, length %d, reliable %d:", ((connPacketHeader*)bleEvent->evt.gatts_evt.params.write.data)->messageType, ((connPacketHeader*)bleEvent->evt.gatts_evt.params.write.data)->hasMoreParts, bleEvent->evt.gatts_evt.params.write.len, bleEvent->evt.gatts_evt.params.write.op);
		logt("CONN_DATA", "%s", stringBuffer);

		//Check if we need to reassemble the packet
		if(connection->packetReassemblyPosition == 0 && packet->hasMoreParts == 0)
   202e6:	27d0      	movs	r7, #208	; 0xd0
			logt("ERROR", "WAAAAAAAAAAAAAHHHHH, WRONG DATAAAAAAAAAAAAAAAAA!!!!!!!!!");
		}

		//Print packet as hex
		char stringBuffer[100];
		Logger::getInstance().convertBufferToHexString(bleEvent->evt.gatts_evt.params.write.data, bleEvent->evt.gatts_evt.params.write.len, stringBuffer, 100);
   202e8:	2364      	movs	r3, #100	; 0x64
   202ea:	8a2a      	ldrh	r2, [r5, #16]
   202ec:	9300      	str	r3, [sp, #0]
   202ee:	1c31      	adds	r1, r6, #0
   202f0:	ab05      	add	r3, sp, #20
		logt("CONN_DATA", "Received type %d, hasMore %d, length %d, reliable %d:", ((connPacketHeader*)bleEvent->evt.gatts_evt.params.write.data)->messageType, ((connPacketHeader*)bleEvent->evt.gatts_evt.params.write.data)->hasMoreParts, bleEvent->evt.gatts_evt.params.write.len, bleEvent->evt.gatts_evt.params.write.op);
		logt("CONN_DATA", "%s", stringBuffer);

		//Check if we need to reassemble the packet
		if(connection->packetReassemblyPosition == 0 && packet->hasMoreParts == 0)
   202f2:	37ff      	adds	r7, #255	; 0xff
			logt("ERROR", "WAAAAAAAAAAAAAHHHHH, WRONG DATAAAAAAAAAAAAAAAAA!!!!!!!!!");
		}

		//Print packet as hex
		char stringBuffer[100];
		Logger::getInstance().convertBufferToHexString(bleEvent->evt.gatts_evt.params.write.data, bleEvent->evt.gatts_evt.params.write.len, stringBuffer, 100);
   202f4:	f7ff fb6c 	bl	1f9d0 <_ZN6Logger24convertBufferToHexStringEPhmPct>
		logt("CONN_DATA", "Received type %d, hasMore %d, length %d, reliable %d:", ((connPacketHeader*)bleEvent->evt.gatts_evt.params.write.data)->messageType, ((connPacketHeader*)bleEvent->evt.gatts_evt.params.write.data)->hasMoreParts, bleEvent->evt.gatts_evt.params.write.len, bleEvent->evt.gatts_evt.params.write.op);
		logt("CONN_DATA", "%s", stringBuffer);

		//Check if we need to reassemble the packet
		if(connection->packetReassemblyPosition == 0 && packet->hasMoreParts == 0)
   202f8:	5de0      	ldrb	r0, [r4, r7]
   202fa:	8a2a      	ldrh	r2, [r5, #16]
   202fc:	2800      	cmp	r0, #0
   202fe:	d116      	bne.n	2032e <_ZN17ConnectionManager23messageReceivedCallbackEP9ble_evt_t+0x96>
   20300:	7cab      	ldrb	r3, [r5, #18]
   20302:	07db      	lsls	r3, r3, #31
   20304:	d40a      	bmi.n	2031c <_ZN17ConnectionManager23messageReceivedCallbackEP9ble_evt_t+0x84>
		{

			//Single packet, no more data
			connectionPacket p;
			p.connectionHandle = bleEvent->evt.gatts_evt.conn_handle;
   20306:	88ab      	ldrh	r3, [r5, #4]
   20308:	a902      	add	r1, sp, #8
			p.data = bleEvent->evt.gatts_evt.params.write.data;
			p.dataLength = bleEvent->evt.gatts_evt.params.write.len;
   2030a:	810a      	strh	r2, [r1, #8]
		if(connection->packetReassemblyPosition == 0 && packet->hasMoreParts == 0)
		{

			//Single packet, no more data
			connectionPacket p;
			p.connectionHandle = bleEvent->evt.gatts_evt.conn_handle;
   2030c:	800b      	strh	r3, [r1, #0]
			p.data = bleEvent->evt.gatts_evt.params.write.data;
   2030e:	604e      	str	r6, [r1, #4]
			p.dataLength = bleEvent->evt.gatts_evt.params.write.len;
			p.reliable = bleEvent->evt.gatts_evt.params.write.op == BLE_GATTS_OP_WRITE_CMD ? false : true;
   20310:	7b2b      	ldrb	r3, [r5, #12]
   20312:	3b02      	subs	r3, #2
   20314:	1e5a      	subs	r2, r3, #1
   20316:	4193      	sbcs	r3, r2
   20318:	708b      	strb	r3, [r1, #2]
   2031a:	e02c      	b.n	20376 <_ZN17ConnectionManager23messageReceivedCallbackEP9ble_evt_t+0xde>
			//Save at correct position of
			memcpy(
					connection->packetReassemblyBuffer,
					bleEvent->evt.gatts_evt.params.write.data,
					bleEvent->evt.gatts_evt.params.write.len
				);
   2031c:	1c20      	adds	r0, r4, #0
   2031e:	306c      	adds	r0, #108	; 0x6c
   20320:	30ff      	adds	r0, #255	; 0xff
   20322:	1c31      	adds	r1, r6, #0
   20324:	f001 f976 	bl	21614 <memcpy>

			connection->packetReassemblyPosition += bleEvent->evt.gatts_evt.params.write.len;
   20328:	8a2a      	ldrh	r2, [r5, #16]
   2032a:	5de3      	ldrb	r3, [r4, r7]
   2032c:	e00f      	b.n	2034e <_ZN17ConnectionManager23messageReceivedCallbackEP9ble_evt_t+0xb6>
		{
			memcpy(
				connection->packetReassemblyBuffer + connection->packetReassemblyPosition,
				bleEvent->evt.gatts_evt.params.write.data + SIZEOF_CONN_PACKET_SPLIT_HEADER,
				bleEvent->evt.gatts_evt.params.write.len - SIZEOF_CONN_PACKET_SPLIT_HEADER
			);
   2032e:	1c29      	adds	r1, r5, #0
   20330:	1820      	adds	r0, r4, r0
   20332:	306c      	adds	r0, #108	; 0x6c
		else if(connection->packetReassemblyPosition != 0)
		{
			memcpy(
				connection->packetReassemblyBuffer + connection->packetReassemblyPosition,
				bleEvent->evt.gatts_evt.params.write.data + SIZEOF_CONN_PACKET_SPLIT_HEADER,
				bleEvent->evt.gatts_evt.params.write.len - SIZEOF_CONN_PACKET_SPLIT_HEADER
   20334:	3a01      	subs	r2, #1
			);
   20336:	30ff      	adds	r0, #255	; 0xff
   20338:	3113      	adds	r1, #19
   2033a:	f001 f96b 	bl	21614 <memcpy>

			//Intermediate packet
			if(packet->hasMoreParts){
   2033e:	2301      	movs	r3, #1
   20340:	7caa      	ldrb	r2, [r5, #18]
   20342:	401a      	ands	r2, r3
   20344:	8a2b      	ldrh	r3, [r5, #16]
   20346:	2a00      	cmp	r2, #0
   20348:	d004      	beq.n	20354 <_ZN17ConnectionManager23messageReceivedCallbackEP9ble_evt_t+0xbc>
   2034a:	5de2      	ldrb	r2, [r4, r7]
   2034c:	3a01      	subs	r2, #1
				connection->packetReassemblyPosition += bleEvent->evt.gatts_evt.params.write.len - SIZEOF_CONN_PACKET_SPLIT_HEADER;
   2034e:	189b      	adds	r3, r3, r2
   20350:	55e3      	strb	r3, [r4, r7]
   20352:	e016      	b.n	20382 <_ZN17ConnectionManager23messageReceivedCallbackEP9ble_evt_t+0xea>
			} else {
				logt("CM", "Received last part of message");

				//Notify connection
				connectionPacket p;
				p.connectionHandle = bleEvent->evt.gatts_evt.conn_handle;
   20354:	88a8      	ldrh	r0, [r5, #4]
   20356:	a902      	add	r1, sp, #8
   20358:	8008      	strh	r0, [r1, #0]
				p.data = connection->packetReassemblyBuffer;
   2035a:	1c20      	adds	r0, r4, #0
   2035c:	306c      	adds	r0, #108	; 0x6c
   2035e:	30ff      	adds	r0, #255	; 0xff
   20360:	6048      	str	r0, [r1, #4]
				p.dataLength = bleEvent->evt.gatts_evt.params.write.len + connection->packetReassemblyPosition - SIZEOF_CONN_PACKET_SPLIT_HEADER;
   20362:	5de0      	ldrb	r0, [r4, r7]
   20364:	3b01      	subs	r3, #1
   20366:	18c3      	adds	r3, r0, r3
   20368:	810b      	strh	r3, [r1, #8]
				p.reliable = bleEvent->evt.gatts_evt.params.write.op == BLE_GATTS_OP_WRITE_CMD ? false : true;
   2036a:	7b2b      	ldrb	r3, [r5, #12]
   2036c:	3b02      	subs	r3, #2
   2036e:	1e58      	subs	r0, r3, #1
   20370:	4183      	sbcs	r3, r0
   20372:	708b      	strb	r3, [r1, #2]

				//Reset the assembly buffer
				connection->packetReassemblyPosition = 0;
   20374:	55e2      	strb	r2, [r4, r7]
}


void Connection::ReceivePacketHandler(connectionPacket* inPacket)
{
	if(connectionState == ConnectionState::DISCONNECTED) return;
   20376:	7a23      	ldrb	r3, [r4, #8]
   20378:	2b00      	cmp	r3, #0
   2037a:	d002      	beq.n	20382 <_ZN17ConnectionManager23messageReceivedCallbackEP9ble_evt_t+0xea>
   2037c:	1c20      	adds	r0, r4, #0
   2037e:	f7ff fdf9 	bl	1ff74 <_ZN10Connection20ReceivePacketHandlerEP16connectionPacket.part.2>

				connection->ReceivePacketHandler(&p);
			}
		}
	}
}
   20382:	b01f      	add	sp, #124	; 0x7c
   20384:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

00020388 <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t>:
	}
}


void ConnectionManager::dataTransmittedCallback(ble_evt_t* bleEvent)
{
   20388:	b5f0      	push	{r4, r5, r6, r7, lr}
   2038a:	1c04      	adds	r4, r0, #0
   2038c:	b087      	sub	sp, #28

	ConnectionManager* cm = ConnectionManager::getInstance();
   2038e:	f7fd f99f 	bl	1d6d0 <_ZN17ConnectionManager11getInstanceEv>
	//There are two types of events that trigger a dataTransmittedCallback
	//A TX complete event frees a number of transmit buffers
	//These are used for all connections
	if(bleEvent->header.evt_id == BLE_EVT_TX_COMPLETE)
   20392:	8823      	ldrh	r3, [r4, #0]


void ConnectionManager::dataTransmittedCallback(ble_evt_t* bleEvent)
{

	ConnectionManager* cm = ConnectionManager::getInstance();
   20394:	1c06      	adds	r6, r0, #0
	//There are two types of events that trigger a dataTransmittedCallback
	//A TX complete event frees a number of transmit buffers
	//These are used for all connections
	if(bleEvent->header.evt_id == BLE_EVT_TX_COMPLETE)
   20396:	2b01      	cmp	r3, #1
   20398:	d10c      	bne.n	203b4 <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t+0x2c>
	{

		logt("CONN_DATA", "write_CMD complete (n=%d)", bleEvent->evt.common_evt.params.tx_complete.count);

		//This connection has just been given back some transmit buffers
		Connection* connection = cm->GetConnectionFromHandle(bleEvent->evt.common_evt.conn_handle);
   2039a:	88a1      	ldrh	r1, [r4, #4]
   2039c:	f7fd fbd2 	bl	1db44 <_ZN17ConnectionManager23GetConnectionFromHandleEt>
		connection->unreliableBuffersFree += bleEvent->evt.common_evt.params.tx_complete.count;
   203a0:	7a22      	ldrb	r2, [r4, #8]
   203a2:	7cc3      	ldrb	r3, [r0, #19]
   203a4:	18d3      	adds	r3, r2, r3

		connection->sentUnreliable++;
   203a6:	2287      	movs	r2, #135	; 0x87

		logt("CONN_DATA", "write_CMD complete (n=%d)", bleEvent->evt.common_evt.params.tx_complete.count);

		//This connection has just been given back some transmit buffers
		Connection* connection = cm->GetConnectionFromHandle(bleEvent->evt.common_evt.conn_handle);
		connection->unreliableBuffersFree += bleEvent->evt.common_evt.params.tx_complete.count;
   203a8:	74c3      	strb	r3, [r0, #19]

		connection->sentUnreliable++;
   203aa:	0092      	lsls	r2, r2, #2
   203ac:	5a83      	ldrh	r3, [r0, r2]
   203ae:	3301      	adds	r3, #1
   203b0:	5283      	strh	r3, [r0, r2]
   203b2:	e098      	b.n	204e6 <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t+0x15e>
		if(cm->GetPendingPackets()) cm->fillTransmitBuffers();

	}
	//The EVT_WRITE_RSP comes after a WRITE_REQ and notifies that a buffer
	//for one specific connection has been cleared
	else if (bleEvent->header.evt_id == BLE_GATTC_EVT_WRITE_RSP)
   203b4:	2b38      	cmp	r3, #56	; 0x38
   203b6:	d000      	beq.n	203ba <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t+0x32>
   203b8:	e09d      	b.n	204f6 <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t+0x16e>
	{
		if(bleEvent->evt.gattc_evt.gatt_status != BLE_GATT_STATUS_SUCCESS)
   203ba:	88e3      	ldrh	r3, [r4, #6]
   203bc:	2b00      	cmp	r3, #0
   203be:	d000      	beq.n	203c2 <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t+0x3a>
   203c0:	e099      	b.n	204f6 <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t+0x16e>

		}
		else
		{
			logt("CONN_DATA", "write_REQ complete");
			Connection* connection = cm->GetConnectionFromHandle(bleEvent->evt.gattc_evt.conn_handle);
   203c2:	88a1      	ldrh	r1, [r4, #4]
   203c4:	f7fd fbbe 	bl	1db44 <_ZN17ConnectionManager23GetConnectionFromHandleEt>
   203c8:	1e04      	subs	r4, r0, #0

			//Connection could have been disconneced
			if(connection == NULL) return;
   203ca:	d100      	bne.n	203ce <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t+0x46>
   203cc:	e093      	b.n	204f6 <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t+0x16e>

			connection->sentReliable++;
   203ce:	4a4b      	ldr	r2, [pc, #300]	; (204fc <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t+0x174>)
   203d0:	5a83      	ldrh	r3, [r0, r2]
   203d2:	3301      	adds	r3, #1
   203d4:	5283      	strh	r3, [r0, r2]

			//Check what type of Packet has just been sent
			connPacketHeader* packetHeader = (connPacketHeader*)connection->lastSentPacket;

			if(packetHeader->messageType == MESSAGE_TYPE_CLUSTER_INFO_UPDATE){
   203d6:	234a      	movs	r3, #74	; 0x4a
   203d8:	33ff      	adds	r3, #255	; 0xff
   203da:	5cc2      	ldrb	r2, [r0, r3]
   203dc:	3b49      	subs	r3, #73	; 0x49
   203de:	1c11      	adds	r1, r2, #0
   203e0:	3bff      	subs	r3, #255	; 0xff
   203e2:	4399      	bics	r1, r3
   203e4:	292e      	cmp	r1, #46	; 0x2e
   203e6:	d07b      	beq.n	204e0 <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t+0x158>
			} else {

				logt("CONN_DATA", "Header was type %d hasMoreParts %d", packetHeader->messageType, packetHeader->hasMoreParts);

				//Check if the packet has more parts
				if(packetHeader->hasMoreParts == 0){
   203e8:	4013      	ands	r3, r2
   203ea:	22a4      	movs	r2, #164	; 0xa4
   203ec:	0052      	lsls	r2, r2, #1
   203ee:	2b00      	cmp	r3, #0
   203f0:	d173      	bne.n	204da <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t+0x152>
					//Packet was either not split at all or is completely sent
					connection->packetSendPosition = 0;
   203f2:	5483      	strb	r3, [r0, r2]

					//Check if this was the end of a handshake, if yes, mark handshake as completed
					if(packetHeader->messageType == MESSAGE_TYPE_CLUSTER_ACK_2)
   203f4:	292c      	cmp	r1, #44	; 0x2c
   203f6:	d16a      	bne.n	204ce <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t+0x146>
					{
						//Notify Node of handshakeDone
						cm->node->HandshakeDoneHandler(connection, true);
   203f8:	6875      	ldr	r5, [r6, #4]

	//We can now commit the changes that were part of the handshake
	//This node was the winner of the handshake and successfully acquired a new member
	if(completedAsWinner){
		//Update node data
		clusterSize += 1;
   203fa:	1c2a      	adds	r2, r5, #0
   203fc:	3278      	adds	r2, #120	; 0x78
   203fe:	8813      	ldrh	r3, [r2, #0]
   20400:	3301      	adds	r3, #1
   20402:	8013      	strh	r3, [r2, #0]
		connection->hopsToSink = connection->clusterAck1Packet.payload.hopsToSink < 0 ? -1 : connection->clusterAck1Packet.payload.hopsToSink + 1;
   20404:	23f0      	movs	r3, #240	; 0xf0
   20406:	33ff      	adds	r3, #255	; 0xff
   20408:	5cc2      	ldrb	r2, [r0, r3]
   2040a:	3301      	adds	r3, #1
   2040c:	5cc3      	ldrb	r3, [r0, r3]
   2040e:	021b      	lsls	r3, r3, #8
   20410:	4313      	orrs	r3, r2
   20412:	b21a      	sxth	r2, r3
   20414:	2a00      	cmp	r2, #0
   20416:	db02      	blt.n	2041e <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t+0x96>
   20418:	3301      	adds	r3, #1
   2041a:	b29b      	uxth	r3, r3
   2041c:	e000      	b.n	20420 <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t+0x98>
   2041e:	4b38      	ldr	r3, [pc, #224]	; (20500 <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t+0x178>)
   20420:	4a38      	ldr	r2, [pc, #224]	; (20504 <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t+0x17c>)
		connection->partnerId = connection->clusterAck1Packet.header.sender;
		connection->connectedClusterSize = 1;

		//Broadcast cluster update to other connections
		connPacketClusterInfoUpdate outPacket;
		memset((u8*)&outPacket, 0x00, sizeof(connPacketClusterInfoUpdate));
   20422:	2100      	movs	r1, #0
	//We can now commit the changes that were part of the handshake
	//This node was the winner of the handshake and successfully acquired a new member
	if(completedAsWinner){
		//Update node data
		clusterSize += 1;
		connection->hopsToSink = connection->clusterAck1Packet.payload.hopsToSink < 0 ? -1 : connection->clusterAck1Packet.payload.hopsToSink + 1;
   20424:	52a3      	strh	r3, [r4, r2]

//		logt("HANDSHAKE", "ClusterSize Change from %d to %d", clusterSize-1, clusterSize);

		//Update connection data
		connection->connectedClusterId = connection->clusterIDBackup;
   20426:	2380      	movs	r3, #128	; 0x80
   20428:	009b      	lsls	r3, r3, #2
   2042a:	58e7      	ldr	r7, [r4, r3]
   2042c:	330c      	adds	r3, #12
   2042e:	50e7      	str	r7, [r4, r3]
		connection->partnerId = connection->clusterAck1Packet.header.sender;
   20430:	23ec      	movs	r3, #236	; 0xec
   20432:	33ff      	adds	r3, #255	; 0xff
   20434:	5ce2      	ldrb	r2, [r4, r3]
   20436:	3301      	adds	r3, #1
   20438:	5ce3      	ldrb	r3, [r4, r3]
		connection->connectedClusterSize = 1;

		//Broadcast cluster update to other connections
		connPacketClusterInfoUpdate outPacket;
		memset((u8*)&outPacket, 0x00, sizeof(connPacketClusterInfoUpdate));
   2043a:	a802      	add	r0, sp, #8

//		logt("HANDSHAKE", "ClusterSize Change from %d to %d", clusterSize-1, clusterSize);

		//Update connection data
		connection->connectedClusterId = connection->clusterIDBackup;
		connection->partnerId = connection->clusterAck1Packet.header.sender;
   2043c:	021b      	lsls	r3, r3, #8
   2043e:	4313      	orrs	r3, r2
   20440:	22e8      	movs	r2, #232	; 0xe8
   20442:	0052      	lsls	r2, r2, #1
   20444:	52a3      	strh	r3, [r4, r2]
		connection->connectedClusterSize = 1;
   20446:	2384      	movs	r3, #132	; 0x84
   20448:	3ad0      	subs	r2, #208	; 0xd0
   2044a:	009b      	lsls	r3, r3, #2
   2044c:	3aff      	subs	r2, #255	; 0xff
   2044e:	52e2      	strh	r2, [r4, r3]

		//Broadcast cluster update to other connections
		connPacketClusterInfoUpdate outPacket;
		memset((u8*)&outPacket, 0x00, sizeof(connPacketClusterInfoUpdate));
   20450:	320d      	adds	r2, #13
   20452:	f001 f8fc 	bl	2164e <memset>

		outPacket.header.messageType = MESSAGE_TYPE_CLUSTER_INFO_UPDATE;
   20456:	232e      	movs	r3, #46	; 0x2e
   20458:	aa02      	add	r2, sp, #8
   2045a:	7013      	strb	r3, [r2, #0]
		outPacket.header.sender = persistentConfig.nodeId;
   2045c:	1c13      	adds	r3, r2, #0
   2045e:	1dea      	adds	r2, r5, #7
   20460:	7fd2      	ldrb	r2, [r2, #31]
		outPacket.payload.newClusterId = connection->clusterIDBackup;
		outPacket.payload.connectionMasterBitHandover = 0;

//		logt("HANDSHAKE", "OUT => ALL MESSAGE_TYPE_CLUSTER_INFO_UPDATE clustChange:1");

		SendClusterInfoUpdate(connection, &outPacket);
   20462:	1c28      	adds	r0, r5, #0
		//Broadcast cluster update to other connections
		connPacketClusterInfoUpdate outPacket;
		memset((u8*)&outPacket, 0x00, sizeof(connPacketClusterInfoUpdate));

		outPacket.header.messageType = MESSAGE_TYPE_CLUSTER_INFO_UPDATE;
		outPacket.header.sender = persistentConfig.nodeId;
   20464:	705a      	strb	r2, [r3, #1]
   20466:	1c2a      	adds	r2, r5, #0
   20468:	3208      	adds	r2, #8
   2046a:	7fd2      	ldrb	r2, [r2, #31]
		outPacket.payload.newClusterId = connection->clusterIDBackup;
		outPacket.payload.connectionMasterBitHandover = 0;

//		logt("HANDSHAKE", "OUT => ALL MESSAGE_TYPE_CLUSTER_INFO_UPDATE clustChange:1");

		SendClusterInfoUpdate(connection, &outPacket);
   2046c:	1c21      	adds	r1, r4, #0
		//Broadcast cluster update to other connections
		connPacketClusterInfoUpdate outPacket;
		memset((u8*)&outPacket, 0x00, sizeof(connPacketClusterInfoUpdate));

		outPacket.header.messageType = MESSAGE_TYPE_CLUSTER_INFO_UPDATE;
		outPacket.header.sender = persistentConfig.nodeId;
   2046e:	709a      	strb	r2, [r3, #2]
		outPacket.header.receiver = NODE_ID_BROADCAST;

		outPacket.payload.clusterSizeChange = 1;
   20470:	2309      	movs	r3, #9
   20472:	aa02      	add	r2, sp, #8
   20474:	189b      	adds	r3, r3, r2
   20476:	2201      	movs	r2, #1
   20478:	701a      	strb	r2, [r3, #0]
   2047a:	2200      	movs	r2, #0
   2047c:	705a      	strb	r2, [r3, #1]
		outPacket.payload.newClusterId = connection->clusterIDBackup;
   2047e:	ab02      	add	r3, sp, #8
   20480:	0a3a      	lsrs	r2, r7, #8
   20482:	719a      	strb	r2, [r3, #6]
   20484:	0c3a      	lsrs	r2, r7, #16
   20486:	715f      	strb	r7, [r3, #5]
   20488:	71da      	strb	r2, [r3, #7]
   2048a:	0e3f      	lsrs	r7, r7, #24
		outPacket.payload.connectionMasterBitHandover = 0;

//		logt("HANDSHAKE", "OUT => ALL MESSAGE_TYPE_CLUSTER_INFO_UPDATE clustChange:1");

		SendClusterInfoUpdate(connection, &outPacket);
   2048c:	aa02      	add	r2, sp, #8
		outPacket.header.messageType = MESSAGE_TYPE_CLUSTER_INFO_UPDATE;
		outPacket.header.sender = persistentConfig.nodeId;
		outPacket.header.receiver = NODE_ID_BROADCAST;

		outPacket.payload.clusterSizeChange = 1;
		outPacket.payload.newClusterId = connection->clusterIDBackup;
   2048e:	721f      	strb	r7, [r3, #8]
		outPacket.payload.connectionMasterBitHandover = 0;

//		logt("HANDSHAKE", "OUT => ALL MESSAGE_TYPE_CLUSTER_INFO_UPDATE clustChange:1");

		SendClusterInfoUpdate(connection, &outPacket);
   20490:	f7fc fdb0 	bl	1cff4 <_ZN4Node21SendClusterInfoUpdateEP10ConnectionP27connPacketClusterInfoUpdate>
//		logt("HANDSHAKE", "ClusterSize set to %d", clusterSize);
	}

//	uart("CLUSTER", "{\"type\":\"cluster_handshake\",\"winner\":%u,\"size\":%d}" SEP, completedAsWinner, clusterSize);

	connection->connectionState = Connection::ConnectionState::HANDSHAKE_DONE;
   20494:	2304      	movs	r3, #4
	connection->connectionHandshakedTimestampDs = appTimerDs;
   20496:	6e6a      	ldr	r2, [r5, #100]	; 0x64
//		logt("HANDSHAKE", "ClusterSize set to %d", clusterSize);
	}

//	uart("CLUSTER", "{\"type\":\"cluster_handshake\",\"winner\":%u,\"size\":%d}" SEP, completedAsWinner, clusterSize);

	connection->connectionState = Connection::ConnectionState::HANDSHAKE_DONE;
   20498:	7223      	strb	r3, [r4, #8]
	connection->connectionHandshakedTimestampDs = appTimerDs;
   2049a:	33dd      	adds	r3, #221	; 0xdd
   2049c:	33ff      	adds	r3, #255	; 0xff
   2049e:	50e2      	str	r2, [r4, r3]
   204a0:	1c2b      	adds	r3, r5, #0
   204a2:	1c2f      	adds	r7, r5, #0
   204a4:	3354      	adds	r3, #84	; 0x54
   204a6:	3740      	adds	r7, #64	; 0x40
   204a8:	9301      	str	r3, [sp, #4]

	//Call our lovely modules
	for(int i=0; i<MAX_MODULE_COUNT; i++){
		if(activeModules[i] != NULL){
   204aa:	6838      	ldr	r0, [r7, #0]
   204ac:	2800      	cmp	r0, #0
   204ae:	d003      	beq.n	204b8 <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t+0x130>
			activeModules[i]->MeshConnectionChangedHandler(connection);
   204b0:	6803      	ldr	r3, [r0, #0]
   204b2:	1c21      	adds	r1, r4, #0
   204b4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   204b6:	4798      	blx	r3

	connection->connectionState = Connection::ConnectionState::HANDSHAKE_DONE;
	connection->connectionHandshakedTimestampDs = appTimerDs;

	//Call our lovely modules
	for(int i=0; i<MAX_MODULE_COUNT; i++){
   204b8:	9b01      	ldr	r3, [sp, #4]
   204ba:	3704      	adds	r7, #4
   204bc:	429f      	cmp	r7, r3
   204be:	d1f4      	bne.n	204aa <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t+0x122>
			activeModules[i]->MeshConnectionChangedHandler(connection);
		}
	}

	//Update our advertisement packet
	UpdateJoinMePacket();
   204c0:	1c28      	adds	r0, r5, #0
   204c2:	f7fd fc73 	bl	1ddac <_ZN4Node18UpdateJoinMePacketEv>

	//Go back to Discovery
	ChangeState(discoveryState::DISCOVERY);
   204c6:	1c28      	adds	r0, r5, #0
   204c8:	2102      	movs	r1, #2
   204ca:	f7fd fcbb 	bl	1de44 <_ZN4Node11ChangeStateE14discoveryState>
					}

					//Discard the last packet because it was now successfully sent
					connection->packetSendQueue->DiscardNext();
   204ce:	1c23      	adds	r3, r4, #0
   204d0:	33fc      	adds	r3, #252	; 0xfc
   204d2:	6c98      	ldr	r0, [r3, #72]	; 0x48
   204d4:	f7ff f810 	bl	1f4f8 <_ZN11PacketQueue11DiscardNextEv>
   204d8:	e002      	b.n	204e0 <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t+0x158>
				} else {
					//Update packet send position if we have more data
					connection->packetSendPosition += MAX_DATA_SIZE_PER_WRITE - SIZEOF_CONN_PACKET_SPLIT_HEADER;
   204da:	5c83      	ldrb	r3, [r0, r2]
   204dc:	3313      	adds	r3, #19
   204de:	5483      	strb	r3, [r0, r2]
				}
			}

			connection->reliableBuffersFree += 1;
   204e0:	7d23      	ldrb	r3, [r4, #20]
   204e2:	3301      	adds	r3, #1
   204e4:	7523      	strb	r3, [r4, #20]


			//Now we continue sending packets
			if(cm->GetPendingPackets()) cm->fillTransmitBuffers();
   204e6:	1c30      	adds	r0, r6, #0
   204e8:	f7fd faf1 	bl	1dace <_ZN17ConnectionManager17GetPendingPacketsEv>
   204ec:	2800      	cmp	r0, #0
   204ee:	d002      	beq.n	204f6 <_ZN17ConnectionManager23dataTransmittedCallbackEP9ble_evt_t+0x16e>
   204f0:	1c30      	adds	r0, r6, #0
   204f2:	f7ff fbf9 	bl	1fce8 <_ZN17ConnectionManager19fillTransmitBuffersEv>
		}
	}
}
   204f6:	b007      	add	sp, #28
   204f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   204fa:	46c0      	nop			; (mov r8, r8)
   204fc:	0000021a 	.word	0x0000021a
   20500:	0000ffff 	.word	0x0000ffff
   20504:	00000212 	.word	0x00000212

00020508 <_ZN6ModuleD1Ev>:
	Logger::getInstance().enableTag("MODULE");
}

Module::~Module()
{
}
   20508:	4770      	bx	lr
	...

0002050c <_ZThn4_N6ModuleD1Ev>:
	public:
		char moduleName[MODULE_NAME_MAX_SIZE];

		//Constructor is passed
		Module(u8 moduleId, Node* node, ConnectionManager* cm, const char* name, u16 storageSlot);
		virtual ~Module();
   2050c:	b408      	push	{r3}
   2050e:	4b02      	ldr	r3, [pc, #8]	; (20518 <_ZThn4_N6ModuleD1Ev+0xc>)
   20510:	469c      	mov	ip, r3
   20512:	3804      	subs	r0, #4
   20514:	bc08      	pop	{r3}
   20516:	4760      	bx	ip
   20518:	00020509 	.word	0x00020509

0002051c <_ZN17AdvertisingModuleD1Ev.lto_priv.104>:
#include <Module.h>

#define ADVERTISING_MODULE_MAX_MESSAGES 1
#define ADVERTISING_MODULE_MAX_MESSAGE_LENGTH 31

class AdvertisingModule: public Module
   2051c:	4770      	bx	lr
	...

00020520 <_ZThn4_N17AdvertisingModuleD1Ev.lto_priv.106>:
   20520:	b408      	push	{r3}
   20522:	4b02      	ldr	r3, [pc, #8]	; (2052c <_ZThn4_N17AdvertisingModuleD1Ev.lto_priv.106+0xc>)
   20524:	469c      	mov	ip, r3
   20526:	3804      	subs	r0, #4
   20528:	bc08      	pop	{r3}
   2052a:	4760      	bx	ip
   2052c:	0002051d 	.word	0x0002051d

00020530 <sd_ble_gap_tx_power_set>:
 * @note The -40dBm setting is only available on nRF52 series ICs.
 *
 * @retval ::NRF_SUCCESS Successfully changed the transmit power.
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
 */
SVCALL(SD_BLE_GAP_TX_POWER_SET, uint32_t, sd_ble_gap_tx_power_set(int8_t tx_power));
   20530:	df77      	svc	119	; 0x77
   20532:	4770      	bx	lr

00020534 <sd_ble_gap_adv_data_set>:
 * @retval ::NRF_ERROR_INVALID_DATA Invalid data type(s) supplied, check the advertising data format specification.
 * @retval ::NRF_ERROR_INVALID_LENGTH Invalid data length(s) supplied.
 * @retval ::NRF_ERROR_NOT_SUPPORTED Unsupported data type.
 * @retval ::BLE_ERROR_GAP_UUID_LIST_MISMATCH Invalid UUID list supplied.
 */
SVCALL(SD_BLE_GAP_ADV_DATA_SET, uint32_t, sd_ble_gap_adv_data_set(uint8_t const *p_data, uint8_t dlen, uint8_t const *p_sr_data, uint8_t srdlen));
   20534:	df72      	svc	114	; 0x72
   20536:	4770      	bx	lr

00020538 <_ZN16EnrollmentModuleD1Ev.lto_priv.98>:

#pragma once

#include <Module.h>

class EnrollmentModule: public Module
   20538:	4770      	bx	lr
	...

0002053c <_ZThn4_N16EnrollmentModuleD1Ev.lto_priv.100>:
   2053c:	b408      	push	{r3}
   2053e:	4b02      	ldr	r3, [pc, #8]	; (20548 <_ZThn4_N16EnrollmentModuleD1Ev.lto_priv.100+0xc>)
   20540:	469c      	mov	ip, r3
   20542:	3804      	subs	r0, #4
   20544:	bc08      	pop	{r3}
   20546:	4760      	bx	ip
   20548:	00020539 	.word	0x00020539

0002054c <_ZN16EnrollmentModule27ResetToDefaultConfigurationEv>:
}

void EnrollmentModule::ResetToDefaultConfiguration()
{
	//Set default configuration values
	configuration.moduleId = moduleId;
   2054c:	1c03      	adds	r3, r0, #0
   2054e:	7c02      	ldrb	r2, [r0, #16]
   20550:	3328      	adds	r3, #40	; 0x28
   20552:	701a      	strb	r2, [r3, #0]
	configuration.moduleActive = true;
   20554:	1c02      	adds	r2, r0, #0
   20556:	2301      	movs	r3, #1
   20558:	322a      	adds	r2, #42	; 0x2a
	configuration.moduleVersion = 1;
   2055a:	3029      	adds	r0, #41	; 0x29

void EnrollmentModule::ResetToDefaultConfiguration()
{
	//Set default configuration values
	configuration.moduleId = moduleId;
	configuration.moduleActive = true;
   2055c:	7013      	strb	r3, [r2, #0]
	configuration.moduleVersion = 1;
   2055e:	7003      	strb	r3, [r0, #0]

	//Set additional config values...

}
   20560:	4770      	bx	lr
	...

00020564 <_ZN16EnrollmentModule17TimerEventHandlerEtm>:

}

void EnrollmentModule::TimerEventHandler(u16 passedTimeDs, u32 appTimerDs)
{
	if(rebootTimeDs != 0 && rebootTimeDs < appTimerDs){
   20564:	6b43      	ldr	r3, [r0, #52]	; 0x34
   20566:	2b00      	cmp	r3, #0
   20568:	d00a      	beq.n	20580 <_ZN16EnrollmentModule17TimerEventHandlerEtm+0x1c>
   2056a:	4293      	cmp	r3, r2
   2056c:	d208      	bcs.n	20580 <_ZN16EnrollmentModule17TimerEventHandlerEtm+0x1c>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   2056e:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                 SCB_AIRCR_SYSRESETREQ_Msk);
   20572:	4a04      	ldr	r2, [pc, #16]	; (20584 <_ZN16EnrollmentModule17TimerEventHandlerEtm+0x20>)
   20574:	4b04      	ldr	r3, [pc, #16]	; (20588 <_ZN16EnrollmentModule17TimerEventHandlerEtm+0x24>)
   20576:	60da      	str	r2, [r3, #12]
   20578:	f3bf 8f4f 	dsb	sy
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
   2057c:	46c0      	nop			; (mov r8, r8)
   2057e:	e7fd      	b.n	2057c <_ZN16EnrollmentModule17TimerEventHandlerEtm+0x18>
		logt("ENROLLMOD", "Rebooting");
		NVIC_SystemReset();
	}
}
   20580:	4770      	bx	lr
   20582:	46c0      	nop			; (mov r8, r8)
   20584:	05fa0004 	.word	0x05fa0004
   20588:	e000ed00 	.word	0xe000ed00

0002058c <_ZN6Module26ConfigurationLoadedHandlerEv>:
	}

}

void Module::ConfigurationLoadedHandler()
{
   2058c:	b508      	push	{r3, lr}
	//Configuration is invalid because the device got flashed
	if(configurationPointer->moduleId == 0xFF)
   2058e:	6a03      	ldr	r3, [r0, #32]
   20590:	781b      	ldrb	r3, [r3, #0]
   20592:	2bff      	cmp	r3, #255	; 0xff
   20594:	d102      	bne.n	2059c <_ZN6Module26ConfigurationLoadedHandlerEv+0x10>
	{
		logt("MODULE", "Config resetted to default for module %d", moduleId);
		ResetToDefaultConfiguration();
   20596:	6803      	ldr	r3, [r0, #0]
   20598:	695b      	ldr	r3, [r3, #20]
   2059a:	4798      	blx	r3
	}
	//Config-> loaded and ok
	else {
		logt("MODULE", "Module %u config loaded version:%d", moduleId, configurationPointer->moduleVersion);
	}
}
   2059c:	bd08      	pop	{r3, pc}

0002059e <_ZN16EnrollmentModule26ConfigurationLoadedHandlerEv>:
	//Start module configuration loading
	LoadModuleConfiguration();
}

void EnrollmentModule::ConfigurationLoadedHandler()
{
   2059e:	b508      	push	{r3, lr}
	//Does basic testing on the loaded configuration
	Module::ConfigurationLoadedHandler();
   205a0:	f7ff fff4 	bl	2058c <_ZN6Module26ConfigurationLoadedHandlerEv>
	//Do additional initialization upon loading the config


	//Start the Module...

}
   205a4:	bd08      	pop	{r3, pc}

000205a6 <_ZN6Module27ResetToDefaultConfigurationEv>:

		//This function is called by the module to get its configuration on startup
		virtual void LoadModuleConfiguration();

		//Called when the load failed
		virtual void ResetToDefaultConfiguration(){};
   205a6:	4770      	bx	lr

000205a8 <_ZN17AdvertisingModule26ConfigurationLoadedHandlerEv>:
}

void AdvertisingModule::ConfigurationLoadedHandler()
{
   205a8:	b510      	push	{r4, lr}
   205aa:	1c04      	adds	r4, r0, #0

	//Version migration can be added here
	if(configuration.moduleVersion == 1){/* ... */};

	//Do additional initialization upon loading the config
	if(configuration.txPower != 0xFF){
   205ac:	3433      	adds	r4, #51	; 0x33

void AdvertisingModule::ConfigurationLoadedHandler()
{
	u32 err = 0;
	//Does basic testing on the loaded configuration
	Module::ConfigurationLoadedHandler();
   205ae:	f7ff ffed 	bl	2058c <_ZN6Module26ConfigurationLoadedHandlerEv>

	//Version migration can be added here
	if(configuration.moduleVersion == 1){/* ... */};

	//Do additional initialization upon loading the config
	if(configuration.txPower != 0xFF){
   205b2:	7820      	ldrb	r0, [r4, #0]
   205b4:	28ff      	cmp	r0, #255	; 0xff
   205b6:	d009      	beq.n	205cc <_ZN17AdvertisingModule26ConfigurationLoadedHandlerEv+0x24>
		//Error code is not checked, will silently fail
		err = sd_ble_gap_tx_power_set(configuration.txPower);
   205b8:	b240      	sxtb	r0, r0
   205ba:	f7ff ffb9 	bl	20530 <sd_ble_gap_tx_power_set>
		if(err == NRF_SUCCESS){
   205be:	2800      	cmp	r0, #0
   205c0:	d104      	bne.n	205cc <_ZN17AdvertisingModule26ConfigurationLoadedHandlerEv+0x24>
			//Update value from config
			Config->radioTransmitPower = configuration.txPower;
   205c2:	f000 fc31 	bl	20e28 <_ZN4Conf11getInstanceEv>
   205c6:	7823      	ldrb	r3, [r4, #0]
   205c8:	3080      	adds	r0, #128	; 0x80
   205ca:	7003      	strb	r3, [r0, #0]
	//Start the Module...
	logt("ADVMOD", "Config set, txPower %d");



}
   205cc:	bd10      	pop	{r4, pc}

000205ce <_ZN17AdvertisingModule27ResetToDefaultConfigurationEv>:
}

void AdvertisingModule::ResetToDefaultConfiguration()
{
	//Set default configuration values
	configuration.moduleId = moduleId;
   205ce:	1c03      	adds	r3, r0, #0
	}

}

void AdvertisingModule::ResetToDefaultConfiguration()
{
   205d0:	b570      	push	{r4, r5, r6, lr}
	//Set default configuration values
	configuration.moduleId = moduleId;
	configuration.moduleActive = true;
   205d2:	2501      	movs	r5, #1
	configuration.moduleVersion = 1;

	memset(configuration.messageData[0].messageData, 0, 31);
   205d4:	1c06      	adds	r6, r0, #0
}

void AdvertisingModule::ResetToDefaultConfiguration()
{
	//Set default configuration values
	configuration.moduleId = moduleId;
   205d6:	7c02      	ldrb	r2, [r0, #16]
   205d8:	332c      	adds	r3, #44	; 0x2c
   205da:	701a      	strb	r2, [r3, #0]
	configuration.moduleActive = true;
   205dc:	709d      	strb	r5, [r3, #2]
	configuration.moduleVersion = 1;

	memset(configuration.messageData[0].messageData, 0, 31);
   205de:	3636      	adds	r6, #54	; 0x36
void AdvertisingModule::ResetToDefaultConfiguration()
{
	//Set default configuration values
	configuration.moduleId = moduleId;
	configuration.moduleActive = true;
	configuration.moduleVersion = 1;
   205e0:	195b      	adds	r3, r3, r5
	}

}

void AdvertisingModule::ResetToDefaultConfiguration()
{
   205e2:	1c04      	adds	r4, r0, #0
	//Set default configuration values
	configuration.moduleId = moduleId;
	configuration.moduleActive = true;
	configuration.moduleVersion = 1;
   205e4:	701d      	strb	r5, [r3, #0]

	memset(configuration.messageData[0].messageData, 0, 31);
   205e6:	1c30      	adds	r0, r6, #0
   205e8:	2100      	movs	r1, #0
   205ea:	221f      	movs	r2, #31
   205ec:	f001 f82f 	bl	2164e <memset>
	name.len = SIZEOF_ADV_STRUCTURE_NAME-1;
	name.type = BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME;
	name.name[0] = 'A';
	name.name[1] = 'B';

	configuration.advertisingIntervalMs = 100;
   205f0:	2364      	movs	r3, #100	; 0x64
   205f2:	8623      	strh	r3, [r4, #48]	; 0x30
	configuration.messageCount = 1;
   205f4:	1c23      	adds	r3, r4, #0
	configuration.txPower = 0xFF; //Set to invalid value
   205f6:	22ff      	movs	r2, #255	; 0xff
	name.type = BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME;
	name.name[0] = 'A';
	name.name[1] = 'B';

	configuration.advertisingIntervalMs = 100;
	configuration.messageCount = 1;
   205f8:	3332      	adds	r3, #50	; 0x32
	configuration.txPower = 0xFF; //Set to invalid value
   205fa:	705a      	strb	r2, [r3, #1]

	configuration.messageData[0].messageLength = 31;
   205fc:	1c22      	adds	r2, r4, #0
   205fe:	2108      	movs	r1, #8
	name.type = BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME;
	name.name[0] = 'A';
	name.name[1] = 'B';

	configuration.advertisingIntervalMs = 100;
	configuration.messageCount = 1;
   20600:	701d      	strb	r5, [r3, #0]
	configuration.txPower = 0xFF; //Set to invalid value

	configuration.messageData[0].messageLength = 31;
   20602:	3235      	adds	r2, #53	; 0x35
   20604:	7813      	ldrb	r3, [r2, #0]
   20606:	4249      	negs	r1, r1
   20608:	430b      	orrs	r3, r1
   2060a:	7013      	strb	r3, [r2, #0]
	memcpy(configuration.messageData[0].messageData, &flags, SIZEOF_ADV_STRUCTURE_FLAGS);
   2060c:	2302      	movs	r3, #2
   2060e:	7033      	strb	r3, [r6, #0]
   20610:	1c23      	adds	r3, r4, #0
   20612:	2206      	movs	r2, #6
   20614:	3337      	adds	r3, #55	; 0x37
   20616:	705a      	strb	r2, [r3, #1]
	memcpy(configuration.messageData[0].messageData+SIZEOF_ADV_STRUCTURE_FLAGS, &name, SIZEOF_ADV_STRUCTURE_NAME);
   20618:	3a03      	subs	r2, #3
   2061a:	709a      	strb	r2, [r3, #2]
   2061c:	3206      	adds	r2, #6
   2061e:	70da      	strb	r2, [r3, #3]
   20620:	3238      	adds	r2, #56	; 0x38
	configuration.advertisingIntervalMs = 100;
	configuration.messageCount = 1;
	configuration.txPower = 0xFF; //Set to invalid value

	configuration.messageData[0].messageLength = 31;
	memcpy(configuration.messageData[0].messageData, &flags, SIZEOF_ADV_STRUCTURE_FLAGS);
   20622:	701d      	strb	r5, [r3, #0]
	memcpy(configuration.messageData[0].messageData+SIZEOF_ADV_STRUCTURE_FLAGS, &name, SIZEOF_ADV_STRUCTURE_NAME);
   20624:	711a      	strb	r2, [r3, #4]
   20626:	2342      	movs	r3, #66	; 0x42
   20628:	343c      	adds	r4, #60	; 0x3c
   2062a:	7023      	strb	r3, [r4, #0]
}
   2062c:	bd70      	pop	{r4, r5, r6, pc}
	...

00020630 <_ZN17AdvertisingModule23NodeStateChangedHandlerE14discoveryState.part.5>:

void AdvertisingModule::NodeStateChangedHandler(discoveryState newState)
   20630:	b5f0      	push	{r4, r5, r6, r7, lr}
   20632:	b0bf      	sub	sp, #252	; 0xfc
   20634:	1c05      	adds	r5, r0, #0
{
	if(newState == discoveryState::BACK_OFF || newState == discoveryState::DISCOVERY_OFF){
		//Activate our advertising

		//This is a small packet for debugging a node's state
		if(Config->advertiseDebugPackets){
   20636:	f000 fbf7 	bl	20e28 <_ZN4Conf11getInstanceEv>
   2063a:	7903      	ldrb	r3, [r0, #4]
   2063c:	2b00      	cmp	r3, #0
   2063e:	d053      	beq.n	206e8 <_ZN17AdvertisingModule23NodeStateChangedHandlerE14discoveryState.part.5+0xb8>
			u8 buffer[31];
			memset(buffer, 0, 31);
   20640:	ac04      	add	r4, sp, #16
   20642:	2100      	movs	r1, #0
   20644:	221f      	movs	r2, #31
   20646:	1c20      	adds	r0, r4, #0
   20648:	f001 f801 	bl	2164e <memset>

			advStructureFlags* flags = (advStructureFlags*)buffer;
			flags->len = SIZEOF_ADV_STRUCTURE_FLAGS-1;
			flags->type = BLE_GAP_AD_TYPE_FLAGS;
   2064c:	2301      	movs	r3, #1
   2064e:	7063      	strb	r3, [r4, #1]
			flags->flags = BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED;
   20650:	3305      	adds	r3, #5
   20652:	70a3      	strb	r3, [r4, #2]

			advStructureManufacturer* manufacturer = (advStructureManufacturer*)(buffer+3);
			manufacturer->len = 26;
   20654:	3314      	adds	r3, #20
   20656:	70e3      	strb	r3, [r4, #3]
			manufacturer->type = BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA;
   20658:	33e5      	adds	r3, #229	; 0xe5
   2065a:	7123      	strb	r3, [r4, #4]
			manufacturer->companyIdentifier = 0x24D;
   2065c:	a902      	add	r1, sp, #8
   2065e:	3bf2      	subs	r3, #242	; 0xf2
   20660:	185b      	adds	r3, r3, r1
		if(Config->advertiseDebugPackets){
			u8 buffer[31];
			memset(buffer, 0, 31);

			advStructureFlags* flags = (advStructureFlags*)buffer;
			flags->len = SIZEOF_ADV_STRUCTURE_FLAGS-1;
   20662:	2202      	movs	r2, #2
			flags->flags = BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED;

			advStructureManufacturer* manufacturer = (advStructureManufacturer*)(buffer+3);
			manufacturer->len = 26;
			manufacturer->type = BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA;
			manufacturer->companyIdentifier = 0x24D;
   20664:	214d      	movs	r1, #77	; 0x4d
   20666:	705a      	strb	r2, [r3, #1]
   20668:	7019      	strb	r1, [r3, #0]

			AdvertisingModuleDebugMessage* msg = (AdvertisingModuleDebugMessage*)(buffer+7);

			msg->debugPacketIdentifier = 0xDE;
   2066a:	23de      	movs	r3, #222	; 0xde
   2066c:	71e3      	strb	r3, [r4, #7]
			msg->senderId = node->persistentConfig.nodeId;
   2066e:	68ab      	ldr	r3, [r5, #8]
		if(Config->advertiseDebugPackets){
			u8 buffer[31];
			memset(buffer, 0, 31);

			advStructureFlags* flags = (advStructureFlags*)buffer;
			flags->len = SIZEOF_ADV_STRUCTURE_FLAGS-1;
   20670:	7022      	strb	r2, [r4, #0]
			manufacturer->companyIdentifier = 0x24D;

			AdvertisingModuleDebugMessage* msg = (AdvertisingModuleDebugMessage*)(buffer+7);

			msg->debugPacketIdentifier = 0xDE;
			msg->senderId = node->persistentConfig.nodeId;
   20672:	8cda      	ldrh	r2, [r3, #38]	; 0x26
   20674:	af07      	add	r7, sp, #28
   20676:	8122      	strh	r2, [r4, #8]
			msg->connLossCounter = node->persistentConfig.connectionLossCounter;
   20678:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
   2067a:	ae09      	add	r6, sp, #36	; 0x24
   2067c:	8163      	strh	r3, [r4, #10]

			for(int i=0; i<Config->meshMaxConnections; i++){
   2067e:	2300      	movs	r3, #0
   20680:	9303      	str	r3, [sp, #12]
   20682:	f000 fbd1 	bl	20e28 <_ZN4Conf11getInstanceEv>
   20686:	3035      	adds	r0, #53	; 0x35
   20688:	7803      	ldrb	r3, [r0, #0]
   2068a:	9a03      	ldr	r2, [sp, #12]
   2068c:	429a      	cmp	r2, r3
   2068e:	da1b      	bge.n	206c8 <_ZN17AdvertisingModule23NodeStateChangedHandlerE14discoveryState.part.5+0x98>
				if(cm->connections[i]->handshakeDone()){
   20690:	9b03      	ldr	r3, [sp, #12]
   20692:	68ea      	ldr	r2, [r5, #12]
   20694:	3308      	adds	r3, #8
   20696:	009b      	lsls	r3, r3, #2
   20698:	589b      	ldr	r3, [r3, r2]
   2069a:	7a1a      	ldrb	r2, [r3, #8]
   2069c:	2a03      	cmp	r2, #3
   2069e:	d909      	bls.n	206b4 <_ZN17AdvertisingModule23NodeStateChangedHandlerE14discoveryState.part.5+0x84>
					msg->partners[i] = cm->connections[i]->partnerId;
   206a0:	22e8      	movs	r2, #232	; 0xe8
   206a2:	0052      	lsls	r2, r2, #1
   206a4:	5a9a      	ldrh	r2, [r3, r2]
   206a6:	803a      	strh	r2, [r7, #0]
					msg->rssiVals[i] = cm->connections[i]->rssiAverage;
   206a8:	7c9a      	ldrb	r2, [r3, #18]
   206aa:	7032      	strb	r2, [r6, #0]
					msg->droppedVals[i] = cm->connections[i]->droppedPackets;
   206ac:	2286      	movs	r2, #134	; 0x86
   206ae:	0092      	lsls	r2, r2, #2
   206b0:	5a9b      	ldrh	r3, [r3, r2]
   206b2:	e002      	b.n	206ba <_ZN17AdvertisingModule23NodeStateChangedHandlerE14discoveryState.part.5+0x8a>
				} else {
					msg->partners[i] = 0;
   206b4:	2300      	movs	r3, #0
   206b6:	803b      	strh	r3, [r7, #0]
					msg->rssiVals[i] = 0;
   206b8:	7033      	strb	r3, [r6, #0]
					msg->droppedVals[i] = 0;
   206ba:	70f3      	strb	r3, [r6, #3]

			msg->debugPacketIdentifier = 0xDE;
			msg->senderId = node->persistentConfig.nodeId;
			msg->connLossCounter = node->persistentConfig.connectionLossCounter;

			for(int i=0; i<Config->meshMaxConnections; i++){
   206bc:	9b03      	ldr	r3, [sp, #12]
   206be:	3702      	adds	r7, #2
   206c0:	3301      	adds	r3, #1
   206c2:	9303      	str	r3, [sp, #12]
   206c4:	3601      	adds	r6, #1
   206c6:	e7dc      	b.n	20682 <_ZN17AdvertisingModule23NodeStateChangedHandlerE14discoveryState.part.5+0x52>




			char strbuffer[200];
			Logger::getInstance().convertBufferToHexString(buffer, 31, strbuffer, 200);
   206c8:	f7fc fde6 	bl	1d298 <_ZN6Logger11getInstanceEv>
   206cc:	23c8      	movs	r3, #200	; 0xc8
   206ce:	1c21      	adds	r1, r4, #0
   206d0:	9300      	str	r3, [sp, #0]
   206d2:	221f      	movs	r2, #31
   206d4:	ab0c      	add	r3, sp, #48	; 0x30
   206d6:	f7ff f97b 	bl	1f9d0 <_ZN6Logger24convertBufferToHexStringEPhmPct>

			logt("ADVMOD", "ADV set to %s", strbuffer);

			u32 err = sd_ble_gap_adv_data_set(buffer, 31, NULL, 0);
   206da:	2200      	movs	r2, #0
   206dc:	1c20      	adds	r0, r4, #0
   206de:	211f      	movs	r1, #31
   206e0:	1c13      	adds	r3, r2, #0
   206e2:	f7ff ff27 	bl	20534 <sd_ble_gap_adv_data_set>
   206e6:	e01c      	b.n	20722 <_ZN17AdvertisingModule23NodeStateChangedHandlerE14discoveryState.part.5+0xf2>
				logt("ADVMOD", "Debug Packet corrupt");
			}

			AdvertisingController::SetAdvertisingState(advState::ADV_STATE_HIGH);
		}
		else if(configuration.messageCount > 0){
   206e8:	1c2a      	adds	r2, r5, #0
   206ea:	3232      	adds	r2, #50	; 0x32
   206ec:	7812      	ldrb	r2, [r2, #0]
   206ee:	2a00      	cmp	r2, #0
   206f0:	d01b      	beq.n	2072a <_ZN17AdvertisingModule23NodeStateChangedHandlerE14discoveryState.part.5+0xfa>
			u32 err = sd_ble_gap_adv_data_set(configuration.messageData[0].messageData, configuration.messageData[0].messageLength, NULL, 0);
   206f2:	1c2c      	adds	r4, r5, #0
   206f4:	3535      	adds	r5, #53	; 0x35
   206f6:	7829      	ldrb	r1, [r5, #0]
   206f8:	3436      	adds	r4, #54	; 0x36
   206fa:	1c1a      	adds	r2, r3, #0
   206fc:	08c9      	lsrs	r1, r1, #3
   206fe:	1c20      	adds	r0, r4, #0
   20700:	f7ff ff18 	bl	20534 <sd_ble_gap_adv_data_set>
				logt("ADVMOD", "Adv msg corrupt");
			}


			char buffer[200];
			Logger::getInstance().convertBufferToHexString((u8*)configuration.messageData[0].messageData, 31, buffer, 200);
   20704:	f7fc fdc8 	bl	1d298 <_ZN6Logger11getInstanceEv>
   20708:	23c8      	movs	r3, #200	; 0xc8
   2070a:	1c21      	adds	r1, r4, #0
   2070c:	9300      	str	r3, [sp, #0]
   2070e:	221f      	movs	r2, #31
   20710:	ab0c      	add	r3, sp, #48	; 0x30
   20712:	f7ff f95d 	bl	1f9d0 <_ZN6Logger24convertBufferToHexStringEPhmPct>

			logt("ADVMOD", "ADV set to %s", buffer);



			if(configuration.messageData[0].forceNonConnectable)
   20716:	782b      	ldrb	r3, [r5, #0]
   20718:	07db      	lsls	r3, r3, #31
   2071a:	d502      	bpl.n	20722 <_ZN17AdvertisingModule23NodeStateChangedHandlerE14discoveryState.part.5+0xf2>
{
	currentAdvertisingParams.type = BLE_GAP_ADV_TYPE_ADV_IND;
}
void AdvertisingController::SetNonConnectable()
{
	currentAdvertisingParams.type = BLE_GAP_ADV_TYPE_ADV_NONCONN_IND;
   2071c:	2203      	movs	r2, #3
   2071e:	4b04      	ldr	r3, [pc, #16]	; (20730 <_ZN17AdvertisingModule23NodeStateChangedHandlerE14discoveryState.part.5+0x100>)
   20720:	701a      	strb	r2, [r3, #0]
				AdvertisingController::SetNonConnectable();
			}

			//Now, start advertising
			//TODO: Use advertising parameters from config to advertise
			AdvertisingController::SetAdvertisingState(advState::ADV_STATE_HIGH);
   20722:	2080      	movs	r0, #128	; 0x80
   20724:	00c0      	lsls	r0, r0, #3
   20726:	f7fc fd79 	bl	1d21c <_ZN21AdvertisingController19SetAdvertisingStateE8advState>

	} else if (newState == discoveryState::DISCOVERY) {
		//Do not trigger custom advertisings anymore, reset to node's advertising
		node->UpdateJoinMePacket();
	}
}
   2072a:	b03f      	add	sp, #252	; 0xfc
   2072c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2072e:	46c0      	nop			; (mov r8, r8)
   20730:	20003524 	.word	0x20003524

00020734 <_ZN17AdvertisingModuleD0Ev.lto_priv.105>:
   20734:	b510      	push	{r4, lr}
   20736:	1c04      	adds	r4, r0, #0
   20738:	f000 fd84 	bl	21244 <_ZdlPv>
   2073c:	1c20      	adds	r0, r4, #0
   2073e:	bd10      	pop	{r4, pc}

00020740 <_ZThn4_N17AdvertisingModuleD0Ev>:
   20740:	b408      	push	{r3}
   20742:	4b02      	ldr	r3, [pc, #8]	; (2074c <_ZThn4_N17AdvertisingModuleD0Ev+0xc>)
   20744:	469c      	mov	ip, r3
   20746:	3804      	subs	r0, #4
   20748:	bc08      	pop	{r3}
   2074a:	4760      	bx	ip
   2074c:	00020735 	.word	0x00020735

00020750 <_ZN16EnrollmentModuleD0Ev.lto_priv.99>:
   20750:	b510      	push	{r4, lr}
   20752:	1c04      	adds	r4, r0, #0
   20754:	f000 fd76 	bl	21244 <_ZdlPv>
   20758:	1c20      	adds	r0, r4, #0
   2075a:	bd10      	pop	{r4, pc}

0002075c <_ZThn4_N16EnrollmentModuleD0Ev>:
   2075c:	b408      	push	{r3}
   2075e:	4b02      	ldr	r3, [pc, #8]	; (20768 <_ZThn4_N16EnrollmentModuleD0Ev+0xc>)
   20760:	469c      	mov	ip, r3
   20762:	3804      	subs	r0, #4
   20764:	bc08      	pop	{r3}
   20766:	4760      	bx	ip
   20768:	00020751 	.word	0x00020751

0002076c <_ZN6ModuleD0Ev>:
	Terminal::AddTerminalCommandListener(this);

	Logger::getInstance().enableTag("MODULE");
}

Module::~Module()
   2076c:	b510      	push	{r4, lr}
   2076e:	1c04      	adds	r4, r0, #0
{
}
   20770:	f000 fd68 	bl	21244 <_ZdlPv>
   20774:	1c20      	adds	r0, r4, #0
   20776:	bd10      	pop	{r4, pc}

00020778 <_ZThn4_N6ModuleD0Ev>:
	public:
		char moduleName[MODULE_NAME_MAX_SIZE];

		//Constructor is passed
		Module(u8 moduleId, Node* node, ConnectionManager* cm, const char* name, u16 storageSlot);
		virtual ~Module();
   20778:	b408      	push	{r3}
   2077a:	4b02      	ldr	r3, [pc, #8]	; (20784 <_ZThn4_N6ModuleD0Ev+0xc>)
   2077c:	469c      	mov	ip, r3
   2077e:	3804      	subs	r0, #4
   20780:	bc08      	pop	{r3}
   20782:	4760      	bx	ip
   20784:	0002076d 	.word	0x0002076d

00020788 <_ZN17AdvertisingModule23NodeStateChangedHandlerE14discoveryState>:
	memcpy(configuration.messageData[0].messageData, &flags, SIZEOF_ADV_STRUCTURE_FLAGS);
	memcpy(configuration.messageData[0].messageData+SIZEOF_ADV_STRUCTURE_FLAGS, &name, SIZEOF_ADV_STRUCTURE_NAME);
}

void AdvertisingModule::NodeStateChangedHandler(discoveryState newState)
{
   20788:	b508      	push	{r3, lr}
	if(newState == discoveryState::BACK_OFF || newState == discoveryState::DISCOVERY_OFF){
   2078a:	1c0b      	adds	r3, r1, #0
   2078c:	3b09      	subs	r3, #9
   2078e:	2b01      	cmp	r3, #1
   20790:	d802      	bhi.n	20798 <_ZN17AdvertisingModule23NodeStateChangedHandlerE14discoveryState+0x10>
   20792:	f7ff ff4d 	bl	20630 <_ZN17AdvertisingModule23NodeStateChangedHandlerE14discoveryState.part.5>
   20796:	e004      	b.n	207a2 <_ZN17AdvertisingModule23NodeStateChangedHandlerE14discoveryState+0x1a>
			//Now, start advertising
			//TODO: Use advertising parameters from config to advertise
			AdvertisingController::SetAdvertisingState(advState::ADV_STATE_HIGH);
		}

	} else if (newState == discoveryState::DISCOVERY) {
   20798:	2902      	cmp	r1, #2
   2079a:	d102      	bne.n	207a2 <_ZN17AdvertisingModule23NodeStateChangedHandlerE14discoveryState+0x1a>
		//Do not trigger custom advertisings anymore, reset to node's advertising
		node->UpdateJoinMePacket();
   2079c:	6880      	ldr	r0, [r0, #8]
   2079e:	f7fd fb05 	bl	1ddac <_ZN4Node18UpdateJoinMePacketEv>
	}
}
   207a2:	bd08      	pop	{r3, pc}

000207a4 <_ZN17AdvertisingModule17TimerEventHandlerEtm>:


}

void AdvertisingModule::TimerEventHandler(u16 passedTimeDs, u32 appTimerDs)
{
   207a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	//Activate asset adv message only after some time
	//because if we had connections, the node would have reset the packet
	//to a join_me packet (that's a hack,...)
	//The assetId is 50 less than the nodeId because of another hack
	//while implementing serialNumbers .... :-(
	if(assetMode != 0 && assetMode < 11) assetMode++;
   207a6:	6a83      	ldr	r3, [r0, #40]	; 0x28


}

void AdvertisingModule::TimerEventHandler(u16 passedTimeDs, u32 appTimerDs)
{
   207a8:	af00      	add	r7, sp, #0
	//Activate asset adv message only after some time
	//because if we had connections, the node would have reset the packet
	//to a join_me packet (that's a hack,...)
	//The assetId is 50 less than the nodeId because of another hack
	//while implementing serialNumbers .... :-(
	if(assetMode != 0 && assetMode < 11) assetMode++;
   207aa:	1e5a      	subs	r2, r3, #1
   207ac:	2a09      	cmp	r2, #9
   207ae:	d801      	bhi.n	207b4 <_ZN17AdvertisingModule17TimerEventHandlerEtm+0x10>
   207b0:	3301      	adds	r3, #1
   207b2:	6283      	str	r3, [r0, #40]	; 0x28
	if(assetMode == 10){
   207b4:	6a83      	ldr	r3, [r0, #40]	; 0x28
   207b6:	2b0a      	cmp	r3, #10
   207b8:	d113      	bne.n	207e2 <_ZN17AdvertisingModule17TimerEventHandlerEtm+0x3e>
   207ba:	466e      	mov	r6, sp
		const char* command = "set_config this adv 01:01:01:00:64:00:01:04:05:61:02:01:06:08:FF:4D:02:02:%02x:%02x:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00 0";
		char tmp[strlen(command)];
   207bc:	b0a6      	sub	sp, #152	; 0x98
   207be:	1c04      	adds	r4, r0, #0
		sprintf(tmp, command, Config->serialNumberIndex & 0xFF, (Config->serialNumberIndex) >> 8);
   207c0:	f000 fb32 	bl	20e28 <_ZN4Conf11getInstanceEv>
   207c4:	6d05      	ldr	r5, [r0, #80]	; 0x50
   207c6:	f000 fb2f 	bl	20e28 <_ZN4Conf11getInstanceEv>
   207ca:	6d03      	ldr	r3, [r0, #80]	; 0x50
   207cc:	b2ed      	uxtb	r5, r5
   207ce:	0a1b      	lsrs	r3, r3, #8
   207d0:	4668      	mov	r0, sp
   207d2:	4905      	ldr	r1, [pc, #20]	; (207e8 <_ZN17AdvertisingModule17TimerEventHandlerEtm+0x44>)
   207d4:	1c2a      	adds	r2, r5, #0
   207d6:	f001 f83d 	bl	21854 <siprintf>

		Terminal::ProcessLine(tmp);
		node->Stop();
   207da:	68a0      	ldr	r0, [r4, #8]
   207dc:	f7fd fe58 	bl	1e490 <_ZN4Node4StopEv>
   207e0:	46b5      	mov	sp, r6

	}

}
   207e2:	46bd      	mov	sp, r7
   207e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   207e6:	46c0      	nop			; (mov r8, r8)
   207e8:	00022b88 	.word	0x00022b88

000207ec <_ZN6Module23LoadModuleConfigurationEv>:
	int paddedLength = configurationLength - (configurationLength % 4);
	Storage::getInstance().QueuedWrite((u8*)configurationPointer, paddedLength, storageSlot, this);
}

void Module::LoadModuleConfiguration()
{
   207ec:	b570      	push	{r4, r5, r6, lr}
   207ee:	1c04      	adds	r4, r0, #0
	if(Config->ignorePersistentModuleConfigurationOnBoot){
   207f0:	f000 fb1a 	bl	20e28 <_ZN4Conf11getInstanceEv>
   207f4:	7843      	ldrb	r3, [r0, #1]
   207f6:	6a20      	ldr	r0, [r4, #32]
   207f8:	2b00      	cmp	r3, #0
   207fa:	d006      	beq.n	2080a <_ZN6Module23LoadModuleConfigurationEv+0x1e>
		//Invalidate config and load default
		configurationPointer->moduleId = 0xFF;
   207fc:	23ff      	movs	r3, #255	; 0xff
   207fe:	7003      	strb	r3, [r0, #0]
		ResetToDefaultConfiguration();
   20800:	6823      	ldr	r3, [r4, #0]
   20802:	1c20      	adds	r0, r4, #0
   20804:	695b      	ldr	r3, [r3, #20]
   20806:	4798      	blx	r3
   20808:	e013      	b.n	20832 <_ZN6Module23LoadModuleConfigurationEv+0x46>
   2080a:	2280      	movs	r2, #128	; 0x80
		ConfigurationLoadedHandler();
	} else {
		//Start to load the saved configuration

		bool bootloaderAvailable = (NRF_UICR->BOOTLOADERADDR != 0xFFFFFFFF);
   2080c:	4b0b      	ldr	r3, [pc, #44]	; (2083c <_ZN6Module23LoadModuleConfigurationEv+0x50>)
   2080e:	0552      	lsls	r2, r2, #21
   20810:	6959      	ldr	r1, [r3, #20]
		u32 bootloaderAddress = bootloaderAvailable ? NRF_UICR->BOOTLOADERADDR : FLASH_SIZE;
   20812:	3101      	adds	r1, #1
   20814:	d001      	beq.n	2081a <_ZN6Module23LoadModuleConfigurationEv+0x2e>
   20816:	695b      	ldr	r3, [r3, #20]
   20818:	e002      	b.n	20820 <_ZN6Module23LoadModuleConfigurationEv+0x34>
   2081a:	6951      	ldr	r1, [r2, #20]
   2081c:	6913      	ldr	r3, [r2, #16]
   2081e:	434b      	muls	r3, r1
		u32 appSettingsAddress = bootloaderAddress - (PSTORAGE_NUM_OF_PAGES+1) * PAGE_SIZE;
   20820:	6916      	ldr	r6, [r2, #16]

		//FIXME: only meant as hotfix, replace with NewStorage
		memcpy((u8*)configurationPointer, (u8*)(appSettingsAddress + storageSlot*STORAGE_BLOCK_SIZE), configurationLength);
   20822:	8a61      	ldrh	r1, [r4, #18]
   20824:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
   20826:	01cd      	lsls	r5, r1, #7
	} else {
		//Start to load the saved configuration

		bool bootloaderAvailable = (NRF_UICR->BOOTLOADERADDR != 0xFFFFFFFF);
		u32 bootloaderAddress = bootloaderAvailable ? NRF_UICR->BOOTLOADERADDR : FLASH_SIZE;
		u32 appSettingsAddress = bootloaderAddress - (PSTORAGE_NUM_OF_PAGES+1) * PAGE_SIZE;
   20828:	0071      	lsls	r1, r6, #1
   2082a:	1a69      	subs	r1, r5, r1

		//FIXME: only meant as hotfix, replace with NewStorage
		memcpy((u8*)configurationPointer, (u8*)(appSettingsAddress + storageSlot*STORAGE_BLOCK_SIZE), configurationLength);
   2082c:	18c9      	adds	r1, r1, r3
   2082e:	f000 fef1 	bl	21614 <memcpy>
		ConfigurationLoadedHandler();
   20832:	6823      	ldr	r3, [r4, #0]
   20834:	1c20      	adds	r0, r4, #0
   20836:	689b      	ldr	r3, [r3, #8]
   20838:	4798      	blx	r3
	}

}
   2083a:	bd70      	pop	{r4, r5, r6, pc}
   2083c:	10001000 	.word	0x10001000

00020840 <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert.part.4>:
	}

	return false;
}

void Module::ConnectionPacketReceivedEventHandler(connectionPacket* inPacket, Connection* connection, connPacketHeader* packetHeader, u16 dataLength)
   20840:	b5f0      	push	{r4, r5, r6, r7, lr}
   20842:	4c6e      	ldr	r4, [pc, #440]	; (209fc <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert.part.4+0x1bc>)
	//We want to handle incoming packets that change the module configuration
	if(
			packetHeader->messageType == MESSAGE_TYPE_MODULE_CONFIG
	){
		connPacketModule* packet = (connPacketModule*) packetHeader;
		if(packet->moduleId == moduleId)
   20844:	7953      	ldrb	r3, [r2, #5]
	}

	return false;
}

void Module::ConnectionPacketReceivedEventHandler(connectionPacket* inPacket, Connection* connection, connPacketHeader* packetHeader, u16 dataLength)
   20846:	44a5      	add	sp, r4
   20848:	1c04      	adds	r4, r0, #0
	//We want to handle incoming packets that change the module configuration
	if(
			packetHeader->messageType == MESSAGE_TYPE_MODULE_CONFIG
	){
		connPacketModule* packet = (connPacketModule*) packetHeader;
		if(packet->moduleId == moduleId)
   2084a:	7c00      	ldrb	r0, [r0, #16]
	}

	return false;
}

void Module::ConnectionPacketReceivedEventHandler(connectionPacket* inPacket, Connection* connection, connPacketHeader* packetHeader, u16 dataLength)
   2084c:	af02      	add	r7, sp, #8
	//We want to handle incoming packets that change the module configuration
	if(
			packetHeader->messageType == MESSAGE_TYPE_MODULE_CONFIG
	){
		connPacketModule* packet = (connPacketModule*) packetHeader;
		if(packet->moduleId == moduleId)
   2084e:	469c      	mov	ip, r3
   20850:	4298      	cmp	r0, r3
   20852:	d000      	beq.n	20856 <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert.part.4+0x16>
   20854:	e0cd      	b.n	209f2 <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert.part.4+0x1b2>
		{

			u16 dataFieldLength = inPacket->dataLength - SIZEOF_CONN_PACKET_MODULE;
   20856:	890b      	ldrh	r3, [r1, #8]
   20858:	1c16      	adds	r6, r2, #0
   2085a:	3b08      	subs	r3, #8
   2085c:	b29b      	uxth	r3, r3
   2085e:	60fb      	str	r3, [r7, #12]

			if(packet->actionType == ModuleConfigMessages::SET_CONFIG)
   20860:	79d5      	ldrb	r5, [r2, #7]
   20862:	2d00      	cmp	r5, #0
   20864:	d143      	bne.n	208ee <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert.part.4+0xae>
				logt("MODULE", "rx (%d): %s", dataFieldLength,  buffer);*/

				//Check if this config seems right
				ModuleConfiguration* newConfig = (ModuleConfiguration*)packet->data;
				if(
						newConfig->moduleVersion == configurationPointer->moduleVersion
   20866:	6a20      	ldr	r0, [r4, #32]
				Logger::getInstance().convertBufferToHexString((u8*)packet->data, dataFieldLength, (char*)buffer);
				logt("MODULE", "rx (%d): %s", dataFieldLength,  buffer);*/

				//Check if this config seems right
				ModuleConfiguration* newConfig = (ModuleConfiguration*)packet->data;
				if(
   20868:	7a52      	ldrb	r2, [r2, #9]
   2086a:	7843      	ldrb	r3, [r0, #1]
   2086c:	429a      	cmp	r2, r3
   2086e:	d000      	beq.n	20872 <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert.part.4+0x32>
   20870:	e0b1      	b.n	209d6 <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert.part.4+0x196>
						newConfig->moduleVersion == configurationPointer->moduleVersion
						&& dataFieldLength == configurationLength - sizeof(u32) //substract u32 reserved padding
   20872:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
   20874:	68f9      	ldr	r1, [r7, #12]
   20876:	1f13      	subs	r3, r2, #4
   20878:	4299      	cmp	r1, r3
   2087a:	d000      	beq.n	2087e <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert.part.4+0x3e>
   2087c:	e0ab      	b.n	209d6 <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert.part.4+0x196>
				){
					//Backup the module id because it must not be sent in the packet
					u8 moduleId = configurationPointer->moduleId;
   2087e:	7803      	ldrb	r3, [r0, #0]
					memset(configurationPointer, 0x00, configurationLength);
   20880:	1c29      	adds	r1, r5, #0
				if(
						newConfig->moduleVersion == configurationPointer->moduleVersion
						&& dataFieldLength == configurationLength - sizeof(u32) //substract u32 reserved padding
				){
					//Backup the module id because it must not be sent in the packet
					u8 moduleId = configurationPointer->moduleId;
   20882:	60bb      	str	r3, [r7, #8]
					memset(configurationPointer, 0x00, configurationLength);
   20884:	f000 fee3 	bl	2164e <memset>
					memcpy(configurationPointer, packet->data, dataFieldLength);
   20888:	1c31      	adds	r1, r6, #0
   2088a:	68fa      	ldr	r2, [r7, #12]
   2088c:	6a20      	ldr	r0, [r4, #32]
   2088e:	3108      	adds	r1, #8
   20890:	f000 fec0 	bl	21614 <memcpy>
					configurationPointer->moduleId = moduleId;
   20894:	6a23      	ldr	r3, [r4, #32]
   20896:	7a3a      	ldrb	r2, [r7, #8]

					//TODO: Maybe, we want to save this configuration, and afterwards send saveOK message

					//Send set_config_ok message
					connPacketModule outPacket;
					outPacket.header.messageType = MESSAGE_TYPE_MODULE_CONFIG;
   20898:	2101      	movs	r1, #1
				){
					//Backup the module id because it must not be sent in the packet
					u8 moduleId = configurationPointer->moduleId;
					memset(configurationPointer, 0x00, configurationLength);
					memcpy(configurationPointer, packet->data, dataFieldLength);
					configurationPointer->moduleId = moduleId;
   2089a:	701a      	strb	r2, [r3, #0]

					//TODO: Maybe, we want to save this configuration, and afterwards send saveOK message

					//Send set_config_ok message
					connPacketModule outPacket;
					outPacket.header.messageType = MESSAGE_TYPE_MODULE_CONFIG;
   2089c:	2264      	movs	r2, #100	; 0x64
   2089e:	7c3b      	ldrb	r3, [r7, #16]
					outPacket.moduleId = moduleId;
					outPacket.requestHandle = packet->requestHandle;
					outPacket.actionType = ModuleConfigMessages::SET_CONFIG_RESULT;
					outPacket.data[0] = NRF_SUCCESS; //Return ok

					cm->SendMessageToReceiver(NULL, (u8*) &outPacket, SIZEOF_CONN_PACKET_MODULE + 1, false);
   208a0:	68e0      	ldr	r0, [r4, #12]

					//TODO: Maybe, we want to save this configuration, and afterwards send saveOK message

					//Send set_config_ok message
					connPacketModule outPacket;
					outPacket.header.messageType = MESSAGE_TYPE_MODULE_CONFIG;
   208a2:	400b      	ands	r3, r1
   208a4:	4313      	orrs	r3, r2
   208a6:	743b      	strb	r3, [r7, #16]
					outPacket.header.sender = node->persistentConfig.nodeId;
   208a8:	68a3      	ldr	r3, [r4, #8]
   208aa:	1dda      	adds	r2, r3, #7
   208ac:	7fd2      	ldrb	r2, [r2, #31]
   208ae:	3308      	adds	r3, #8
   208b0:	747a      	strb	r2, [r7, #17]
   208b2:	7fdb      	ldrb	r3, [r3, #31]
					outPacket.header.receiver = packet->header.sender;
   208b4:	7872      	ldrb	r2, [r6, #1]
					//TODO: Maybe, we want to save this configuration, and afterwards send saveOK message

					//Send set_config_ok message
					connPacketModule outPacket;
					outPacket.header.messageType = MESSAGE_TYPE_MODULE_CONFIG;
					outPacket.header.sender = node->persistentConfig.nodeId;
   208b6:	74bb      	strb	r3, [r7, #18]
					outPacket.header.receiver = packet->header.sender;
   208b8:	78b3      	ldrb	r3, [r6, #2]
   208ba:	021b      	lsls	r3, r3, #8
   208bc:	4313      	orrs	r3, r2
   208be:	74fb      	strb	r3, [r7, #19]
   208c0:	0a1b      	lsrs	r3, r3, #8
   208c2:	753b      	strb	r3, [r7, #20]

					outPacket.moduleId = moduleId;
   208c4:	7a3b      	ldrb	r3, [r7, #8]
					outPacket.requestHandle = packet->requestHandle;
					outPacket.actionType = ModuleConfigMessages::SET_CONFIG_RESULT;
					outPacket.data[0] = NRF_SUCCESS; //Return ok

					cm->SendMessageToReceiver(NULL, (u8*) &outPacket, SIZEOF_CONN_PACKET_MODULE + 1, false);
   208c6:	2209      	movs	r2, #9
					connPacketModule outPacket;
					outPacket.header.messageType = MESSAGE_TYPE_MODULE_CONFIG;
					outPacket.header.sender = node->persistentConfig.nodeId;
					outPacket.header.receiver = packet->header.sender;

					outPacket.moduleId = moduleId;
   208c8:	757b      	strb	r3, [r7, #21]
					outPacket.requestHandle = packet->requestHandle;
   208ca:	79b3      	ldrb	r3, [r6, #6]
					outPacket.actionType = ModuleConfigMessages::SET_CONFIG_RESULT;
   208cc:	75f9      	strb	r1, [r7, #23]
					outPacket.header.messageType = MESSAGE_TYPE_MODULE_CONFIG;
					outPacket.header.sender = node->persistentConfig.nodeId;
					outPacket.header.receiver = packet->header.sender;

					outPacket.moduleId = moduleId;
					outPacket.requestHandle = packet->requestHandle;
   208ce:	75bb      	strb	r3, [r7, #22]
					outPacket.actionType = ModuleConfigMessages::SET_CONFIG_RESULT;
					outPacket.data[0] = NRF_SUCCESS; //Return ok

					cm->SendMessageToReceiver(NULL, (u8*) &outPacket, SIZEOF_CONN_PACKET_MODULE + 1, false);
   208d0:	2310      	movs	r3, #16
   208d2:	18f9      	adds	r1, r7, r3
   208d4:	1c2b      	adds	r3, r5, #0
					outPacket.header.receiver = packet->header.sender;

					outPacket.moduleId = moduleId;
					outPacket.requestHandle = packet->requestHandle;
					outPacket.actionType = ModuleConfigMessages::SET_CONFIG_RESULT;
					outPacket.data[0] = NRF_SUCCESS; //Return ok
   208d6:	763d      	strb	r5, [r7, #24]

					cm->SendMessageToReceiver(NULL, (u8*) &outPacket, SIZEOF_CONN_PACKET_MODULE + 1, false);
   208d8:	f7fe fc60 	bl	1f19c <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10>

					ConfigurationLoadedHandler();
   208dc:	6823      	ldr	r3, [r4, #0]
   208de:	1c20      	adds	r0, r4, #0
   208e0:	689b      	ldr	r3, [r3, #8]
   208e2:	4798      	blx	r3

					SaveModuleConfiguration();
   208e4:	6823      	ldr	r3, [r4, #0]
   208e6:	1c20      	adds	r0, r4, #0
   208e8:	68db      	ldr	r3, [r3, #12]
   208ea:	4798      	blx	r3
   208ec:	e073      	b.n	209d6 <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert.part.4+0x196>
				{
					if(newConfig->moduleVersion != configurationPointer->moduleVersion) uart("ERROR", "{\"type\":\"error\",\"module\":%u,\"code\":1,\"text\":\"wrong config version.\"}" SEP, moduleId);
					else uart("ERROR", "{\"type\":\"error\",\"module\":%u,\"code\":2,\"text\":\"wrong config length %u instead of %u \"}" SEP, moduleId, dataFieldLength, configurationLength - sizeof(u32));
				}
			}
			else if(packet->actionType == ModuleConfigMessages::GET_CONFIG)
   208ee:	2d04      	cmp	r5, #4
   208f0:	d13c      	bne.n	2096c <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert.part.4+0x12c>
   208f2:	466b      	mov	r3, sp
			{

				u8 buffer[SIZEOF_CONN_PACKET_MODULE + configurationLength];
   208f4:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
   208f6:	607b      	str	r3, [r7, #4]
   208f8:	1c13      	adds	r3, r2, #0
   208fa:	4669      	mov	r1, sp
   208fc:	3308      	adds	r3, #8
   208fe:	603b      	str	r3, [r7, #0]
   20900:	3307      	adds	r3, #7
   20902:	08db      	lsrs	r3, r3, #3
   20904:	00db      	lsls	r3, r3, #3
   20906:	1acb      	subs	r3, r1, r3
   20908:	469d      	mov	sp, r3

				connPacketModule* outPacket = (connPacketModule*)buffer;
				outPacket->header.messageType = MESSAGE_TYPE_MODULE_CONFIG;
   2090a:	2301      	movs	r3, #1
				}
			}
			else if(packet->actionType == ModuleConfigMessages::GET_CONFIG)
			{

				u8 buffer[SIZEOF_CONN_PACKET_MODULE + configurationLength];
   2090c:	ad02      	add	r5, sp, #8

				connPacketModule* outPacket = (connPacketModule*)buffer;
				outPacket->header.messageType = MESSAGE_TYPE_MODULE_CONFIG;
   2090e:	7829      	ldrb	r1, [r5, #0]
   20910:	400b      	ands	r3, r1
   20912:	2164      	movs	r1, #100	; 0x64
   20914:	430b      	orrs	r3, r1
   20916:	702b      	strb	r3, [r5, #0]
				outPacket->header.sender = node->persistentConfig.nodeId;
   20918:	68a3      	ldr	r3, [r4, #8]
   2091a:	395b      	subs	r1, #91	; 0x5b
   2091c:	3307      	adds	r3, #7
   2091e:	7fdb      	ldrb	r3, [r3, #31]
   20920:	4469      	add	r1, sp
   20922:	700b      	strb	r3, [r1, #0]
   20924:	68a3      	ldr	r3, [r4, #8]
   20926:	3308      	adds	r3, #8
   20928:	7fdb      	ldrb	r3, [r3, #31]
   2092a:	704b      	strb	r3, [r1, #1]
				outPacket->header.receiver = packet->header.sender;
   2092c:	78b1      	ldrb	r1, [r6, #2]
   2092e:	7873      	ldrb	r3, [r6, #1]
   20930:	0209      	lsls	r1, r1, #8
   20932:	468c      	mov	ip, r1
   20934:	210b      	movs	r1, #11
   20936:	4469      	add	r1, sp
   20938:	60b9      	str	r1, [r7, #8]
   2093a:	4661      	mov	r1, ip
   2093c:	430b      	orrs	r3, r1
   2093e:	68b9      	ldr	r1, [r7, #8]
   20940:	700b      	strb	r3, [r1, #0]
   20942:	0a1b      	lsrs	r3, r3, #8
   20944:	704b      	strb	r3, [r1, #1]

				outPacket->moduleId = moduleId;
   20946:	7168      	strb	r0, [r5, #5]
				outPacket->requestHandle = packet->requestHandle;
   20948:	79b3      	ldrb	r3, [r6, #6]
				outPacket->actionType = ModuleConfigMessages::CONFIG;

				memcpy(outPacket->data, (u8*)configurationPointer, configurationLength);
   2094a:	1c28      	adds	r0, r5, #0
				outPacket->header.messageType = MESSAGE_TYPE_MODULE_CONFIG;
				outPacket->header.sender = node->persistentConfig.nodeId;
				outPacket->header.receiver = packet->header.sender;

				outPacket->moduleId = moduleId;
				outPacket->requestHandle = packet->requestHandle;
   2094c:	71ab      	strb	r3, [r5, #6]
				outPacket->actionType = ModuleConfigMessages::CONFIG;
   2094e:	2305      	movs	r3, #5

				memcpy(outPacket->data, (u8*)configurationPointer, configurationLength);
   20950:	6a21      	ldr	r1, [r4, #32]
				outPacket->header.sender = node->persistentConfig.nodeId;
				outPacket->header.receiver = packet->header.sender;

				outPacket->moduleId = moduleId;
				outPacket->requestHandle = packet->requestHandle;
				outPacket->actionType = ModuleConfigMessages::CONFIG;
   20952:	71eb      	strb	r3, [r5, #7]

				memcpy(outPacket->data, (u8*)configurationPointer, configurationLength);
   20954:	3008      	adds	r0, #8
   20956:	f000 fe5d 	bl	21614 <memcpy>

				cm->SendMessageToReceiver(NULL, buffer, SIZEOF_CONN_PACKET_MODULE + configurationLength, false);
   2095a:	2300      	movs	r3, #0
   2095c:	883a      	ldrh	r2, [r7, #0]
   2095e:	68e0      	ldr	r0, [r4, #12]
   20960:	1c29      	adds	r1, r5, #0
   20962:	f7fe fc1b 	bl	1f19c <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10>
   20966:	687b      	ldr	r3, [r7, #4]
   20968:	469d      	mov	sp, r3
   2096a:	e034      	b.n	209d6 <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert.part.4+0x196>

			}
			else if(packet->actionType == ModuleConfigMessages::SET_ACTIVE)
   2096c:	2d02      	cmp	r5, #2
   2096e:	d132      	bne.n	209d6 <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert.part.4+0x196>
			{
				//Look for the module and set it active or inactive
				for(u32 i=0; i<MAX_MODULE_COUNT; i++){
					if(node->activeModules[i] && node->activeModules[i]->moduleId == packet->moduleId)
   20970:	68a3      	ldr	r3, [r4, #8]
   20972:	1c1a      	adds	r2, r3, #0
   20974:	3354      	adds	r3, #84	; 0x54
   20976:	3240      	adds	r2, #64	; 0x40
   20978:	6811      	ldr	r1, [r2, #0]
   2097a:	2900      	cmp	r1, #0
   2097c:	d028      	beq.n	209d0 <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert.part.4+0x190>
   2097e:	7c08      	ldrb	r0, [r1, #16]
   20980:	4560      	cmp	r0, ip
   20982:	d125      	bne.n	209d0 <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert.part.4+0x190>
					{
						node->activeModules[i]->configurationPointer->moduleActive = packet->data[0];
   20984:	6a0b      	ldr	r3, [r1, #32]
   20986:	7a32      	ldrb	r2, [r6, #8]
   20988:	709a      	strb	r2, [r3, #2]

						//Send confirmation that the module is now active
						connPacketModule outPacket;
						outPacket.header.messageType = MESSAGE_TYPE_MODULE_CONFIG;
   2098a:	2301      	movs	r3, #1
   2098c:	7c3a      	ldrb	r2, [r7, #16]
						outPacket.moduleId = moduleId;
						outPacket.requestHandle = packet->requestHandle;
						outPacket.actionType = ModuleConfigMessages::SET_ACTIVE_RESULT;
						outPacket.data[0] = NRF_SUCCESS; //Return ok

						cm->SendMessageToReceiver(NULL, (u8*) &outPacket, SIZEOF_CONN_PACKET_MODULE + 1, false);
   2098e:	68e0      	ldr	r0, [r4, #12]
					{
						node->activeModules[i]->configurationPointer->moduleActive = packet->data[0];

						//Send confirmation that the module is now active
						connPacketModule outPacket;
						outPacket.header.messageType = MESSAGE_TYPE_MODULE_CONFIG;
   20990:	4013      	ands	r3, r2
   20992:	2264      	movs	r2, #100	; 0x64
   20994:	4313      	orrs	r3, r2
						outPacket.header.sender = node->persistentConfig.nodeId;
   20996:	68a2      	ldr	r2, [r4, #8]
					{
						node->activeModules[i]->configurationPointer->moduleActive = packet->data[0];

						//Send confirmation that the module is now active
						connPacketModule outPacket;
						outPacket.header.messageType = MESSAGE_TYPE_MODULE_CONFIG;
   20998:	743b      	strb	r3, [r7, #16]
						outPacket.header.sender = node->persistentConfig.nodeId;
   2099a:	1dd3      	adds	r3, r2, #7
   2099c:	7fd9      	ldrb	r1, [r3, #31]
   2099e:	3208      	adds	r2, #8
   209a0:	7479      	strb	r1, [r7, #17]
   209a2:	7fd2      	ldrb	r2, [r2, #31]
						outPacket.header.receiver = packet->header.sender;
   209a4:	7871      	ldrb	r1, [r6, #1]
						node->activeModules[i]->configurationPointer->moduleActive = packet->data[0];

						//Send confirmation that the module is now active
						connPacketModule outPacket;
						outPacket.header.messageType = MESSAGE_TYPE_MODULE_CONFIG;
						outPacket.header.sender = node->persistentConfig.nodeId;
   209a6:	74ba      	strb	r2, [r7, #18]
						outPacket.header.receiver = packet->header.sender;
   209a8:	78b2      	ldrb	r2, [r6, #2]
						node->activeModules[i]->configurationPointer->moduleActive = packet->data[0];

						//Send confirmation that the module is now active
						connPacketModule outPacket;
						outPacket.header.messageType = MESSAGE_TYPE_MODULE_CONFIG;
						outPacket.header.sender = node->persistentConfig.nodeId;
   209aa:	2300      	movs	r3, #0
						outPacket.header.receiver = packet->header.sender;
   209ac:	0212      	lsls	r2, r2, #8
   209ae:	430a      	orrs	r2, r1
   209b0:	74fa      	strb	r2, [r7, #19]
   209b2:	0a12      	lsrs	r2, r2, #8
   209b4:	753a      	strb	r2, [r7, #20]

						outPacket.moduleId = moduleId;
   209b6:	7c22      	ldrb	r2, [r4, #16]
   209b8:	757a      	strb	r2, [r7, #21]
						outPacket.requestHandle = packet->requestHandle;
   209ba:	79b2      	ldrb	r2, [r6, #6]
						outPacket.actionType = ModuleConfigMessages::SET_ACTIVE_RESULT;
						outPacket.data[0] = NRF_SUCCESS; //Return ok
   209bc:	763b      	strb	r3, [r7, #24]
						outPacket.header.messageType = MESSAGE_TYPE_MODULE_CONFIG;
						outPacket.header.sender = node->persistentConfig.nodeId;
						outPacket.header.receiver = packet->header.sender;

						outPacket.moduleId = moduleId;
						outPacket.requestHandle = packet->requestHandle;
   209be:	75ba      	strb	r2, [r7, #22]
						outPacket.actionType = ModuleConfigMessages::SET_ACTIVE_RESULT;
   209c0:	2203      	movs	r2, #3
   209c2:	75fa      	strb	r2, [r7, #23]
						outPacket.data[0] = NRF_SUCCESS; //Return ok

						cm->SendMessageToReceiver(NULL, (u8*) &outPacket, SIZEOF_CONN_PACKET_MODULE + 1, false);
   209c4:	320d      	adds	r2, #13
   209c6:	18b9      	adds	r1, r7, r2
   209c8:	3a07      	subs	r2, #7
   209ca:	f7fe fbe7 	bl	1f19c <_ZN17ConnectionManager21SendMessageToReceiverEP10ConnectionPhtb.constprop.10>
   209ce:	e002      	b.n	209d6 <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert.part.4+0x196>
   209d0:	3204      	adds	r2, #4

			}
			else if(packet->actionType == ModuleConfigMessages::SET_ACTIVE)
			{
				//Look for the module and set it active or inactive
				for(u32 i=0; i<MAX_MODULE_COUNT; i++){
   209d2:	429a      	cmp	r2, r3
   209d4:	d1d0      	bne.n	20978 <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert.part.4+0x138>


			/*
			 * ######################### RESPONSES
			 * */
			if(packet->actionType == ModuleConfigMessages::SET_CONFIG_RESULT)
   209d6:	79f3      	ldrb	r3, [r6, #7]
   209d8:	2b05      	cmp	r3, #5
   209da:	d10a      	bne.n	209f2 <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert.part.4+0x1b2>
				uart("MODULE",  "\"requestHandle\":%u,\"code\":%u}" SEP, packet->requestHandle, packet->data[0]);
			}
			else if(packet->actionType == ModuleConfigMessages::CONFIG)
			{
				char* buffer[200];
				Logger::getInstance().convertBufferToHexString(packet->data, dataFieldLength, (char*)buffer, 200);
   209dc:	f7fc fc5c 	bl	1d298 <_ZN6Logger11getInstanceEv>
   209e0:	23c8      	movs	r3, #200	; 0xc8
   209e2:	1c31      	adds	r1, r6, #0
   209e4:	9300      	str	r3, [sp, #0]
   209e6:	3bb8      	subs	r3, #184	; 0xb8
   209e8:	3108      	adds	r1, #8
   209ea:	68fa      	ldr	r2, [r7, #12]
   209ec:	18fb      	adds	r3, r7, r3
   209ee:	f7fe ffef 	bl	1f9d0 <_ZN6Logger24convertBufferToHexStringEPhmPct>


			}
		}
	}
}
   209f2:	46bd      	mov	sp, r7
   209f4:	23cd      	movs	r3, #205	; 0xcd
   209f6:	009b      	lsls	r3, r3, #2
   209f8:	449d      	add	sp, r3
   209fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
   209fc:	fffffcc4 	.word	0xfffffcc4

00020a00 <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert>:

	return false;
}

void Module::ConnectionPacketReceivedEventHandler(connectionPacket* inPacket, Connection* connection, connPacketHeader* packetHeader, u16 dataLength)
{
   20a00:	b510      	push	{r4, lr}
	//We want to handle incoming packets that change the module configuration
	if(
   20a02:	2401      	movs	r4, #1
			packetHeader->messageType == MESSAGE_TYPE_MODULE_CONFIG
   20a04:	781a      	ldrb	r2, [r3, #0]
}

void Module::ConnectionPacketReceivedEventHandler(connectionPacket* inPacket, Connection* connection, connPacketHeader* packetHeader, u16 dataLength)
{
	//We want to handle incoming packets that change the module configuration
	if(
   20a06:	43a2      	bics	r2, r4
   20a08:	2a64      	cmp	r2, #100	; 0x64
   20a0a:	d102      	bne.n	20a12 <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x12>
   20a0c:	1c1a      	adds	r2, r3, #0
   20a0e:	f7ff ff17 	bl	20840 <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert.part.4>


			}
		}
	}
}
   20a12:	bd10      	pop	{r4, pc}

00020a14 <_ZN16EnrollmentModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert>:
	//Must be called to allow the module to get and set the config
	return Module::TerminalCommandHandler(commandName, commandArgs);
}

void EnrollmentModule::ConnectionPacketReceivedEventHandler(connectionPacket* inPacket, Connection* connection, connPacketHeader* packetHeader, u16 dataLength)
{
   20a14:	b5f0      	push	{r4, r5, r6, r7, lr}
   20a16:	1c1c      	adds	r4, r3, #0
   20a18:	b085      	sub	sp, #20
   20a1a:	ab0a      	add	r3, sp, #40	; 0x28
   20a1c:	881b      	ldrh	r3, [r3, #0]
   20a1e:	1c05      	adds	r5, r0, #0
	//Must call superclass for handling
	Module::ConnectionPacketReceivedEventHandler(inPacket, connection, packetHeader, dataLength);
   20a20:	9300      	str	r3, [sp, #0]
   20a22:	1c23      	adds	r3, r4, #0
   20a24:	f7ff ffec 	bl	20a00 <_ZN6Module36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert>

	if(packetHeader->messageType == MESSAGE_TYPE_MODULE_TRIGGER_ACTION){
   20a28:	2201      	movs	r2, #1
   20a2a:	7823      	ldrb	r3, [r4, #0]
   20a2c:	4393      	bics	r3, r2
   20a2e:	2b66      	cmp	r3, #102	; 0x66
   20a30:	d167      	bne.n	20b02 <_ZN16EnrollmentModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0xee>
		connPacketModule* packet = (connPacketModule*)packetHeader;

		//Check if our module is meant and we should trigger an action
		if(packet->moduleId == moduleId){
   20a32:	7962      	ldrb	r2, [r4, #5]
   20a34:	7c2b      	ldrb	r3, [r5, #16]
   20a36:	429a      	cmp	r2, r3
   20a38:	d163      	bne.n	20b02 <_ZN16EnrollmentModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0xee>
			if(packet->actionType == EnrollmentModuleTriggerActionMessages::SET_ENROLLMENT_BY_NODE_ID)
   20a3a:	79e6      	ldrb	r6, [r4, #7]
   20a3c:	2e00      	cmp	r6, #0
   20a3e:	d10e      	bne.n	20a5e <_ZN16EnrollmentModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x4a>
				EnrollmentModuleSetEnrollmentByNodeIdMessage* data = (EnrollmentModuleSetEnrollmentByNodeIdMessage*)packet->data;

				logt("ENROLLMOD", "Enrollment (by nodeId) received nodeId:%u, networkid:%u", data->nodeId, data->networkId);

				//Stop all meshing
				node->Stop();
   20a40:	68a8      	ldr	r0, [r5, #8]
   20a42:	f7fd fd25 	bl	1e490 <_ZN4Node4StopEv>

				//Save values to persistent config
				node->persistentConfig.nodeId = data->nodeId;
   20a46:	7a63      	ldrb	r3, [r4, #9]
   20a48:	7a22      	ldrb	r2, [r4, #8]
   20a4a:	68a8      	ldr	r0, [r5, #8]
   20a4c:	021b      	lsls	r3, r3, #8
   20a4e:	4313      	orrs	r3, r2
   20a50:	84c3      	strh	r3, [r0, #38]	; 0x26
				node->persistentConfig.networkId = data->networkId;
   20a52:	7ae3      	ldrb	r3, [r4, #11]
   20a54:	7aa2      	ldrb	r2, [r4, #10]
   20a56:	021b      	lsls	r3, r3, #8
   20a58:	4313      	orrs	r3, r2
   20a5a:	8483      	strh	r3, [r0, #36]	; 0x24
   20a5c:	e079      	b.n	20b52 <_ZN16EnrollmentModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x13e>

				node->SaveConfiguration();
				SendEnrollmentResponse(NODE_ID_BROADCAST, enrollmentMethods::BY_NODE_ID, packet->requestHandle, 0, (u8*)Config->serialNumber);

			}
			else if(packet->actionType == EnrollmentModuleTriggerActionMessages::SET_ENROLLMENT_BY_CHIP_ID)
   20a5e:	2e01      	cmp	r6, #1
   20a60:	d11f      	bne.n	20aa2 <_ZN16EnrollmentModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x8e>
			{
				EnrollmentModuleSetEnrollmentByChipIdMessage* data = (EnrollmentModuleSetEnrollmentByChipIdMessage*)packet->data;

				if(data->chipIdA == NRF_FICR->DEVICEID[0] && data->chipIdB == NRF_FICR->DEVICEID[1])
   20a62:	2780      	movs	r7, #128	; 0x80
   20a64:	057f      	lsls	r7, r7, #21
   20a66:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   20a68:	7a62      	ldrb	r2, [r4, #9]
   20a6a:	469c      	mov	ip, r3
   20a6c:	7a20      	ldrb	r0, [r4, #8]
   20a6e:	7aa3      	ldrb	r3, [r4, #10]
   20a70:	0212      	lsls	r2, r2, #8
   20a72:	4302      	orrs	r2, r0
   20a74:	041b      	lsls	r3, r3, #16
   20a76:	4313      	orrs	r3, r2
   20a78:	1c1a      	adds	r2, r3, #0
   20a7a:	7ae3      	ldrb	r3, [r4, #11]
   20a7c:	061b      	lsls	r3, r3, #24
   20a7e:	4313      	orrs	r3, r2
   20a80:	4563      	cmp	r3, ip
   20a82:	d13e      	bne.n	20b02 <_ZN16EnrollmentModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0xee>
   20a84:	7b62      	ldrb	r2, [r4, #13]
   20a86:	7b20      	ldrb	r0, [r4, #12]
   20a88:	7ba3      	ldrb	r3, [r4, #14]
   20a8a:	0212      	lsls	r2, r2, #8
   20a8c:	4302      	orrs	r2, r0
   20a8e:	041b      	lsls	r3, r3, #16
   20a90:	4313      	orrs	r3, r2
   20a92:	1c1a      	adds	r2, r3, #0
   20a94:	7be3      	ldrb	r3, [r4, #15]
   20a96:	6e7f      	ldr	r7, [r7, #100]	; 0x64
   20a98:	061b      	lsls	r3, r3, #24
   20a9a:	4313      	orrs	r3, r2
   20a9c:	42bb      	cmp	r3, r7
   20a9e:	d130      	bne.n	20b02 <_ZN16EnrollmentModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0xee>
   20aa0:	e042      	b.n	20b28 <_ZN16EnrollmentModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x114>

					SendEnrollmentResponse(NODE_ID_BROADCAST, enrollmentMethods::BY_CHIP_ID, packet->requestHandle, 0, (u8*)Config->serialNumber);
				}
			}
			//If an enrollment by serial is received
			else if(packet->actionType == EnrollmentModuleTriggerActionMessages::SET_ENROLLMENT_BY_SERIAL)
   20aa2:	2e02      	cmp	r6, #2
   20aa4:	d12d      	bne.n	20b02 <_ZN16EnrollmentModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0xee>
			{
				EnrollmentModuleSetEnrollmentBySerialMessage* data = (EnrollmentModuleSetEnrollmentBySerialMessage*)packet->data;

				if(memcmp(data->serialNumber, Config->serialNumber, SERIAL_NUMBER_LENGTH) == 0)
   20aa6:	f000 f9bf 	bl	20e28 <_ZN4Conf11getInstanceEv>
   20aaa:	1c01      	adds	r1, r0, #0
   20aac:	1c20      	adds	r0, r4, #0
   20aae:	3148      	adds	r1, #72	; 0x48
   20ab0:	3008      	adds	r0, #8
   20ab2:	2205      	movs	r2, #5
   20ab4:	f000 fd9f 	bl	215f6 <memcmp>
   20ab8:	2800      	cmp	r0, #0
   20aba:	d122      	bne.n	20b02 <_ZN16EnrollmentModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0xee>
				{
					logt("ENROLLMOD", "Enrollment (by serial) received nodeId:%u, networkid:%u, key[0]=%u, key[10]=%u, key[15]=%u", data->newNodeId, data->newNetworkId, data->newNetworkKey[0], data->newNetworkKey[10], data->newNetworkKey[15]);

					//Stop all meshing
					node->Stop();
   20abc:	68a8      	ldr	r0, [r5, #8]
   20abe:	f7fd fce7 	bl	1e490 <_ZN4Node4StopEv>

					//Save values to persistent config
					node->persistentConfig.nodeId = data->newNodeId;
					node->persistentConfig.networkId = data->newNetworkId;
					memcpy(&node->persistentConfig.networkKey, data->newNetworkKey, 16);
   20ac2:	1c21      	adds	r1, r4, #0

					//Stop all meshing
					node->Stop();

					//Save values to persistent config
					node->persistentConfig.nodeId = data->newNodeId;
   20ac4:	7ba3      	ldrb	r3, [r4, #14]
   20ac6:	7b62      	ldrb	r2, [r4, #13]
   20ac8:	68a8      	ldr	r0, [r5, #8]
   20aca:	021b      	lsls	r3, r3, #8
   20acc:	4313      	orrs	r3, r2
   20ace:	84c3      	strh	r3, [r0, #38]	; 0x26
					node->persistentConfig.networkId = data->newNetworkId;
   20ad0:	7c23      	ldrb	r3, [r4, #16]
   20ad2:	7be2      	ldrb	r2, [r4, #15]
   20ad4:	021b      	lsls	r3, r3, #8
   20ad6:	4313      	orrs	r3, r2
   20ad8:	8483      	strh	r3, [r0, #36]	; 0x24
					memcpy(&node->persistentConfig.networkKey, data->newNetworkKey, 16);
   20ada:	3111      	adds	r1, #17
   20adc:	2210      	movs	r2, #16
   20ade:	3028      	adds	r0, #40	; 0x28
   20ae0:	f000 fd98 	bl	21614 <memcpy>

					node->SaveConfiguration();
   20ae4:	68a8      	ldr	r0, [r5, #8]
   20ae6:	f7fd f943 	bl	1dd70 <_ZN4Node17SaveConfigurationEv>

					//FIXME: Should only send response after enrollment is saved
					SendEnrollmentResponse(NODE_ID_BROADCAST, enrollmentMethods::BY_SERIAL, packet->requestHandle, 0, (u8*)Config->serialNumber);
   20aea:	79a7      	ldrb	r7, [r4, #6]
   20aec:	f000 f99c 	bl	20e28 <_ZN4Conf11getInstanceEv>
   20af0:	1c28      	adds	r0, r5, #0
   20af2:	1c31      	adds	r1, r6, #0
   20af4:	1c3a      	adds	r2, r7, #0
   20af6:	f7fe fccf 	bl	1f498 <_ZN16EnrollmentModule22SendEnrollmentResponseEthhhPh.constprop.0>

					//FIXME: Hotfix until NewStorage supports page swapping
					//We wait some time until the enrollment is saved
					rebootTimeDs = node->appTimerDs + SEC_TO_DS(8);
   20afa:	68ab      	ldr	r3, [r5, #8]
   20afc:	6e5b      	ldr	r3, [r3, #100]	; 0x64
   20afe:	3350      	adds	r3, #80	; 0x50
   20b00:	636b      	str	r3, [r5, #52]	; 0x34
			}
		}
	}

	//Parse Module responses
	if(packetHeader->messageType == MESSAGE_TYPE_MODULE_ACTION_RESPONSE){
   20b02:	2201      	movs	r2, #1
   20b04:	7823      	ldrb	r3, [r4, #0]
   20b06:	4393      	bics	r3, r2
   20b08:	2b68      	cmp	r3, #104	; 0x68
   20b0a:	d12d      	bne.n	20b68 <_ZN16EnrollmentModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x154>
		connPacketModule* packet = (connPacketModule*)packetHeader;

		//Check if our module is meant and we should trigger an action
		if(packet->moduleId == moduleId)
   20b0c:	7962      	ldrb	r2, [r4, #5]
   20b0e:	7c2b      	ldrb	r3, [r5, #16]
   20b10:	429a      	cmp	r2, r3
   20b12:	d129      	bne.n	20b68 <_ZN16EnrollmentModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x154>
		{
			if(packet->actionType == EnrollmentModuleActionResponseMessages::ENROLLMENT_SUCCESSFUL)
   20b14:	79e3      	ldrb	r3, [r4, #7]
   20b16:	2b00      	cmp	r3, #0
   20b18:	d126      	bne.n	20b68 <_ZN16EnrollmentModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x154>
				else if(data->enrollmentMethod == enrollmentMethods::BY_CHIP_ID) enrollmentMethodString = "chip_id";
				else if(data->enrollmentMethod == enrollmentMethods::BY_SERIAL) enrollmentMethodString = "serial";

				//Add null terminator to string
				u8 serialNumber[SERIAL_NUMBER_LENGTH+1];
				memcpy(serialNumber, data->serialNumber, SERIAL_NUMBER_LENGTH);
   20b1a:	1c21      	adds	r1, r4, #0
   20b1c:	a802      	add	r0, sp, #8
   20b1e:	310a      	adds	r1, #10
   20b20:	2205      	movs	r2, #5
   20b22:	f000 fd77 	bl	21614 <memcpy>
   20b26:	e01f      	b.n	20b68 <_ZN16EnrollmentModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0x154>
				if(data->chipIdA == NRF_FICR->DEVICEID[0] && data->chipIdB == NRF_FICR->DEVICEID[1])
				{
					logt("ENROLLMOD", "Enrollment (by chipId) received nodeId:%u, networkid:%u, key[0]=%u, key[10]=%u, key[15]=%u", data->nodeId, data->networkId, data->networkKey[0], data->networkKey[10], data->networkKey[15]);

					//Stop all meshing
					node->Stop();
   20b28:	68a8      	ldr	r0, [r5, #8]
   20b2a:	f7fd fcb1 	bl	1e490 <_ZN4Node4StopEv>

					//Save values to persistent config
					node->persistentConfig.nodeId = data->nodeId;
					node->persistentConfig.networkId = data->networkId;
					memcpy(&node->persistentConfig.networkKey, data->networkKey, 16);
   20b2e:	1c21      	adds	r1, r4, #0

					//Stop all meshing
					node->Stop();

					//Save values to persistent config
					node->persistentConfig.nodeId = data->nodeId;
   20b30:	7c63      	ldrb	r3, [r4, #17]
   20b32:	7c22      	ldrb	r2, [r4, #16]
   20b34:	68a8      	ldr	r0, [r5, #8]
   20b36:	021b      	lsls	r3, r3, #8
   20b38:	4313      	orrs	r3, r2
   20b3a:	84c3      	strh	r3, [r0, #38]	; 0x26
					node->persistentConfig.networkId = data->networkId;
   20b3c:	7ce3      	ldrb	r3, [r4, #19]
   20b3e:	7ca2      	ldrb	r2, [r4, #18]
   20b40:	021b      	lsls	r3, r3, #8
   20b42:	4313      	orrs	r3, r2
   20b44:	8483      	strh	r3, [r0, #36]	; 0x24
					memcpy(&node->persistentConfig.networkKey, data->networkKey, 16);
   20b46:	3114      	adds	r1, #20
   20b48:	3028      	adds	r0, #40	; 0x28
   20b4a:	2210      	movs	r2, #16
   20b4c:	f000 fd62 	bl	21614 <memcpy>

					node->SaveConfiguration();
   20b50:	68a8      	ldr	r0, [r5, #8]
   20b52:	f7fd f90d 	bl	1dd70 <_ZN4Node17SaveConfigurationEv>

					SendEnrollmentResponse(NODE_ID_BROADCAST, enrollmentMethods::BY_CHIP_ID, packet->requestHandle, 0, (u8*)Config->serialNumber);
   20b56:	79a7      	ldrb	r7, [r4, #6]
   20b58:	f000 f966 	bl	20e28 <_ZN4Conf11getInstanceEv>
   20b5c:	1c28      	adds	r0, r5, #0
   20b5e:	1c31      	adds	r1, r6, #0
   20b60:	1c3a      	adds	r2, r7, #0
   20b62:	f7fe fc99 	bl	1f498 <_ZN16EnrollmentModule22SendEnrollmentResponseEthhhPh.constprop.0>
   20b66:	e7cc      	b.n	20b02 <_ZN16EnrollmentModule36ConnectionPacketReceivedEventHandlerEP16connectionPacketP10ConnectionP16connPacketHeadert+0xee>
				uart("ENROLLMOD", "{\"nodeId\":%u,\"type\":\"enroll_response_%s\",\"module\":%d,", packet->header.sender, enrollmentMethodString, moduleId);
				uart("ENROLLMOD", "\"requestId\":%u,\"serialNumber\":\"%s\"}" SEP,  packet->requestHandle, serialNumber);
			}
		}
	}
}
   20b68:	b005      	add	sp, #20
   20b6a:	bdf0      	pop	{r4, r5, r6, r7, pc}

00020b6c <_ZN6Module23SaveModuleConfigurationEv>:
{
}


void Module::SaveModuleConfiguration()
{
   20b6c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   20b6e:	1c04      	adds	r4, r0, #0
	int paddedLength = configurationLength - (configurationLength % 4);
   20b70:	2303      	movs	r3, #3
   20b72:	8c85      	ldrh	r5, [r0, #36]	; 0x24
   20b74:	439d      	bics	r5, r3
	Storage::getInstance().QueuedWrite((u8*)configurationPointer, paddedLength, storageSlot, this);
   20b76:	f000 f875 	bl	20c64 <_ZN7Storage11getInstanceEv>
   20b7a:	8a63      	ldrh	r3, [r4, #18]
}

void Storage::QueuedWrite(u8* data, u16 dataLength, u32 blockId, StorageEventListener* callback)
{
	taskitem task;
	task.data = data;
   20b7c:	6a22      	ldr	r2, [r4, #32]
	task.dataLength = dataLength;
	task.storageBlock = blockId;
   20b7e:	9301      	str	r3, [sp, #4]
}

void Storage::QueuedWrite(u8* data, u16 dataLength, u32 blockId, StorageEventListener* callback)
{
	taskitem task;
	task.data = data;
   20b80:	9202      	str	r2, [sp, #8]
	task.dataLength = dataLength;
	task.storageBlock = blockId;
	task.callback = callback;
	task.operation = operation::OPERATION_WRITE;
   20b82:	2301      	movs	r3, #1

void Storage::QueuedWrite(u8* data, u16 dataLength, u32 blockId, StorageEventListener* callback)
{
	taskitem task;
	task.data = data;
	task.dataLength = dataLength;
   20b84:	466a      	mov	r2, sp
	task.storageBlock = blockId;
	task.callback = callback;
	task.operation = operation::OPERATION_WRITE;
   20b86:	8013      	strh	r3, [r2, #0]

	taskQueue->Put((u8*)&task, sizeof(taskitem));
   20b88:	1c03      	adds	r3, r0, #0
   20b8a:	1c06      	adds	r6, r0, #0
   20b8c:	33a4      	adds	r3, #164	; 0xa4
   20b8e:	6818      	ldr	r0, [r3, #0]
   20b90:	4669      	mov	r1, sp

void Storage::QueuedWrite(u8* data, u16 dataLength, u32 blockId, StorageEventListener* callback)
{
	taskitem task;
	task.data = data;
	task.dataLength = dataLength;
   20b92:	8055      	strh	r5, [r2, #2]
	task.storageBlock = blockId;
	task.callback = callback;
   20b94:	9403      	str	r4, [sp, #12]
	task.operation = operation::OPERATION_WRITE;

	taskQueue->Put((u8*)&task, sizeof(taskitem));
   20b96:	f7fe faa7 	bl	1f0e8 <_ZN11SimpleQueue3PutEPhm.constprop.15>

	ProcessQueue();
   20b9a:	1c30      	adds	r0, r6, #0
   20b9c:	f7fe fcb8 	bl	1f510 <_ZN7Storage12ProcessQueueEv>
}
   20ba0:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

00020ba2 <_ZN20StatusReporterModuleD0Ev.lto_priv.66>:
   20ba2:	b510      	push	{r4, lr}
   20ba4:	1c04      	adds	r4, r0, #0
   20ba6:	f7fd fc7b 	bl	1e4a0 <_ZN20StatusReporterModuleD1Ev.lto_priv.107>
   20baa:	1c20      	adds	r0, r4, #0
   20bac:	f000 fb4a 	bl	21244 <_ZdlPv>
   20bb0:	1c20      	adds	r0, r4, #0
   20bb2:	bd10      	pop	{r4, pc}

00020bb4 <_ZThn4_N20StatusReporterModuleD0Ev>:
   20bb4:	b408      	push	{r3}
   20bb6:	4b02      	ldr	r3, [pc, #8]	; (20bc0 <_ZThn4_N20StatusReporterModuleD0Ev+0xc>)
   20bb8:	469c      	mov	ip, r3
   20bba:	3804      	subs	r0, #4
   20bbc:	bc08      	pop	{r3}
   20bbe:	4760      	bx	ip
   20bc0:	00020ba3 	.word	0x00020ba3

00020bc4 <_ZN6ModuleC2EhP4NodeP17ConnectionManagerPKct>:
extern "C"{
#include <stdlib.h>
}


Module::Module(u8 moduleId, Node* node, ConnectionManager* cm, const char* name, u16 storageSlot)
   20bc4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   20bc6:	1c04      	adds	r4, r0, #0
   20bc8:	a808      	add	r0, sp, #32
   20bca:	1c0e      	adds	r6, r1, #0
   20bcc:	c802      	ldmia	r0!, {r1}
{
	this->node = node;
	this->cm = cm;
   20bce:	60e3      	str	r3, [r4, #12]
extern "C"{
#include <stdlib.h>
}


Module::Module(u8 moduleId, Node* node, ConnectionManager* cm, const char* name, u16 storageSlot)
   20bd0:	8805      	ldrh	r5, [r0, #0]
   20bd2:	480e      	ldr	r0, [pc, #56]	; (20c0c <_ZN6ModuleC2EhP4NodeP17ConnectionManagerPKct+0x48>)
{
	this->node = node;
	this->cm = cm;
	this->moduleId  = moduleId;
	this->storageSlot = storageSlot;
	this->configurationPointer = NULL;
   20bd4:	2300      	movs	r3, #0
extern "C"{
#include <stdlib.h>
}


Module::Module(u8 moduleId, Node* node, ConnectionManager* cm, const char* name, u16 storageSlot)
   20bd6:	1c07      	adds	r7, r0, #0
   20bd8:	3048      	adds	r0, #72	; 0x48
   20bda:	6060      	str	r0, [r4, #4]
	this->cm = cm;
	this->moduleId  = moduleId;
	this->storageSlot = storageSlot;
	this->configurationPointer = NULL;
	this->configurationLength = 0;
	memcpy(moduleName, name, MODULE_NAME_MAX_SIZE);
   20bdc:	1c20      	adds	r0, r4, #0
extern "C"{
#include <stdlib.h>
}


Module::Module(u8 moduleId, Node* node, ConnectionManager* cm, const char* name, u16 storageSlot)
   20bde:	3708      	adds	r7, #8
{
	this->node = node;
	this->cm = cm;
	this->moduleId  = moduleId;
	this->storageSlot = storageSlot;
	this->configurationPointer = NULL;
   20be0:	6223      	str	r3, [r4, #32]
	this->configurationLength = 0;
   20be2:	84a3      	strh	r3, [r4, #36]	; 0x24
extern "C"{
#include <stdlib.h>
}


Module::Module(u8 moduleId, Node* node, ConnectionManager* cm, const char* name, u16 storageSlot)
   20be4:	6027      	str	r7, [r4, #0]
{
	this->node = node;
   20be6:	60a2      	str	r2, [r4, #8]
	this->cm = cm;
	this->moduleId  = moduleId;
   20be8:	7426      	strb	r6, [r4, #16]
	this->storageSlot = storageSlot;
   20bea:	8265      	strh	r5, [r4, #18]
	this->configurationPointer = NULL;
	this->configurationLength = 0;
	memcpy(moduleName, name, MODULE_NAME_MAX_SIZE);
   20bec:	220a      	movs	r2, #10
   20bee:	3014      	adds	r0, #20
   20bf0:	f000 fd10 	bl	21614 <memcpy>

	Terminal::AddTerminalCommandListener(this);

	Logger::getInstance().enableTag("MODULE");
   20bf4:	f7fc fb50 	bl	1d298 <_ZN6Logger11getInstanceEv>
   20bf8:	4905      	ldr	r1, [pc, #20]	; (20c10 <_ZN6ModuleC2EhP4NodeP17ConnectionManagerPKct+0x4c>)
   20bfa:	466a      	mov	r2, sp
   20bfc:	a801      	add	r0, sp, #4
   20bfe:	f000 fbb5 	bl	2136c <_ZNSsC1EPKcRKSaIcE>
   20c02:	a801      	add	r0, sp, #4
   20c04:	f000 fb82 	bl	2130c <_ZNSsD1Ev>
}
   20c08:	1c20      	adds	r0, r4, #0
   20c0a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   20c0c:	00022b38 	.word	0x00022b38
   20c10:	00022c1d 	.word	0x00022c1d

00020c14 <_ZN6Module15BleEventHandlerEP9ble_evt_t>:

		//This handler receives all timer events
		virtual void TimerEventHandler(u16 passedTimeDs, u32 appTimerDs){};

		//This handler receives all ble events and can act on them
		virtual void BleEventHandler(ble_evt_t* bleEvent){};
   20c14:	4770      	bx	lr

00020c16 <_ZN6Module17TimerEventHandlerEtm>:

		//Handle system events
		virtual void SystemEventHandler(u32 systemEvent){};

		//This handler receives all timer events
		virtual void TimerEventHandler(u16 passedTimeDs, u32 appTimerDs){};
   20c16:	4770      	bx	lr

00020c18 <_ZN6Module18SystemEventHandlerEm>:

		//Called when the module should send back its data
		virtual void GetDataHandler(u8* request, u8 length){};

		//Handle system events
		virtual void SystemEventHandler(u32 systemEvent){};
   20c18:	4770      	bx	lr

00020c1a <__tcf_0>:
		//a new item is added to the queue
		void ProcessQueue();

	public:
		static Storage& getInstance(){
			static Storage instance;
   20c1a:	4770      	bx	lr

00020c1c <_ZN4Conf20generateRandomSerialEv>:
//	}
//	return NULL;
}


void Conf::generateRandomSerial(){
   20c1c:	b570      	push	{r4, r5, r6, lr}
	//(removed vocals to prevent bad words, removed 0 because it could be mistaken for an o)
	const char* alphabet = "BCDFGHJKLMNPQRSTVWXYZ123456789"; //30 chars

	//This takes 5bit wide chunks from the device id to generate a serial number
	//in tests, 10k serial numbers had 4 duplicates
	for(int i=0; i<SERIAL_NUMBER_LENGTH; i++){
   20c1e:	2400      	movs	r4, #0
		u8 fiveBitChunk = (NRF_FICR->DEVICEID[0] & 0x1F << (i*5)) >> (i*5);
		instance->serialNumber[i] = alphabet[fiveBitChunk % 30];
   20c20:	4b0e      	ldr	r3, [pc, #56]	; (20c5c <_ZN4Conf20generateRandomSerialEv+0x40>)
   20c22:	681d      	ldr	r5, [r3, #0]
	const char* alphabet = "BCDFGHJKLMNPQRSTVWXYZ123456789"; //30 chars

	//This takes 5bit wide chunks from the device id to generate a serial number
	//in tests, 10k serial numbers had 4 duplicates
	for(int i=0; i<SERIAL_NUMBER_LENGTH; i++){
		u8 fiveBitChunk = (NRF_FICR->DEVICEID[0] & 0x1F << (i*5)) >> (i*5);
   20c24:	2380      	movs	r3, #128	; 0x80
   20c26:	2205      	movs	r2, #5
   20c28:	055b      	lsls	r3, r3, #21
   20c2a:	6e18      	ldr	r0, [r3, #96]	; 0x60
   20c2c:	231f      	movs	r3, #31
   20c2e:	4362      	muls	r2, r4
   20c30:	4093      	lsls	r3, r2
   20c32:	4018      	ands	r0, r3
   20c34:	40d0      	lsrs	r0, r2
		instance->serialNumber[i] = alphabet[fiveBitChunk % 30];
   20c36:	211e      	movs	r1, #30
   20c38:	b2c0      	uxtb	r0, r0
   20c3a:	f001 faa3 	bl	22184 <__aeabi_uidivmod>
   20c3e:	1c26      	adds	r6, r4, #0
   20c40:	4b07      	ldr	r3, [pc, #28]	; (20c60 <_ZN4Conf20generateRandomSerialEv+0x44>)
   20c42:	b2c9      	uxtb	r1, r1
   20c44:	3648      	adds	r6, #72	; 0x48
   20c46:	5c5b      	ldrb	r3, [r3, r1]
   20c48:	19ae      	adds	r6, r5, r6
	//(removed vocals to prevent bad words, removed 0 because it could be mistaken for an o)
	const char* alphabet = "BCDFGHJKLMNPQRSTVWXYZ123456789"; //30 chars

	//This takes 5bit wide chunks from the device id to generate a serial number
	//in tests, 10k serial numbers had 4 duplicates
	for(int i=0; i<SERIAL_NUMBER_LENGTH; i++){
   20c4a:	3401      	adds	r4, #1
		u8 fiveBitChunk = (NRF_FICR->DEVICEID[0] & 0x1F << (i*5)) >> (i*5);
		instance->serialNumber[i] = alphabet[fiveBitChunk % 30];
   20c4c:	7033      	strb	r3, [r6, #0]
	//(removed vocals to prevent bad words, removed 0 because it could be mistaken for an o)
	const char* alphabet = "BCDFGHJKLMNPQRSTVWXYZ123456789"; //30 chars

	//This takes 5bit wide chunks from the device id to generate a serial number
	//in tests, 10k serial numbers had 4 duplicates
	for(int i=0; i<SERIAL_NUMBER_LENGTH; i++){
   20c4e:	2c05      	cmp	r4, #5
   20c50:	d1e8      	bne.n	20c24 <_ZN4Conf20generateRandomSerialEv+0x8>
		u8 fiveBitChunk = (NRF_FICR->DEVICEID[0] & 0x1F << (i*5)) >> (i*5);
		instance->serialNumber[i] = alphabet[fiveBitChunk % 30];
	}
	instance->serialNumber[SERIAL_NUMBER_LENGTH] = '\0';
   20c52:	2300      	movs	r3, #0
   20c54:	354d      	adds	r5, #77	; 0x4d
   20c56:	702b      	strb	r3, [r5, #0]
}
   20c58:	bd70      	pop	{r4, r5, r6, pc}
   20c5a:	46c0      	nop			; (mov r8, r8)
   20c5c:	200036c0 	.word	0x200036c0
   20c60:	00022c8f 	.word	0x00022c8f

00020c64 <_ZN7Storage11getInstanceEv>:
   20c64:	4b52      	ldr	r3, [pc, #328]	; (20db0 <_ZN7Storage11getInstanceEv+0x14c>)
		//This function is called when pstorage finished writing/reading sth or when
		//a new item is added to the queue
		void ProcessQueue();

	public:
		static Storage& getInstance(){
   20c66:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
			static Storage instance;
   20c68:	681c      	ldr	r4, [r3, #0]
   20c6a:	2301      	movs	r3, #1
   20c6c:	401c      	ands	r4, r3
   20c6e:	d000      	beq.n	20c72 <_ZN7Storage11getInstanceEv+0xe>
   20c70:	e09b      	b.n	20daa <_ZN7Storage11getInstanceEv+0x146>

//Use this storage class to save module configurations and either implement a callback queue
//or even better a save and load queue with callback handlers


Storage::Storage()
   20c72:	4d50      	ldr	r5, [pc, #320]	; (20db4 <_ZN7Storage11getInstanceEv+0x150>)
   20c74:	4b50      	ldr	r3, [pc, #320]	; (20db8 <_ZN7Storage11getInstanceEv+0x154>)
   20c76:	1c2e      	adds	r6, r5, #0

	//Register with Terminal
	Terminal::AddTerminalCommandListener(this);

	//Initialize queue for queueing store and load tasks
	taskQueue = new SimpleQueue(taskBuffer, TASK_BUFFER_LENGTH);
   20c78:	2018      	movs	r0, #24

//Use this storage class to save module configurations and either implement a callback queue
//or even better a save and load queue with callback handlers


Storage::Storage()
   20c7a:	c608      	stmia	r6!, {r3}

	//Register with Terminal
	Terminal::AddTerminalCommandListener(this);

	//Initialize queue for queueing store and load tasks
	taskQueue = new SimpleQueue(taskBuffer, TASK_BUFFER_LENGTH);
   20c7c:	f000 fad0 	bl	21220 <_Znwj>

SimpleQueue::SimpleQueue(u8* buffer, u32 bufferLength)
{
    this->_numElements = 0;
    this->bufferStart = buffer;
    this->bufferEnd = buffer + bufferLength;
   20c80:	1c2b      	adds	r3, r5, #0
    this->bufferLength = bufferLength;
   20c82:	22a0      	movs	r2, #160	; 0xa0

SimpleQueue::SimpleQueue(u8* buffer, u32 bufferLength)
{
    this->_numElements = 0;
    this->bufferStart = buffer;
    this->bufferEnd = buffer + bufferLength;
   20c84:	33a4      	adds	r3, #164	; 0xa4
//TODO: This queue might hardfault because of unaligned memory access, must be fixed

SimpleQueue::SimpleQueue(u8* buffer, u32 bufferLength)
{
    this->_numElements = 0;
    this->bufferStart = buffer;
   20c86:	6006      	str	r6, [r0, #0]
    this->bufferEnd = buffer + bufferLength;
   20c88:	6043      	str	r3, [r0, #4]
    this->bufferLength = bufferLength;
   20c8a:	8102      	strh	r2, [r0, #8]

//TODO: This queue might hardfault because of unaligned memory access, must be fixed

SimpleQueue::SimpleQueue(u8* buffer, u32 bufferLength)
{
    this->_numElements = 0;
   20c8c:	8284      	strh	r4, [r0, #20]
    this->bufferStart = buffer;
    this->bufferEnd = buffer + bufferLength;
    this->bufferLength = bufferLength;

    this->readPointer = this->bufferStart;
   20c8e:	60c6      	str	r6, [r0, #12]
    this->writePointer = this->bufferStart;
   20c90:	6106      	str	r6, [r0, #16]
   20c92:	6018      	str	r0, [r3, #0]

/**@brief Function for initializing the command queue.
 */
static void cmd_queue_init(void)
{
    m_cmd_queue.rp    = 0;
   20c94:	4b49      	ldr	r3, [pc, #292]	; (20dbc <_ZN7Storage11getInstanceEv+0x158>)


    ((u32*)writePointer)[0] = 0;
   20c96:	606c      	str	r4, [r5, #4]
   20c98:	701c      	strb	r4, [r3, #0]

	//Initialize pstorage library
	pstorage_module_param_t param;
	u8 num_blocks = STORAGE_BLOCK_NUMBER;

	bufferedOperationInProgress = false;
   20c9a:	35ff      	adds	r5, #255	; 0xff
    m_cmd_queue.count = 0;
   20c9c:	705c      	strb	r4, [r3, #1]
   20c9e:	4a48      	ldr	r2, [pc, #288]	; (20dc0 <_ZN7Storage11getInstanceEv+0x15c>)
   20ca0:	4b48      	ldr	r3, [pc, #288]	; (20dc4 <_ZN7Storage11getInstanceEv+0x160>)
   20ca2:	706c      	strb	r4, [r5, #1]
 * @param[in] index Index of the element to be initialized.
 */
static void cmd_queue_element_init(uint32_t index)
{
    // Internal function and checks on range of index can be avoided.
    m_cmd_queue.cmd[index].op_code                = INVALID_OPCODE;
   20ca4:	2400      	movs	r4, #0
    m_cmd_queue.cmd[index].size                   = 0;
    m_cmd_queue.cmd[index].storage_addr.module_id = PSTORAGE_NUM_OF_PAGES;
   20ca6:	2101      	movs	r1, #1
 * @param[in] index Index of the element to be initialized.
 */
static void cmd_queue_element_init(uint32_t index)
{
    // Internal function and checks on range of index can be avoided.
    m_cmd_queue.cmd[index].op_code                = INVALID_OPCODE;
   20ca8:	701c      	strb	r4, [r3, #0]
    m_cmd_queue.cmd[index].size                   = 0;
   20caa:	805c      	strh	r4, [r3, #2]
    m_cmd_queue.cmd[index].storage_addr.module_id = PSTORAGE_NUM_OF_PAGES;
   20cac:	6099      	str	r1, [r3, #8]
    m_cmd_queue.cmd[index].storage_addr.block_id  = 0;
   20cae:	60dc      	str	r4, [r3, #12]
    m_cmd_queue.cmd[index].p_data_addr            = NULL;
   20cb0:	611c      	str	r4, [r3, #16]
    m_cmd_queue.cmd[index].offset                 = 0;
   20cb2:	809c      	strh	r4, [r3, #4]
   20cb4:	3314      	adds	r3, #20
static void cmd_queue_init(void)
{
    m_cmd_queue.rp    = 0;
    m_cmd_queue.count = 0;

    for (uint32_t cmd_index = 0; cmd_index < PSTORAGE_CMD_QUEUE_SIZE; ++cmd_index)
   20cb6:	4293      	cmp	r3, r2
   20cb8:	d1f4      	bne.n	20ca4 <_ZN7Storage11getInstanceEv+0x40>
   20cba:	2680      	movs	r6, #128	; 0x80

uint32_t pstorage_init(void)
{
    cmd_queue_init();

    m_next_app_instance = 0;
   20cbc:	4b42      	ldr	r3, [pc, #264]	; (20dc8 <_ZN7Storage11getInstanceEv+0x164>)
   20cbe:	0576      	lsls	r6, r6, #21
   20cc0:	801c      	strh	r4, [r3, #0]
    m_next_page_addr    = PSTORAGE_DATA_START_ADDR;
   20cc2:	f7fb ffbb 	bl	1cc3c <pstorage_flash_page_end.lto_priv.133>
   20cc6:	6933      	ldr	r3, [r6, #16]
   20cc8:	3802      	subs	r0, #2
   20cca:	b29b      	uxth	r3, r3
   20ccc:	4343      	muls	r3, r0
   20cce:	1c1f      	adds	r7, r3, #0

    m_state                     = STATE_IDLE;
    m_num_of_command_retries    = 0;
    m_flags                     = 0;
    m_num_of_bytes_written      = 0;
    m_flags                    |= MASK_MODULE_INITIALIZED;
   20cd0:	2204      	movs	r2, #4
uint32_t pstorage_init(void)
{
    cmd_queue_init();

    m_next_app_instance = 0;
    m_next_page_addr    = PSTORAGE_DATA_START_ADDR;
   20cd2:	4b3e      	ldr	r3, [pc, #248]	; (20dcc <_ZN7Storage11getInstanceEv+0x168>)
    m_current_page_id   = 0;
    
    for (uint32_t index = 0; index < PSTORAGE_NUM_OF_PAGES; index++)
    {
        m_app_table[index].cb           = NULL;
   20cd4:	4d3e      	ldr	r5, [pc, #248]	; (20dd0 <_ZN7Storage11getInstanceEv+0x16c>)
uint32_t pstorage_init(void)
{
    cmd_queue_init();

    m_next_app_instance = 0;
    m_next_page_addr    = PSTORAGE_DATA_START_ADDR;
   20cd6:	601f      	str	r7, [r3, #0]
    m_current_page_id   = 0;
   20cd8:	4b3e      	ldr	r3, [pc, #248]	; (20dd4 <_ZN7Storage11getInstanceEv+0x170>)
    
    for (uint32_t index = 0; index < PSTORAGE_NUM_OF_PAGES; index++)
    {
        m_app_table[index].cb           = NULL;
   20cda:	602c      	str	r4, [r5, #0]
{
    cmd_queue_init();

    m_next_app_instance = 0;
    m_next_page_addr    = PSTORAGE_DATA_START_ADDR;
    m_current_page_id   = 0;
   20cdc:	601c      	str	r4, [r3, #0]

#ifdef PSTORAGE_RAW_MODE_ENABLE
    m_raw_app_table.cb           = NULL;
#endif //PSTORAGE_RAW_MODE_ENABLE

    m_state                     = STATE_IDLE;
   20cde:	4b3e      	ldr	r3, [pc, #248]	; (20dd8 <_ZN7Storage11getInstanceEv+0x174>)
    m_current_page_id   = 0;
    
    for (uint32_t index = 0; index < PSTORAGE_NUM_OF_PAGES; index++)
    {
        m_app_table[index].cb           = NULL;
        m_app_table[index].block_size   = 0;
   20ce0:	812c      	strh	r4, [r5, #8]

#ifdef PSTORAGE_RAW_MODE_ENABLE
    m_raw_app_table.cb           = NULL;
#endif //PSTORAGE_RAW_MODE_ENABLE

    m_state                     = STATE_IDLE;
   20ce2:	701c      	strb	r4, [r3, #0]
    m_num_of_command_retries    = 0;
   20ce4:	4b3d      	ldr	r3, [pc, #244]	; (20ddc <_ZN7Storage11getInstanceEv+0x178>)
    
    for (uint32_t index = 0; index < PSTORAGE_NUM_OF_PAGES; index++)
    {
        m_app_table[index].cb           = NULL;
        m_app_table[index].block_size   = 0;
        m_app_table[index].block_count  = 0;
   20ce6:	816c      	strh	r4, [r5, #10]
#ifdef PSTORAGE_RAW_MODE_ENABLE
    m_raw_app_table.cb           = NULL;
#endif //PSTORAGE_RAW_MODE_ENABLE

    m_state                     = STATE_IDLE;
    m_num_of_command_retries    = 0;
   20ce8:	601c      	str	r4, [r3, #0]
    m_flags                     = 0;
    m_num_of_bytes_written      = 0;
   20cea:	4b3d      	ldr	r3, [pc, #244]	; (20de0 <_ZN7Storage11getInstanceEv+0x17c>)
   20cec:	601c      	str	r4, [r3, #0]
    m_flags                    |= MASK_MODULE_INITIALIZED;
   20cee:	4b3d      	ldr	r3, [pc, #244]	; (20de4 <_ZN7Storage11getInstanceEv+0x180>)
   20cf0:	601a      	str	r2, [r3, #0]
   20cf2:	6933      	ldr	r3, [r6, #16]
{
    VERIFY_MODULE_INITIALIZED();
    NULL_PARAM_CHECK(p_module_param);
    NULL_PARAM_CHECK(p_block_id);
    NULL_PARAM_CHECK(p_module_param->cb);
    BLOCK_SIZE_CHECK(p_module_param->block_size);    
   20cf4:	b29b      	uxth	r3, r3
   20cf6:	2b7f      	cmp	r3, #127	; 0x7f
   20cf8:	d928      	bls.n	20d4c <_ZN7Storage11getInstanceEv+0xe8>
    BLOCK_COUNT_CHECK(p_module_param->block_count, p_module_param->block_size);
   20cfa:	f7fb ff9f 	bl	1cc3c <pstorage_flash_page_end.lto_priv.133>
   20cfe:	6933      	ldr	r3, [r6, #16]
   20d00:	3801      	subs	r0, #1
   20d02:	b29b      	uxth	r3, r3
   20d04:	4358      	muls	r0, r3
   20d06:	2380      	movs	r3, #128	; 0x80
   20d08:	009b      	lsls	r3, r3, #2
   20d0a:	18fb      	adds	r3, r7, r3
   20d0c:	4283      	cmp	r3, r0
   20d0e:	d81d      	bhi.n	20d4c <_ZN7Storage11getInstanceEv+0xe8>
    if (m_next_app_instance == PSTORAGE_NUM_OF_PAGES)
    {
        return NRF_ERROR_NO_MEM;
    }

    p_block_id->module_id = m_next_app_instance;
   20d10:	4b28      	ldr	r3, [pc, #160]	; (20db4 <_ZN7Storage11getInstanceEv+0x150>)
    p_block_id->block_id  = m_next_page_addr;

    m_app_table[m_next_app_instance].base_id     = p_block_id->block_id;
   20d12:	606f      	str	r7, [r5, #4]
    if (m_next_app_instance == PSTORAGE_NUM_OF_PAGES)
    {
        return NRF_ERROR_NO_MEM;
    }

    p_block_id->module_id = m_next_app_instance;
   20d14:	1c1a      	adds	r2, r3, #0
    p_block_id->block_id  = m_next_page_addr;
   20d16:	33ac      	adds	r3, #172	; 0xac
   20d18:	601f      	str	r7, [r3, #0]

    m_app_table[m_next_app_instance].base_id     = p_block_id->block_id;
    m_app_table[m_next_app_instance].cb          = p_module_param->cb;
   20d1a:	4b33      	ldr	r3, [pc, #204]	; (20de8 <_ZN7Storage11getInstanceEv+0x184>)
    if (m_next_app_instance == PSTORAGE_NUM_OF_PAGES)
    {
        return NRF_ERROR_NO_MEM;
    }

    p_block_id->module_id = m_next_app_instance;
   20d1c:	32a8      	adds	r2, #168	; 0xa8
    p_block_id->block_id  = m_next_page_addr;

    m_app_table[m_next_app_instance].base_id     = p_block_id->block_id;
    m_app_table[m_next_app_instance].cb          = p_module_param->cb;
   20d1e:	602b      	str	r3, [r5, #0]
    m_app_table[m_next_app_instance].block_size  = p_module_param->block_size;
   20d20:	2380      	movs	r3, #128	; 0x80
    if (m_next_app_instance == PSTORAGE_NUM_OF_PAGES)
    {
        return NRF_ERROR_NO_MEM;
    }

    p_block_id->module_id = m_next_app_instance;
   20d22:	6014      	str	r4, [r2, #0]
   20d24:	6930      	ldr	r0, [r6, #16]
    p_block_id->block_id  = m_next_page_addr;

    m_app_table[m_next_app_instance].base_id     = p_block_id->block_id;
    m_app_table[m_next_app_instance].cb          = p_module_param->cb;
    m_app_table[m_next_app_instance].block_size  = p_module_param->block_size;
   20d26:	812b      	strh	r3, [r5, #8]
    m_app_table[m_next_app_instance].block_count = p_module_param->block_count;
   20d28:	3b7c      	subs	r3, #124	; 0x7c
   20d2a:	6931      	ldr	r1, [r6, #16]
   20d2c:	816b      	strh	r3, [r5, #10]

    // Calculate number of flash pages allocated for the device and adjust next free page address.
    /*lint -save -e666 */
    const uint32_t page_count = CEIL_DIV((p_module_param->block_size * p_module_param->block_count), 
   20d2e:	4b2f      	ldr	r3, [pc, #188]	; (20dec <_ZN7Storage11getInstanceEv+0x188>)
   20d30:	b280      	uxth	r0, r0
   20d32:	18c0      	adds	r0, r0, r3
   20d34:	b289      	uxth	r1, r1
   20d36:	f001 fa2f 	bl	22198 <__aeabi_idiv>
   20d3a:	6934      	ldr	r4, [r6, #16]
                                         PSTORAGE_FLASH_PAGE_SIZE);
    /*lint -restore */
    m_next_page_addr         += page_count * PSTORAGE_FLASH_PAGE_SIZE;
   20d3c:	4b23      	ldr	r3, [pc, #140]	; (20dcc <_ZN7Storage11getInstanceEv+0x168>)
   20d3e:	b2a4      	uxth	r4, r4
   20d40:	4360      	muls	r0, r4
   20d42:	1838      	adds	r0, r7, r0
   20d44:	6018      	str	r0, [r3, #0]
    
    ++m_next_app_instance;
   20d46:	2301      	movs	r3, #1
   20d48:	4a1f      	ldr	r2, [pc, #124]	; (20dc8 <_ZN7Storage11getInstanceEv+0x164>)
   20d4a:	8013      	strh	r3, [r2, #0]
                                       pstorage_size_t     block_num,
                                       pstorage_handle_t * p_block_id)
{
    pstorage_handle_t temp_id;

    VERIFY_MODULE_INITIALIZED();
   20d4c:	4b25      	ldr	r3, [pc, #148]	; (20de4 <_ZN7Storage11getInstanceEv+0x180>)
    MODULE_ID_RANGE_CHECK(p_base_id);

    temp_id           = (*p_base_id);
    temp_id.block_id += (block_num * MODULE_BLOCK_SIZE(p_base_id));

    BLOCK_ID_RANGE_CHECK(&temp_id);
   20d4e:	2000      	movs	r0, #0
                                       pstorage_size_t     block_num,
                                       pstorage_handle_t * p_block_id)
{
    pstorage_handle_t temp_id;

    VERIFY_MODULE_INITIALIZED();
   20d50:	681c      	ldr	r4, [r3, #0]
   20d52:	2304      	movs	r3, #4
   20d54:	401c      	ands	r4, r3
    NULL_PARAM_CHECK(p_base_id);
    NULL_PARAM_CHECK(p_block_id);
    MODULE_ID_RANGE_CHECK(p_base_id);
   20d56:	4b1e      	ldr	r3, [pc, #120]	; (20dd0 <_ZN7Storage11getInstanceEv+0x16c>)
   20d58:	891e      	ldrh	r6, [r3, #8]
   20d5a:	895d      	ldrh	r5, [r3, #10]
   20d5c:	681a      	ldr	r2, [r3, #0]

    temp_id           = (*p_base_id);
    temp_id.block_id += (block_num * MODULE_BLOCK_SIZE(p_base_id));

    BLOCK_ID_RANGE_CHECK(&temp_id);
   20d5e:	4375      	muls	r5, r6
   20d60:	685b      	ldr	r3, [r3, #4]
    pstorage_handle_t temp_id;

    VERIFY_MODULE_INITIALIZED();
    NULL_PARAM_CHECK(p_base_id);
    NULL_PARAM_CHECK(p_block_id);
    MODULE_ID_RANGE_CHECK(p_base_id);
   20d62:	4694      	mov	ip, r2
   20d64:	4a13      	ldr	r2, [pc, #76]	; (20db4 <_ZN7Storage11getInstanceEv+0x150>)

    temp_id           = (*p_base_id);
    temp_id.block_id += (block_num * MODULE_BLOCK_SIZE(p_base_id));

    BLOCK_ID_RANGE_CHECK(&temp_id);
   20d66:	18ed      	adds	r5, r5, r3
   20d68:	1c13      	adds	r3, r2, #0
   20d6a:	32d0      	adds	r2, #208	; 0xd0
   20d6c:	33b0      	adds	r3, #176	; 0xb0
   20d6e:	9201      	str	r2, [sp, #4]
                                       pstorage_size_t     block_num,
                                       pstorage_handle_t * p_block_id)
{
    pstorage_handle_t temp_id;

    VERIFY_MODULE_INITIALIZED();
   20d70:	2c00      	cmp	r4, #0
   20d72:	d00f      	beq.n	20d94 <_ZN7Storage11getInstanceEv+0x130>
    NULL_PARAM_CHECK(p_base_id);
    NULL_PARAM_CHECK(p_block_id);
    MODULE_ID_RANGE_CHECK(p_base_id);
   20d74:	490f      	ldr	r1, [pc, #60]	; (20db4 <_ZN7Storage11getInstanceEv+0x150>)
   20d76:	1c0f      	adds	r7, r1, #0
   20d78:	37a8      	adds	r7, #168	; 0xa8
   20d7a:	683f      	ldr	r7, [r7, #0]
   20d7c:	2f00      	cmp	r7, #0
   20d7e:	d109      	bne.n	20d94 <_ZN7Storage11getInstanceEv+0x130>
   20d80:	4662      	mov	r2, ip
   20d82:	2a00      	cmp	r2, #0
   20d84:	d006      	beq.n	20d94 <_ZN7Storage11getInstanceEv+0x130>

    temp_id           = (*p_base_id);
   20d86:	31ac      	adds	r1, #172	; 0xac
    temp_id.block_id += (block_num * MODULE_BLOCK_SIZE(p_base_id));
   20d88:	6809      	ldr	r1, [r1, #0]
   20d8a:	1841      	adds	r1, r0, r1

    BLOCK_ID_RANGE_CHECK(&temp_id);
   20d8c:	42a9      	cmp	r1, r5
   20d8e:	d201      	bcs.n	20d94 <_ZN7Storage11getInstanceEv+0x130>

    (*p_block_id) = temp_id;
   20d90:	601f      	str	r7, [r3, #0]
   20d92:	6059      	str	r1, [r3, #4]

	//Register a number of blocks
	if (pstorage_register(&param, &handle) != NRF_SUCCESS){
//		logt("STORAGE", "Could not register storage");
	}
	for (u32 i = 0; i < num_blocks; ++i){
   20d94:	9a01      	ldr	r2, [sp, #4]
   20d96:	3308      	adds	r3, #8
   20d98:	1980      	adds	r0, r0, r6
   20d9a:	4293      	cmp	r3, r2
   20d9c:	d1e8      	bne.n	20d70 <_ZN7Storage11getInstanceEv+0x10c>
   20d9e:	2201      	movs	r2, #1
   20da0:	4b03      	ldr	r3, [pc, #12]	; (20db0 <_ZN7Storage11getInstanceEv+0x14c>)
   20da2:	4813      	ldr	r0, [pc, #76]	; (20df0 <_ZN7Storage11getInstanceEv+0x18c>)
   20da4:	601a      	str	r2, [r3, #0]
   20da6:	f000 fbc2 	bl	2152e <atexit>
			return instance;
		}
   20daa:	4802      	ldr	r0, [pc, #8]	; (20db4 <_ZN7Storage11getInstanceEv+0x150>)
   20dac:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   20dae:	46c0      	nop			; (mov r8, r8)
   20db0:	200036c4 	.word	0x200036c4
   20db4:	200035b4 	.word	0x200035b4
   20db8:	00022980 	.word	0x00022980
   20dbc:	200033e0 	.word	0x200033e0
   20dc0:	200034ac 	.word	0x200034ac
   20dc4:	200033e4 	.word	0x200033e4
   20dc8:	200035b0 	.word	0x200035b0
   20dcc:	200036bc 	.word	0x200036bc
   20dd0:	20003568 	.word	0x20003568
   20dd4:	200035ac 	.word	0x200035ac
   20dd8:	2000357e 	.word	0x2000357e
   20ddc:	200031d0 	.word	0x200031d0
   20de0:	200035a8 	.word	0x200035a8
   20de4:	2000353c 	.word	0x2000353c
   20de8:	0001f671 	.word	0x0001f671
   20dec:	000001ff 	.word	0x000001ff
   20df0:	00020c1b 	.word	0x00020c1b

00020df4 <sd_app_evt_wait.lto_priv.109>:
 *
 * @post An application interrupt has happened or a interrupt pending flag is set.
 *
 * @retval ::NRF_SUCCESS
 */
SVCALL(SD_APP_EVT_WAIT, uint32_t, sd_app_evt_wait(void));
   20df4:	df48      	svc	72	; 0x48
   20df6:	4770      	bx	lr

00020df8 <sd_power_dcdc_mode_set.lto_priv.122>:
 * @param[in] dcdc_mode The mode of the DCDC, see @ref NRF_POWER_DCDC_MODES.
 *
 * @retval ::NRF_SUCCESS
 * @retval ::NRF_ERROR_INVALID_PARAM The DCDC mode is invalid.
 */
SVCALL(SD_POWER_DCDC_MODE_SET, uint32_t, sd_power_dcdc_mode_set(uint8_t dcdc_mode));
   20df8:	df47      	svc	71	; 0x47
   20dfa:	4770      	bx	lr

00020dfc <sd_power_mode_set.lto_priv.121>:
 * @param[in] power_mode The power mode to use when in CPU sleep, see @ref NRF_POWER_MODES. @sa sd_app_evt_wait
 *
 * @retval ::NRF_SUCCESS The power mode was set.
 * @retval ::NRF_ERROR_SOC_POWER_MODE_UNKNOWN The power mode was unknown.
 */
SVCALL(SD_POWER_MODE_SET, uint32_t, sd_power_mode_set(uint8_t power_mode));
   20dfc:	df3b      	svc	59	; 0x3b
   20dfe:	4770      	bx	lr

00020e00 <sd_ble_evt_get.lto_priv.110>:
 * @retval ::NRF_SUCCESS Event pulled and stored into the supplied buffer.
 * @retval ::NRF_ERROR_INVALID_ADDR Invalid or not sufficiently aligned pointer supplied.
 * @retval ::NRF_ERROR_NOT_FOUND No events ready to be pulled.
 * @retval ::NRF_ERROR_DATA_SIZE Event ready but could not fit into the supplied buffer.
 */
SVCALL(SD_BLE_EVT_GET, uint32_t, sd_ble_evt_get(uint8_t *p_dest, uint16_t *p_len));
   20e00:	df61      	svc	97	; 0x61
   20e02:	4770      	bx	lr

00020e04 <sd_ble_enable.lto_priv.123>:
 *                                    large enough to fit this configuration's memory requirement. Check *p_app_ram_base
 *                                    and set the start address of the application RAM region accordingly.
 * @retval ::NRF_ERROR_CONN_COUNT     The requested number of connections exceeds the maximum supported by the SoftDevice.
 *                                    Please refer to the SoftDevice Specification for more information on role configuration.
 */
SVCALL(SD_BLE_ENABLE, uint32_t, sd_ble_enable(ble_enable_params_t * p_ble_enable_params, uint32_t * p_app_ram_base));
   20e04:	df60      	svc	96	; 0x60
   20e06:	4770      	bx	lr

00020e08 <sd_ble_gap_tx_power_set.lto_priv.120>:
 * @note The -40dBm setting is only available on nRF52 series ICs.
 *
 * @retval ::NRF_SUCCESS Successfully changed the transmit power.
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
 */
SVCALL(SD_BLE_GAP_TX_POWER_SET, uint32_t, sd_ble_gap_tx_power_set(int8_t tx_power));
   20e08:	df77      	svc	119	; 0x77
   20e0a:	4770      	bx	lr

00020e0c <NVIC_SystemReset.lto_priv.72>:
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   20e0c:	f3bf 8f4f 	dsb	sy
   20e10:	4a03      	ldr	r2, [pc, #12]	; (20e20 <NVIC_SystemReset.lto_priv.72+0x14>)
   20e12:	4b04      	ldr	r3, [pc, #16]	; (20e24 <NVIC_SystemReset.lto_priv.72+0x18>)
   20e14:	60da      	str	r2, [r3, #12]
   20e16:	f3bf 8f4f 	dsb	sy
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
   20e1a:	46c0      	nop			; (mov r8, r8)
   20e1c:	e7fd      	b.n	20e1a <NVIC_SystemReset.lto_priv.72+0xe>
   20e1e:	46c0      	nop			; (mov r8, r8)
   20e20:	05fa0004 	.word	0x05fa0004
   20e24:	e000ed00 	.word	0xe000ed00

00020e28 <_ZN4Conf11getInstanceEv>:
#include <Config.h>

//Config.cpp initializes variables defined in Config.h with values from UICR
Conf* Conf::instance;

Conf* Conf::getInstance(){
   20e28:	b5f0      	push	{r4, r5, r6, r7, lr}
	if(!instance){
   20e2a:	4f6d      	ldr	r7, [pc, #436]	; (20fe0 <_ZN4Conf11getInstanceEv+0x1b8>)
#include <Config.h>

//Config.cpp initializes variables defined in Config.h with values from UICR
Conf* Conf::instance;

Conf* Conf::getInstance(){
   20e2c:	b087      	sub	sp, #28
	if(!instance){
   20e2e:	683d      	ldr	r5, [r7, #0]
   20e30:	2d00      	cmp	r5, #0
   20e32:	d000      	beq.n	20e36 <_ZN4Conf11getInstanceEv+0xe>
   20e34:	e0cf      	b.n	20fd6 <_ZN4Conf11getInstanceEv+0x1ae>
		instance = new Conf();
   20e36:	2084      	movs	r0, #132	; 0x84
   20e38:	f000 f9f2 	bl	21220 <_Znwj>

//This class holds the configuration and some bits are changeable at runtime
class Conf
{
	private:
		Conf(){};
   20e3c:	2104      	movs	r1, #4
   20e3e:	2302      	movs	r3, #2
   20e40:	82c1      	strh	r1, [r0, #22]
   20e42:	21fa      	movs	r1, #250	; 0xfa
   20e44:	80c3      	strh	r3, [r0, #6]
   20e46:	334e      	adds	r3, #78	; 0x4e
   20e48:	8103      	strh	r3, [r0, #8]
   20e4a:	8143      	strh	r3, [r0, #10]
   20e4c:	8383      	strh	r3, [r0, #28]
   20e4e:	3b4a      	subs	r3, #74	; 0x4a
   20e50:	8403      	strh	r3, [r0, #32]
   20e52:	2296      	movs	r2, #150	; 0x96
   20e54:	3322      	adds	r3, #34	; 0x22
   20e56:	8483      	strh	r3, [r0, #36]	; 0x24
   20e58:	3b14      	subs	r3, #20
   20e5a:	84c3      	strh	r3, [r0, #38]	; 0x26
   20e5c:	3350      	adds	r3, #80	; 0x50
   20e5e:	8503      	strh	r3, [r0, #40]	; 0x28
   20e60:	0149      	lsls	r1, r1, #5
   20e62:	3b5a      	subs	r3, #90	; 0x5a
   20e64:	8301      	strh	r1, [r0, #24]
   20e66:	8583      	strh	r3, [r0, #44]	; 0x2c
   20e68:	85c3      	strh	r3, [r0, #46]	; 0x2e
   20e6a:	21c8      	movs	r1, #200	; 0xc8
   20e6c:	1c03      	adds	r3, r0, #0
   20e6e:	2601      	movs	r6, #1
   20e70:	1c04      	adds	r4, r0, #0
   20e72:	0092      	lsls	r2, r2, #2
   20e74:	81c2      	strh	r2, [r0, #14]
   20e76:	3ab9      	subs	r2, #185	; 0xb9
   20e78:	3aff      	subs	r2, #255	; 0xff
   20e7a:	8242      	strh	r2, [r0, #18]
   20e7c:	3a80      	subs	r2, #128	; 0x80
   20e7e:	3330      	adds	r3, #48	; 0x30
   20e80:	8282      	strh	r2, [r0, #20]
   20e82:	83c2      	strh	r2, [r0, #30]
   20e84:	00c9      	lsls	r1, r1, #3
   20e86:	3a1d      	subs	r2, #29
   20e88:	8341      	strh	r1, [r0, #26]
   20e8a:	7005      	strb	r5, [r0, #0]
   20e8c:	7045      	strb	r5, [r0, #1]
   20e8e:	7085      	strb	r5, [r0, #2]
   20e90:	70c6      	strb	r6, [r0, #3]
   20e92:	7105      	strb	r5, [r0, #4]
   20e94:	7146      	strb	r6, [r0, #5]
   20e96:	8185      	strh	r5, [r0, #12]
   20e98:	8205      	strh	r5, [r0, #16]
   20e9a:	8446      	strh	r6, [r0, #34]	; 0x22
   20e9c:	8545      	strh	r5, [r0, #42]	; 0x2a
   20e9e:	711a      	strb	r2, [r3, #4]
   20ea0:	1992      	adds	r2, r2, r6
   20ea2:	715a      	strb	r2, [r3, #5]
   20ea4:	32bd      	adds	r2, #189	; 0xbd
   20ea6:	701e      	strb	r6, [r3, #0]
   20ea8:	705e      	strb	r6, [r3, #1]
   20eaa:	709e      	strb	r6, [r3, #2]
   20eac:	70de      	strb	r6, [r3, #3]
   20eae:	719d      	strb	r5, [r3, #6]
   20eb0:	749a      	strb	r2, [r3, #18]
   20eb2:	71de      	strb	r6, [r3, #7]
   20eb4:	3313      	adds	r3, #19
   20eb6:	701d      	strb	r5, [r3, #0]
   20eb8:	9301      	str	r3, [sp, #4]
   20eba:	3311      	adds	r3, #17
   20ebc:	6446      	str	r6, [r0, #68]	; 0x44
   20ebe:	9302      	str	r3, [sp, #8]
   20ec0:	801d      	strh	r5, [r3, #0]
   20ec2:	709d      	strb	r5, [r3, #2]
   20ec4:	3303      	adds	r3, #3
   20ec6:	1c18      	adds	r0, r3, #0
   20ec8:	4946      	ldr	r1, [pc, #280]	; (20fe4 <_ZN4Conf11getInstanceEv+0x1bc>)
   20eca:	3ab1      	subs	r2, #177	; 0xb1
   20ecc:	9303      	str	r3, [sp, #12]
   20ece:	f000 fba1 	bl	21614 <memcpy>
   20ed2:	1c23      	adds	r3, r4, #0
   20ed4:	1c20      	adds	r0, r4, #0
   20ed6:	3368      	adds	r3, #104	; 0x68
   20ed8:	801e      	strh	r6, [r3, #0]
   20eda:	9304      	str	r3, [sp, #16]
   20edc:	4941      	ldr	r1, [pc, #260]	; (20fe4 <_ZN4Conf11getInstanceEv+0x1bc>)
   20ede:	3302      	adds	r3, #2
   20ee0:	9300      	str	r3, [sp, #0]
   20ee2:	801d      	strh	r5, [r3, #0]
   20ee4:	3302      	adds	r3, #2
   20ee6:	701d      	strb	r5, [r3, #0]
   20ee8:	2207      	movs	r2, #7
   20eea:	306d      	adds	r0, #109	; 0x6d
   20eec:	3110      	adds	r1, #16
   20eee:	9305      	str	r3, [sp, #20]
   20ef0:	f000 fb90 	bl	21614 <memcpy>
   20ef4:	1c23      	adds	r3, r4, #0
   20ef6:	2203      	movs	r2, #3
   20ef8:	3374      	adds	r3, #116	; 0x74
   20efa:	805a      	strh	r2, [r3, #2]
   20efc:	322f      	adds	r2, #47	; 0x2f
   20efe:	801d      	strh	r5, [r3, #0]
   20f00:	809a      	strh	r2, [r3, #4]
   20f02:	4b39      	ldr	r3, [pc, #228]	; (20fe8 <_ZN4Conf11getInstanceEv+0x1c0>)
   20f04:	3a2e      	subs	r2, #46	; 0x2e
   20f06:	67e3      	str	r3, [r4, #124]	; 0x7c
   20f08:	1c23      	adds	r3, r4, #0
   20f0a:	3380      	adds	r3, #128	; 0x80
   20f0c:	701a      	strb	r2, [r3, #0]
		 * [11] DEVICE_TYPE, type of device (sink, mobile, etc,..)
		 * [12] SERIAL_NUMBER_INDEX, unique index that represents the serial number
		 */

		//If magic number exists, fill Config with valid data from UICR
		if(NRF_UICR->CUSTOMER[0] == 0xF07700){
   20f0e:	4b37      	ldr	r3, [pc, #220]	; (20fec <_ZN4Conf11getInstanceEv+0x1c4>)
//Config.cpp initializes variables defined in Config.h with values from UICR
Conf* Conf::instance;

Conf* Conf::getInstance(){
	if(!instance){
		instance = new Conf();
   20f10:	603c      	str	r4, [r7, #0]
		 * [11] DEVICE_TYPE, type of device (sink, mobile, etc,..)
		 * [12] SERIAL_NUMBER_INDEX, unique index that represents the serial number
		 */

		//If magic number exists, fill Config with valid data from UICR
		if(NRF_UICR->CUSTOMER[0] == 0xF07700){
   20f12:	6fda      	ldr	r2, [r3, #124]	; 0x7c
   20f14:	4b36      	ldr	r3, [pc, #216]	; (20ff0 <_ZN4Conf11getInstanceEv+0x1c8>)
   20f16:	429a      	cmp	r2, r3
   20f18:	d14a      	bne.n	20fb0 <_ZN4Conf11getInstanceEv+0x188>
			instance->deviceConfigOrigin = deviceConfigOrigins::UICR_CONFIG;
   20f1a:	9b01      	ldr	r3, [sp, #4]
   20f1c:	701e      	strb	r6, [r3, #0]

			if(NRF_UICR->CUSTOMER[1] != EMPTY_WORD) instance->boardType = NRF_UICR->CUSTOMER[1];
   20f1e:	4b35      	ldr	r3, [pc, #212]	; (20ff4 <_ZN4Conf11getInstanceEv+0x1cc>)
   20f20:	6fda      	ldr	r2, [r3, #124]	; 0x7c
   20f22:	3201      	adds	r2, #1
   20f24:	d001      	beq.n	20f2a <_ZN4Conf11getInstanceEv+0x102>
   20f26:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
   20f28:	6463      	str	r3, [r4, #68]	; 0x44
			if(NRF_UICR->CUSTOMER[2] != EMPTY_WORD){
   20f2a:	4933      	ldr	r1, [pc, #204]	; (20ff8 <_ZN4Conf11getInstanceEv+0x1d0>)
   20f2c:	680b      	ldr	r3, [r1, #0]
   20f2e:	3301      	adds	r3, #1
   20f30:	d009      	beq.n	20f46 <_ZN4Conf11getInstanceEv+0x11e>
				memcpy((u8*)instance->serialNumber, (u8*)(NRF_UICR->CUSTOMER + 2), 5);
   20f32:	1c20      	adds	r0, r4, #0
   20f34:	2205      	movs	r2, #5
   20f36:	3048      	adds	r0, #72	; 0x48
   20f38:	f000 fb6c 	bl	21614 <memcpy>
				instance->serialNumber[5] = '\0';
   20f3c:	1c23      	adds	r3, r4, #0
   20f3e:	2200      	movs	r2, #0
   20f40:	334d      	adds	r3, #77	; 0x4d
   20f42:	701a      	strb	r2, [r3, #0]
   20f44:	e001      	b.n	20f4a <_ZN4Conf11getInstanceEv+0x122>
			} else {
				generateRandomSerial();
   20f46:	f7ff fe69 	bl	20c1c <_ZN4Conf20generateRandomSerialEv>
}

//Tests if a memory region in flash storage is empty (0xFF)
bool Conf::isEmpty(u32* mem, u8 numWords){
	for(u8 i=0; i<numWords; i++){
		if(*(mem+i) != 0xFFFFFFFF) return false;
   20f4a:	4b2c      	ldr	r3, [pc, #176]	; (20ffc <_ZN4Conf11getInstanceEv+0x1d4>)
   20f4c:	681b      	ldr	r3, [r3, #0]
   20f4e:	3301      	adds	r3, #1
   20f50:	d13b      	bne.n	20fca <_ZN4Conf11getInstanceEv+0x1a2>
   20f52:	4b2b      	ldr	r3, [pc, #172]	; (21000 <_ZN4Conf11getInstanceEv+0x1d8>)
   20f54:	681b      	ldr	r3, [r3, #0]
   20f56:	3301      	adds	r3, #1
   20f58:	d137      	bne.n	20fca <_ZN4Conf11getInstanceEv+0x1a2>
   20f5a:	4b2a      	ldr	r3, [pc, #168]	; (21004 <_ZN4Conf11getInstanceEv+0x1dc>)
   20f5c:	681b      	ldr	r3, [r3, #0]
   20f5e:	3301      	adds	r3, #1
   20f60:	d133      	bne.n	20fca <_ZN4Conf11getInstanceEv+0x1a2>
   20f62:	4b29      	ldr	r3, [pc, #164]	; (21008 <_ZN4Conf11getInstanceEv+0x1e0>)
   20f64:	681b      	ldr	r3, [r3, #0]
   20f66:	3301      	adds	r3, #1
   20f68:	d12f      	bne.n	20fca <_ZN4Conf11getInstanceEv+0x1a2>
				generateRandomSerial();
			}
			if(!isEmpty((u32*)(NRF_UICR->CUSTOMER + 4), 4)){
				memcpy(&instance->meshNetworkKey, (u8*)(NRF_UICR->CUSTOMER + 4), 16);
			}
			if(NRF_UICR->CUSTOMER[8] != EMPTY_WORD) instance->manufacturerId = (u16)NRF_UICR->CUSTOMER[8];
   20f6a:	4b28      	ldr	r3, [pc, #160]	; (2100c <_ZN4Conf11getInstanceEv+0x1e4>)
   20f6c:	681a      	ldr	r2, [r3, #0]
   20f6e:	3201      	adds	r2, #1
   20f70:	d002      	beq.n	20f78 <_ZN4Conf11getInstanceEv+0x150>
   20f72:	681b      	ldr	r3, [r3, #0]
   20f74:	9a02      	ldr	r2, [sp, #8]
   20f76:	8013      	strh	r3, [r2, #0]
			if(NRF_UICR->CUSTOMER[9] != EMPTY_WORD) instance->meshNetworkIdentifier = (u16)NRF_UICR->CUSTOMER[9];
   20f78:	4b25      	ldr	r3, [pc, #148]	; (21010 <_ZN4Conf11getInstanceEv+0x1e8>)
   20f7a:	681a      	ldr	r2, [r3, #0]
   20f7c:	3201      	adds	r2, #1
   20f7e:	d002      	beq.n	20f86 <_ZN4Conf11getInstanceEv+0x15e>
   20f80:	681b      	ldr	r3, [r3, #0]
   20f82:	9a04      	ldr	r2, [sp, #16]
   20f84:	8013      	strh	r3, [r2, #0]
			if(NRF_UICR->CUSTOMER[10] != EMPTY_WORD) instance->defaultNodeId = (u16)NRF_UICR->CUSTOMER[10];
   20f86:	4b23      	ldr	r3, [pc, #140]	; (21014 <_ZN4Conf11getInstanceEv+0x1ec>)
   20f88:	681a      	ldr	r2, [r3, #0]
   20f8a:	3201      	adds	r2, #1
   20f8c:	d002      	beq.n	20f94 <_ZN4Conf11getInstanceEv+0x16c>
   20f8e:	681b      	ldr	r3, [r3, #0]
   20f90:	9a00      	ldr	r2, [sp, #0]
   20f92:	8013      	strh	r3, [r2, #0]
			if(NRF_UICR->CUSTOMER[11] != EMPTY_WORD) instance->deviceType = (deviceTypes)NRF_UICR->CUSTOMER[11];
   20f94:	4b20      	ldr	r3, [pc, #128]	; (21018 <_ZN4Conf11getInstanceEv+0x1f0>)
   20f96:	681a      	ldr	r2, [r3, #0]
   20f98:	3201      	adds	r2, #1
   20f9a:	d002      	beq.n	20fa2 <_ZN4Conf11getInstanceEv+0x17a>
   20f9c:	681b      	ldr	r3, [r3, #0]
   20f9e:	9a05      	ldr	r2, [sp, #20]
   20fa0:	7013      	strb	r3, [r2, #0]
			if(NRF_UICR->CUSTOMER[12] != EMPTY_WORD) instance->serialNumberIndex = (u32)NRF_UICR->CUSTOMER[12];
   20fa2:	4b1e      	ldr	r3, [pc, #120]	; (2101c <_ZN4Conf11getInstanceEv+0x1f4>)
   20fa4:	681a      	ldr	r2, [r3, #0]
   20fa6:	3201      	adds	r2, #1
   20fa8:	d015      	beq.n	20fd6 <_ZN4Conf11getInstanceEv+0x1ae>
   20faa:	681b      	ldr	r3, [r3, #0]
   20fac:	6523      	str	r3, [r4, #80]	; 0x50
   20fae:	e012      	b.n	20fd6 <_ZN4Conf11getInstanceEv+0x1ae>
		//No device specific config was found, generate random values
		} else {
			instance->deviceConfigOrigin = deviceConfigOrigins::RANDOM_CONFIG;


			instance->defaultNodeId = (nodeID)NRF_FICR->DEVICEID[1] % 15000 + 1;
   20fb0:	2380      	movs	r3, #128	; 0x80
   20fb2:	055b      	lsls	r3, r3, #21
   20fb4:	6e58      	ldr	r0, [r3, #100]	; 0x64
   20fb6:	491a      	ldr	r1, [pc, #104]	; (21020 <_ZN4Conf11getInstanceEv+0x1f8>)
   20fb8:	b280      	uxth	r0, r0
   20fba:	f001 f8e3 	bl	22184 <__aeabi_uidivmod>
   20fbe:	9b00      	ldr	r3, [sp, #0]
   20fc0:	3101      	adds	r1, #1
   20fc2:	8019      	strh	r1, [r3, #0]
			generateRandomSerial();
   20fc4:	f7ff fe2a 	bl	20c1c <_ZN4Conf20generateRandomSerialEv>
   20fc8:	e005      	b.n	20fd6 <_ZN4Conf11getInstanceEv+0x1ae>
				instance->serialNumber[5] = '\0';
			} else {
				generateRandomSerial();
			}
			if(!isEmpty((u32*)(NRF_UICR->CUSTOMER + 4), 4)){
				memcpy(&instance->meshNetworkKey, (u8*)(NRF_UICR->CUSTOMER + 4), 16);
   20fca:	9803      	ldr	r0, [sp, #12]
   20fcc:	490b      	ldr	r1, [pc, #44]	; (20ffc <_ZN4Conf11getInstanceEv+0x1d4>)
   20fce:	2210      	movs	r2, #16
   20fd0:	f000 fb20 	bl	21614 <memcpy>
   20fd4:	e7c9      	b.n	20f6a <_ZN4Conf11getInstanceEv+0x142>
			instance->defaultNodeId = (nodeID)NRF_FICR->DEVICEID[1] % 15000 + 1;
			generateRandomSerial();
		}
	}

	return instance;
   20fd6:	4b02      	ldr	r3, [pc, #8]	; (20fe0 <_ZN4Conf11getInstanceEv+0x1b8>)
   20fd8:	6818      	ldr	r0, [r3, #0]
}
   20fda:	b007      	add	sp, #28
   20fdc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   20fde:	46c0      	nop			; (mov r8, r8)
   20fe0:	200036c0 	.word	0x200036c0
   20fe4:	00022c78 	.word	0x00022c78
   20fe8:	00007562 	.word	0x00007562
   20fec:	10001004 	.word	0x10001004
   20ff0:	00f07700 	.word	0x00f07700
   20ff4:	10001008 	.word	0x10001008
   20ff8:	10001088 	.word	0x10001088
   20ffc:	10001090 	.word	0x10001090
   21000:	10001094 	.word	0x10001094
   21004:	10001098 	.word	0x10001098
   21008:	1000109c 	.word	0x1000109c
   2100c:	100010a0 	.word	0x100010a0
   21010:	100010a4 	.word	0x100010a4
   21014:	100010a8 	.word	0x100010a8
   21018:	100010ac 	.word	0x100010ac
   2101c:	100010b0 	.word	0x100010b0
   21020:	00003a98 	.word	0x00003a98

00021024 <SystemInit>:
}


static bool is_manual_peripheral_setup_needed(void)
{
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x1) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0))
   21024:	4b2d      	ldr	r3, [pc, #180]	; (210dc <SystemInit+0xb8>)
{
    SystemCoreClock = __SYSTEM_CLOCK;
}

void SystemInit(void)
{
   21026:	b510      	push	{r4, lr}
}


static bool is_manual_peripheral_setup_needed(void)
{
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x1) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0))
   21028:	781a      	ldrb	r2, [r3, #0]
   2102a:	2a01      	cmp	r2, #1
   2102c:	d119      	bne.n	21062 <SystemInit+0x3e>
   2102e:	4a2c      	ldr	r2, [pc, #176]	; (210e0 <SystemInit+0xbc>)
   21030:	6812      	ldr	r2, [r2, #0]
   21032:	0712      	lsls	r2, r2, #28
   21034:	d115      	bne.n	21062 <SystemInit+0x3e>
    {
        if ((((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x00) && (((*(uint32_t *)0xF0000FEC) & 0x000000F0) == 0x0))
   21036:	4a2b      	ldr	r2, [pc, #172]	; (210e4 <SystemInit+0xc0>)
   21038:	24e0      	movs	r4, #224	; 0xe0
   2103a:	6811      	ldr	r1, [r2, #0]
   2103c:	22f0      	movs	r2, #240	; 0xf0
   2103e:	1c08      	adds	r0, r1, #0
   21040:	4010      	ands	r0, r2
   21042:	4221      	tst	r1, r4
   21044:	d10b      	bne.n	2105e <SystemInit+0x3a>
   21046:	4928      	ldr	r1, [pc, #160]	; (210e8 <SystemInit+0xc4>)
   21048:	6809      	ldr	r1, [r1, #0]
   2104a:	4211      	tst	r1, r2
   2104c:	d109      	bne.n	21062 <SystemInit+0x3e>
       https://www.nordicsemi.com/. The side effect of executing these instructions in the devices
       that do not need it is that the new peripherals in the second generation devices (LPCOMP for
       example) will not be available. */
    if (is_manual_peripheral_setup_needed())
    {
        *(uint32_t volatile *)0x40000504 = 0xC007FFDF;
   2104e:	4927      	ldr	r1, [pc, #156]	; (210ec <SystemInit+0xc8>)
   21050:	4a27      	ldr	r2, [pc, #156]	; (210f0 <SystemInit+0xcc>)
   21052:	6011      	str	r1, [r2, #0]
        *(uint32_t volatile *)0x40006C18 = 0x00008000;
   21054:	2180      	movs	r1, #128	; 0x80
   21056:	4a27      	ldr	r2, [pc, #156]	; (210f4 <SystemInit+0xd0>)
   21058:	0209      	lsls	r1, r1, #8
   2105a:	6011      	str	r1, [r2, #0]
   2105c:	e001      	b.n	21062 <SystemInit+0x3e>
        }
        if ((((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x10) && (((*(uint32_t *)0xF0000FEC) & 0x000000F0) == 0x0))
        {
            return true;
        }
        if ((((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30) && (((*(uint32_t *)0xF0000FEC) & 0x000000F0) == 0x0))
   2105e:	2830      	cmp	r0, #48	; 0x30
   21060:	d0f1      	beq.n	21046 <SystemInit+0x22>
    return false;
}

static bool is_disabled_in_debug_needed(void)
{
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x1) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0))
   21062:	781a      	ldrb	r2, [r3, #0]
   21064:	2a01      	cmp	r2, #1
   21066:	d10d      	bne.n	21084 <SystemInit+0x60>
   21068:	491d      	ldr	r1, [pc, #116]	; (210e0 <SystemInit+0xbc>)
   2106a:	6809      	ldr	r1, [r1, #0]
   2106c:	0709      	lsls	r1, r1, #28
   2106e:	d109      	bne.n	21084 <SystemInit+0x60>
    {
        if ((((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x40) && (((*(uint32_t *)0xF0000FEC) & 0x000000F0) == 0x0))
   21070:	20f0      	movs	r0, #240	; 0xf0
   21072:	491c      	ldr	r1, [pc, #112]	; (210e4 <SystemInit+0xc0>)
   21074:	6809      	ldr	r1, [r1, #0]
   21076:	4001      	ands	r1, r0
   21078:	2940      	cmp	r1, #64	; 0x40
   2107a:	d103      	bne.n	21084 <SystemInit+0x60>
   2107c:	491a      	ldr	r1, [pc, #104]	; (210e8 <SystemInit+0xc4>)
   2107e:	6809      	ldr	r1, [r1, #0]
   21080:	4201      	tst	r1, r0
   21082:	d023      	beq.n	210cc <SystemInit+0xa8>
    return false;
}

static bool is_peripheral_domain_setup_needed(void)
{
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x1) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0))
   21084:	681b      	ldr	r3, [r3, #0]
   21086:	b2db      	uxtb	r3, r3
   21088:	2b01      	cmp	r3, #1
   2108a:	d125      	bne.n	210d8 <SystemInit+0xb4>
   2108c:	4b14      	ldr	r3, [pc, #80]	; (210e0 <SystemInit+0xbc>)
   2108e:	681b      	ldr	r3, [r3, #0]
   21090:	071b      	lsls	r3, r3, #28
   21092:	d121      	bne.n	210d8 <SystemInit+0xb4>
    {
        if ((((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0xA0) && (((*(uint32_t *)0xF0000FEC) & 0x000000F0) == 0x0))
   21094:	4b13      	ldr	r3, [pc, #76]	; (210e4 <SystemInit+0xc0>)
   21096:	681a      	ldr	r2, [r3, #0]
   21098:	23f0      	movs	r3, #240	; 0xf0
   2109a:	401a      	ands	r2, r3
   2109c:	2aa0      	cmp	r2, #160	; 0xa0
   2109e:	d104      	bne.n	210aa <SystemInit+0x86>
   210a0:	4a11      	ldr	r2, [pc, #68]	; (210e8 <SystemInit+0xc4>)
   210a2:	6812      	ldr	r2, [r2, #0]
    }

    /* Execute the following code to eliminate excessive current in sleep mode with RAM retention in nRF51802 devices,
       as indicated by PAN 76 "System: Excessive current in sleep mode with retention" found at Product Anomaly document
       for your device found at https://www.nordicsemi.com/. */
    if (is_peripheral_domain_setup_needed()){
   210a4:	421a      	tst	r2, r3
   210a6:	d003      	beq.n	210b0 <SystemInit+0x8c>
   210a8:	e016      	b.n	210d8 <SystemInit+0xb4>
    {
        if ((((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0xA0) && (((*(uint32_t *)0xF0000FEC) & 0x000000F0) == 0x0))
        {
            return true;
        }
        if ((((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0xD0) && (((*(uint32_t *)0xF0000FEC) & 0x000000F0) == 0x0))
   210aa:	2ad0      	cmp	r2, #208	; 0xd0
   210ac:	d114      	bne.n	210d8 <SystemInit+0xb4>
   210ae:	e7f7      	b.n	210a0 <SystemInit+0x7c>

    /* Execute the following code to eliminate excessive current in sleep mode with RAM retention in nRF51802 devices,
       as indicated by PAN 76 "System: Excessive current in sleep mode with retention" found at Product Anomaly document
       for your device found at https://www.nordicsemi.com/. */
    if (is_peripheral_domain_setup_needed()){
        if (*(uint32_t volatile *)0x4006EC00 != 1){
   210b0:	4b11      	ldr	r3, [pc, #68]	; (210f8 <SystemInit+0xd4>)
   210b2:	681a      	ldr	r2, [r3, #0]
   210b4:	2a01      	cmp	r2, #1
   210b6:	d103      	bne.n	210c0 <SystemInit+0x9c>
            *(uint32_t volatile *)0x4006EC00 = 0x9375;
            while (*(uint32_t volatile *)0x4006EC00 != 1){
            }
        }
        *(uint32_t volatile *)0x4006EC14 = 0xC0;
   210b8:	22c0      	movs	r2, #192	; 0xc0
   210ba:	4b10      	ldr	r3, [pc, #64]	; (210fc <SystemInit+0xd8>)
   210bc:	601a      	str	r2, [r3, #0]
   210be:	e00b      	b.n	210d8 <SystemInit+0xb4>
    /* Execute the following code to eliminate excessive current in sleep mode with RAM retention in nRF51802 devices,
       as indicated by PAN 76 "System: Excessive current in sleep mode with retention" found at Product Anomaly document
       for your device found at https://www.nordicsemi.com/. */
    if (is_peripheral_domain_setup_needed()){
        if (*(uint32_t volatile *)0x4006EC00 != 1){
            *(uint32_t volatile *)0x4006EC00 = 0x9375;
   210c0:	4a0f      	ldr	r2, [pc, #60]	; (21100 <SystemInit+0xdc>)
   210c2:	601a      	str	r2, [r3, #0]
            while (*(uint32_t volatile *)0x4006EC00 != 1){
   210c4:	681a      	ldr	r2, [r3, #0]
   210c6:	2a01      	cmp	r2, #1
   210c8:	d1fc      	bne.n	210c4 <SystemInit+0xa0>
   210ca:	e7f5      	b.n	210b8 <SystemInit+0x94>
    /* Disable PROTENSET registers under debug, as indicated by PAN 59 "MPU: Reset value of DISABLEINDEBUG
       register is incorrect" found at Product Anomaly document for your device found at
       https://www.nordicsemi.com/. There is no side effect of using these instruction if not needed. */
    if (is_disabled_in_debug_needed())
    {
        NRF_MPU->DISABLEINDEBUG = MPU_DISABLEINDEBUG_DISABLEINDEBUG_Disabled << MPU_DISABLEINDEBUG_DISABLEINDEBUG_Pos;
   210cc:	21c1      	movs	r1, #193	; 0xc1
   210ce:	2080      	movs	r0, #128	; 0x80
   210d0:	00c9      	lsls	r1, r1, #3
   210d2:	05c0      	lsls	r0, r0, #23
   210d4:	5042      	str	r2, [r0, r1]
   210d6:	e7d5      	b.n	21084 <SystemInit+0x60>
            while (*(uint32_t volatile *)0x4006EC00 != 1){
            }
        }
        *(uint32_t volatile *)0x4006EC14 = 0xC0;
    }
}
   210d8:	bd10      	pop	{r4, pc}
   210da:	46c0      	nop			; (mov r8, r8)
   210dc:	f0000fe0 	.word	0xf0000fe0
   210e0:	f0000fe4 	.word	0xf0000fe4
   210e4:	f0000fe8 	.word	0xf0000fe8
   210e8:	f0000fec 	.word	0xf0000fec
   210ec:	c007ffdf 	.word	0xc007ffdf
   210f0:	40000504 	.word	0x40000504
   210f4:	40006c18 	.word	0x40006c18
   210f8:	4006ec00 	.word	0x4006ec00
   210fc:	4006ec14 	.word	0x4006ec14
   21100:	00009375 	.word	0x00009375

00021104 <SWI2_IRQHandler>:
/**@brief   Function for handling the Application's BLE Stack events interrupt.
 *
 * @details This function is called whenever an event is ready to be pulled.
 */
void SOFTDEVICE_EVT_IRQHandler(void)
{
   21104:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (m_evt_schedule_func != NULL)
   21106:	4b27      	ldr	r3, [pc, #156]	; (211a4 <SWI2_IRQHandler+0xa0>)
/**@brief   Function for handling the Application's BLE Stack events interrupt.
 *
 * @details This function is called whenever an event is ready to be pulled.
 */
void SOFTDEVICE_EVT_IRQHandler(void)
{
   21108:	b085      	sub	sp, #20
    if (m_evt_schedule_func != NULL)
   2110a:	681b      	ldr	r3, [r3, #0]
   2110c:	2b00      	cmp	r3, #0
   2110e:	d005      	beq.n	2111c <SWI2_IRQHandler+0x18>
    {
        uint32_t err_code = m_evt_schedule_func();
   21110:	4798      	blx	r3
        APP_ERROR_CHECK(err_code);
   21112:	2800      	cmp	r0, #0
   21114:	d044      	beq.n	211a0 <SWI2_IRQHandler+0x9c>
   21116:	21b3      	movs	r1, #179	; 0xb3
   21118:	0049      	lsls	r1, r1, #1
   2111a:	e019      	b.n	21150 <SWI2_IRQHandler+0x4c>
}


void intern_softdevice_events_execute(void)
{
    if (!m_softdevice_enabled)
   2111c:	4b22      	ldr	r3, [pc, #136]	; (211a8 <SWI2_IRQHandler+0xa4>)
   2111e:	781b      	ldrb	r3, [r3, #0]
   21120:	2b00      	cmp	r3, #0
   21122:	d03d      	beq.n	211a0 <SWI2_IRQHandler+0x9c>
        return;
    }
#if CLOCK_ENABLED
    bool no_more_soc_evts = false;
#else
    bool no_more_soc_evts = (m_sys_evt_handler == NULL);
   21124:	4d21      	ldr	r5, [pc, #132]	; (211ac <SWI2_IRQHandler+0xa8>)
   21126:	682b      	ldr	r3, [r5, #0]
   21128:	425a      	negs	r2, r3
   2112a:	4153      	adcs	r3, r2
   2112c:	b2de      	uxtb	r6, r3
#endif
#ifdef BLE_STACK_SUPPORT_REQD
    bool no_more_ble_evts = (m_ble_evt_handler == NULL);
   2112e:	4b20      	ldr	r3, [pc, #128]	; (211b0 <SWI2_IRQHandler+0xac>)
   21130:	681b      	ldr	r3, [r3, #0]
   21132:	1c1c      	adds	r4, r3, #0
   21134:	9301      	str	r3, [sp, #4]
   21136:	4263      	negs	r3, r4
   21138:	415c      	adcs	r4, r3
   2113a:	b2e4      	uxtb	r4, r4

    for (;;)
    {
        uint32_t err_code;

        if (!no_more_soc_evts)
   2113c:	2e00      	cmp	r6, #0
   2113e:	d12d      	bne.n	2119c <SWI2_IRQHandler+0x98>
        {
            uint32_t evt_id;

            // Pull event from SOC.
            err_code = sd_evt_get(&evt_id);
   21140:	a803      	add	r0, sp, #12
   21142:	f7fa ffd1 	bl	1c0e8 <sd_evt_get.lto_priv.134>

            if (err_code == NRF_ERROR_NOT_FOUND)
   21146:	2805      	cmp	r0, #5
   21148:	d009      	beq.n	2115e <SWI2_IRQHandler+0x5a>
            {
                no_more_soc_evts = true;
            }
            else if (err_code != NRF_SUCCESS)
   2114a:	2800      	cmp	r0, #0
   2114c:	d003      	beq.n	21156 <SWI2_IRQHandler+0x52>
            {
                APP_ERROR_HANDLER(err_code);
   2114e:	2193      	movs	r1, #147	; 0x93
   21150:	4a18      	ldr	r2, [pc, #96]	; (211b4 <SWI2_IRQHandler+0xb0>)
   21152:	f7fc f957 	bl	1d404 <app_error_handler>
                if (m_sys_evt_handler)
                {
                    m_sys_evt_handler(evt_id);
                }
#else
                m_sys_evt_handler(evt_id);
   21156:	9803      	ldr	r0, [sp, #12]
   21158:	682b      	ldr	r3, [r5, #0]
   2115a:	4798      	blx	r3
   2115c:	e000      	b.n	21160 <SWI2_IRQHandler+0x5c>
            // Pull event from SOC.
            err_code = sd_evt_get(&evt_id);

            if (err_code == NRF_ERROR_NOT_FOUND)
            {
                no_more_soc_evts = true;
   2115e:	2601      	movs	r6, #1
            }
        }

#ifdef BLE_STACK_SUPPORT_REQD
        // Fetch BLE Events.
        if (!no_more_ble_evts)
   21160:	2c00      	cmp	r4, #0
   21162:	d118      	bne.n	21196 <SWI2_IRQHandler+0x92>
        {
            // Pull event from stack
            uint16_t evt_len = m_ble_evt_buffer_size;
   21164:	4b14      	ldr	r3, [pc, #80]	; (211b8 <SWI2_IRQHandler+0xb4>)

            err_code = sd_ble_evt_get(mp_ble_evt_buffer, &evt_len);
   21166:	4f15      	ldr	r7, [pc, #84]	; (211bc <SWI2_IRQHandler+0xb8>)
#ifdef BLE_STACK_SUPPORT_REQD
        // Fetch BLE Events.
        if (!no_more_ble_evts)
        {
            // Pull event from stack
            uint16_t evt_len = m_ble_evt_buffer_size;
   21168:	881b      	ldrh	r3, [r3, #0]
   2116a:	a903      	add	r1, sp, #12

            err_code = sd_ble_evt_get(mp_ble_evt_buffer, &evt_len);
   2116c:	6838      	ldr	r0, [r7, #0]
#ifdef BLE_STACK_SUPPORT_REQD
        // Fetch BLE Events.
        if (!no_more_ble_evts)
        {
            // Pull event from stack
            uint16_t evt_len = m_ble_evt_buffer_size;
   2116e:	800b      	strh	r3, [r1, #0]

            err_code = sd_ble_evt_get(mp_ble_evt_buffer, &evt_len);
   21170:	f7fa ffb6 	bl	1c0e0 <sd_ble_evt_get.lto_priv.135>
   21174:	1e04      	subs	r4, r0, #0
            if (err_code == NRF_ERROR_NOT_FOUND)
   21176:	2c05      	cmp	r4, #5
   21178:	d007      	beq.n	2118a <SWI2_IRQHandler+0x86>
            {
                no_more_ble_evts = true;
            }
            else if (err_code != NRF_SUCCESS)
   2117a:	2800      	cmp	r0, #0
   2117c:	d001      	beq.n	21182 <SWI2_IRQHandler+0x7e>
            {
                APP_ERROR_HANDLER(err_code);
   2117e:	21b2      	movs	r1, #178	; 0xb2
   21180:	e7e6      	b.n	21150 <SWI2_IRQHandler+0x4c>
            }
            else
            {
                // Call application's BLE stack event handler.
                m_ble_evt_handler((ble_evt_t *)mp_ble_evt_buffer);
   21182:	6838      	ldr	r0, [r7, #0]
   21184:	9b01      	ldr	r3, [sp, #4]
   21186:	4798      	blx	r3
   21188:	e000      	b.n	2118c <SWI2_IRQHandler+0x88>
            uint16_t evt_len = m_ble_evt_buffer_size;

            err_code = sd_ble_evt_get(mp_ble_evt_buffer, &evt_len);
            if (err_code == NRF_ERROR_NOT_FOUND)
            {
                no_more_ble_evts = true;
   2118a:	2401      	movs	r4, #1
                m_ant_evt_handler(&m_ant_evt_buffer);
            }
        }
#endif

        if (no_more_soc_evts)
   2118c:	2e00      	cmp	r6, #0
   2118e:	d0d5      	beq.n	2113c <SWI2_IRQHandler+0x38>
            {
                break;
            }
#elif defined(BLE_STACK_SUPPORT_REQD)
            // Check if there are any remaining BLE events.
            if (no_more_ble_evts)
   21190:	2c00      	cmp	r4, #0
   21192:	d0d3      	beq.n	2113c <SWI2_IRQHandler+0x38>
   21194:	e004      	b.n	211a0 <SWI2_IRQHandler+0x9c>
                m_ant_evt_handler(&m_ant_evt_buffer);
            }
        }
#endif

        if (no_more_soc_evts)
   21196:	2e00      	cmp	r6, #0
   21198:	d102      	bne.n	211a0 <SWI2_IRQHandler+0x9c>
   2119a:	e7cf      	b.n	2113c <SWI2_IRQHandler+0x38>
            }
        }

#ifdef BLE_STACK_SUPPORT_REQD
        // Fetch BLE Events.
        if (!no_more_ble_evts)
   2119c:	2c00      	cmp	r4, #0
   2119e:	d0e1      	beq.n	21164 <SWI2_IRQHandler+0x60>
    }
    else
    {
        intern_softdevice_events_execute();
    }
}
   211a0:	b005      	add	sp, #20
   211a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   211a4:	20003308 	.word	0x20003308
   211a8:	2000330c 	.word	0x2000330c
   211ac:	20003310 	.word	0x20003310
   211b0:	200036b8 	.word	0x200036b8
   211b4:	00022cae 	.word	0x00022cae
   211b8:	20002fd6 	.word	0x20002fd6
   211bc:	200032b8 	.word	0x200032b8

000211c0 <__gnu_thumb1_case_sqi>:
   211c0:	b402      	push	{r1}
   211c2:	4671      	mov	r1, lr
   211c4:	0849      	lsrs	r1, r1, #1
   211c6:	0049      	lsls	r1, r1, #1
   211c8:	5609      	ldrsb	r1, [r1, r0]
   211ca:	0049      	lsls	r1, r1, #1
   211cc:	448e      	add	lr, r1
   211ce:	bc02      	pop	{r1}
   211d0:	4770      	bx	lr
   211d2:	46c0      	nop			; (mov r8, r8)

000211d4 <Reset_Handler>:
    .align 1
    .globl Reset_Handler
    .type Reset_Handler, %function
Reset_Handler:

    MOVS    R1, #NRF_POWER_RAMONx_RAMxON_ONMODE_Msk
   211d4:	2103      	movs	r1, #3
    
    LDR     R0, =NRF_POWER_RAMON_ADDRESS
   211d6:	480a      	ldr	r0, [pc, #40]	; (21200 <Reset_Handler+0x2c>)
    LDR     R2, [R0]
   211d8:	6802      	ldr	r2, [r0, #0]
    ORRS    R2, R1
   211da:	430a      	orrs	r2, r1
    STR     R2, [R0]
   211dc:	6002      	str	r2, [r0, #0]

    LDR     R0, =NRF_POWER_RAMONB_ADDRESS
   211de:	4809      	ldr	r0, [pc, #36]	; (21204 <Reset_Handler+0x30>)
    LDR     R2, [R0]
   211e0:	6802      	ldr	r2, [r0, #0]
    ORRS    R2, R1
   211e2:	430a      	orrs	r2, r1
    STR     R2, [R0]
   211e4:	6002      	str	r2, [r0, #0]
 *      __bss_start__: VMA of end of the section to copy to. Normally __data_end__ is used, but by using __bss_start__ 
 *                    the user can add their own initialized data section before BSS section with the INTERT AFTER command. 
 *
 * All addresses must be aligned to 4 bytes boundary.
 */
    ldr r1, =__etext
   211e6:	4908      	ldr	r1, [pc, #32]	; (21208 <Reset_Handler+0x34>)
    ldr r2, =__data_start__
   211e8:	4a08      	ldr	r2, [pc, #32]	; (2120c <Reset_Handler+0x38>)
    ldr r3, =__bss_start__
   211ea:	4b09      	ldr	r3, [pc, #36]	; (21210 <Reset_Handler+0x3c>)

    subs r3, r2
   211ec:	1a9b      	subs	r3, r3, r2
    ble .L_loop1_done
   211ee:	dd03      	ble.n	211f8 <Reset_Handler+0x24>

.L_loop1:
    subs r3, #4
   211f0:	3b04      	subs	r3, #4
    ldr r0, [r1,r3]
   211f2:	58c8      	ldr	r0, [r1, r3]
    str r0, [r2,r3]
   211f4:	50d0      	str	r0, [r2, r3]
    bgt .L_loop1
   211f6:	dcfb      	bgt.n	211f0 <Reset_Handler+0x1c>
    
.L_loop3_done:
#endif /* __STARTUP_CLEAR_BSS */
 
/* Execute SystemInit function. */
    bl SystemInit
   211f8:	f7ff ff14 	bl	21024 <SystemInit>
 * If those libraries are not accessible, define __START as your entry point. 
 */
#ifndef __START
#define __START _start
#endif
    bl __START    
   211fc:	f7fa f940 	bl	1b480 <_mainCRTStartup>
    .type Reset_Handler, %function
Reset_Handler:

    MOVS    R1, #NRF_POWER_RAMONx_RAMxON_ONMODE_Msk
    
    LDR     R0, =NRF_POWER_RAMON_ADDRESS
   21200:	40000524 	.word	0x40000524
    LDR     R2, [R0]
    ORRS    R2, R1
    STR     R2, [R0]

    LDR     R0, =NRF_POWER_RAMONB_ADDRESS
   21204:	40000554 	.word	0x40000554
 *      __bss_start__: VMA of end of the section to copy to. Normally __data_end__ is used, but by using __bss_start__ 
 *                    the user can add their own initialized data section before BSS section with the INTERT AFTER command. 
 *
 * All addresses must be aligned to 4 bytes boundary.
 */
    ldr r1, =__etext
   21208:	00022f68 	.word	0x00022f68
    ldr r2, =__data_start__
   2120c:	20002e80 	.word	0x20002e80
    ldr r3, =__bss_start__
   21210:	20002ef8 	.word	0x20002ef8

00021214 <NMI_Handler>:
/* Dummy Exception Handlers (infinite loops which can be modified) */

    .weak   NMI_Handler
    .type   NMI_Handler, %function
NMI_Handler:
    b       .
   21214:	e7fe      	b.n	21214 <NMI_Handler>


    .weak   HardFault_Handler
    .type   HardFault_Handler, %function
HardFault_Handler:
    b       .
   21216:	e7fe      	b.n	21216 <NMI_Handler+0x2>

00021218 <SVC_Handler>:


    .weak   SVC_Handler
    .type   SVC_Handler, %function
SVC_Handler:
    b       .
   21218:	e7fe      	b.n	21218 <SVC_Handler>

0002121a <PendSV_Handler>:


    .weak   PendSV_Handler
    .type   PendSV_Handler, %function
PendSV_Handler:
    b       .
   2121a:	e7fe      	b.n	2121a <PendSV_Handler>

0002121c <SysTick_Handler>:


    .weak   SysTick_Handler
    .type   SysTick_Handler, %function
SysTick_Handler:
    b       .
   2121c:	e7fe      	b.n	2121c <SysTick_Handler>

0002121e <Default_Handler>:
/* IRQ Handlers */

    .globl  Default_Handler
    .type   Default_Handler, %function
Default_Handler:
    b       .
   2121e:	e7fe      	b.n	2121e <Default_Handler>

00021220 <_Znwj>:
   21220:	b510      	push	{r4, lr}
   21222:	1e04      	subs	r4, r0, #0
   21224:	d102      	bne.n	2122c <_Znwj+0xc>
   21226:	3401      	adds	r4, #1
   21228:	e000      	b.n	2122c <_Znwj+0xc>
   2122a:	4780      	blx	r0
   2122c:	1c20      	adds	r0, r4, #0
   2122e:	f000 f9c3 	bl	215b8 <malloc>
   21232:	2800      	cmp	r0, #0
   21234:	d105      	bne.n	21242 <_Znwj+0x22>
   21236:	f000 f809 	bl	2124c <_ZSt15get_new_handlerv>
   2123a:	2800      	cmp	r0, #0
   2123c:	d1f5      	bne.n	2122a <_Znwj+0xa>
   2123e:	f000 f96f 	bl	21520 <abort>
   21242:	bd10      	pop	{r4, pc}

00021244 <_ZdlPv>:
   21244:	b508      	push	{r3, lr}
   21246:	f000 f9c1 	bl	215cc <free>
   2124a:	bd08      	pop	{r3, pc}

0002124c <_ZSt15get_new_handlerv>:
   2124c:	4b01      	ldr	r3, [pc, #4]	; (21254 <_ZSt15get_new_handlerv+0x8>)
   2124e:	6818      	ldr	r0, [r3, #0]
   21250:	4770      	bx	lr
   21252:	46c0      	nop			; (mov r8, r8)
   21254:	200036c8 	.word	0x200036c8

00021258 <_ZSt19__throw_logic_errorPKc>:
   21258:	b508      	push	{r3, lr}
   2125a:	f000 f961 	bl	21520 <abort>

0002125e <_ZSt20__throw_length_errorPKc>:
   2125e:	b508      	push	{r3, lr}
   21260:	f000 f95e 	bl	21520 <abort>

00021264 <_ZNSs7_M_copyEPcPKcj>:
   21264:	b508      	push	{r3, lr}
   21266:	2a01      	cmp	r2, #1
   21268:	d102      	bne.n	21270 <_ZNSs7_M_copyEPcPKcj+0xc>
   2126a:	780b      	ldrb	r3, [r1, #0]
   2126c:	7003      	strb	r3, [r0, #0]
   2126e:	e001      	b.n	21274 <_ZNSs7_M_copyEPcPKcj+0x10>
   21270:	f000 f9d0 	bl	21614 <memcpy>
   21274:	bd08      	pop	{r3, pc}

00021276 <_ZNSs13_S_copy_charsEPcPKcS1_>:
   21276:	b508      	push	{r3, lr}
   21278:	1a52      	subs	r2, r2, r1
   2127a:	f7ff fff3 	bl	21264 <_ZNSs7_M_copyEPcPKcj>
   2127e:	bd08      	pop	{r3, pc}

00021280 <_ZNSs4_Rep26_M_set_length_and_sharableEj>:
   21280:	4b04      	ldr	r3, [pc, #16]	; (21294 <_ZNSs4_Rep26_M_set_length_and_sharableEj+0x14>)
   21282:	4298      	cmp	r0, r3
   21284:	d004      	beq.n	21290 <_ZNSs4_Rep26_M_set_length_and_sharableEj+0x10>
   21286:	2300      	movs	r3, #0
   21288:	6001      	str	r1, [r0, #0]
   2128a:	1841      	adds	r1, r0, r1
   2128c:	6083      	str	r3, [r0, #8]
   2128e:	730b      	strb	r3, [r1, #12]
   21290:	4770      	bx	lr
   21292:	46c0      	nop			; (mov r8, r8)
   21294:	200036cc 	.word	0x200036cc

00021298 <_ZNSs4_Rep9_S_createEjjRKSaIcE>:
   21298:	4a13      	ldr	r2, [pc, #76]	; (212e8 <_ZNSs4_Rep9_S_createEjjRKSaIcE+0x50>)
   2129a:	b538      	push	{r3, r4, r5, lr}
   2129c:	1e04      	subs	r4, r0, #0
   2129e:	4294      	cmp	r4, r2
   212a0:	d902      	bls.n	212a8 <_ZNSs4_Rep9_S_createEjjRKSaIcE+0x10>
   212a2:	4812      	ldr	r0, [pc, #72]	; (212ec <_ZNSs4_Rep9_S_createEjjRKSaIcE+0x54>)
   212a4:	f7ff ffdb 	bl	2125e <_ZSt20__throw_length_errorPKc>
   212a8:	4288      	cmp	r0, r1
   212aa:	d903      	bls.n	212b4 <_ZNSs4_Rep9_S_createEjjRKSaIcE+0x1c>
   212ac:	004b      	lsls	r3, r1, #1
   212ae:	4298      	cmp	r0, r3
   212b0:	d200      	bcs.n	212b4 <_ZNSs4_Rep9_S_createEjjRKSaIcE+0x1c>
   212b2:	1c1c      	adds	r4, r3, #0
   212b4:	1c23      	adds	r3, r4, #0
   212b6:	1c20      	adds	r0, r4, #0
   212b8:	2580      	movs	r5, #128	; 0x80
   212ba:	331d      	adds	r3, #29
   212bc:	300d      	adds	r0, #13
   212be:	016d      	lsls	r5, r5, #5
   212c0:	42ab      	cmp	r3, r5
   212c2:	d90a      	bls.n	212da <_ZNSs4_Rep9_S_createEjjRKSaIcE+0x42>
   212c4:	428c      	cmp	r4, r1
   212c6:	d908      	bls.n	212da <_ZNSs4_Rep9_S_createEjjRKSaIcE+0x42>
   212c8:	051b      	lsls	r3, r3, #20
   212ca:	1964      	adds	r4, r4, r5
   212cc:	0d1b      	lsrs	r3, r3, #20
   212ce:	1ae4      	subs	r4, r4, r3
   212d0:	4294      	cmp	r4, r2
   212d2:	d900      	bls.n	212d6 <_ZNSs4_Rep9_S_createEjjRKSaIcE+0x3e>
   212d4:	4c04      	ldr	r4, [pc, #16]	; (212e8 <_ZNSs4_Rep9_S_createEjjRKSaIcE+0x50>)
   212d6:	1c20      	adds	r0, r4, #0
   212d8:	300d      	adds	r0, #13
   212da:	f7ff ffa1 	bl	21220 <_Znwj>
   212de:	2300      	movs	r3, #0
   212e0:	6044      	str	r4, [r0, #4]
   212e2:	6083      	str	r3, [r0, #8]
   212e4:	bd38      	pop	{r3, r4, r5, pc}
   212e6:	46c0      	nop			; (mov r8, r8)
   212e8:	3ffffffc 	.word	0x3ffffffc
   212ec:	00022db8 	.word	0x00022db8

000212f0 <_ZNSs4_Rep10_M_disposeERKSaIcE>:
   212f0:	b508      	push	{r3, lr}
   212f2:	4b05      	ldr	r3, [pc, #20]	; (21308 <_ZNSs4_Rep10_M_disposeERKSaIcE+0x18>)
   212f4:	4298      	cmp	r0, r3
   212f6:	d006      	beq.n	21306 <_ZNSs4_Rep10_M_disposeERKSaIcE+0x16>
   212f8:	6883      	ldr	r3, [r0, #8]
   212fa:	1e5a      	subs	r2, r3, #1
   212fc:	6082      	str	r2, [r0, #8]
   212fe:	2b00      	cmp	r3, #0
   21300:	dc01      	bgt.n	21306 <_ZNSs4_Rep10_M_disposeERKSaIcE+0x16>
   21302:	f7ff ff9f 	bl	21244 <_ZdlPv>
   21306:	bd08      	pop	{r3, pc}
   21308:	200036cc 	.word	0x200036cc

0002130c <_ZNSsD1Ev>:
   2130c:	b513      	push	{r0, r1, r4, lr}
   2130e:	1c04      	adds	r4, r0, #0
   21310:	6800      	ldr	r0, [r0, #0]
   21312:	a901      	add	r1, sp, #4
   21314:	380c      	subs	r0, #12
   21316:	f7ff ffeb 	bl	212f0 <_ZNSs4_Rep10_M_disposeERKSaIcE>
   2131a:	1c20      	adds	r0, r4, #0
   2131c:	bd16      	pop	{r1, r2, r4, pc}
	...

00021320 <_ZNSs12_S_constructIPKcEEPcT_S3_RKSaIcESt20forward_iterator_tag>:
   21320:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   21322:	4288      	cmp	r0, r1
   21324:	d101      	bne.n	2132a <_ZNSs12_S_constructIPKcEEPcT_S3_RKSaIcESt20forward_iterator_tag+0xa>
   21326:	4e0f      	ldr	r6, [pc, #60]	; (21364 <_ZNSs12_S_constructIPKcEEPcT_S3_RKSaIcESt20forward_iterator_tag+0x44>)
   21328:	e019      	b.n	2135e <_ZNSs12_S_constructIPKcEEPcT_S3_RKSaIcESt20forward_iterator_tag+0x3e>
   2132a:	1c0c      	adds	r4, r1, #0
   2132c:	1e05      	subs	r5, r0, #0
   2132e:	d104      	bne.n	2133a <_ZNSs12_S_constructIPKcEEPcT_S3_RKSaIcESt20forward_iterator_tag+0x1a>
   21330:	2c00      	cmp	r4, #0
   21332:	d002      	beq.n	2133a <_ZNSs12_S_constructIPKcEEPcT_S3_RKSaIcESt20forward_iterator_tag+0x1a>
   21334:	480c      	ldr	r0, [pc, #48]	; (21368 <_ZNSs12_S_constructIPKcEEPcT_S3_RKSaIcESt20forward_iterator_tag+0x48>)
   21336:	f7ff ff8f 	bl	21258 <_ZSt19__throw_logic_errorPKc>
   2133a:	1b63      	subs	r3, r4, r5
   2133c:	1c18      	adds	r0, r3, #0
   2133e:	2100      	movs	r1, #0
   21340:	9301      	str	r3, [sp, #4]
   21342:	f7ff ffa9 	bl	21298 <_ZNSs4_Rep9_S_createEjjRKSaIcE>
   21346:	1c06      	adds	r6, r0, #0
   21348:	1c07      	adds	r7, r0, #0
   2134a:	360c      	adds	r6, #12
   2134c:	1c30      	adds	r0, r6, #0
   2134e:	1c29      	adds	r1, r5, #0
   21350:	1c22      	adds	r2, r4, #0
   21352:	f7ff ff90 	bl	21276 <_ZNSs13_S_copy_charsEPcPKcS1_>
   21356:	1c38      	adds	r0, r7, #0
   21358:	9901      	ldr	r1, [sp, #4]
   2135a:	f7ff ff91 	bl	21280 <_ZNSs4_Rep26_M_set_length_and_sharableEj>
   2135e:	1c30      	adds	r0, r6, #0
   21360:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   21362:	46c0      	nop			; (mov r8, r8)
   21364:	200036d8 	.word	0x200036d8
   21368:	00022e6b 	.word	0x00022e6b

0002136c <_ZNSsC1EPKcRKSaIcE>:
   2136c:	b570      	push	{r4, r5, r6, lr}
   2136e:	1c05      	adds	r5, r0, #0
   21370:	1c0c      	adds	r4, r1, #0
   21372:	1c16      	adds	r6, r2, #0
   21374:	2900      	cmp	r1, #0
   21376:	d004      	beq.n	21382 <_ZNSsC1EPKcRKSaIcE+0x16>
   21378:	1c08      	adds	r0, r1, #0
   2137a:	f000 fa8d 	bl	21898 <strlen>
   2137e:	1821      	adds	r1, r4, r0
   21380:	e001      	b.n	21386 <_ZNSsC1EPKcRKSaIcE+0x1a>
   21382:	2101      	movs	r1, #1
   21384:	4249      	negs	r1, r1
   21386:	1c32      	adds	r2, r6, #0
   21388:	1c20      	adds	r0, r4, #0
   2138a:	2300      	movs	r3, #0
   2138c:	f7ff ffc8 	bl	21320 <_ZNSs12_S_constructIPKcEEPcT_S3_RKSaIcESt20forward_iterator_tag>
   21390:	6028      	str	r0, [r5, #0]
   21392:	1c28      	adds	r0, r5, #0
   21394:	bd70      	pop	{r4, r5, r6, pc}
	...

00021398 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE>:
   21398:	2301      	movs	r3, #1
   2139a:	4a24      	ldr	r2, [pc, #144]	; (2142c <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x94>)
   2139c:	6811      	ldr	r1, [r2, #0]
   2139e:	4219      	tst	r1, r3
   213a0:	d100      	bne.n	213a4 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xc>
   213a2:	6013      	str	r3, [r2, #0]
   213a4:	4a22      	ldr	r2, [pc, #136]	; (21430 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x98>)
   213a6:	6811      	ldr	r1, [r2, #0]
   213a8:	4219      	tst	r1, r3
   213aa:	d101      	bne.n	213b0 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x18>
   213ac:	2301      	movs	r3, #1
   213ae:	6013      	str	r3, [r2, #0]
   213b0:	2301      	movs	r3, #1
   213b2:	4a20      	ldr	r2, [pc, #128]	; (21434 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x9c>)
   213b4:	6811      	ldr	r1, [r2, #0]
   213b6:	4219      	tst	r1, r3
   213b8:	d100      	bne.n	213bc <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x24>
   213ba:	6013      	str	r3, [r2, #0]
   213bc:	4a1e      	ldr	r2, [pc, #120]	; (21438 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xa0>)
   213be:	6811      	ldr	r1, [r2, #0]
   213c0:	4219      	tst	r1, r3
   213c2:	d101      	bne.n	213c8 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x30>
   213c4:	2301      	movs	r3, #1
   213c6:	6013      	str	r3, [r2, #0]
   213c8:	2301      	movs	r3, #1
   213ca:	4a1c      	ldr	r2, [pc, #112]	; (2143c <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xa4>)
   213cc:	6811      	ldr	r1, [r2, #0]
   213ce:	4219      	tst	r1, r3
   213d0:	d100      	bne.n	213d4 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x3c>
   213d2:	6013      	str	r3, [r2, #0]
   213d4:	4a1a      	ldr	r2, [pc, #104]	; (21440 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xa8>)
   213d6:	6811      	ldr	r1, [r2, #0]
   213d8:	4219      	tst	r1, r3
   213da:	d101      	bne.n	213e0 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x48>
   213dc:	2301      	movs	r3, #1
   213de:	6013      	str	r3, [r2, #0]
   213e0:	2301      	movs	r3, #1
   213e2:	4a18      	ldr	r2, [pc, #96]	; (21444 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xac>)
   213e4:	6811      	ldr	r1, [r2, #0]
   213e6:	4219      	tst	r1, r3
   213e8:	d100      	bne.n	213ec <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x54>
   213ea:	6013      	str	r3, [r2, #0]
   213ec:	4a16      	ldr	r2, [pc, #88]	; (21448 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xb0>)
   213ee:	6811      	ldr	r1, [r2, #0]
   213f0:	4219      	tst	r1, r3
   213f2:	d101      	bne.n	213f8 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x60>
   213f4:	2301      	movs	r3, #1
   213f6:	6013      	str	r3, [r2, #0]
   213f8:	2301      	movs	r3, #1
   213fa:	4a14      	ldr	r2, [pc, #80]	; (2144c <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xb4>)
   213fc:	6811      	ldr	r1, [r2, #0]
   213fe:	4219      	tst	r1, r3
   21400:	d100      	bne.n	21404 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x6c>
   21402:	6013      	str	r3, [r2, #0]
   21404:	4a12      	ldr	r2, [pc, #72]	; (21450 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xb8>)
   21406:	6811      	ldr	r1, [r2, #0]
   21408:	4219      	tst	r1, r3
   2140a:	d101      	bne.n	21410 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x78>
   2140c:	2301      	movs	r3, #1
   2140e:	6013      	str	r3, [r2, #0]
   21410:	2301      	movs	r3, #1
   21412:	4a10      	ldr	r2, [pc, #64]	; (21454 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xbc>)
   21414:	6811      	ldr	r1, [r2, #0]
   21416:	4219      	tst	r1, r3
   21418:	d100      	bne.n	2141c <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x84>
   2141a:	6013      	str	r3, [r2, #0]
   2141c:	4a0e      	ldr	r2, [pc, #56]	; (21458 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xc0>)
   2141e:	6811      	ldr	r1, [r2, #0]
   21420:	4219      	tst	r1, r3
   21422:	d101      	bne.n	21428 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x90>
   21424:	2301      	movs	r3, #1
   21426:	6013      	str	r3, [r2, #0]
   21428:	4770      	bx	lr
   2142a:	46c0      	nop			; (mov r8, r8)
   2142c:	20003708 	.word	0x20003708
   21430:	20003704 	.word	0x20003704
   21434:	20003700 	.word	0x20003700
   21438:	200036fc 	.word	0x200036fc
   2143c:	200036f8 	.word	0x200036f8
   21440:	200036f4 	.word	0x200036f4
   21444:	200036f0 	.word	0x200036f0
   21448:	200036ec 	.word	0x200036ec
   2144c:	200036e8 	.word	0x200036e8
   21450:	200036e4 	.word	0x200036e4
   21454:	200036e0 	.word	0x200036e0
   21458:	200036dc 	.word	0x200036dc

0002145c <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE>:
   2145c:	2301      	movs	r3, #1
   2145e:	4a24      	ldr	r2, [pc, #144]	; (214f0 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x94>)
   21460:	6811      	ldr	r1, [r2, #0]
   21462:	4219      	tst	r1, r3
   21464:	d100      	bne.n	21468 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xc>
   21466:	6013      	str	r3, [r2, #0]
   21468:	4a22      	ldr	r2, [pc, #136]	; (214f4 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x98>)
   2146a:	6811      	ldr	r1, [r2, #0]
   2146c:	4219      	tst	r1, r3
   2146e:	d101      	bne.n	21474 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x18>
   21470:	2301      	movs	r3, #1
   21472:	6013      	str	r3, [r2, #0]
   21474:	2301      	movs	r3, #1
   21476:	4a20      	ldr	r2, [pc, #128]	; (214f8 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x9c>)
   21478:	6811      	ldr	r1, [r2, #0]
   2147a:	4219      	tst	r1, r3
   2147c:	d100      	bne.n	21480 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x24>
   2147e:	6013      	str	r3, [r2, #0]
   21480:	4a1e      	ldr	r2, [pc, #120]	; (214fc <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xa0>)
   21482:	6811      	ldr	r1, [r2, #0]
   21484:	4219      	tst	r1, r3
   21486:	d101      	bne.n	2148c <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x30>
   21488:	2301      	movs	r3, #1
   2148a:	6013      	str	r3, [r2, #0]
   2148c:	2301      	movs	r3, #1
   2148e:	4a1c      	ldr	r2, [pc, #112]	; (21500 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xa4>)
   21490:	6811      	ldr	r1, [r2, #0]
   21492:	4219      	tst	r1, r3
   21494:	d100      	bne.n	21498 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x3c>
   21496:	6013      	str	r3, [r2, #0]
   21498:	4a1a      	ldr	r2, [pc, #104]	; (21504 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xa8>)
   2149a:	6811      	ldr	r1, [r2, #0]
   2149c:	4219      	tst	r1, r3
   2149e:	d101      	bne.n	214a4 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x48>
   214a0:	2301      	movs	r3, #1
   214a2:	6013      	str	r3, [r2, #0]
   214a4:	2301      	movs	r3, #1
   214a6:	4a18      	ldr	r2, [pc, #96]	; (21508 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xac>)
   214a8:	6811      	ldr	r1, [r2, #0]
   214aa:	4219      	tst	r1, r3
   214ac:	d100      	bne.n	214b0 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x54>
   214ae:	6013      	str	r3, [r2, #0]
   214b0:	4a16      	ldr	r2, [pc, #88]	; (2150c <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xb0>)
   214b2:	6811      	ldr	r1, [r2, #0]
   214b4:	4219      	tst	r1, r3
   214b6:	d101      	bne.n	214bc <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x60>
   214b8:	2301      	movs	r3, #1
   214ba:	6013      	str	r3, [r2, #0]
   214bc:	2301      	movs	r3, #1
   214be:	4a14      	ldr	r2, [pc, #80]	; (21510 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xb4>)
   214c0:	6811      	ldr	r1, [r2, #0]
   214c2:	4219      	tst	r1, r3
   214c4:	d100      	bne.n	214c8 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x6c>
   214c6:	6013      	str	r3, [r2, #0]
   214c8:	4a12      	ldr	r2, [pc, #72]	; (21514 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xb8>)
   214ca:	6811      	ldr	r1, [r2, #0]
   214cc:	4219      	tst	r1, r3
   214ce:	d101      	bne.n	214d4 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x78>
   214d0:	2301      	movs	r3, #1
   214d2:	6013      	str	r3, [r2, #0]
   214d4:	2301      	movs	r3, #1
   214d6:	4a10      	ldr	r2, [pc, #64]	; (21518 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xbc>)
   214d8:	6811      	ldr	r1, [r2, #0]
   214da:	4219      	tst	r1, r3
   214dc:	d100      	bne.n	214e0 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x84>
   214de:	6013      	str	r3, [r2, #0]
   214e0:	4a0e      	ldr	r2, [pc, #56]	; (2151c <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xc0>)
   214e2:	6811      	ldr	r1, [r2, #0]
   214e4:	4219      	tst	r1, r3
   214e6:	d101      	bne.n	214ec <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x90>
   214e8:	2301      	movs	r3, #1
   214ea:	6013      	str	r3, [r2, #0]
   214ec:	4770      	bx	lr
   214ee:	46c0      	nop			; (mov r8, r8)
   214f0:	20003738 	.word	0x20003738
   214f4:	20003734 	.word	0x20003734
   214f8:	20003730 	.word	0x20003730
   214fc:	2000372c 	.word	0x2000372c
   21500:	20003728 	.word	0x20003728
   21504:	20003724 	.word	0x20003724
   21508:	20003720 	.word	0x20003720
   2150c:	2000371c 	.word	0x2000371c
   21510:	20003718 	.word	0x20003718
   21514:	20003714 	.word	0x20003714
   21518:	20003710 	.word	0x20003710
   2151c:	2000370c 	.word	0x2000370c

00021520 <abort>:
   21520:	b508      	push	{r3, lr}
   21522:	2006      	movs	r0, #6
   21524:	f000 f976 	bl	21814 <raise>
   21528:	2001      	movs	r0, #1
   2152a:	f001 f993 	bl	22854 <_exit>

0002152e <atexit>:
   2152e:	1c01      	adds	r1, r0, #0
   21530:	2000      	movs	r0, #0
   21532:	b508      	push	{r3, lr}
   21534:	1c02      	adds	r2, r0, #0
   21536:	1c03      	adds	r3, r0, #0
   21538:	f000 f9b6 	bl	218a8 <__register_exitproc>
   2153c:	bd08      	pop	{r3, pc}
	...

00021540 <exit>:
   21540:	4b08      	ldr	r3, [pc, #32]	; (21564 <exit+0x24>)
   21542:	b510      	push	{r4, lr}
   21544:	1c04      	adds	r4, r0, #0
   21546:	2b00      	cmp	r3, #0
   21548:	d002      	beq.n	21550 <exit+0x10>
   2154a:	2100      	movs	r1, #0
   2154c:	f000 fa08 	bl	21960 <__call_exitprocs>
   21550:	4b05      	ldr	r3, [pc, #20]	; (21568 <exit+0x28>)
   21552:	6818      	ldr	r0, [r3, #0]
   21554:	6a83      	ldr	r3, [r0, #40]	; 0x28
   21556:	2b00      	cmp	r3, #0
   21558:	d000      	beq.n	2155c <exit+0x1c>
   2155a:	4798      	blx	r3
   2155c:	1c20      	adds	r0, r4, #0
   2155e:	f001 f979 	bl	22854 <_exit>
   21562:	46c0      	nop			; (mov r8, r8)
   21564:	00021961 	.word	0x00021961
   21568:	00022ec8 	.word	0x00022ec8

0002156c <__libc_init_array>:
   2156c:	4b0e      	ldr	r3, [pc, #56]	; (215a8 <__libc_init_array+0x3c>)
   2156e:	b570      	push	{r4, r5, r6, lr}
   21570:	2500      	movs	r5, #0
   21572:	1c1e      	adds	r6, r3, #0
   21574:	4c0d      	ldr	r4, [pc, #52]	; (215ac <__libc_init_array+0x40>)
   21576:	1ae4      	subs	r4, r4, r3
   21578:	10a4      	asrs	r4, r4, #2
   2157a:	42a5      	cmp	r5, r4
   2157c:	d004      	beq.n	21588 <__libc_init_array+0x1c>
   2157e:	00ab      	lsls	r3, r5, #2
   21580:	58f3      	ldr	r3, [r6, r3]
   21582:	4798      	blx	r3
   21584:	3501      	adds	r5, #1
   21586:	e7f8      	b.n	2157a <__libc_init_array+0xe>
   21588:	f7f9 ff3e 	bl	1b408 <_init>
   2158c:	4b08      	ldr	r3, [pc, #32]	; (215b0 <__libc_init_array+0x44>)
   2158e:	2500      	movs	r5, #0
   21590:	1c1e      	adds	r6, r3, #0
   21592:	4c08      	ldr	r4, [pc, #32]	; (215b4 <__libc_init_array+0x48>)
   21594:	1ae4      	subs	r4, r4, r3
   21596:	10a4      	asrs	r4, r4, #2
   21598:	42a5      	cmp	r5, r4
   2159a:	d004      	beq.n	215a6 <__libc_init_array+0x3a>
   2159c:	00ab      	lsls	r3, r5, #2
   2159e:	58f3      	ldr	r3, [r6, r3]
   215a0:	4798      	blx	r3
   215a2:	3501      	adds	r5, #1
   215a4:	e7f8      	b.n	21598 <__libc_init_array+0x2c>
   215a6:	bd70      	pop	{r4, r5, r6, pc}
   215a8:	20002e80 	.word	0x20002e80
   215ac:	20002e80 	.word	0x20002e80
   215b0:	20002e80 	.word	0x20002e80
   215b4:	20002e8c 	.word	0x20002e8c

000215b8 <malloc>:
   215b8:	b508      	push	{r3, lr}
   215ba:	4b03      	ldr	r3, [pc, #12]	; (215c8 <malloc+0x10>)
   215bc:	1c01      	adds	r1, r0, #0
   215be:	6818      	ldr	r0, [r3, #0]
   215c0:	f000 f894 	bl	216ec <_malloc_r>
   215c4:	bd08      	pop	{r3, pc}
   215c6:	46c0      	nop			; (mov r8, r8)
   215c8:	20002ef4 	.word	0x20002ef4

000215cc <free>:
   215cc:	b508      	push	{r3, lr}
   215ce:	4b03      	ldr	r3, [pc, #12]	; (215dc <free+0x10>)
   215d0:	1c01      	adds	r1, r0, #0
   215d2:	6818      	ldr	r0, [r3, #0]
   215d4:	f000 f844 	bl	21660 <_free_r>
   215d8:	bd08      	pop	{r3, pc}
   215da:	46c0      	nop			; (mov r8, r8)
   215dc:	20002ef4 	.word	0x20002ef4

000215e0 <memchr>:
   215e0:	b2c9      	uxtb	r1, r1
   215e2:	1882      	adds	r2, r0, r2
   215e4:	4290      	cmp	r0, r2
   215e6:	d004      	beq.n	215f2 <memchr+0x12>
   215e8:	7803      	ldrb	r3, [r0, #0]
   215ea:	428b      	cmp	r3, r1
   215ec:	d002      	beq.n	215f4 <memchr+0x14>
   215ee:	3001      	adds	r0, #1
   215f0:	e7f8      	b.n	215e4 <memchr+0x4>
   215f2:	2000      	movs	r0, #0
   215f4:	4770      	bx	lr

000215f6 <memcmp>:
   215f6:	b530      	push	{r4, r5, lr}
   215f8:	2400      	movs	r4, #0
   215fa:	4294      	cmp	r4, r2
   215fc:	d008      	beq.n	21610 <memcmp+0x1a>
   215fe:	5d03      	ldrb	r3, [r0, r4]
   21600:	1c65      	adds	r5, r4, #1
   21602:	5d0c      	ldrb	r4, [r1, r4]
   21604:	42a3      	cmp	r3, r4
   21606:	d001      	beq.n	2160c <memcmp+0x16>
   21608:	1b18      	subs	r0, r3, r4
   2160a:	e002      	b.n	21612 <memcmp+0x1c>
   2160c:	1c2c      	adds	r4, r5, #0
   2160e:	e7f4      	b.n	215fa <memcmp+0x4>
   21610:	2000      	movs	r0, #0
   21612:	bd30      	pop	{r4, r5, pc}

00021614 <memcpy>:
   21614:	2300      	movs	r3, #0
   21616:	b510      	push	{r4, lr}
   21618:	4293      	cmp	r3, r2
   2161a:	d003      	beq.n	21624 <memcpy+0x10>
   2161c:	5ccc      	ldrb	r4, [r1, r3]
   2161e:	54c4      	strb	r4, [r0, r3]
   21620:	3301      	adds	r3, #1
   21622:	e7f9      	b.n	21618 <memcpy+0x4>
   21624:	bd10      	pop	{r4, pc}

00021626 <memmove>:
   21626:	b510      	push	{r4, lr}
   21628:	4281      	cmp	r1, r0
   2162a:	d208      	bcs.n	2163e <memmove+0x18>
   2162c:	188b      	adds	r3, r1, r2
   2162e:	4298      	cmp	r0, r3
   21630:	d205      	bcs.n	2163e <memmove+0x18>
   21632:	1a9b      	subs	r3, r3, r2
   21634:	3a01      	subs	r2, #1
   21636:	d309      	bcc.n	2164c <memmove+0x26>
   21638:	5c99      	ldrb	r1, [r3, r2]
   2163a:	5481      	strb	r1, [r0, r2]
   2163c:	e7fa      	b.n	21634 <memmove+0xe>
   2163e:	2300      	movs	r3, #0
   21640:	4293      	cmp	r3, r2
   21642:	d003      	beq.n	2164c <memmove+0x26>
   21644:	5ccc      	ldrb	r4, [r1, r3]
   21646:	54c4      	strb	r4, [r0, r3]
   21648:	3301      	adds	r3, #1
   2164a:	e7f9      	b.n	21640 <memmove+0x1a>
   2164c:	bd10      	pop	{r4, pc}

0002164e <memset>:
   2164e:	1c03      	adds	r3, r0, #0
   21650:	1882      	adds	r2, r0, r2
   21652:	4293      	cmp	r3, r2
   21654:	d002      	beq.n	2165c <memset+0xe>
   21656:	7019      	strb	r1, [r3, #0]
   21658:	3301      	adds	r3, #1
   2165a:	e7fa      	b.n	21652 <memset+0x4>
   2165c:	4770      	bx	lr
	...

00021660 <_free_r>:
   21660:	b530      	push	{r4, r5, lr}
   21662:	2900      	cmp	r1, #0
   21664:	d03e      	beq.n	216e4 <_free_r+0x84>
   21666:	3904      	subs	r1, #4
   21668:	680b      	ldr	r3, [r1, #0]
   2166a:	2b00      	cmp	r3, #0
   2166c:	da00      	bge.n	21670 <_free_r+0x10>
   2166e:	18c9      	adds	r1, r1, r3
   21670:	4a1d      	ldr	r2, [pc, #116]	; (216e8 <_free_r+0x88>)
   21672:	6813      	ldr	r3, [r2, #0]
   21674:	1c14      	adds	r4, r2, #0
   21676:	2b00      	cmp	r3, #0
   21678:	d102      	bne.n	21680 <_free_r+0x20>
   2167a:	604b      	str	r3, [r1, #4]
   2167c:	6011      	str	r1, [r2, #0]
   2167e:	e031      	b.n	216e4 <_free_r+0x84>
   21680:	4299      	cmp	r1, r3
   21682:	d20d      	bcs.n	216a0 <_free_r+0x40>
   21684:	6808      	ldr	r0, [r1, #0]
   21686:	180a      	adds	r2, r1, r0
   21688:	429a      	cmp	r2, r3
   2168a:	d103      	bne.n	21694 <_free_r+0x34>
   2168c:	6813      	ldr	r3, [r2, #0]
   2168e:	18c3      	adds	r3, r0, r3
   21690:	600b      	str	r3, [r1, #0]
   21692:	6853      	ldr	r3, [r2, #4]
   21694:	604b      	str	r3, [r1, #4]
   21696:	6021      	str	r1, [r4, #0]
   21698:	e024      	b.n	216e4 <_free_r+0x84>
   2169a:	428a      	cmp	r2, r1
   2169c:	d803      	bhi.n	216a6 <_free_r+0x46>
   2169e:	1c13      	adds	r3, r2, #0
   216a0:	685a      	ldr	r2, [r3, #4]
   216a2:	2a00      	cmp	r2, #0
   216a4:	d1f9      	bne.n	2169a <_free_r+0x3a>
   216a6:	681d      	ldr	r5, [r3, #0]
   216a8:	195c      	adds	r4, r3, r5
   216aa:	428c      	cmp	r4, r1
   216ac:	d10b      	bne.n	216c6 <_free_r+0x66>
   216ae:	6809      	ldr	r1, [r1, #0]
   216b0:	1869      	adds	r1, r5, r1
   216b2:	1858      	adds	r0, r3, r1
   216b4:	6019      	str	r1, [r3, #0]
   216b6:	4290      	cmp	r0, r2
   216b8:	d114      	bne.n	216e4 <_free_r+0x84>
   216ba:	6810      	ldr	r0, [r2, #0]
   216bc:	6852      	ldr	r2, [r2, #4]
   216be:	1809      	adds	r1, r1, r0
   216c0:	6019      	str	r1, [r3, #0]
   216c2:	605a      	str	r2, [r3, #4]
   216c4:	e00e      	b.n	216e4 <_free_r+0x84>
   216c6:	428c      	cmp	r4, r1
   216c8:	d902      	bls.n	216d0 <_free_r+0x70>
   216ca:	230c      	movs	r3, #12
   216cc:	6003      	str	r3, [r0, #0]
   216ce:	e009      	b.n	216e4 <_free_r+0x84>
   216d0:	6808      	ldr	r0, [r1, #0]
   216d2:	180c      	adds	r4, r1, r0
   216d4:	4294      	cmp	r4, r2
   216d6:	d103      	bne.n	216e0 <_free_r+0x80>
   216d8:	6814      	ldr	r4, [r2, #0]
   216da:	6852      	ldr	r2, [r2, #4]
   216dc:	1900      	adds	r0, r0, r4
   216de:	6008      	str	r0, [r1, #0]
   216e0:	604a      	str	r2, [r1, #4]
   216e2:	6059      	str	r1, [r3, #4]
   216e4:	bd30      	pop	{r4, r5, pc}
   216e6:	46c0      	nop			; (mov r8, r8)
   216e8:	20003740 	.word	0x20003740

000216ec <_malloc_r>:
   216ec:	2303      	movs	r3, #3
   216ee:	b570      	push	{r4, r5, r6, lr}
   216f0:	1ccc      	adds	r4, r1, #3
   216f2:	439c      	bics	r4, r3
   216f4:	3408      	adds	r4, #8
   216f6:	1c05      	adds	r5, r0, #0
   216f8:	2c0c      	cmp	r4, #12
   216fa:	d201      	bcs.n	21700 <_malloc_r+0x14>
   216fc:	240c      	movs	r4, #12
   216fe:	e005      	b.n	2170c <_malloc_r+0x20>
   21700:	2c00      	cmp	r4, #0
   21702:	da03      	bge.n	2170c <_malloc_r+0x20>
   21704:	230c      	movs	r3, #12
   21706:	2000      	movs	r0, #0
   21708:	602b      	str	r3, [r5, #0]
   2170a:	e042      	b.n	21792 <_malloc_r+0xa6>
   2170c:	428c      	cmp	r4, r1
   2170e:	d3f9      	bcc.n	21704 <_malloc_r+0x18>
   21710:	4a20      	ldr	r2, [pc, #128]	; (21794 <_malloc_r+0xa8>)
   21712:	6813      	ldr	r3, [r2, #0]
   21714:	1c10      	adds	r0, r2, #0
   21716:	1c19      	adds	r1, r3, #0
   21718:	2900      	cmp	r1, #0
   2171a:	d013      	beq.n	21744 <_malloc_r+0x58>
   2171c:	680a      	ldr	r2, [r1, #0]
   2171e:	1b12      	subs	r2, r2, r4
   21720:	d40d      	bmi.n	2173e <_malloc_r+0x52>
   21722:	2a0b      	cmp	r2, #11
   21724:	d902      	bls.n	2172c <_malloc_r+0x40>
   21726:	600a      	str	r2, [r1, #0]
   21728:	188b      	adds	r3, r1, r2
   2172a:	e01f      	b.n	2176c <_malloc_r+0x80>
   2172c:	428b      	cmp	r3, r1
   2172e:	d102      	bne.n	21736 <_malloc_r+0x4a>
   21730:	685a      	ldr	r2, [r3, #4]
   21732:	6002      	str	r2, [r0, #0]
   21734:	e01b      	b.n	2176e <_malloc_r+0x82>
   21736:	684a      	ldr	r2, [r1, #4]
   21738:	605a      	str	r2, [r3, #4]
   2173a:	1c0b      	adds	r3, r1, #0
   2173c:	e017      	b.n	2176e <_malloc_r+0x82>
   2173e:	1c0b      	adds	r3, r1, #0
   21740:	6849      	ldr	r1, [r1, #4]
   21742:	e7e9      	b.n	21718 <_malloc_r+0x2c>
   21744:	4e14      	ldr	r6, [pc, #80]	; (21798 <_malloc_r+0xac>)
   21746:	6833      	ldr	r3, [r6, #0]
   21748:	2b00      	cmp	r3, #0
   2174a:	d103      	bne.n	21754 <_malloc_r+0x68>
   2174c:	1c28      	adds	r0, r5, #0
   2174e:	f000 f825 	bl	2179c <_sbrk_r>
   21752:	6030      	str	r0, [r6, #0]
   21754:	1c28      	adds	r0, r5, #0
   21756:	1c21      	adds	r1, r4, #0
   21758:	f000 f820 	bl	2179c <_sbrk_r>
   2175c:	1c03      	adds	r3, r0, #0
   2175e:	1c42      	adds	r2, r0, #1
   21760:	d0d0      	beq.n	21704 <_malloc_r+0x18>
   21762:	2203      	movs	r2, #3
   21764:	1cc6      	adds	r6, r0, #3
   21766:	4396      	bics	r6, r2
   21768:	4286      	cmp	r6, r0
   2176a:	d10a      	bne.n	21782 <_malloc_r+0x96>
   2176c:	601c      	str	r4, [r3, #0]
   2176e:	1c18      	adds	r0, r3, #0
   21770:	2107      	movs	r1, #7
   21772:	300b      	adds	r0, #11
   21774:	1d1a      	adds	r2, r3, #4
   21776:	4388      	bics	r0, r1
   21778:	1a82      	subs	r2, r0, r2
   2177a:	d00a      	beq.n	21792 <_malloc_r+0xa6>
   2177c:	4251      	negs	r1, r2
   2177e:	5099      	str	r1, [r3, r2]
   21780:	e007      	b.n	21792 <_malloc_r+0xa6>
   21782:	1a31      	subs	r1, r6, r0
   21784:	1c28      	adds	r0, r5, #0
   21786:	f000 f809 	bl	2179c <_sbrk_r>
   2178a:	1c43      	adds	r3, r0, #1
   2178c:	d0ba      	beq.n	21704 <_malloc_r+0x18>
   2178e:	1c33      	adds	r3, r6, #0
   21790:	e7ec      	b.n	2176c <_malloc_r+0x80>
   21792:	bd70      	pop	{r4, r5, r6, pc}
   21794:	20003740 	.word	0x20003740
   21798:	2000373c 	.word	0x2000373c

0002179c <_sbrk_r>:
   2179c:	b538      	push	{r3, r4, r5, lr}
   2179e:	2300      	movs	r3, #0
   217a0:	4c06      	ldr	r4, [pc, #24]	; (217bc <_sbrk_r+0x20>)
   217a2:	1c05      	adds	r5, r0, #0
   217a4:	1c08      	adds	r0, r1, #0
   217a6:	6023      	str	r3, [r4, #0]
   217a8:	f001 f846 	bl	22838 <_sbrk>
   217ac:	1c43      	adds	r3, r0, #1
   217ae:	d103      	bne.n	217b8 <_sbrk_r+0x1c>
   217b0:	6823      	ldr	r3, [r4, #0]
   217b2:	2b00      	cmp	r3, #0
   217b4:	d000      	beq.n	217b8 <_sbrk_r+0x1c>
   217b6:	602b      	str	r3, [r5, #0]
   217b8:	bd38      	pop	{r3, r4, r5, pc}
   217ba:	46c0      	nop			; (mov r8, r8)
   217bc:	200037d8 	.word	0x200037d8

000217c0 <_raise_r>:
   217c0:	b538      	push	{r3, r4, r5, lr}
   217c2:	291f      	cmp	r1, #31
   217c4:	d904      	bls.n	217d0 <_raise_r+0x10>
   217c6:	2316      	movs	r3, #22
   217c8:	6003      	str	r3, [r0, #0]
   217ca:	2001      	movs	r0, #1
   217cc:	4240      	negs	r0, r0
   217ce:	e020      	b.n	21812 <_raise_r+0x52>
   217d0:	6c42      	ldr	r2, [r0, #68]	; 0x44
   217d2:	1c0d      	adds	r5, r1, #0
   217d4:	1c04      	adds	r4, r0, #0
   217d6:	2a00      	cmp	r2, #0
   217d8:	d004      	beq.n	217e4 <_raise_r+0x24>
   217da:	008b      	lsls	r3, r1, #2
   217dc:	18d2      	adds	r2, r2, r3
   217de:	6813      	ldr	r3, [r2, #0]
   217e0:	2b00      	cmp	r3, #0
   217e2:	d108      	bne.n	217f6 <_raise_r+0x36>
   217e4:	1c20      	adds	r0, r4, #0
   217e6:	f000 f831 	bl	2184c <_getpid_r>
   217ea:	1c2a      	adds	r2, r5, #0
   217ec:	1c01      	adds	r1, r0, #0
   217ee:	1c20      	adds	r0, r4, #0
   217f0:	f000 f81a 	bl	21828 <_kill_r>
   217f4:	e00d      	b.n	21812 <_raise_r+0x52>
   217f6:	2000      	movs	r0, #0
   217f8:	2b01      	cmp	r3, #1
   217fa:	d00a      	beq.n	21812 <_raise_r+0x52>
   217fc:	1c59      	adds	r1, r3, #1
   217fe:	d103      	bne.n	21808 <_raise_r+0x48>
   21800:	3317      	adds	r3, #23
   21802:	6023      	str	r3, [r4, #0]
   21804:	3001      	adds	r0, #1
   21806:	e004      	b.n	21812 <_raise_r+0x52>
   21808:	2400      	movs	r4, #0
   2180a:	1c28      	adds	r0, r5, #0
   2180c:	6014      	str	r4, [r2, #0]
   2180e:	4798      	blx	r3
   21810:	1c20      	adds	r0, r4, #0
   21812:	bd38      	pop	{r3, r4, r5, pc}

00021814 <raise>:
   21814:	b508      	push	{r3, lr}
   21816:	4b03      	ldr	r3, [pc, #12]	; (21824 <raise+0x10>)
   21818:	1c01      	adds	r1, r0, #0
   2181a:	6818      	ldr	r0, [r3, #0]
   2181c:	f7ff ffd0 	bl	217c0 <_raise_r>
   21820:	bd08      	pop	{r3, pc}
   21822:	46c0      	nop			; (mov r8, r8)
   21824:	20002ef4 	.word	0x20002ef4

00021828 <_kill_r>:
   21828:	b538      	push	{r3, r4, r5, lr}
   2182a:	2300      	movs	r3, #0
   2182c:	4c06      	ldr	r4, [pc, #24]	; (21848 <_kill_r+0x20>)
   2182e:	1c05      	adds	r5, r0, #0
   21830:	1c08      	adds	r0, r1, #0
   21832:	1c11      	adds	r1, r2, #0
   21834:	6023      	str	r3, [r4, #0]
   21836:	f000 fff7 	bl	22828 <_kill>
   2183a:	1c43      	adds	r3, r0, #1
   2183c:	d103      	bne.n	21846 <_kill_r+0x1e>
   2183e:	6823      	ldr	r3, [r4, #0]
   21840:	2b00      	cmp	r3, #0
   21842:	d000      	beq.n	21846 <_kill_r+0x1e>
   21844:	602b      	str	r3, [r5, #0]
   21846:	bd38      	pop	{r3, r4, r5, pc}
   21848:	200037d8 	.word	0x200037d8

0002184c <_getpid_r>:
   2184c:	b508      	push	{r3, lr}
   2184e:	f000 ffe3 	bl	22818 <_getpid>
   21852:	bd08      	pop	{r3, pc}

00021854 <siprintf>:
   21854:	b40e      	push	{r1, r2, r3}
   21856:	b510      	push	{r4, lr}
   21858:	b09d      	sub	sp, #116	; 0x74
   2185a:	a902      	add	r1, sp, #8
   2185c:	9002      	str	r0, [sp, #8]
   2185e:	6108      	str	r0, [r1, #16]
   21860:	480b      	ldr	r0, [pc, #44]	; (21890 <siprintf+0x3c>)
   21862:	2482      	movs	r4, #130	; 0x82
   21864:	6088      	str	r0, [r1, #8]
   21866:	6148      	str	r0, [r1, #20]
   21868:	2001      	movs	r0, #1
   2186a:	4240      	negs	r0, r0
   2186c:	ab1f      	add	r3, sp, #124	; 0x7c
   2186e:	81c8      	strh	r0, [r1, #14]
   21870:	4808      	ldr	r0, [pc, #32]	; (21894 <siprintf+0x40>)
   21872:	cb04      	ldmia	r3!, {r2}
   21874:	00a4      	lsls	r4, r4, #2
   21876:	6800      	ldr	r0, [r0, #0]
   21878:	9301      	str	r3, [sp, #4]
   2187a:	818c      	strh	r4, [r1, #12]
   2187c:	f000 f96a 	bl	21b54 <_svfiprintf_r>
   21880:	2300      	movs	r3, #0
   21882:	9a02      	ldr	r2, [sp, #8]
   21884:	7013      	strb	r3, [r2, #0]
   21886:	b01d      	add	sp, #116	; 0x74
   21888:	bc10      	pop	{r4}
   2188a:	bc08      	pop	{r3}
   2188c:	b003      	add	sp, #12
   2188e:	4718      	bx	r3
   21890:	7fffffff 	.word	0x7fffffff
   21894:	20002ef4 	.word	0x20002ef4

00021898 <strlen>:
   21898:	2300      	movs	r3, #0
   2189a:	5cc2      	ldrb	r2, [r0, r3]
   2189c:	3301      	adds	r3, #1
   2189e:	2a00      	cmp	r2, #0
   218a0:	d1fb      	bne.n	2189a <strlen+0x2>
   218a2:	1e58      	subs	r0, r3, #1
   218a4:	4770      	bx	lr
	...

000218a8 <__register_exitproc>:
   218a8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   218aa:	4d2a      	ldr	r5, [pc, #168]	; (21954 <__register_exitproc+0xac>)
   218ac:	1c06      	adds	r6, r0, #0
   218ae:	682c      	ldr	r4, [r5, #0]
   218b0:	9100      	str	r1, [sp, #0]
   218b2:	1c17      	adds	r7, r2, #0
   218b4:	9301      	str	r3, [sp, #4]
   218b6:	2c00      	cmp	r4, #0
   218b8:	d101      	bne.n	218be <__register_exitproc+0x16>
   218ba:	4c27      	ldr	r4, [pc, #156]	; (21958 <__register_exitproc+0xb0>)
   218bc:	602c      	str	r4, [r5, #0]
   218be:	6863      	ldr	r3, [r4, #4]
   218c0:	2b1f      	cmp	r3, #31
   218c2:	dd15      	ble.n	218f0 <__register_exitproc+0x48>
   218c4:	4b25      	ldr	r3, [pc, #148]	; (2195c <__register_exitproc+0xb4>)
   218c6:	2b00      	cmp	r3, #0
   218c8:	d102      	bne.n	218d0 <__register_exitproc+0x28>
   218ca:	2001      	movs	r0, #1
   218cc:	4240      	negs	r0, r0
   218ce:	e040      	b.n	21952 <__register_exitproc+0xaa>
   218d0:	208c      	movs	r0, #140	; 0x8c
   218d2:	f7ff fe71 	bl	215b8 <malloc>
   218d6:	1e04      	subs	r4, r0, #0
   218d8:	d0f7      	beq.n	218ca <__register_exitproc+0x22>
   218da:	682a      	ldr	r2, [r5, #0]
   218dc:	2300      	movs	r3, #0
   218de:	6002      	str	r2, [r0, #0]
   218e0:	1c02      	adds	r2, r0, #0
   218e2:	3288      	adds	r2, #136	; 0x88
   218e4:	6043      	str	r3, [r0, #4]
   218e6:	6028      	str	r0, [r5, #0]
   218e8:	6013      	str	r3, [r2, #0]
   218ea:	429e      	cmp	r6, r3
   218ec:	d10a      	bne.n	21904 <__register_exitproc+0x5c>
   218ee:	e028      	b.n	21942 <__register_exitproc+0x9a>
   218f0:	2e00      	cmp	r6, #0
   218f2:	d026      	beq.n	21942 <__register_exitproc+0x9a>
   218f4:	1c23      	adds	r3, r4, #0
   218f6:	3388      	adds	r3, #136	; 0x88
   218f8:	6818      	ldr	r0, [r3, #0]
   218fa:	2800      	cmp	r0, #0
   218fc:	d110      	bne.n	21920 <__register_exitproc+0x78>
   218fe:	4b17      	ldr	r3, [pc, #92]	; (2195c <__register_exitproc+0xb4>)
   21900:	2b00      	cmp	r3, #0
   21902:	d0e2      	beq.n	218ca <__register_exitproc+0x22>
   21904:	2084      	movs	r0, #132	; 0x84
   21906:	0040      	lsls	r0, r0, #1
   21908:	f7ff fe56 	bl	215b8 <malloc>
   2190c:	2800      	cmp	r0, #0
   2190e:	d0dc      	beq.n	218ca <__register_exitproc+0x22>
   21910:	1c03      	adds	r3, r0, #0
   21912:	2200      	movs	r2, #0
   21914:	33fc      	adds	r3, #252	; 0xfc
   21916:	605a      	str	r2, [r3, #4]
   21918:	609a      	str	r2, [r3, #8]
   2191a:	1c23      	adds	r3, r4, #0
   2191c:	3388      	adds	r3, #136	; 0x88
   2191e:	6018      	str	r0, [r3, #0]
   21920:	2201      	movs	r2, #1
   21922:	6861      	ldr	r1, [r4, #4]
   21924:	408a      	lsls	r2, r1
   21926:	008b      	lsls	r3, r1, #2
   21928:	18c3      	adds	r3, r0, r3
   2192a:	c380      	stmia	r3!, {r7}
   2192c:	30fc      	adds	r0, #252	; 0xfc
   2192e:	6841      	ldr	r1, [r0, #4]
   21930:	4311      	orrs	r1, r2
   21932:	6041      	str	r1, [r0, #4]
   21934:	9901      	ldr	r1, [sp, #4]
   21936:	67d9      	str	r1, [r3, #124]	; 0x7c
   21938:	2e02      	cmp	r6, #2
   2193a:	d102      	bne.n	21942 <__register_exitproc+0x9a>
   2193c:	6883      	ldr	r3, [r0, #8]
   2193e:	431a      	orrs	r2, r3
   21940:	6082      	str	r2, [r0, #8]
   21942:	2000      	movs	r0, #0
   21944:	6863      	ldr	r3, [r4, #4]
   21946:	1c5a      	adds	r2, r3, #1
   21948:	6062      	str	r2, [r4, #4]
   2194a:	3302      	adds	r3, #2
   2194c:	9a00      	ldr	r2, [sp, #0]
   2194e:	009b      	lsls	r3, r3, #2
   21950:	511a      	str	r2, [r3, r4]
   21952:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   21954:	200037d0 	.word	0x200037d0
   21958:	20003744 	.word	0x20003744
   2195c:	000215b9 	.word	0x000215b9

00021960 <__call_exitprocs>:
   21960:	b5f0      	push	{r4, r5, r6, r7, lr}
   21962:	b087      	sub	sp, #28
   21964:	9005      	str	r0, [sp, #20]
   21966:	9103      	str	r1, [sp, #12]
   21968:	4d34      	ldr	r5, [pc, #208]	; (21a3c <__call_exitprocs+0xdc>)
   2196a:	682c      	ldr	r4, [r5, #0]
   2196c:	2c00      	cmp	r4, #0
   2196e:	d063      	beq.n	21a38 <__call_exitprocs+0xd8>
   21970:	1c23      	adds	r3, r4, #0
   21972:	3388      	adds	r3, #136	; 0x88
   21974:	681e      	ldr	r6, [r3, #0]
   21976:	6863      	ldr	r3, [r4, #4]
   21978:	1e5a      	subs	r2, r3, #1
   2197a:	9201      	str	r2, [sp, #4]
   2197c:	4a30      	ldr	r2, [pc, #192]	; (21a40 <__call_exitprocs+0xe0>)
   2197e:	189b      	adds	r3, r3, r2
   21980:	009b      	lsls	r3, r3, #2
   21982:	18f7      	adds	r7, r6, r3
   21984:	3304      	adds	r3, #4
   21986:	18e3      	adds	r3, r4, r3
   21988:	9302      	str	r3, [sp, #8]
   2198a:	9b01      	ldr	r3, [sp, #4]
   2198c:	2b00      	cmp	r3, #0
   2198e:	db3d      	blt.n	21a0c <__call_exitprocs+0xac>
   21990:	9b03      	ldr	r3, [sp, #12]
   21992:	2b00      	cmp	r3, #0
   21994:	d007      	beq.n	219a6 <__call_exitprocs+0x46>
   21996:	2e00      	cmp	r6, #0
   21998:	d031      	beq.n	219fe <__call_exitprocs+0x9e>
   2199a:	1c3b      	adds	r3, r7, #0
   2199c:	3380      	adds	r3, #128	; 0x80
   2199e:	681b      	ldr	r3, [r3, #0]
   219a0:	9a03      	ldr	r2, [sp, #12]
   219a2:	4293      	cmp	r3, r2
   219a4:	d12b      	bne.n	219fe <__call_exitprocs+0x9e>
   219a6:	6862      	ldr	r2, [r4, #4]
   219a8:	9b02      	ldr	r3, [sp, #8]
   219aa:	9901      	ldr	r1, [sp, #4]
   219ac:	3a01      	subs	r2, #1
   219ae:	685b      	ldr	r3, [r3, #4]
   219b0:	4291      	cmp	r1, r2
   219b2:	d101      	bne.n	219b8 <__call_exitprocs+0x58>
   219b4:	6061      	str	r1, [r4, #4]
   219b6:	e002      	b.n	219be <__call_exitprocs+0x5e>
   219b8:	2200      	movs	r2, #0
   219ba:	9902      	ldr	r1, [sp, #8]
   219bc:	604a      	str	r2, [r1, #4]
   219be:	2b00      	cmp	r3, #0
   219c0:	d01d      	beq.n	219fe <__call_exitprocs+0x9e>
   219c2:	6862      	ldr	r2, [r4, #4]
   219c4:	9204      	str	r2, [sp, #16]
   219c6:	2e00      	cmp	r6, #0
   219c8:	d007      	beq.n	219da <__call_exitprocs+0x7a>
   219ca:	2201      	movs	r2, #1
   219cc:	9901      	ldr	r1, [sp, #4]
   219ce:	408a      	lsls	r2, r1
   219d0:	1c31      	adds	r1, r6, #0
   219d2:	31fc      	adds	r1, #252	; 0xfc
   219d4:	6848      	ldr	r0, [r1, #4]
   219d6:	4210      	tst	r0, r2
   219d8:	d101      	bne.n	219de <__call_exitprocs+0x7e>
   219da:	4798      	blx	r3
   219dc:	e008      	b.n	219f0 <__call_exitprocs+0x90>
   219de:	6889      	ldr	r1, [r1, #8]
   219e0:	4211      	tst	r1, r2
   219e2:	d103      	bne.n	219ec <__call_exitprocs+0x8c>
   219e4:	9805      	ldr	r0, [sp, #20]
   219e6:	6839      	ldr	r1, [r7, #0]
   219e8:	4798      	blx	r3
   219ea:	e001      	b.n	219f0 <__call_exitprocs+0x90>
   219ec:	6838      	ldr	r0, [r7, #0]
   219ee:	4798      	blx	r3
   219f0:	9b04      	ldr	r3, [sp, #16]
   219f2:	6862      	ldr	r2, [r4, #4]
   219f4:	4293      	cmp	r3, r2
   219f6:	d1b7      	bne.n	21968 <__call_exitprocs+0x8>
   219f8:	682b      	ldr	r3, [r5, #0]
   219fa:	42a3      	cmp	r3, r4
   219fc:	d1b4      	bne.n	21968 <__call_exitprocs+0x8>
   219fe:	9b01      	ldr	r3, [sp, #4]
   21a00:	3f04      	subs	r7, #4
   21a02:	3b01      	subs	r3, #1
   21a04:	9301      	str	r3, [sp, #4]
   21a06:	9b02      	ldr	r3, [sp, #8]
   21a08:	3b04      	subs	r3, #4
   21a0a:	e7bd      	b.n	21988 <__call_exitprocs+0x28>
   21a0c:	4b0d      	ldr	r3, [pc, #52]	; (21a44 <__call_exitprocs+0xe4>)
   21a0e:	2b00      	cmp	r3, #0
   21a10:	d012      	beq.n	21a38 <__call_exitprocs+0xd8>
   21a12:	6862      	ldr	r2, [r4, #4]
   21a14:	6823      	ldr	r3, [r4, #0]
   21a16:	2a00      	cmp	r2, #0
   21a18:	d10b      	bne.n	21a32 <__call_exitprocs+0xd2>
   21a1a:	2b00      	cmp	r3, #0
   21a1c:	d009      	beq.n	21a32 <__call_exitprocs+0xd2>
   21a1e:	602b      	str	r3, [r5, #0]
   21a20:	2e00      	cmp	r6, #0
   21a22:	d002      	beq.n	21a2a <__call_exitprocs+0xca>
   21a24:	1c30      	adds	r0, r6, #0
   21a26:	f7ff fdd1 	bl	215cc <free>
   21a2a:	1c20      	adds	r0, r4, #0
   21a2c:	f7ff fdce 	bl	215cc <free>
   21a30:	e79b      	b.n	2196a <__call_exitprocs+0xa>
   21a32:	1c25      	adds	r5, r4, #0
   21a34:	1c1c      	adds	r4, r3, #0
   21a36:	e799      	b.n	2196c <__call_exitprocs+0xc>
   21a38:	b007      	add	sp, #28
   21a3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   21a3c:	200037d0 	.word	0x200037d0
   21a40:	3fffffff 	.word	0x3fffffff
   21a44:	000215cd 	.word	0x000215cd

00021a48 <_realloc_r>:
   21a48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   21a4a:	1c06      	adds	r6, r0, #0
   21a4c:	1c0c      	adds	r4, r1, #0
   21a4e:	1c15      	adds	r5, r2, #0
   21a50:	2900      	cmp	r1, #0
   21a52:	d104      	bne.n	21a5e <_realloc_r+0x16>
   21a54:	1c11      	adds	r1, r2, #0
   21a56:	f7ff fe49 	bl	216ec <_malloc_r>
   21a5a:	1c04      	adds	r4, r0, #0
   21a5c:	e018      	b.n	21a90 <_realloc_r+0x48>
   21a5e:	2a00      	cmp	r2, #0
   21a60:	d103      	bne.n	21a6a <_realloc_r+0x22>
   21a62:	f7ff fdfd 	bl	21660 <_free_r>
   21a66:	1c2c      	adds	r4, r5, #0
   21a68:	e012      	b.n	21a90 <_realloc_r+0x48>
   21a6a:	f000 faef 	bl	2204c <_malloc_usable_size_r>
   21a6e:	42a8      	cmp	r0, r5
   21a70:	d20e      	bcs.n	21a90 <_realloc_r+0x48>
   21a72:	1c30      	adds	r0, r6, #0
   21a74:	1c29      	adds	r1, r5, #0
   21a76:	f7ff fe39 	bl	216ec <_malloc_r>
   21a7a:	1e07      	subs	r7, r0, #0
   21a7c:	d007      	beq.n	21a8e <_realloc_r+0x46>
   21a7e:	1c21      	adds	r1, r4, #0
   21a80:	1c2a      	adds	r2, r5, #0
   21a82:	f7ff fdc7 	bl	21614 <memcpy>
   21a86:	1c30      	adds	r0, r6, #0
   21a88:	1c21      	adds	r1, r4, #0
   21a8a:	f7ff fde9 	bl	21660 <_free_r>
   21a8e:	1c3c      	adds	r4, r7, #0
   21a90:	1c20      	adds	r0, r4, #0
   21a92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00021a94 <__ssputs_r>:
   21a94:	b5f0      	push	{r4, r5, r6, r7, lr}
   21a96:	688e      	ldr	r6, [r1, #8]
   21a98:	b085      	sub	sp, #20
   21a9a:	1c07      	adds	r7, r0, #0
   21a9c:	1c0c      	adds	r4, r1, #0
   21a9e:	9203      	str	r2, [sp, #12]
   21aa0:	9301      	str	r3, [sp, #4]
   21aa2:	42b3      	cmp	r3, r6
   21aa4:	d345      	bcc.n	21b32 <__ssputs_r+0x9e>
   21aa6:	2390      	movs	r3, #144	; 0x90
   21aa8:	898a      	ldrh	r2, [r1, #12]
   21aaa:	00db      	lsls	r3, r3, #3
   21aac:	421a      	tst	r2, r3
   21aae:	d03d      	beq.n	21b2c <__ssputs_r+0x98>
   21ab0:	2503      	movs	r5, #3
   21ab2:	6909      	ldr	r1, [r1, #16]
   21ab4:	6823      	ldr	r3, [r4, #0]
   21ab6:	9801      	ldr	r0, [sp, #4]
   21ab8:	1a5b      	subs	r3, r3, r1
   21aba:	9302      	str	r3, [sp, #8]
   21abc:	6963      	ldr	r3, [r4, #20]
   21abe:	435d      	muls	r5, r3
   21ac0:	0feb      	lsrs	r3, r5, #31
   21ac2:	195d      	adds	r5, r3, r5
   21ac4:	9b02      	ldr	r3, [sp, #8]
   21ac6:	106d      	asrs	r5, r5, #1
   21ac8:	3301      	adds	r3, #1
   21aca:	181b      	adds	r3, r3, r0
   21acc:	429d      	cmp	r5, r3
   21ace:	d200      	bcs.n	21ad2 <__ssputs_r+0x3e>
   21ad0:	1c1d      	adds	r5, r3, #0
   21ad2:	1c38      	adds	r0, r7, #0
   21ad4:	0553      	lsls	r3, r2, #21
   21ad6:	d50f      	bpl.n	21af8 <__ssputs_r+0x64>
   21ad8:	1c29      	adds	r1, r5, #0
   21ada:	f7ff fe07 	bl	216ec <_malloc_r>
   21ade:	1e06      	subs	r6, r0, #0
   21ae0:	d013      	beq.n	21b0a <__ssputs_r+0x76>
   21ae2:	9a02      	ldr	r2, [sp, #8]
   21ae4:	6921      	ldr	r1, [r4, #16]
   21ae6:	f7ff fd95 	bl	21614 <memcpy>
   21aea:	89a2      	ldrh	r2, [r4, #12]
   21aec:	4b18      	ldr	r3, [pc, #96]	; (21b50 <__ssputs_r+0xbc>)
   21aee:	4013      	ands	r3, r2
   21af0:	2280      	movs	r2, #128	; 0x80
   21af2:	4313      	orrs	r3, r2
   21af4:	81a3      	strh	r3, [r4, #12]
   21af6:	e011      	b.n	21b1c <__ssputs_r+0x88>
   21af8:	1c2a      	adds	r2, r5, #0
   21afa:	f7ff ffa5 	bl	21a48 <_realloc_r>
   21afe:	1e06      	subs	r6, r0, #0
   21b00:	d10c      	bne.n	21b1c <__ssputs_r+0x88>
   21b02:	1c38      	adds	r0, r7, #0
   21b04:	6921      	ldr	r1, [r4, #16]
   21b06:	f7ff fdab 	bl	21660 <_free_r>
   21b0a:	230c      	movs	r3, #12
   21b0c:	2240      	movs	r2, #64	; 0x40
   21b0e:	2001      	movs	r0, #1
   21b10:	603b      	str	r3, [r7, #0]
   21b12:	89a3      	ldrh	r3, [r4, #12]
   21b14:	4240      	negs	r0, r0
   21b16:	4313      	orrs	r3, r2
   21b18:	81a3      	strh	r3, [r4, #12]
   21b1a:	e017      	b.n	21b4c <__ssputs_r+0xb8>
   21b1c:	9b02      	ldr	r3, [sp, #8]
   21b1e:	6126      	str	r6, [r4, #16]
   21b20:	18f6      	adds	r6, r6, r3
   21b22:	6026      	str	r6, [r4, #0]
   21b24:	6165      	str	r5, [r4, #20]
   21b26:	9e01      	ldr	r6, [sp, #4]
   21b28:	1aed      	subs	r5, r5, r3
   21b2a:	60a5      	str	r5, [r4, #8]
   21b2c:	9b01      	ldr	r3, [sp, #4]
   21b2e:	42b3      	cmp	r3, r6
   21b30:	d200      	bcs.n	21b34 <__ssputs_r+0xa0>
   21b32:	9e01      	ldr	r6, [sp, #4]
   21b34:	1c32      	adds	r2, r6, #0
   21b36:	6820      	ldr	r0, [r4, #0]
   21b38:	9903      	ldr	r1, [sp, #12]
   21b3a:	f7ff fd74 	bl	21626 <memmove>
   21b3e:	2000      	movs	r0, #0
   21b40:	68a3      	ldr	r3, [r4, #8]
   21b42:	1b9b      	subs	r3, r3, r6
   21b44:	60a3      	str	r3, [r4, #8]
   21b46:	6823      	ldr	r3, [r4, #0]
   21b48:	199e      	adds	r6, r3, r6
   21b4a:	6026      	str	r6, [r4, #0]
   21b4c:	b005      	add	sp, #20
   21b4e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   21b50:	fffffb7f 	.word	0xfffffb7f

00021b54 <_svfiprintf_r>:
   21b54:	b5f0      	push	{r4, r5, r6, r7, lr}
   21b56:	b09f      	sub	sp, #124	; 0x7c
   21b58:	9002      	str	r0, [sp, #8]
   21b5a:	9305      	str	r3, [sp, #20]
   21b5c:	898b      	ldrh	r3, [r1, #12]
   21b5e:	1c0e      	adds	r6, r1, #0
   21b60:	1c17      	adds	r7, r2, #0
   21b62:	061b      	lsls	r3, r3, #24
   21b64:	d510      	bpl.n	21b88 <_svfiprintf_r+0x34>
   21b66:	690b      	ldr	r3, [r1, #16]
   21b68:	2b00      	cmp	r3, #0
   21b6a:	d10d      	bne.n	21b88 <_svfiprintf_r+0x34>
   21b6c:	2140      	movs	r1, #64	; 0x40
   21b6e:	f7ff fdbd 	bl	216ec <_malloc_r>
   21b72:	6030      	str	r0, [r6, #0]
   21b74:	6130      	str	r0, [r6, #16]
   21b76:	2800      	cmp	r0, #0
   21b78:	d104      	bne.n	21b84 <_svfiprintf_r+0x30>
   21b7a:	230c      	movs	r3, #12
   21b7c:	9a02      	ldr	r2, [sp, #8]
   21b7e:	3801      	subs	r0, #1
   21b80:	6013      	str	r3, [r2, #0]
   21b82:	e0d0      	b.n	21d26 <_svfiprintf_r+0x1d2>
   21b84:	2340      	movs	r3, #64	; 0x40
   21b86:	6173      	str	r3, [r6, #20]
   21b88:	2300      	movs	r3, #0
   21b8a:	ad06      	add	r5, sp, #24
   21b8c:	616b      	str	r3, [r5, #20]
   21b8e:	3320      	adds	r3, #32
   21b90:	766b      	strb	r3, [r5, #25]
   21b92:	3310      	adds	r3, #16
   21b94:	76ab      	strb	r3, [r5, #26]
   21b96:	1c3c      	adds	r4, r7, #0
   21b98:	7823      	ldrb	r3, [r4, #0]
   21b9a:	2b00      	cmp	r3, #0
   21b9c:	d103      	bne.n	21ba6 <_svfiprintf_r+0x52>
   21b9e:	1be3      	subs	r3, r4, r7
   21ba0:	9304      	str	r3, [sp, #16]
   21ba2:	d012      	beq.n	21bca <_svfiprintf_r+0x76>
   21ba4:	e003      	b.n	21bae <_svfiprintf_r+0x5a>
   21ba6:	2b25      	cmp	r3, #37	; 0x25
   21ba8:	d0f9      	beq.n	21b9e <_svfiprintf_r+0x4a>
   21baa:	3401      	adds	r4, #1
   21bac:	e7f4      	b.n	21b98 <_svfiprintf_r+0x44>
   21bae:	9b04      	ldr	r3, [sp, #16]
   21bb0:	9802      	ldr	r0, [sp, #8]
   21bb2:	1c31      	adds	r1, r6, #0
   21bb4:	1c3a      	adds	r2, r7, #0
   21bb6:	f7ff ff6d 	bl	21a94 <__ssputs_r>
   21bba:	1c43      	adds	r3, r0, #1
   21bbc:	d100      	bne.n	21bc0 <_svfiprintf_r+0x6c>
   21bbe:	e0ac      	b.n	21d1a <_svfiprintf_r+0x1c6>
   21bc0:	696a      	ldr	r2, [r5, #20]
   21bc2:	9b04      	ldr	r3, [sp, #16]
   21bc4:	4694      	mov	ip, r2
   21bc6:	4463      	add	r3, ip
   21bc8:	616b      	str	r3, [r5, #20]
   21bca:	7823      	ldrb	r3, [r4, #0]
   21bcc:	2b00      	cmp	r3, #0
   21bce:	d100      	bne.n	21bd2 <_svfiprintf_r+0x7e>
   21bd0:	e0a3      	b.n	21d1a <_svfiprintf_r+0x1c6>
   21bd2:	2201      	movs	r2, #1
   21bd4:	2300      	movs	r3, #0
   21bd6:	4252      	negs	r2, r2
   21bd8:	606a      	str	r2, [r5, #4]
   21bda:	a902      	add	r1, sp, #8
   21bdc:	3254      	adds	r2, #84	; 0x54
   21bde:	1852      	adds	r2, r2, r1
   21be0:	3401      	adds	r4, #1
   21be2:	602b      	str	r3, [r5, #0]
   21be4:	60eb      	str	r3, [r5, #12]
   21be6:	60ab      	str	r3, [r5, #8]
   21be8:	7013      	strb	r3, [r2, #0]
   21bea:	65ab      	str	r3, [r5, #88]	; 0x58
   21bec:	4f4f      	ldr	r7, [pc, #316]	; (21d2c <_svfiprintf_r+0x1d8>)
   21bee:	7821      	ldrb	r1, [r4, #0]
   21bf0:	1c38      	adds	r0, r7, #0
   21bf2:	2205      	movs	r2, #5
   21bf4:	f7ff fcf4 	bl	215e0 <memchr>
   21bf8:	2800      	cmp	r0, #0
   21bfa:	d008      	beq.n	21c0e <_svfiprintf_r+0xba>
   21bfc:	1bc0      	subs	r0, r0, r7
   21bfe:	2701      	movs	r7, #1
   21c00:	4087      	lsls	r7, r0
   21c02:	1c38      	adds	r0, r7, #0
   21c04:	682b      	ldr	r3, [r5, #0]
   21c06:	3401      	adds	r4, #1
   21c08:	4318      	orrs	r0, r3
   21c0a:	6028      	str	r0, [r5, #0]
   21c0c:	e7ee      	b.n	21bec <_svfiprintf_r+0x98>
   21c0e:	682b      	ldr	r3, [r5, #0]
   21c10:	06da      	lsls	r2, r3, #27
   21c12:	d504      	bpl.n	21c1e <_svfiprintf_r+0xca>
   21c14:	2253      	movs	r2, #83	; 0x53
   21c16:	2120      	movs	r1, #32
   21c18:	a802      	add	r0, sp, #8
   21c1a:	1812      	adds	r2, r2, r0
   21c1c:	7011      	strb	r1, [r2, #0]
   21c1e:	071a      	lsls	r2, r3, #28
   21c20:	d504      	bpl.n	21c2c <_svfiprintf_r+0xd8>
   21c22:	2253      	movs	r2, #83	; 0x53
   21c24:	212b      	movs	r1, #43	; 0x2b
   21c26:	a802      	add	r0, sp, #8
   21c28:	1812      	adds	r2, r2, r0
   21c2a:	7011      	strb	r1, [r2, #0]
   21c2c:	7822      	ldrb	r2, [r4, #0]
   21c2e:	2a2a      	cmp	r2, #42	; 0x2a
   21c30:	d001      	beq.n	21c36 <_svfiprintf_r+0xe2>
   21c32:	9b09      	ldr	r3, [sp, #36]	; 0x24
   21c34:	e00e      	b.n	21c54 <_svfiprintf_r+0x100>
   21c36:	9a05      	ldr	r2, [sp, #20]
   21c38:	1d11      	adds	r1, r2, #4
   21c3a:	6812      	ldr	r2, [r2, #0]
   21c3c:	9105      	str	r1, [sp, #20]
   21c3e:	2a00      	cmp	r2, #0
   21c40:	db01      	blt.n	21c46 <_svfiprintf_r+0xf2>
   21c42:	9209      	str	r2, [sp, #36]	; 0x24
   21c44:	e004      	b.n	21c50 <_svfiprintf_r+0xfc>
   21c46:	4252      	negs	r2, r2
   21c48:	60ea      	str	r2, [r5, #12]
   21c4a:	2202      	movs	r2, #2
   21c4c:	4313      	orrs	r3, r2
   21c4e:	602b      	str	r3, [r5, #0]
   21c50:	3401      	adds	r4, #1
   21c52:	e009      	b.n	21c68 <_svfiprintf_r+0x114>
   21c54:	7822      	ldrb	r2, [r4, #0]
   21c56:	3a30      	subs	r2, #48	; 0x30
   21c58:	2a09      	cmp	r2, #9
   21c5a:	d804      	bhi.n	21c66 <_svfiprintf_r+0x112>
   21c5c:	210a      	movs	r1, #10
   21c5e:	434b      	muls	r3, r1
   21c60:	3401      	adds	r4, #1
   21c62:	189b      	adds	r3, r3, r2
   21c64:	e7f6      	b.n	21c54 <_svfiprintf_r+0x100>
   21c66:	9309      	str	r3, [sp, #36]	; 0x24
   21c68:	7823      	ldrb	r3, [r4, #0]
   21c6a:	2b2e      	cmp	r3, #46	; 0x2e
   21c6c:	d118      	bne.n	21ca0 <_svfiprintf_r+0x14c>
   21c6e:	7863      	ldrb	r3, [r4, #1]
   21c70:	2b2a      	cmp	r3, #42	; 0x2a
   21c72:	d109      	bne.n	21c88 <_svfiprintf_r+0x134>
   21c74:	9b05      	ldr	r3, [sp, #20]
   21c76:	3402      	adds	r4, #2
   21c78:	1d1a      	adds	r2, r3, #4
   21c7a:	681b      	ldr	r3, [r3, #0]
   21c7c:	9205      	str	r2, [sp, #20]
   21c7e:	2b00      	cmp	r3, #0
   21c80:	da0d      	bge.n	21c9e <_svfiprintf_r+0x14a>
   21c82:	2301      	movs	r3, #1
   21c84:	425b      	negs	r3, r3
   21c86:	e00a      	b.n	21c9e <_svfiprintf_r+0x14a>
   21c88:	2300      	movs	r3, #0
   21c8a:	3401      	adds	r4, #1
   21c8c:	7822      	ldrb	r2, [r4, #0]
   21c8e:	3a30      	subs	r2, #48	; 0x30
   21c90:	2a09      	cmp	r2, #9
   21c92:	d804      	bhi.n	21c9e <_svfiprintf_r+0x14a>
   21c94:	210a      	movs	r1, #10
   21c96:	434b      	muls	r3, r1
   21c98:	3401      	adds	r4, #1
   21c9a:	189b      	adds	r3, r3, r2
   21c9c:	e7f6      	b.n	21c8c <_svfiprintf_r+0x138>
   21c9e:	9307      	str	r3, [sp, #28]
   21ca0:	4f23      	ldr	r7, [pc, #140]	; (21d30 <_svfiprintf_r+0x1dc>)
   21ca2:	7821      	ldrb	r1, [r4, #0]
   21ca4:	1c38      	adds	r0, r7, #0
   21ca6:	2203      	movs	r2, #3
   21ca8:	f7ff fc9a 	bl	215e0 <memchr>
   21cac:	2800      	cmp	r0, #0
   21cae:	d007      	beq.n	21cc0 <_svfiprintf_r+0x16c>
   21cb0:	1bc0      	subs	r0, r0, r7
   21cb2:	2740      	movs	r7, #64	; 0x40
   21cb4:	4087      	lsls	r7, r0
   21cb6:	1c38      	adds	r0, r7, #0
   21cb8:	682b      	ldr	r3, [r5, #0]
   21cba:	3401      	adds	r4, #1
   21cbc:	4318      	orrs	r0, r3
   21cbe:	6028      	str	r0, [r5, #0]
   21cc0:	7821      	ldrb	r1, [r4, #0]
   21cc2:	481c      	ldr	r0, [pc, #112]	; (21d34 <_svfiprintf_r+0x1e0>)
   21cc4:	2206      	movs	r2, #6
   21cc6:	1c67      	adds	r7, r4, #1
   21cc8:	7629      	strb	r1, [r5, #24]
   21cca:	f7ff fc89 	bl	215e0 <memchr>
   21cce:	2800      	cmp	r0, #0
   21cd0:	d012      	beq.n	21cf8 <_svfiprintf_r+0x1a4>
   21cd2:	4b19      	ldr	r3, [pc, #100]	; (21d38 <_svfiprintf_r+0x1e4>)
   21cd4:	2b00      	cmp	r3, #0
   21cd6:	d106      	bne.n	21ce6 <_svfiprintf_r+0x192>
   21cd8:	2207      	movs	r2, #7
   21cda:	9b05      	ldr	r3, [sp, #20]
   21cdc:	3307      	adds	r3, #7
   21cde:	4393      	bics	r3, r2
   21ce0:	3308      	adds	r3, #8
   21ce2:	9305      	str	r3, [sp, #20]
   21ce4:	e014      	b.n	21d10 <_svfiprintf_r+0x1bc>
   21ce6:	ab05      	add	r3, sp, #20
   21ce8:	9300      	str	r3, [sp, #0]
   21cea:	9802      	ldr	r0, [sp, #8]
   21cec:	1c29      	adds	r1, r5, #0
   21cee:	1c32      	adds	r2, r6, #0
   21cf0:	4b12      	ldr	r3, [pc, #72]	; (21d3c <_svfiprintf_r+0x1e8>)
   21cf2:	e000      	b.n	21cf6 <_svfiprintf_r+0x1a2>
   21cf4:	bf00      	nop
   21cf6:	e007      	b.n	21d08 <_svfiprintf_r+0x1b4>
   21cf8:	ab05      	add	r3, sp, #20
   21cfa:	9300      	str	r3, [sp, #0]
   21cfc:	9802      	ldr	r0, [sp, #8]
   21cfe:	1c29      	adds	r1, r5, #0
   21d00:	1c32      	adds	r2, r6, #0
   21d02:	4b0e      	ldr	r3, [pc, #56]	; (21d3c <_svfiprintf_r+0x1e8>)
   21d04:	f000 f88a 	bl	21e1c <_printf_i>
   21d08:	9003      	str	r0, [sp, #12]
   21d0a:	9b03      	ldr	r3, [sp, #12]
   21d0c:	3301      	adds	r3, #1
   21d0e:	d004      	beq.n	21d1a <_svfiprintf_r+0x1c6>
   21d10:	696b      	ldr	r3, [r5, #20]
   21d12:	9a03      	ldr	r2, [sp, #12]
   21d14:	189b      	adds	r3, r3, r2
   21d16:	616b      	str	r3, [r5, #20]
   21d18:	e73d      	b.n	21b96 <_svfiprintf_r+0x42>
   21d1a:	89b3      	ldrh	r3, [r6, #12]
   21d1c:	980b      	ldr	r0, [sp, #44]	; 0x2c
   21d1e:	065b      	lsls	r3, r3, #25
   21d20:	d501      	bpl.n	21d26 <_svfiprintf_r+0x1d2>
   21d22:	2001      	movs	r0, #1
   21d24:	4240      	negs	r0, r0
   21d26:	b01f      	add	sp, #124	; 0x7c
   21d28:	bdf0      	pop	{r4, r5, r6, r7, pc}
   21d2a:	46c0      	nop			; (mov r8, r8)
   21d2c:	00022f2c 	.word	0x00022f2c
   21d30:	00022f32 	.word	0x00022f32
   21d34:	00022f36 	.word	0x00022f36
   21d38:	00000000 	.word	0x00000000
   21d3c:	00021a95 	.word	0x00021a95

00021d40 <_printf_common>:
   21d40:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   21d42:	1c17      	adds	r7, r2, #0
   21d44:	9301      	str	r3, [sp, #4]
   21d46:	690a      	ldr	r2, [r1, #16]
   21d48:	688b      	ldr	r3, [r1, #8]
   21d4a:	9000      	str	r0, [sp, #0]
   21d4c:	1c0c      	adds	r4, r1, #0
   21d4e:	4293      	cmp	r3, r2
   21d50:	da00      	bge.n	21d54 <_printf_common+0x14>
   21d52:	1c13      	adds	r3, r2, #0
   21d54:	1c22      	adds	r2, r4, #0
   21d56:	603b      	str	r3, [r7, #0]
   21d58:	3243      	adds	r2, #67	; 0x43
   21d5a:	7812      	ldrb	r2, [r2, #0]
   21d5c:	2a00      	cmp	r2, #0
   21d5e:	d001      	beq.n	21d64 <_printf_common+0x24>
   21d60:	3301      	adds	r3, #1
   21d62:	603b      	str	r3, [r7, #0]
   21d64:	6823      	ldr	r3, [r4, #0]
   21d66:	069b      	lsls	r3, r3, #26
   21d68:	d502      	bpl.n	21d70 <_printf_common+0x30>
   21d6a:	683b      	ldr	r3, [r7, #0]
   21d6c:	3302      	adds	r3, #2
   21d6e:	603b      	str	r3, [r7, #0]
   21d70:	2506      	movs	r5, #6
   21d72:	6823      	ldr	r3, [r4, #0]
   21d74:	401d      	ands	r5, r3
   21d76:	d01e      	beq.n	21db6 <_printf_common+0x76>
   21d78:	1c23      	adds	r3, r4, #0
   21d7a:	3343      	adds	r3, #67	; 0x43
   21d7c:	781b      	ldrb	r3, [r3, #0]
   21d7e:	1e5a      	subs	r2, r3, #1
   21d80:	4193      	sbcs	r3, r2
   21d82:	6822      	ldr	r2, [r4, #0]
   21d84:	0692      	lsls	r2, r2, #26
   21d86:	d51c      	bpl.n	21dc2 <_printf_common+0x82>
   21d88:	2030      	movs	r0, #48	; 0x30
   21d8a:	18e1      	adds	r1, r4, r3
   21d8c:	3140      	adds	r1, #64	; 0x40
   21d8e:	70c8      	strb	r0, [r1, #3]
   21d90:	1c21      	adds	r1, r4, #0
   21d92:	1c5a      	adds	r2, r3, #1
   21d94:	3145      	adds	r1, #69	; 0x45
   21d96:	7809      	ldrb	r1, [r1, #0]
   21d98:	18a2      	adds	r2, r4, r2
   21d9a:	3240      	adds	r2, #64	; 0x40
   21d9c:	3302      	adds	r3, #2
   21d9e:	70d1      	strb	r1, [r2, #3]
   21da0:	e00f      	b.n	21dc2 <_printf_common+0x82>
   21da2:	1c22      	adds	r2, r4, #0
   21da4:	2301      	movs	r3, #1
   21da6:	9800      	ldr	r0, [sp, #0]
   21da8:	9901      	ldr	r1, [sp, #4]
   21daa:	3219      	adds	r2, #25
   21dac:	9e08      	ldr	r6, [sp, #32]
   21dae:	47b0      	blx	r6
   21db0:	1c43      	adds	r3, r0, #1
   21db2:	d00e      	beq.n	21dd2 <_printf_common+0x92>
   21db4:	3501      	adds	r5, #1
   21db6:	68e3      	ldr	r3, [r4, #12]
   21db8:	683a      	ldr	r2, [r7, #0]
   21dba:	1a9b      	subs	r3, r3, r2
   21dbc:	429d      	cmp	r5, r3
   21dbe:	dbf0      	blt.n	21da2 <_printf_common+0x62>
   21dc0:	e7da      	b.n	21d78 <_printf_common+0x38>
   21dc2:	1c22      	adds	r2, r4, #0
   21dc4:	9800      	ldr	r0, [sp, #0]
   21dc6:	9901      	ldr	r1, [sp, #4]
   21dc8:	3243      	adds	r2, #67	; 0x43
   21dca:	9d08      	ldr	r5, [sp, #32]
   21dcc:	47a8      	blx	r5
   21dce:	1c43      	adds	r3, r0, #1
   21dd0:	d102      	bne.n	21dd8 <_printf_common+0x98>
   21dd2:	2001      	movs	r0, #1
   21dd4:	4240      	negs	r0, r0
   21dd6:	e020      	b.n	21e1a <_printf_common+0xda>
   21dd8:	2306      	movs	r3, #6
   21dda:	6820      	ldr	r0, [r4, #0]
   21ddc:	68e1      	ldr	r1, [r4, #12]
   21dde:	683a      	ldr	r2, [r7, #0]
   21de0:	4003      	ands	r3, r0
   21de2:	2500      	movs	r5, #0
   21de4:	2b04      	cmp	r3, #4
   21de6:	d103      	bne.n	21df0 <_printf_common+0xb0>
   21de8:	1a8d      	subs	r5, r1, r2
   21dea:	43eb      	mvns	r3, r5
   21dec:	17db      	asrs	r3, r3, #31
   21dee:	401d      	ands	r5, r3
   21df0:	68a3      	ldr	r3, [r4, #8]
   21df2:	6922      	ldr	r2, [r4, #16]
   21df4:	4293      	cmp	r3, r2
   21df6:	dd01      	ble.n	21dfc <_printf_common+0xbc>
   21df8:	1a9b      	subs	r3, r3, r2
   21dfa:	18ed      	adds	r5, r5, r3
   21dfc:	2700      	movs	r7, #0
   21dfe:	42af      	cmp	r7, r5
   21e00:	da0a      	bge.n	21e18 <_printf_common+0xd8>
   21e02:	1c22      	adds	r2, r4, #0
   21e04:	2301      	movs	r3, #1
   21e06:	9800      	ldr	r0, [sp, #0]
   21e08:	9901      	ldr	r1, [sp, #4]
   21e0a:	321a      	adds	r2, #26
   21e0c:	9e08      	ldr	r6, [sp, #32]
   21e0e:	47b0      	blx	r6
   21e10:	1c43      	adds	r3, r0, #1
   21e12:	d0de      	beq.n	21dd2 <_printf_common+0x92>
   21e14:	3701      	adds	r7, #1
   21e16:	e7f2      	b.n	21dfe <_printf_common+0xbe>
   21e18:	2000      	movs	r0, #0
   21e1a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

00021e1c <_printf_i>:
   21e1c:	b5f0      	push	{r4, r5, r6, r7, lr}
   21e1e:	b08b      	sub	sp, #44	; 0x2c
   21e20:	9206      	str	r2, [sp, #24]
   21e22:	1c0a      	adds	r2, r1, #0
   21e24:	3243      	adds	r2, #67	; 0x43
   21e26:	9307      	str	r3, [sp, #28]
   21e28:	9005      	str	r0, [sp, #20]
   21e2a:	9204      	str	r2, [sp, #16]
   21e2c:	7e0a      	ldrb	r2, [r1, #24]
   21e2e:	1c0c      	adds	r4, r1, #0
   21e30:	9b10      	ldr	r3, [sp, #64]	; 0x40
   21e32:	2a6e      	cmp	r2, #110	; 0x6e
   21e34:	d100      	bne.n	21e38 <_printf_i+0x1c>
   21e36:	e0a8      	b.n	21f8a <_printf_i+0x16e>
   21e38:	d811      	bhi.n	21e5e <_printf_i+0x42>
   21e3a:	2a63      	cmp	r2, #99	; 0x63
   21e3c:	d022      	beq.n	21e84 <_printf_i+0x68>
   21e3e:	d809      	bhi.n	21e54 <_printf_i+0x38>
   21e40:	2a00      	cmp	r2, #0
   21e42:	d100      	bne.n	21e46 <_printf_i+0x2a>
   21e44:	e0b2      	b.n	21fac <_printf_i+0x190>
   21e46:	2a58      	cmp	r2, #88	; 0x58
   21e48:	d000      	beq.n	21e4c <_printf_i+0x30>
   21e4a:	e0c2      	b.n	21fd2 <_printf_i+0x1b6>
   21e4c:	3145      	adds	r1, #69	; 0x45
   21e4e:	700a      	strb	r2, [r1, #0]
   21e50:	4a7c      	ldr	r2, [pc, #496]	; (22044 <_printf_i+0x228>)
   21e52:	e04f      	b.n	21ef4 <_printf_i+0xd8>
   21e54:	2a64      	cmp	r2, #100	; 0x64
   21e56:	d01d      	beq.n	21e94 <_printf_i+0x78>
   21e58:	2a69      	cmp	r2, #105	; 0x69
   21e5a:	d01b      	beq.n	21e94 <_printf_i+0x78>
   21e5c:	e0b9      	b.n	21fd2 <_printf_i+0x1b6>
   21e5e:	2a73      	cmp	r2, #115	; 0x73
   21e60:	d100      	bne.n	21e64 <_printf_i+0x48>
   21e62:	e0a7      	b.n	21fb4 <_printf_i+0x198>
   21e64:	d809      	bhi.n	21e7a <_printf_i+0x5e>
   21e66:	2a6f      	cmp	r2, #111	; 0x6f
   21e68:	d029      	beq.n	21ebe <_printf_i+0xa2>
   21e6a:	2a70      	cmp	r2, #112	; 0x70
   21e6c:	d000      	beq.n	21e70 <_printf_i+0x54>
   21e6e:	e0b0      	b.n	21fd2 <_printf_i+0x1b6>
   21e70:	2220      	movs	r2, #32
   21e72:	6809      	ldr	r1, [r1, #0]
   21e74:	430a      	orrs	r2, r1
   21e76:	6022      	str	r2, [r4, #0]
   21e78:	e037      	b.n	21eea <_printf_i+0xce>
   21e7a:	2a75      	cmp	r2, #117	; 0x75
   21e7c:	d01f      	beq.n	21ebe <_printf_i+0xa2>
   21e7e:	2a78      	cmp	r2, #120	; 0x78
   21e80:	d033      	beq.n	21eea <_printf_i+0xce>
   21e82:	e0a6      	b.n	21fd2 <_printf_i+0x1b6>
   21e84:	1c0e      	adds	r6, r1, #0
   21e86:	681a      	ldr	r2, [r3, #0]
   21e88:	3642      	adds	r6, #66	; 0x42
   21e8a:	1d11      	adds	r1, r2, #4
   21e8c:	6019      	str	r1, [r3, #0]
   21e8e:	6813      	ldr	r3, [r2, #0]
   21e90:	7033      	strb	r3, [r6, #0]
   21e92:	e0a1      	b.n	21fd8 <_printf_i+0x1bc>
   21e94:	6821      	ldr	r1, [r4, #0]
   21e96:	681a      	ldr	r2, [r3, #0]
   21e98:	0608      	lsls	r0, r1, #24
   21e9a:	d406      	bmi.n	21eaa <_printf_i+0x8e>
   21e9c:	0649      	lsls	r1, r1, #25
   21e9e:	d504      	bpl.n	21eaa <_printf_i+0x8e>
   21ea0:	1d11      	adds	r1, r2, #4
   21ea2:	6019      	str	r1, [r3, #0]
   21ea4:	2300      	movs	r3, #0
   21ea6:	5ed5      	ldrsh	r5, [r2, r3]
   21ea8:	e002      	b.n	21eb0 <_printf_i+0x94>
   21eaa:	1d11      	adds	r1, r2, #4
   21eac:	6019      	str	r1, [r3, #0]
   21eae:	6815      	ldr	r5, [r2, #0]
   21eb0:	2d00      	cmp	r5, #0
   21eb2:	da3b      	bge.n	21f2c <_printf_i+0x110>
   21eb4:	232d      	movs	r3, #45	; 0x2d
   21eb6:	9a04      	ldr	r2, [sp, #16]
   21eb8:	426d      	negs	r5, r5
   21eba:	7013      	strb	r3, [r2, #0]
   21ebc:	e036      	b.n	21f2c <_printf_i+0x110>
   21ebe:	6821      	ldr	r1, [r4, #0]
   21ec0:	681a      	ldr	r2, [r3, #0]
   21ec2:	0608      	lsls	r0, r1, #24
   21ec4:	d406      	bmi.n	21ed4 <_printf_i+0xb8>
   21ec6:	0649      	lsls	r1, r1, #25
   21ec8:	d504      	bpl.n	21ed4 <_printf_i+0xb8>
   21eca:	6815      	ldr	r5, [r2, #0]
   21ecc:	1d11      	adds	r1, r2, #4
   21ece:	6019      	str	r1, [r3, #0]
   21ed0:	b2ad      	uxth	r5, r5
   21ed2:	e002      	b.n	21eda <_printf_i+0xbe>
   21ed4:	1d11      	adds	r1, r2, #4
   21ed6:	6019      	str	r1, [r3, #0]
   21ed8:	6815      	ldr	r5, [r2, #0]
   21eda:	4b5a      	ldr	r3, [pc, #360]	; (22044 <_printf_i+0x228>)
   21edc:	7e22      	ldrb	r2, [r4, #24]
   21ede:	9303      	str	r3, [sp, #12]
   21ee0:	270a      	movs	r7, #10
   21ee2:	2a6f      	cmp	r2, #111	; 0x6f
   21ee4:	d11d      	bne.n	21f22 <_printf_i+0x106>
   21ee6:	2708      	movs	r7, #8
   21ee8:	e01b      	b.n	21f22 <_printf_i+0x106>
   21eea:	1c22      	adds	r2, r4, #0
   21eec:	2178      	movs	r1, #120	; 0x78
   21eee:	3245      	adds	r2, #69	; 0x45
   21ef0:	7011      	strb	r1, [r2, #0]
   21ef2:	4a55      	ldr	r2, [pc, #340]	; (22048 <_printf_i+0x22c>)
   21ef4:	6819      	ldr	r1, [r3, #0]
   21ef6:	9203      	str	r2, [sp, #12]
   21ef8:	1d08      	adds	r0, r1, #4
   21efa:	6822      	ldr	r2, [r4, #0]
   21efc:	6018      	str	r0, [r3, #0]
   21efe:	680d      	ldr	r5, [r1, #0]
   21f00:	0610      	lsls	r0, r2, #24
   21f02:	d402      	bmi.n	21f0a <_printf_i+0xee>
   21f04:	0650      	lsls	r0, r2, #25
   21f06:	d500      	bpl.n	21f0a <_printf_i+0xee>
   21f08:	b2ad      	uxth	r5, r5
   21f0a:	07d3      	lsls	r3, r2, #31
   21f0c:	d502      	bpl.n	21f14 <_printf_i+0xf8>
   21f0e:	2320      	movs	r3, #32
   21f10:	431a      	orrs	r2, r3
   21f12:	6022      	str	r2, [r4, #0]
   21f14:	2710      	movs	r7, #16
   21f16:	2d00      	cmp	r5, #0
   21f18:	d103      	bne.n	21f22 <_printf_i+0x106>
   21f1a:	2320      	movs	r3, #32
   21f1c:	6822      	ldr	r2, [r4, #0]
   21f1e:	439a      	bics	r2, r3
   21f20:	6022      	str	r2, [r4, #0]
   21f22:	1c23      	adds	r3, r4, #0
   21f24:	2200      	movs	r2, #0
   21f26:	3343      	adds	r3, #67	; 0x43
   21f28:	701a      	strb	r2, [r3, #0]
   21f2a:	e002      	b.n	21f32 <_printf_i+0x116>
   21f2c:	270a      	movs	r7, #10
   21f2e:	4b45      	ldr	r3, [pc, #276]	; (22044 <_printf_i+0x228>)
   21f30:	9303      	str	r3, [sp, #12]
   21f32:	6863      	ldr	r3, [r4, #4]
   21f34:	60a3      	str	r3, [r4, #8]
   21f36:	2b00      	cmp	r3, #0
   21f38:	db03      	blt.n	21f42 <_printf_i+0x126>
   21f3a:	2204      	movs	r2, #4
   21f3c:	6821      	ldr	r1, [r4, #0]
   21f3e:	4391      	bics	r1, r2
   21f40:	6021      	str	r1, [r4, #0]
   21f42:	2d00      	cmp	r5, #0
   21f44:	d102      	bne.n	21f4c <_printf_i+0x130>
   21f46:	9e04      	ldr	r6, [sp, #16]
   21f48:	2b00      	cmp	r3, #0
   21f4a:	d00e      	beq.n	21f6a <_printf_i+0x14e>
   21f4c:	9e04      	ldr	r6, [sp, #16]
   21f4e:	1c28      	adds	r0, r5, #0
   21f50:	1c39      	adds	r1, r7, #0
   21f52:	f000 f917 	bl	22184 <__aeabi_uidivmod>
   21f56:	9b03      	ldr	r3, [sp, #12]
   21f58:	3e01      	subs	r6, #1
   21f5a:	5c5b      	ldrb	r3, [r3, r1]
   21f5c:	1c28      	adds	r0, r5, #0
   21f5e:	7033      	strb	r3, [r6, #0]
   21f60:	1c39      	adds	r1, r7, #0
   21f62:	f000 f889 	bl	22078 <__aeabi_uidiv>
   21f66:	1e05      	subs	r5, r0, #0
   21f68:	d1f1      	bne.n	21f4e <_printf_i+0x132>
   21f6a:	2f08      	cmp	r7, #8
   21f6c:	d109      	bne.n	21f82 <_printf_i+0x166>
   21f6e:	6823      	ldr	r3, [r4, #0]
   21f70:	07db      	lsls	r3, r3, #31
   21f72:	d506      	bpl.n	21f82 <_printf_i+0x166>
   21f74:	6863      	ldr	r3, [r4, #4]
   21f76:	6922      	ldr	r2, [r4, #16]
   21f78:	4293      	cmp	r3, r2
   21f7a:	dc02      	bgt.n	21f82 <_printf_i+0x166>
   21f7c:	2330      	movs	r3, #48	; 0x30
   21f7e:	3e01      	subs	r6, #1
   21f80:	7033      	strb	r3, [r6, #0]
   21f82:	9b04      	ldr	r3, [sp, #16]
   21f84:	1b9b      	subs	r3, r3, r6
   21f86:	6123      	str	r3, [r4, #16]
   21f88:	e02b      	b.n	21fe2 <_printf_i+0x1c6>
   21f8a:	6809      	ldr	r1, [r1, #0]
   21f8c:	681a      	ldr	r2, [r3, #0]
   21f8e:	0608      	lsls	r0, r1, #24
   21f90:	d407      	bmi.n	21fa2 <_printf_i+0x186>
   21f92:	0649      	lsls	r1, r1, #25
   21f94:	d505      	bpl.n	21fa2 <_printf_i+0x186>
   21f96:	1d11      	adds	r1, r2, #4
   21f98:	6019      	str	r1, [r3, #0]
   21f9a:	6813      	ldr	r3, [r2, #0]
   21f9c:	8aa2      	ldrh	r2, [r4, #20]
   21f9e:	801a      	strh	r2, [r3, #0]
   21fa0:	e004      	b.n	21fac <_printf_i+0x190>
   21fa2:	1d11      	adds	r1, r2, #4
   21fa4:	6019      	str	r1, [r3, #0]
   21fa6:	6813      	ldr	r3, [r2, #0]
   21fa8:	6962      	ldr	r2, [r4, #20]
   21faa:	601a      	str	r2, [r3, #0]
   21fac:	2300      	movs	r3, #0
   21fae:	9e04      	ldr	r6, [sp, #16]
   21fb0:	6123      	str	r3, [r4, #16]
   21fb2:	e016      	b.n	21fe2 <_printf_i+0x1c6>
   21fb4:	681a      	ldr	r2, [r3, #0]
   21fb6:	1d11      	adds	r1, r2, #4
   21fb8:	6019      	str	r1, [r3, #0]
   21fba:	6816      	ldr	r6, [r2, #0]
   21fbc:	2100      	movs	r1, #0
   21fbe:	1c30      	adds	r0, r6, #0
   21fc0:	6862      	ldr	r2, [r4, #4]
   21fc2:	f7ff fb0d 	bl	215e0 <memchr>
   21fc6:	2800      	cmp	r0, #0
   21fc8:	d001      	beq.n	21fce <_printf_i+0x1b2>
   21fca:	1b80      	subs	r0, r0, r6
   21fcc:	6060      	str	r0, [r4, #4]
   21fce:	6863      	ldr	r3, [r4, #4]
   21fd0:	e003      	b.n	21fda <_printf_i+0x1be>
   21fd2:	1c26      	adds	r6, r4, #0
   21fd4:	3642      	adds	r6, #66	; 0x42
   21fd6:	7032      	strb	r2, [r6, #0]
   21fd8:	2301      	movs	r3, #1
   21fda:	6123      	str	r3, [r4, #16]
   21fdc:	2300      	movs	r3, #0
   21fde:	9a04      	ldr	r2, [sp, #16]
   21fe0:	7013      	strb	r3, [r2, #0]
   21fe2:	9b07      	ldr	r3, [sp, #28]
   21fe4:	9805      	ldr	r0, [sp, #20]
   21fe6:	9300      	str	r3, [sp, #0]
   21fe8:	1c21      	adds	r1, r4, #0
   21fea:	9b06      	ldr	r3, [sp, #24]
   21fec:	aa09      	add	r2, sp, #36	; 0x24
   21fee:	f7ff fea7 	bl	21d40 <_printf_common>
   21ff2:	1c43      	adds	r3, r0, #1
   21ff4:	d102      	bne.n	21ffc <_printf_i+0x1e0>
   21ff6:	2001      	movs	r0, #1
   21ff8:	4240      	negs	r0, r0
   21ffa:	e021      	b.n	22040 <_printf_i+0x224>
   21ffc:	6923      	ldr	r3, [r4, #16]
   21ffe:	9805      	ldr	r0, [sp, #20]
   22000:	9906      	ldr	r1, [sp, #24]
   22002:	1c32      	adds	r2, r6, #0
   22004:	9d07      	ldr	r5, [sp, #28]
   22006:	47a8      	blx	r5
   22008:	1c43      	adds	r3, r0, #1
   2200a:	d0f4      	beq.n	21ff6 <_printf_i+0x1da>
   2200c:	6823      	ldr	r3, [r4, #0]
   2200e:	079b      	lsls	r3, r3, #30
   22010:	d405      	bmi.n	2201e <_printf_i+0x202>
   22012:	9b09      	ldr	r3, [sp, #36]	; 0x24
   22014:	68e0      	ldr	r0, [r4, #12]
   22016:	4298      	cmp	r0, r3
   22018:	da12      	bge.n	22040 <_printf_i+0x224>
   2201a:	1c18      	adds	r0, r3, #0
   2201c:	e010      	b.n	22040 <_printf_i+0x224>
   2201e:	2500      	movs	r5, #0
   22020:	68e3      	ldr	r3, [r4, #12]
   22022:	9a09      	ldr	r2, [sp, #36]	; 0x24
   22024:	1a9b      	subs	r3, r3, r2
   22026:	429d      	cmp	r5, r3
   22028:	daf3      	bge.n	22012 <_printf_i+0x1f6>
   2202a:	1c22      	adds	r2, r4, #0
   2202c:	2301      	movs	r3, #1
   2202e:	9805      	ldr	r0, [sp, #20]
   22030:	9906      	ldr	r1, [sp, #24]
   22032:	3219      	adds	r2, #25
   22034:	9e07      	ldr	r6, [sp, #28]
   22036:	47b0      	blx	r6
   22038:	1c43      	adds	r3, r0, #1
   2203a:	d0dc      	beq.n	21ff6 <_printf_i+0x1da>
   2203c:	3501      	adds	r5, #1
   2203e:	e7ef      	b.n	22020 <_printf_i+0x204>
   22040:	b00b      	add	sp, #44	; 0x2c
   22042:	bdf0      	pop	{r4, r5, r6, r7, pc}
   22044:	00022f3d 	.word	0x00022f3d
   22048:	00022f4e 	.word	0x00022f4e

0002204c <_malloc_usable_size_r>:
   2204c:	1f0b      	subs	r3, r1, #4
   2204e:	681a      	ldr	r2, [r3, #0]
   22050:	1f10      	subs	r0, r2, #4
   22052:	2a00      	cmp	r2, #0
   22054:	da04      	bge.n	22060 <_malloc_usable_size_r+0x14>
   22056:	1889      	adds	r1, r1, r2
   22058:	3904      	subs	r1, #4
   2205a:	680b      	ldr	r3, [r1, #0]
   2205c:	18d0      	adds	r0, r2, r3
   2205e:	3804      	subs	r0, #4
   22060:	4770      	bx	lr
	...

00022064 <__gnu_thumb1_case_uqi>:
   22064:	b402      	push	{r1}
   22066:	4671      	mov	r1, lr
   22068:	0849      	lsrs	r1, r1, #1
   2206a:	0049      	lsls	r1, r1, #1
   2206c:	5c09      	ldrb	r1, [r1, r0]
   2206e:	0049      	lsls	r1, r1, #1
   22070:	448e      	add	lr, r1
   22072:	bc02      	pop	{r1}
   22074:	4770      	bx	lr
   22076:	46c0      	nop			; (mov r8, r8)

00022078 <__aeabi_uidiv>:
   22078:	2200      	movs	r2, #0
   2207a:	0843      	lsrs	r3, r0, #1
   2207c:	428b      	cmp	r3, r1
   2207e:	d374      	bcc.n	2216a <__aeabi_uidiv+0xf2>
   22080:	0903      	lsrs	r3, r0, #4
   22082:	428b      	cmp	r3, r1
   22084:	d35f      	bcc.n	22146 <__aeabi_uidiv+0xce>
   22086:	0a03      	lsrs	r3, r0, #8
   22088:	428b      	cmp	r3, r1
   2208a:	d344      	bcc.n	22116 <__aeabi_uidiv+0x9e>
   2208c:	0b03      	lsrs	r3, r0, #12
   2208e:	428b      	cmp	r3, r1
   22090:	d328      	bcc.n	220e4 <__aeabi_uidiv+0x6c>
   22092:	0c03      	lsrs	r3, r0, #16
   22094:	428b      	cmp	r3, r1
   22096:	d30d      	bcc.n	220b4 <__aeabi_uidiv+0x3c>
   22098:	22ff      	movs	r2, #255	; 0xff
   2209a:	0209      	lsls	r1, r1, #8
   2209c:	ba12      	rev	r2, r2
   2209e:	0c03      	lsrs	r3, r0, #16
   220a0:	428b      	cmp	r3, r1
   220a2:	d302      	bcc.n	220aa <__aeabi_uidiv+0x32>
   220a4:	1212      	asrs	r2, r2, #8
   220a6:	0209      	lsls	r1, r1, #8
   220a8:	d065      	beq.n	22176 <__aeabi_uidiv+0xfe>
   220aa:	0b03      	lsrs	r3, r0, #12
   220ac:	428b      	cmp	r3, r1
   220ae:	d319      	bcc.n	220e4 <__aeabi_uidiv+0x6c>
   220b0:	e000      	b.n	220b4 <__aeabi_uidiv+0x3c>
   220b2:	0a09      	lsrs	r1, r1, #8
   220b4:	0bc3      	lsrs	r3, r0, #15
   220b6:	428b      	cmp	r3, r1
   220b8:	d301      	bcc.n	220be <__aeabi_uidiv+0x46>
   220ba:	03cb      	lsls	r3, r1, #15
   220bc:	1ac0      	subs	r0, r0, r3
   220be:	4152      	adcs	r2, r2
   220c0:	0b83      	lsrs	r3, r0, #14
   220c2:	428b      	cmp	r3, r1
   220c4:	d301      	bcc.n	220ca <__aeabi_uidiv+0x52>
   220c6:	038b      	lsls	r3, r1, #14
   220c8:	1ac0      	subs	r0, r0, r3
   220ca:	4152      	adcs	r2, r2
   220cc:	0b43      	lsrs	r3, r0, #13
   220ce:	428b      	cmp	r3, r1
   220d0:	d301      	bcc.n	220d6 <__aeabi_uidiv+0x5e>
   220d2:	034b      	lsls	r3, r1, #13
   220d4:	1ac0      	subs	r0, r0, r3
   220d6:	4152      	adcs	r2, r2
   220d8:	0b03      	lsrs	r3, r0, #12
   220da:	428b      	cmp	r3, r1
   220dc:	d301      	bcc.n	220e2 <__aeabi_uidiv+0x6a>
   220de:	030b      	lsls	r3, r1, #12
   220e0:	1ac0      	subs	r0, r0, r3
   220e2:	4152      	adcs	r2, r2
   220e4:	0ac3      	lsrs	r3, r0, #11
   220e6:	428b      	cmp	r3, r1
   220e8:	d301      	bcc.n	220ee <__aeabi_uidiv+0x76>
   220ea:	02cb      	lsls	r3, r1, #11
   220ec:	1ac0      	subs	r0, r0, r3
   220ee:	4152      	adcs	r2, r2
   220f0:	0a83      	lsrs	r3, r0, #10
   220f2:	428b      	cmp	r3, r1
   220f4:	d301      	bcc.n	220fa <__aeabi_uidiv+0x82>
   220f6:	028b      	lsls	r3, r1, #10
   220f8:	1ac0      	subs	r0, r0, r3
   220fa:	4152      	adcs	r2, r2
   220fc:	0a43      	lsrs	r3, r0, #9
   220fe:	428b      	cmp	r3, r1
   22100:	d301      	bcc.n	22106 <__aeabi_uidiv+0x8e>
   22102:	024b      	lsls	r3, r1, #9
   22104:	1ac0      	subs	r0, r0, r3
   22106:	4152      	adcs	r2, r2
   22108:	0a03      	lsrs	r3, r0, #8
   2210a:	428b      	cmp	r3, r1
   2210c:	d301      	bcc.n	22112 <__aeabi_uidiv+0x9a>
   2210e:	020b      	lsls	r3, r1, #8
   22110:	1ac0      	subs	r0, r0, r3
   22112:	4152      	adcs	r2, r2
   22114:	d2cd      	bcs.n	220b2 <__aeabi_uidiv+0x3a>
   22116:	09c3      	lsrs	r3, r0, #7
   22118:	428b      	cmp	r3, r1
   2211a:	d301      	bcc.n	22120 <__aeabi_uidiv+0xa8>
   2211c:	01cb      	lsls	r3, r1, #7
   2211e:	1ac0      	subs	r0, r0, r3
   22120:	4152      	adcs	r2, r2
   22122:	0983      	lsrs	r3, r0, #6
   22124:	428b      	cmp	r3, r1
   22126:	d301      	bcc.n	2212c <__aeabi_uidiv+0xb4>
   22128:	018b      	lsls	r3, r1, #6
   2212a:	1ac0      	subs	r0, r0, r3
   2212c:	4152      	adcs	r2, r2
   2212e:	0943      	lsrs	r3, r0, #5
   22130:	428b      	cmp	r3, r1
   22132:	d301      	bcc.n	22138 <__aeabi_uidiv+0xc0>
   22134:	014b      	lsls	r3, r1, #5
   22136:	1ac0      	subs	r0, r0, r3
   22138:	4152      	adcs	r2, r2
   2213a:	0903      	lsrs	r3, r0, #4
   2213c:	428b      	cmp	r3, r1
   2213e:	d301      	bcc.n	22144 <__aeabi_uidiv+0xcc>
   22140:	010b      	lsls	r3, r1, #4
   22142:	1ac0      	subs	r0, r0, r3
   22144:	4152      	adcs	r2, r2
   22146:	08c3      	lsrs	r3, r0, #3
   22148:	428b      	cmp	r3, r1
   2214a:	d301      	bcc.n	22150 <__aeabi_uidiv+0xd8>
   2214c:	00cb      	lsls	r3, r1, #3
   2214e:	1ac0      	subs	r0, r0, r3
   22150:	4152      	adcs	r2, r2
   22152:	0883      	lsrs	r3, r0, #2
   22154:	428b      	cmp	r3, r1
   22156:	d301      	bcc.n	2215c <__aeabi_uidiv+0xe4>
   22158:	008b      	lsls	r3, r1, #2
   2215a:	1ac0      	subs	r0, r0, r3
   2215c:	4152      	adcs	r2, r2
   2215e:	0843      	lsrs	r3, r0, #1
   22160:	428b      	cmp	r3, r1
   22162:	d301      	bcc.n	22168 <__aeabi_uidiv+0xf0>
   22164:	004b      	lsls	r3, r1, #1
   22166:	1ac0      	subs	r0, r0, r3
   22168:	4152      	adcs	r2, r2
   2216a:	1a41      	subs	r1, r0, r1
   2216c:	d200      	bcs.n	22170 <__aeabi_uidiv+0xf8>
   2216e:	4601      	mov	r1, r0
   22170:	4152      	adcs	r2, r2
   22172:	4610      	mov	r0, r2
   22174:	4770      	bx	lr
   22176:	e7ff      	b.n	22178 <__aeabi_uidiv+0x100>
   22178:	b501      	push	{r0, lr}
   2217a:	2000      	movs	r0, #0
   2217c:	f000 f8fc 	bl	22378 <__aeabi_idiv0>
   22180:	bd02      	pop	{r1, pc}
   22182:	46c0      	nop			; (mov r8, r8)

00022184 <__aeabi_uidivmod>:
   22184:	2900      	cmp	r1, #0
   22186:	d0f7      	beq.n	22178 <__aeabi_uidiv+0x100>
   22188:	b503      	push	{r0, r1, lr}
   2218a:	f7ff ff75 	bl	22078 <__aeabi_uidiv>
   2218e:	bc0e      	pop	{r1, r2, r3}
   22190:	4342      	muls	r2, r0
   22192:	1a89      	subs	r1, r1, r2
   22194:	4718      	bx	r3
   22196:	46c0      	nop			; (mov r8, r8)

00022198 <__aeabi_idiv>:
   22198:	4603      	mov	r3, r0
   2219a:	430b      	orrs	r3, r1
   2219c:	d47f      	bmi.n	2229e <__aeabi_idiv+0x106>
   2219e:	2200      	movs	r2, #0
   221a0:	0843      	lsrs	r3, r0, #1
   221a2:	428b      	cmp	r3, r1
   221a4:	d374      	bcc.n	22290 <__aeabi_idiv+0xf8>
   221a6:	0903      	lsrs	r3, r0, #4
   221a8:	428b      	cmp	r3, r1
   221aa:	d35f      	bcc.n	2226c <__aeabi_idiv+0xd4>
   221ac:	0a03      	lsrs	r3, r0, #8
   221ae:	428b      	cmp	r3, r1
   221b0:	d344      	bcc.n	2223c <__aeabi_idiv+0xa4>
   221b2:	0b03      	lsrs	r3, r0, #12
   221b4:	428b      	cmp	r3, r1
   221b6:	d328      	bcc.n	2220a <__aeabi_idiv+0x72>
   221b8:	0c03      	lsrs	r3, r0, #16
   221ba:	428b      	cmp	r3, r1
   221bc:	d30d      	bcc.n	221da <__aeabi_idiv+0x42>
   221be:	22ff      	movs	r2, #255	; 0xff
   221c0:	0209      	lsls	r1, r1, #8
   221c2:	ba12      	rev	r2, r2
   221c4:	0c03      	lsrs	r3, r0, #16
   221c6:	428b      	cmp	r3, r1
   221c8:	d302      	bcc.n	221d0 <__aeabi_idiv+0x38>
   221ca:	1212      	asrs	r2, r2, #8
   221cc:	0209      	lsls	r1, r1, #8
   221ce:	d065      	beq.n	2229c <__aeabi_idiv+0x104>
   221d0:	0b03      	lsrs	r3, r0, #12
   221d2:	428b      	cmp	r3, r1
   221d4:	d319      	bcc.n	2220a <__aeabi_idiv+0x72>
   221d6:	e000      	b.n	221da <__aeabi_idiv+0x42>
   221d8:	0a09      	lsrs	r1, r1, #8
   221da:	0bc3      	lsrs	r3, r0, #15
   221dc:	428b      	cmp	r3, r1
   221de:	d301      	bcc.n	221e4 <__aeabi_idiv+0x4c>
   221e0:	03cb      	lsls	r3, r1, #15
   221e2:	1ac0      	subs	r0, r0, r3
   221e4:	4152      	adcs	r2, r2
   221e6:	0b83      	lsrs	r3, r0, #14
   221e8:	428b      	cmp	r3, r1
   221ea:	d301      	bcc.n	221f0 <__aeabi_idiv+0x58>
   221ec:	038b      	lsls	r3, r1, #14
   221ee:	1ac0      	subs	r0, r0, r3
   221f0:	4152      	adcs	r2, r2
   221f2:	0b43      	lsrs	r3, r0, #13
   221f4:	428b      	cmp	r3, r1
   221f6:	d301      	bcc.n	221fc <__aeabi_idiv+0x64>
   221f8:	034b      	lsls	r3, r1, #13
   221fa:	1ac0      	subs	r0, r0, r3
   221fc:	4152      	adcs	r2, r2
   221fe:	0b03      	lsrs	r3, r0, #12
   22200:	428b      	cmp	r3, r1
   22202:	d301      	bcc.n	22208 <__aeabi_idiv+0x70>
   22204:	030b      	lsls	r3, r1, #12
   22206:	1ac0      	subs	r0, r0, r3
   22208:	4152      	adcs	r2, r2
   2220a:	0ac3      	lsrs	r3, r0, #11
   2220c:	428b      	cmp	r3, r1
   2220e:	d301      	bcc.n	22214 <__aeabi_idiv+0x7c>
   22210:	02cb      	lsls	r3, r1, #11
   22212:	1ac0      	subs	r0, r0, r3
   22214:	4152      	adcs	r2, r2
   22216:	0a83      	lsrs	r3, r0, #10
   22218:	428b      	cmp	r3, r1
   2221a:	d301      	bcc.n	22220 <__aeabi_idiv+0x88>
   2221c:	028b      	lsls	r3, r1, #10
   2221e:	1ac0      	subs	r0, r0, r3
   22220:	4152      	adcs	r2, r2
   22222:	0a43      	lsrs	r3, r0, #9
   22224:	428b      	cmp	r3, r1
   22226:	d301      	bcc.n	2222c <__aeabi_idiv+0x94>
   22228:	024b      	lsls	r3, r1, #9
   2222a:	1ac0      	subs	r0, r0, r3
   2222c:	4152      	adcs	r2, r2
   2222e:	0a03      	lsrs	r3, r0, #8
   22230:	428b      	cmp	r3, r1
   22232:	d301      	bcc.n	22238 <__aeabi_idiv+0xa0>
   22234:	020b      	lsls	r3, r1, #8
   22236:	1ac0      	subs	r0, r0, r3
   22238:	4152      	adcs	r2, r2
   2223a:	d2cd      	bcs.n	221d8 <__aeabi_idiv+0x40>
   2223c:	09c3      	lsrs	r3, r0, #7
   2223e:	428b      	cmp	r3, r1
   22240:	d301      	bcc.n	22246 <__aeabi_idiv+0xae>
   22242:	01cb      	lsls	r3, r1, #7
   22244:	1ac0      	subs	r0, r0, r3
   22246:	4152      	adcs	r2, r2
   22248:	0983      	lsrs	r3, r0, #6
   2224a:	428b      	cmp	r3, r1
   2224c:	d301      	bcc.n	22252 <__aeabi_idiv+0xba>
   2224e:	018b      	lsls	r3, r1, #6
   22250:	1ac0      	subs	r0, r0, r3
   22252:	4152      	adcs	r2, r2
   22254:	0943      	lsrs	r3, r0, #5
   22256:	428b      	cmp	r3, r1
   22258:	d301      	bcc.n	2225e <__aeabi_idiv+0xc6>
   2225a:	014b      	lsls	r3, r1, #5
   2225c:	1ac0      	subs	r0, r0, r3
   2225e:	4152      	adcs	r2, r2
   22260:	0903      	lsrs	r3, r0, #4
   22262:	428b      	cmp	r3, r1
   22264:	d301      	bcc.n	2226a <__aeabi_idiv+0xd2>
   22266:	010b      	lsls	r3, r1, #4
   22268:	1ac0      	subs	r0, r0, r3
   2226a:	4152      	adcs	r2, r2
   2226c:	08c3      	lsrs	r3, r0, #3
   2226e:	428b      	cmp	r3, r1
   22270:	d301      	bcc.n	22276 <__aeabi_idiv+0xde>
   22272:	00cb      	lsls	r3, r1, #3
   22274:	1ac0      	subs	r0, r0, r3
   22276:	4152      	adcs	r2, r2
   22278:	0883      	lsrs	r3, r0, #2
   2227a:	428b      	cmp	r3, r1
   2227c:	d301      	bcc.n	22282 <__aeabi_idiv+0xea>
   2227e:	008b      	lsls	r3, r1, #2
   22280:	1ac0      	subs	r0, r0, r3
   22282:	4152      	adcs	r2, r2
   22284:	0843      	lsrs	r3, r0, #1
   22286:	428b      	cmp	r3, r1
   22288:	d301      	bcc.n	2228e <__aeabi_idiv+0xf6>
   2228a:	004b      	lsls	r3, r1, #1
   2228c:	1ac0      	subs	r0, r0, r3
   2228e:	4152      	adcs	r2, r2
   22290:	1a41      	subs	r1, r0, r1
   22292:	d200      	bcs.n	22296 <__aeabi_idiv+0xfe>
   22294:	4601      	mov	r1, r0
   22296:	4152      	adcs	r2, r2
   22298:	4610      	mov	r0, r2
   2229a:	4770      	bx	lr
   2229c:	e05d      	b.n	2235a <__aeabi_idiv+0x1c2>
   2229e:	0fca      	lsrs	r2, r1, #31
   222a0:	d000      	beq.n	222a4 <__aeabi_idiv+0x10c>
   222a2:	4249      	negs	r1, r1
   222a4:	1003      	asrs	r3, r0, #32
   222a6:	d300      	bcc.n	222aa <__aeabi_idiv+0x112>
   222a8:	4240      	negs	r0, r0
   222aa:	4053      	eors	r3, r2
   222ac:	2200      	movs	r2, #0
   222ae:	469c      	mov	ip, r3
   222b0:	0903      	lsrs	r3, r0, #4
   222b2:	428b      	cmp	r3, r1
   222b4:	d32d      	bcc.n	22312 <__aeabi_idiv+0x17a>
   222b6:	0a03      	lsrs	r3, r0, #8
   222b8:	428b      	cmp	r3, r1
   222ba:	d312      	bcc.n	222e2 <__aeabi_idiv+0x14a>
   222bc:	22fc      	movs	r2, #252	; 0xfc
   222be:	0189      	lsls	r1, r1, #6
   222c0:	ba12      	rev	r2, r2
   222c2:	0a03      	lsrs	r3, r0, #8
   222c4:	428b      	cmp	r3, r1
   222c6:	d30c      	bcc.n	222e2 <__aeabi_idiv+0x14a>
   222c8:	0189      	lsls	r1, r1, #6
   222ca:	1192      	asrs	r2, r2, #6
   222cc:	428b      	cmp	r3, r1
   222ce:	d308      	bcc.n	222e2 <__aeabi_idiv+0x14a>
   222d0:	0189      	lsls	r1, r1, #6
   222d2:	1192      	asrs	r2, r2, #6
   222d4:	428b      	cmp	r3, r1
   222d6:	d304      	bcc.n	222e2 <__aeabi_idiv+0x14a>
   222d8:	0189      	lsls	r1, r1, #6
   222da:	d03a      	beq.n	22352 <__aeabi_idiv+0x1ba>
   222dc:	1192      	asrs	r2, r2, #6
   222de:	e000      	b.n	222e2 <__aeabi_idiv+0x14a>
   222e0:	0989      	lsrs	r1, r1, #6
   222e2:	09c3      	lsrs	r3, r0, #7
   222e4:	428b      	cmp	r3, r1
   222e6:	d301      	bcc.n	222ec <__aeabi_idiv+0x154>
   222e8:	01cb      	lsls	r3, r1, #7
   222ea:	1ac0      	subs	r0, r0, r3
   222ec:	4152      	adcs	r2, r2
   222ee:	0983      	lsrs	r3, r0, #6
   222f0:	428b      	cmp	r3, r1
   222f2:	d301      	bcc.n	222f8 <__aeabi_idiv+0x160>
   222f4:	018b      	lsls	r3, r1, #6
   222f6:	1ac0      	subs	r0, r0, r3
   222f8:	4152      	adcs	r2, r2
   222fa:	0943      	lsrs	r3, r0, #5
   222fc:	428b      	cmp	r3, r1
   222fe:	d301      	bcc.n	22304 <__aeabi_idiv+0x16c>
   22300:	014b      	lsls	r3, r1, #5
   22302:	1ac0      	subs	r0, r0, r3
   22304:	4152      	adcs	r2, r2
   22306:	0903      	lsrs	r3, r0, #4
   22308:	428b      	cmp	r3, r1
   2230a:	d301      	bcc.n	22310 <__aeabi_idiv+0x178>
   2230c:	010b      	lsls	r3, r1, #4
   2230e:	1ac0      	subs	r0, r0, r3
   22310:	4152      	adcs	r2, r2
   22312:	08c3      	lsrs	r3, r0, #3
   22314:	428b      	cmp	r3, r1
   22316:	d301      	bcc.n	2231c <__aeabi_idiv+0x184>
   22318:	00cb      	lsls	r3, r1, #3
   2231a:	1ac0      	subs	r0, r0, r3
   2231c:	4152      	adcs	r2, r2
   2231e:	0883      	lsrs	r3, r0, #2
   22320:	428b      	cmp	r3, r1
   22322:	d301      	bcc.n	22328 <__aeabi_idiv+0x190>
   22324:	008b      	lsls	r3, r1, #2
   22326:	1ac0      	subs	r0, r0, r3
   22328:	4152      	adcs	r2, r2
   2232a:	d2d9      	bcs.n	222e0 <__aeabi_idiv+0x148>
   2232c:	0843      	lsrs	r3, r0, #1
   2232e:	428b      	cmp	r3, r1
   22330:	d301      	bcc.n	22336 <__aeabi_idiv+0x19e>
   22332:	004b      	lsls	r3, r1, #1
   22334:	1ac0      	subs	r0, r0, r3
   22336:	4152      	adcs	r2, r2
   22338:	1a41      	subs	r1, r0, r1
   2233a:	d200      	bcs.n	2233e <__aeabi_idiv+0x1a6>
   2233c:	4601      	mov	r1, r0
   2233e:	4663      	mov	r3, ip
   22340:	4152      	adcs	r2, r2
   22342:	105b      	asrs	r3, r3, #1
   22344:	4610      	mov	r0, r2
   22346:	d301      	bcc.n	2234c <__aeabi_idiv+0x1b4>
   22348:	4240      	negs	r0, r0
   2234a:	2b00      	cmp	r3, #0
   2234c:	d500      	bpl.n	22350 <__aeabi_idiv+0x1b8>
   2234e:	4249      	negs	r1, r1
   22350:	4770      	bx	lr
   22352:	4663      	mov	r3, ip
   22354:	105b      	asrs	r3, r3, #1
   22356:	d300      	bcc.n	2235a <__aeabi_idiv+0x1c2>
   22358:	4240      	negs	r0, r0
   2235a:	b501      	push	{r0, lr}
   2235c:	2000      	movs	r0, #0
   2235e:	f000 f80b 	bl	22378 <__aeabi_idiv0>
   22362:	bd02      	pop	{r1, pc}

00022364 <__aeabi_idivmod>:
   22364:	2900      	cmp	r1, #0
   22366:	d0f8      	beq.n	2235a <__aeabi_idiv+0x1c2>
   22368:	b503      	push	{r0, r1, lr}
   2236a:	f7ff ff15 	bl	22198 <__aeabi_idiv>
   2236e:	bc0e      	pop	{r1, r2, r3}
   22370:	4342      	muls	r2, r0
   22372:	1a89      	subs	r1, r1, r2
   22374:	4718      	bx	r3
   22376:	46c0      	nop			; (mov r8, r8)

00022378 <__aeabi_idiv0>:
   22378:	4770      	bx	lr
   2237a:	46c0      	nop			; (mov r8, r8)

0002237c <__aeabi_uldivmod>:
   2237c:	2b00      	cmp	r3, #0
   2237e:	d111      	bne.n	223a4 <__aeabi_uldivmod+0x28>
   22380:	2a00      	cmp	r2, #0
   22382:	d10f      	bne.n	223a4 <__aeabi_uldivmod+0x28>
   22384:	2900      	cmp	r1, #0
   22386:	d100      	bne.n	2238a <__aeabi_uldivmod+0xe>
   22388:	2800      	cmp	r0, #0
   2238a:	d002      	beq.n	22392 <__aeabi_uldivmod+0x16>
   2238c:	2100      	movs	r1, #0
   2238e:	43c9      	mvns	r1, r1
   22390:	1c08      	adds	r0, r1, #0
   22392:	b407      	push	{r0, r1, r2}
   22394:	4802      	ldr	r0, [pc, #8]	; (223a0 <__aeabi_uldivmod+0x24>)
   22396:	a102      	add	r1, pc, #8	; (adr r1, 223a0 <__aeabi_uldivmod+0x24>)
   22398:	1840      	adds	r0, r0, r1
   2239a:	9002      	str	r0, [sp, #8]
   2239c:	bd03      	pop	{r0, r1, pc}
   2239e:	46c0      	nop			; (mov r8, r8)
   223a0:	ffffffd9 	.word	0xffffffd9
   223a4:	b403      	push	{r0, r1}
   223a6:	4668      	mov	r0, sp
   223a8:	b501      	push	{r0, lr}
   223aa:	9802      	ldr	r0, [sp, #8]
   223ac:	f000 f84c 	bl	22448 <__gnu_uldivmod_helper>
   223b0:	9b01      	ldr	r3, [sp, #4]
   223b2:	469e      	mov	lr, r3
   223b4:	b002      	add	sp, #8
   223b6:	bc0c      	pop	{r2, r3}
   223b8:	4770      	bx	lr
   223ba:	46c0      	nop			; (mov r8, r8)

000223bc <__aeabi_lmul>:
   223bc:	b5f0      	push	{r4, r5, r6, r7, lr}
   223be:	464f      	mov	r7, r9
   223c0:	4646      	mov	r6, r8
   223c2:	0405      	lsls	r5, r0, #16
   223c4:	0c2d      	lsrs	r5, r5, #16
   223c6:	1c2c      	adds	r4, r5, #0
   223c8:	b4c0      	push	{r6, r7}
   223ca:	0417      	lsls	r7, r2, #16
   223cc:	0c16      	lsrs	r6, r2, #16
   223ce:	0c3f      	lsrs	r7, r7, #16
   223d0:	4699      	mov	r9, r3
   223d2:	0c03      	lsrs	r3, r0, #16
   223d4:	437c      	muls	r4, r7
   223d6:	4375      	muls	r5, r6
   223d8:	435f      	muls	r7, r3
   223da:	4373      	muls	r3, r6
   223dc:	197d      	adds	r5, r7, r5
   223de:	0c26      	lsrs	r6, r4, #16
   223e0:	19ad      	adds	r5, r5, r6
   223e2:	469c      	mov	ip, r3
   223e4:	42af      	cmp	r7, r5
   223e6:	d903      	bls.n	223f0 <__aeabi_lmul+0x34>
   223e8:	2380      	movs	r3, #128	; 0x80
   223ea:	025b      	lsls	r3, r3, #9
   223ec:	4698      	mov	r8, r3
   223ee:	44c4      	add	ip, r8
   223f0:	464b      	mov	r3, r9
   223f2:	4351      	muls	r1, r2
   223f4:	4343      	muls	r3, r0
   223f6:	0424      	lsls	r4, r4, #16
   223f8:	0c2e      	lsrs	r6, r5, #16
   223fa:	0c24      	lsrs	r4, r4, #16
   223fc:	042d      	lsls	r5, r5, #16
   223fe:	4466      	add	r6, ip
   22400:	192c      	adds	r4, r5, r4
   22402:	1859      	adds	r1, r3, r1
   22404:	1989      	adds	r1, r1, r6
   22406:	1c20      	adds	r0, r4, #0
   22408:	bc0c      	pop	{r2, r3}
   2240a:	4690      	mov	r8, r2
   2240c:	4699      	mov	r9, r3
   2240e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00022410 <__gnu_ldivmod_helper>:
   22410:	b5f0      	push	{r4, r5, r6, r7, lr}
   22412:	b083      	sub	sp, #12
   22414:	1c16      	adds	r6, r2, #0
   22416:	1c1f      	adds	r7, r3, #0
   22418:	9000      	str	r0, [sp, #0]
   2241a:	9101      	str	r1, [sp, #4]
   2241c:	f000 f84c 	bl	224b8 <__divdi3>
   22420:	1c04      	adds	r4, r0, #0
   22422:	1c0d      	adds	r5, r1, #0
   22424:	1c22      	adds	r2, r4, #0
   22426:	1c2b      	adds	r3, r5, #0
   22428:	1c30      	adds	r0, r6, #0
   2242a:	1c39      	adds	r1, r7, #0
   2242c:	f7ff ffc6 	bl	223bc <__aeabi_lmul>
   22430:	9a00      	ldr	r2, [sp, #0]
   22432:	9b01      	ldr	r3, [sp, #4]
   22434:	1a12      	subs	r2, r2, r0
   22436:	418b      	sbcs	r3, r1
   22438:	9908      	ldr	r1, [sp, #32]
   2243a:	1c20      	adds	r0, r4, #0
   2243c:	600a      	str	r2, [r1, #0]
   2243e:	604b      	str	r3, [r1, #4]
   22440:	1c29      	adds	r1, r5, #0
   22442:	b003      	add	sp, #12
   22444:	bdf0      	pop	{r4, r5, r6, r7, pc}
   22446:	46c0      	nop			; (mov r8, r8)

00022448 <__gnu_uldivmod_helper>:
   22448:	b5f0      	push	{r4, r5, r6, r7, lr}
   2244a:	1c14      	adds	r4, r2, #0
   2244c:	b083      	sub	sp, #12
   2244e:	1c1d      	adds	r5, r3, #0
   22450:	9000      	str	r0, [sp, #0]
   22452:	9101      	str	r1, [sp, #4]
   22454:	f000 f928 	bl	226a8 <__udivdi3>
   22458:	1c22      	adds	r2, r4, #0
   2245a:	1c2b      	adds	r3, r5, #0
   2245c:	1c06      	adds	r6, r0, #0
   2245e:	1c0f      	adds	r7, r1, #0
   22460:	f7ff ffac 	bl	223bc <__aeabi_lmul>
   22464:	9a00      	ldr	r2, [sp, #0]
   22466:	9b01      	ldr	r3, [sp, #4]
   22468:	1a12      	subs	r2, r2, r0
   2246a:	418b      	sbcs	r3, r1
   2246c:	9908      	ldr	r1, [sp, #32]
   2246e:	1c30      	adds	r0, r6, #0
   22470:	600a      	str	r2, [r1, #0]
   22472:	604b      	str	r3, [r1, #4]
   22474:	1c39      	adds	r1, r7, #0
   22476:	b003      	add	sp, #12
   22478:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2247a:	46c0      	nop			; (mov r8, r8)

0002247c <__clzsi2>:
   2247c:	211c      	movs	r1, #28
   2247e:	2301      	movs	r3, #1
   22480:	041b      	lsls	r3, r3, #16
   22482:	4298      	cmp	r0, r3
   22484:	d301      	bcc.n	2248a <__clzsi2+0xe>
   22486:	0c00      	lsrs	r0, r0, #16
   22488:	3910      	subs	r1, #16
   2248a:	0a1b      	lsrs	r3, r3, #8
   2248c:	4298      	cmp	r0, r3
   2248e:	d301      	bcc.n	22494 <__clzsi2+0x18>
   22490:	0a00      	lsrs	r0, r0, #8
   22492:	3908      	subs	r1, #8
   22494:	091b      	lsrs	r3, r3, #4
   22496:	4298      	cmp	r0, r3
   22498:	d301      	bcc.n	2249e <__clzsi2+0x22>
   2249a:	0900      	lsrs	r0, r0, #4
   2249c:	3904      	subs	r1, #4
   2249e:	a202      	add	r2, pc, #8	; (adr r2, 224a8 <__clzsi2+0x2c>)
   224a0:	5c10      	ldrb	r0, [r2, r0]
   224a2:	1840      	adds	r0, r0, r1
   224a4:	4770      	bx	lr
   224a6:	46c0      	nop			; (mov r8, r8)
   224a8:	02020304 	.word	0x02020304
   224ac:	01010101 	.word	0x01010101
	...

000224b8 <__divdi3>:
   224b8:	b5f0      	push	{r4, r5, r6, r7, lr}
   224ba:	4644      	mov	r4, r8
   224bc:	465f      	mov	r7, fp
   224be:	4656      	mov	r6, sl
   224c0:	464d      	mov	r5, r9
   224c2:	b4f0      	push	{r4, r5, r6, r7}
   224c4:	1c1c      	adds	r4, r3, #0
   224c6:	b085      	sub	sp, #20
   224c8:	2900      	cmp	r1, #0
   224ca:	da00      	bge.n	224ce <__divdi3+0x16>
   224cc:	e0a9      	b.n	22622 <__divdi3+0x16a>
   224ce:	1c0f      	adds	r7, r1, #0
   224d0:	2100      	movs	r1, #0
   224d2:	1c06      	adds	r6, r0, #0
   224d4:	4688      	mov	r8, r1
   224d6:	1c10      	adds	r0, r2, #0
   224d8:	1c19      	adds	r1, r3, #0
   224da:	2c00      	cmp	r4, #0
   224dc:	da00      	bge.n	224e0 <__divdi3+0x28>
   224de:	e097      	b.n	22610 <__divdi3+0x158>
   224e0:	1c34      	adds	r4, r6, #0
   224e2:	1c3d      	adds	r5, r7, #0
   224e4:	4682      	mov	sl, r0
   224e6:	4689      	mov	r9, r1
   224e8:	42b9      	cmp	r1, r7
   224ea:	d873      	bhi.n	225d4 <__divdi3+0x11c>
   224ec:	d070      	beq.n	225d0 <__divdi3+0x118>
   224ee:	4649      	mov	r1, r9
   224f0:	4650      	mov	r0, sl
   224f2:	f000 f985 	bl	22800 <__clzdi2>
   224f6:	4683      	mov	fp, r0
   224f8:	1c39      	adds	r1, r7, #0
   224fa:	1c30      	adds	r0, r6, #0
   224fc:	f000 f980 	bl	22800 <__clzdi2>
   22500:	465b      	mov	r3, fp
   22502:	1a18      	subs	r0, r3, r0
   22504:	1c03      	adds	r3, r0, #0
   22506:	4683      	mov	fp, r0
   22508:	3b20      	subs	r3, #32
   2250a:	469c      	mov	ip, r3
   2250c:	d500      	bpl.n	22510 <__divdi3+0x58>
   2250e:	e09c      	b.n	2264a <__divdi3+0x192>
   22510:	2300      	movs	r3, #0
   22512:	2200      	movs	r2, #0
   22514:	4651      	mov	r1, sl
   22516:	9200      	str	r2, [sp, #0]
   22518:	9301      	str	r3, [sp, #4]
   2251a:	4663      	mov	r3, ip
   2251c:	4099      	lsls	r1, r3
   2251e:	9101      	str	r1, [sp, #4]
   22520:	4651      	mov	r1, sl
   22522:	4081      	lsls	r1, r0
   22524:	9b01      	ldr	r3, [sp, #4]
   22526:	9100      	str	r1, [sp, #0]
   22528:	42bb      	cmp	r3, r7
   2252a:	d900      	bls.n	2252e <__divdi3+0x76>
   2252c:	e083      	b.n	22636 <__divdi3+0x17e>
   2252e:	d100      	bne.n	22532 <__divdi3+0x7a>
   22530:	e07e      	b.n	22630 <__divdi3+0x178>
   22532:	9a00      	ldr	r2, [sp, #0]
   22534:	9b01      	ldr	r3, [sp, #4]
   22536:	1c34      	adds	r4, r6, #0
   22538:	1c3d      	adds	r5, r7, #0
   2253a:	1aa4      	subs	r4, r4, r2
   2253c:	419d      	sbcs	r5, r3
   2253e:	4663      	mov	r3, ip
   22540:	2b00      	cmp	r3, #0
   22542:	da00      	bge.n	22546 <__divdi3+0x8e>
   22544:	e09a      	b.n	2267c <__divdi3+0x1c4>
   22546:	2600      	movs	r6, #0
   22548:	2700      	movs	r7, #0
   2254a:	9602      	str	r6, [sp, #8]
   2254c:	9703      	str	r7, [sp, #12]
   2254e:	3601      	adds	r6, #1
   22550:	409e      	lsls	r6, r3
   22552:	9603      	str	r6, [sp, #12]
   22554:	2601      	movs	r6, #1
   22556:	4086      	lsls	r6, r0
   22558:	9602      	str	r6, [sp, #8]
   2255a:	2800      	cmp	r0, #0
   2255c:	d100      	bne.n	22560 <__divdi3+0xa8>
   2255e:	e071      	b.n	22644 <__divdi3+0x18c>
   22560:	9900      	ldr	r1, [sp, #0]
   22562:	9a01      	ldr	r2, [sp, #4]
   22564:	07d3      	lsls	r3, r2, #31
   22566:	4699      	mov	r9, r3
   22568:	464b      	mov	r3, r9
   2256a:	084e      	lsrs	r6, r1, #1
   2256c:	431e      	orrs	r6, r3
   2256e:	0857      	lsrs	r7, r2, #1
   22570:	2300      	movs	r3, #0
   22572:	2201      	movs	r2, #1
   22574:	e00c      	b.n	22590 <__divdi3+0xd8>
   22576:	42af      	cmp	r7, r5
   22578:	d101      	bne.n	2257e <__divdi3+0xc6>
   2257a:	42a6      	cmp	r6, r4
   2257c:	d80a      	bhi.n	22594 <__divdi3+0xdc>
   2257e:	1ba4      	subs	r4, r4, r6
   22580:	41bd      	sbcs	r5, r7
   22582:	1924      	adds	r4, r4, r4
   22584:	416d      	adcs	r5, r5
   22586:	3801      	subs	r0, #1
   22588:	18a4      	adds	r4, r4, r2
   2258a:	415d      	adcs	r5, r3
   2258c:	2800      	cmp	r0, #0
   2258e:	d006      	beq.n	2259e <__divdi3+0xe6>
   22590:	42af      	cmp	r7, r5
   22592:	d9f0      	bls.n	22576 <__divdi3+0xbe>
   22594:	3801      	subs	r0, #1
   22596:	1924      	adds	r4, r4, r4
   22598:	416d      	adcs	r5, r5
   2259a:	2800      	cmp	r0, #0
   2259c:	d1f8      	bne.n	22590 <__divdi3+0xd8>
   2259e:	2220      	movs	r2, #32
   225a0:	9e02      	ldr	r6, [sp, #8]
   225a2:	9f03      	ldr	r7, [sp, #12]
   225a4:	465b      	mov	r3, fp
   225a6:	4252      	negs	r2, r2
   225a8:	1936      	adds	r6, r6, r4
   225aa:	416f      	adcs	r7, r5
   225ac:	1899      	adds	r1, r3, r2
   225ae:	d45a      	bmi.n	22666 <__divdi3+0x1ae>
   225b0:	1c28      	adds	r0, r5, #0
   225b2:	40c8      	lsrs	r0, r1
   225b4:	1c2c      	adds	r4, r5, #0
   225b6:	465b      	mov	r3, fp
   225b8:	40dc      	lsrs	r4, r3
   225ba:	2900      	cmp	r1, #0
   225bc:	db68      	blt.n	22690 <__divdi3+0x1d8>
   225be:	1c04      	adds	r4, r0, #0
   225c0:	408c      	lsls	r4, r1
   225c2:	1c23      	adds	r3, r4, #0
   225c4:	4659      	mov	r1, fp
   225c6:	4088      	lsls	r0, r1
   225c8:	1c02      	adds	r2, r0, #0
   225ca:	1ab6      	subs	r6, r6, r2
   225cc:	419f      	sbcs	r7, r3
   225ce:	e003      	b.n	225d8 <__divdi3+0x120>
   225d0:	42b0      	cmp	r0, r6
   225d2:	d98c      	bls.n	224ee <__divdi3+0x36>
   225d4:	2600      	movs	r6, #0
   225d6:	2700      	movs	r7, #0
   225d8:	4641      	mov	r1, r8
   225da:	1e4b      	subs	r3, r1, #1
   225dc:	4199      	sbcs	r1, r3
   225de:	2300      	movs	r3, #0
   225e0:	9100      	str	r1, [sp, #0]
   225e2:	9301      	str	r3, [sp, #4]
   225e4:	9a00      	ldr	r2, [sp, #0]
   225e6:	9b01      	ldr	r3, [sp, #4]
   225e8:	2500      	movs	r5, #0
   225ea:	4254      	negs	r4, r2
   225ec:	419d      	sbcs	r5, r3
   225ee:	1c33      	adds	r3, r6, #0
   225f0:	4063      	eors	r3, r4
   225f2:	1c18      	adds	r0, r3, #0
   225f4:	1c3b      	adds	r3, r7, #0
   225f6:	406b      	eors	r3, r5
   225f8:	1c19      	adds	r1, r3, #0
   225fa:	9b00      	ldr	r3, [sp, #0]
   225fc:	9c01      	ldr	r4, [sp, #4]
   225fe:	18c0      	adds	r0, r0, r3
   22600:	4161      	adcs	r1, r4
   22602:	b005      	add	sp, #20
   22604:	bc3c      	pop	{r2, r3, r4, r5}
   22606:	4690      	mov	r8, r2
   22608:	4699      	mov	r9, r3
   2260a:	46a2      	mov	sl, r4
   2260c:	46ab      	mov	fp, r5
   2260e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   22610:	4643      	mov	r3, r8
   22612:	43db      	mvns	r3, r3
   22614:	1c0c      	adds	r4, r1, #0
   22616:	4698      	mov	r8, r3
   22618:	1c13      	adds	r3, r2, #0
   2261a:	2100      	movs	r1, #0
   2261c:	4258      	negs	r0, r3
   2261e:	41a1      	sbcs	r1, r4
   22620:	e75e      	b.n	224e0 <__divdi3+0x28>
   22622:	2700      	movs	r7, #0
   22624:	4246      	negs	r6, r0
   22626:	418f      	sbcs	r7, r1
   22628:	2101      	movs	r1, #1
   2262a:	4249      	negs	r1, r1
   2262c:	4688      	mov	r8, r1
   2262e:	e752      	b.n	224d6 <__divdi3+0x1e>
   22630:	42b1      	cmp	r1, r6
   22632:	d800      	bhi.n	22636 <__divdi3+0x17e>
   22634:	e77d      	b.n	22532 <__divdi3+0x7a>
   22636:	2600      	movs	r6, #0
   22638:	2700      	movs	r7, #0
   2263a:	9602      	str	r6, [sp, #8]
   2263c:	9703      	str	r7, [sp, #12]
   2263e:	2800      	cmp	r0, #0
   22640:	d000      	beq.n	22644 <__divdi3+0x18c>
   22642:	e78d      	b.n	22560 <__divdi3+0xa8>
   22644:	9e02      	ldr	r6, [sp, #8]
   22646:	9f03      	ldr	r7, [sp, #12]
   22648:	e7c6      	b.n	225d8 <__divdi3+0x120>
   2264a:	2120      	movs	r1, #32
   2264c:	4653      	mov	r3, sl
   2264e:	1a09      	subs	r1, r1, r0
   22650:	40cb      	lsrs	r3, r1
   22652:	2200      	movs	r2, #0
   22654:	1c19      	adds	r1, r3, #0
   22656:	2300      	movs	r3, #0
   22658:	9200      	str	r2, [sp, #0]
   2265a:	9301      	str	r3, [sp, #4]
   2265c:	464b      	mov	r3, r9
   2265e:	4083      	lsls	r3, r0
   22660:	430b      	orrs	r3, r1
   22662:	9301      	str	r3, [sp, #4]
   22664:	e75c      	b.n	22520 <__divdi3+0x68>
   22666:	465a      	mov	r2, fp
   22668:	2320      	movs	r3, #32
   2266a:	1a9b      	subs	r3, r3, r2
   2266c:	1c2a      	adds	r2, r5, #0
   2266e:	409a      	lsls	r2, r3
   22670:	1c20      	adds	r0, r4, #0
   22672:	1c13      	adds	r3, r2, #0
   22674:	465a      	mov	r2, fp
   22676:	40d0      	lsrs	r0, r2
   22678:	4318      	orrs	r0, r3
   2267a:	e79b      	b.n	225b4 <__divdi3+0xfc>
   2267c:	2620      	movs	r6, #32
   2267e:	2700      	movs	r7, #0
   22680:	1a33      	subs	r3, r6, r0
   22682:	2600      	movs	r6, #0
   22684:	9602      	str	r6, [sp, #8]
   22686:	9703      	str	r7, [sp, #12]
   22688:	2701      	movs	r7, #1
   2268a:	40df      	lsrs	r7, r3
   2268c:	9703      	str	r7, [sp, #12]
   2268e:	e761      	b.n	22554 <__divdi3+0x9c>
   22690:	465b      	mov	r3, fp
   22692:	2120      	movs	r1, #32
   22694:	465d      	mov	r5, fp
   22696:	1ac9      	subs	r1, r1, r3
   22698:	1c03      	adds	r3, r0, #0
   2269a:	40ac      	lsls	r4, r5
   2269c:	40cb      	lsrs	r3, r1
   2269e:	1c19      	adds	r1, r3, #0
   226a0:	1c23      	adds	r3, r4, #0
   226a2:	430b      	orrs	r3, r1
   226a4:	e78e      	b.n	225c4 <__divdi3+0x10c>
   226a6:	46c0      	nop			; (mov r8, r8)

000226a8 <__udivdi3>:
   226a8:	b5f0      	push	{r4, r5, r6, r7, lr}
   226aa:	4645      	mov	r5, r8
   226ac:	464e      	mov	r6, r9
   226ae:	4657      	mov	r7, sl
   226b0:	b4e0      	push	{r5, r6, r7}
   226b2:	1c04      	adds	r4, r0, #0
   226b4:	b082      	sub	sp, #8
   226b6:	1c0d      	adds	r5, r1, #0
   226b8:	4691      	mov	r9, r2
   226ba:	4698      	mov	r8, r3
   226bc:	428b      	cmp	r3, r1
   226be:	d862      	bhi.n	22786 <__udivdi3+0xde>
   226c0:	d05f      	beq.n	22782 <__udivdi3+0xda>
   226c2:	4641      	mov	r1, r8
   226c4:	4648      	mov	r0, r9
   226c6:	f000 f89b 	bl	22800 <__clzdi2>
   226ca:	1c29      	adds	r1, r5, #0
   226cc:	1c06      	adds	r6, r0, #0
   226ce:	1c20      	adds	r0, r4, #0
   226d0:	f000 f896 	bl	22800 <__clzdi2>
   226d4:	2320      	movs	r3, #32
   226d6:	1a31      	subs	r1, r6, r0
   226d8:	425b      	negs	r3, r3
   226da:	468a      	mov	sl, r1
   226dc:	18c8      	adds	r0, r1, r3
   226de:	d465      	bmi.n	227ac <__udivdi3+0x104>
   226e0:	464b      	mov	r3, r9
   226e2:	4083      	lsls	r3, r0
   226e4:	1c1f      	adds	r7, r3, #0
   226e6:	464b      	mov	r3, r9
   226e8:	408b      	lsls	r3, r1
   226ea:	1c1e      	adds	r6, r3, #0
   226ec:	42af      	cmp	r7, r5
   226ee:	d858      	bhi.n	227a2 <__udivdi3+0xfa>
   226f0:	d055      	beq.n	2279e <__udivdi3+0xf6>
   226f2:	1ba4      	subs	r4, r4, r6
   226f4:	41bd      	sbcs	r5, r7
   226f6:	2800      	cmp	r0, #0
   226f8:	da00      	bge.n	226fc <__udivdi3+0x54>
   226fa:	e077      	b.n	227ec <__udivdi3+0x144>
   226fc:	2200      	movs	r2, #0
   226fe:	2300      	movs	r3, #0
   22700:	9200      	str	r2, [sp, #0]
   22702:	9301      	str	r3, [sp, #4]
   22704:	3201      	adds	r2, #1
   22706:	4082      	lsls	r2, r0
   22708:	9201      	str	r2, [sp, #4]
   2270a:	2301      	movs	r3, #1
   2270c:	408b      	lsls	r3, r1
   2270e:	9300      	str	r3, [sp, #0]
   22710:	2900      	cmp	r1, #0
   22712:	d03c      	beq.n	2278e <__udivdi3+0xe6>
   22714:	07fb      	lsls	r3, r7, #31
   22716:	4698      	mov	r8, r3
   22718:	4640      	mov	r0, r8
   2271a:	0872      	lsrs	r2, r6, #1
   2271c:	087b      	lsrs	r3, r7, #1
   2271e:	4302      	orrs	r2, r0
   22720:	2601      	movs	r6, #1
   22722:	2700      	movs	r7, #0
   22724:	e00c      	b.n	22740 <__udivdi3+0x98>
   22726:	42ab      	cmp	r3, r5
   22728:	d101      	bne.n	2272e <__udivdi3+0x86>
   2272a:	42a2      	cmp	r2, r4
   2272c:	d80a      	bhi.n	22744 <__udivdi3+0x9c>
   2272e:	1aa4      	subs	r4, r4, r2
   22730:	419d      	sbcs	r5, r3
   22732:	1924      	adds	r4, r4, r4
   22734:	416d      	adcs	r5, r5
   22736:	3901      	subs	r1, #1
   22738:	19a4      	adds	r4, r4, r6
   2273a:	417d      	adcs	r5, r7
   2273c:	2900      	cmp	r1, #0
   2273e:	d006      	beq.n	2274e <__udivdi3+0xa6>
   22740:	42ab      	cmp	r3, r5
   22742:	d9f0      	bls.n	22726 <__udivdi3+0x7e>
   22744:	3901      	subs	r1, #1
   22746:	1924      	adds	r4, r4, r4
   22748:	416d      	adcs	r5, r5
   2274a:	2900      	cmp	r1, #0
   2274c:	d1f8      	bne.n	22740 <__udivdi3+0x98>
   2274e:	2220      	movs	r2, #32
   22750:	9800      	ldr	r0, [sp, #0]
   22752:	9901      	ldr	r1, [sp, #4]
   22754:	4653      	mov	r3, sl
   22756:	4252      	negs	r2, r2
   22758:	1900      	adds	r0, r0, r4
   2275a:	4169      	adcs	r1, r5
   2275c:	189e      	adds	r6, r3, r2
   2275e:	d43a      	bmi.n	227d6 <__udivdi3+0x12e>
   22760:	1c2f      	adds	r7, r5, #0
   22762:	40f7      	lsrs	r7, r6
   22764:	4653      	mov	r3, sl
   22766:	40dd      	lsrs	r5, r3
   22768:	2e00      	cmp	r6, #0
   2276a:	db29      	blt.n	227c0 <__udivdi3+0x118>
   2276c:	1c3c      	adds	r4, r7, #0
   2276e:	40b4      	lsls	r4, r6
   22770:	1c23      	adds	r3, r4, #0
   22772:	4654      	mov	r4, sl
   22774:	40a7      	lsls	r7, r4
   22776:	1c3a      	adds	r2, r7, #0
   22778:	1a80      	subs	r0, r0, r2
   2277a:	4199      	sbcs	r1, r3
   2277c:	9000      	str	r0, [sp, #0]
   2277e:	9101      	str	r1, [sp, #4]
   22780:	e005      	b.n	2278e <__udivdi3+0xe6>
   22782:	4282      	cmp	r2, r0
   22784:	d99d      	bls.n	226c2 <__udivdi3+0x1a>
   22786:	2300      	movs	r3, #0
   22788:	2400      	movs	r4, #0
   2278a:	9300      	str	r3, [sp, #0]
   2278c:	9401      	str	r4, [sp, #4]
   2278e:	9800      	ldr	r0, [sp, #0]
   22790:	9901      	ldr	r1, [sp, #4]
   22792:	b002      	add	sp, #8
   22794:	bc1c      	pop	{r2, r3, r4}
   22796:	4690      	mov	r8, r2
   22798:	4699      	mov	r9, r3
   2279a:	46a2      	mov	sl, r4
   2279c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2279e:	42a3      	cmp	r3, r4
   227a0:	d9a7      	bls.n	226f2 <__udivdi3+0x4a>
   227a2:	2200      	movs	r2, #0
   227a4:	2300      	movs	r3, #0
   227a6:	9200      	str	r2, [sp, #0]
   227a8:	9301      	str	r3, [sp, #4]
   227aa:	e7b1      	b.n	22710 <__udivdi3+0x68>
   227ac:	2220      	movs	r2, #32
   227ae:	464b      	mov	r3, r9
   227b0:	1a52      	subs	r2, r2, r1
   227b2:	40d3      	lsrs	r3, r2
   227b4:	1c1a      	adds	r2, r3, #0
   227b6:	4643      	mov	r3, r8
   227b8:	408b      	lsls	r3, r1
   227ba:	1c1f      	adds	r7, r3, #0
   227bc:	4317      	orrs	r7, r2
   227be:	e792      	b.n	226e6 <__udivdi3+0x3e>
   227c0:	4653      	mov	r3, sl
   227c2:	2420      	movs	r4, #32
   227c4:	4656      	mov	r6, sl
   227c6:	1ae4      	subs	r4, r4, r3
   227c8:	1c3b      	adds	r3, r7, #0
   227ca:	40b5      	lsls	r5, r6
   227cc:	40e3      	lsrs	r3, r4
   227ce:	1c1c      	adds	r4, r3, #0
   227d0:	1c2b      	adds	r3, r5, #0
   227d2:	4323      	orrs	r3, r4
   227d4:	e7cd      	b.n	22772 <__udivdi3+0xca>
   227d6:	4652      	mov	r2, sl
   227d8:	2320      	movs	r3, #32
   227da:	1a9b      	subs	r3, r3, r2
   227dc:	1c2a      	adds	r2, r5, #0
   227de:	409a      	lsls	r2, r3
   227e0:	1c27      	adds	r7, r4, #0
   227e2:	1c13      	adds	r3, r2, #0
   227e4:	4652      	mov	r2, sl
   227e6:	40d7      	lsrs	r7, r2
   227e8:	431f      	orrs	r7, r3
   227ea:	e7bb      	b.n	22764 <__udivdi3+0xbc>
   227ec:	2320      	movs	r3, #32
   227ee:	2200      	movs	r2, #0
   227f0:	1a58      	subs	r0, r3, r1
   227f2:	2300      	movs	r3, #0
   227f4:	9200      	str	r2, [sp, #0]
   227f6:	9301      	str	r3, [sp, #4]
   227f8:	3201      	adds	r2, #1
   227fa:	40c2      	lsrs	r2, r0
   227fc:	9201      	str	r2, [sp, #4]
   227fe:	e784      	b.n	2270a <__udivdi3+0x62>

00022800 <__clzdi2>:
   22800:	b510      	push	{r4, lr}
   22802:	2900      	cmp	r1, #0
   22804:	d103      	bne.n	2280e <__clzdi2+0xe>
   22806:	f7ff fe39 	bl	2247c <__clzsi2>
   2280a:	3020      	adds	r0, #32
   2280c:	e002      	b.n	22814 <__clzdi2+0x14>
   2280e:	1c08      	adds	r0, r1, #0
   22810:	f7ff fe34 	bl	2247c <__clzsi2>
   22814:	bd10      	pop	{r4, pc}
   22816:	46c0      	nop			; (mov r8, r8)

00022818 <_getpid>:
   22818:	2258      	movs	r2, #88	; 0x58
   2281a:	2001      	movs	r0, #1
   2281c:	4b01      	ldr	r3, [pc, #4]	; (22824 <_getpid+0xc>)
   2281e:	4240      	negs	r0, r0
   22820:	601a      	str	r2, [r3, #0]
   22822:	4770      	bx	lr
   22824:	200037d8 	.word	0x200037d8

00022828 <_kill>:
   22828:	2258      	movs	r2, #88	; 0x58
   2282a:	2001      	movs	r0, #1
   2282c:	4b01      	ldr	r3, [pc, #4]	; (22834 <_kill+0xc>)
   2282e:	4240      	negs	r0, r0
   22830:	601a      	str	r2, [r3, #0]
   22832:	4770      	bx	lr
   22834:	200037d8 	.word	0x200037d8

00022838 <_sbrk>:
   22838:	4a04      	ldr	r2, [pc, #16]	; (2284c <_sbrk+0x14>)
   2283a:	6813      	ldr	r3, [r2, #0]
   2283c:	2b00      	cmp	r3, #0
   2283e:	d003      	beq.n	22848 <_sbrk+0x10>
   22840:	1818      	adds	r0, r3, r0
   22842:	6010      	str	r0, [r2, #0]
   22844:	1c18      	adds	r0, r3, #0
   22846:	4770      	bx	lr
   22848:	4b01      	ldr	r3, [pc, #4]	; (22850 <_sbrk+0x18>)
   2284a:	e7f9      	b.n	22840 <_sbrk+0x8>
   2284c:	200037d4 	.word	0x200037d4
   22850:	200037e0 	.word	0x200037e0

00022854 <_exit>:
   22854:	e7fe      	b.n	22854 <_exit>
   22856:	46c0      	nop			; (mov r8, r8)
   22858:	2f637273 	.word	0x2f637273
   2285c:	6e69614d 	.word	0x6e69614d
   22860:	7070632e 	.word	0x7070632e
   22864:	57454e00 	.word	0x57454e00
   22868:	524f5453 	.word	0x524f5453
   2286c:	00454741 	.word	0x00454741
   22870:	74617473 	.word	0x74617473
   22874:	53007375 	.word	0x53007375
   22878:	55544154 	.word	0x55544154
   2287c:	444f4d53 	.word	0x444f4d53
   22880:	76646100 	.word	0x76646100
   22884:	61637300 	.word	0x61637300
   22888:	4353006e 	.word	0x4353006e
   2288c:	4f4d4e41 	.word	0x4f4d4e41
   22890:	6e650044 	.word	0x6e650044
   22894:	6c6c6f72 	.word	0x6c6c6f72
   22898:	524e4500 	.word	0x524e4500
   2289c:	4d4c4c4f 	.word	0x4d4c4c4f
   228a0:	7300444f 	.word	0x7300444f
   228a4:	622f6372 	.word	0x622f6372
   228a8:	2f657361 	.word	0x2f657361
   228ac:	43504147 	.word	0x43504147
   228b0:	72746e6f 	.word	0x72746e6f
   228b4:	656c6c6f 	.word	0x656c6c6f
   228b8:	70632e72 	.word	0x70632e72
   228bc:	72730070 	.word	0x72730070
   228c0:	61622f63 	.word	0x61622f63
   228c4:	472f6573 	.word	0x472f6573
   228c8:	43545441 	.word	0x43545441
   228cc:	72746e6f 	.word	0x72746e6f
   228d0:	656c6c6f 	.word	0x656c6c6f
   228d4:	70632e72 	.word	0x70632e72
   228d8:	0070      	.short	0x0070
   228da:	3a43      	.short	0x3a43
   228dc:	66726e2f 	.word	0x66726e2f
   228e0:	6b64732f 	.word	0x6b64732f
   228e4:	66726e2f 	.word	0x66726e2f
   228e8:	6b64735f 	.word	0x6b64735f
   228ec:	5f31315f 	.word	0x5f31315f
   228f0:	6f632f30 	.word	0x6f632f30
   228f4:	6e6f706d 	.word	0x6e6f706d
   228f8:	73746e65 	.word	0x73746e65
   228fc:	62696c2f 	.word	0x62696c2f
   22900:	69726172 	.word	0x69726172
   22904:	742f7365 	.word	0x742f7365
   22908:	72656d69 	.word	0x72656d69
   2290c:	7070612f 	.word	0x7070612f
   22910:	6d69745f 	.word	0x6d69745f
   22914:	632e7265 	.word	0x632e7265
   22918:	00000000 	.word	0x00000000

0002291c <swap_sub_state_sm_lut.7157>:
   2291c:	0001cd05 0001ccd9 0001c989 0001cc91     ................
   2292c:	0001cc5d                                ]...

00022930 <swap_sub_state_sm_lut.7232>:
   22930:	0001c681 0001c6a5 0001cb19 0001cb8d     ................
   22940:	0001cba9 eabcd123 1523785f 1212efde     ....#..._x#.....
   22950:	00000000 6d003146 57687365 65746972     ....F1.meshWrite
	...

00022968 <_ZTV6Logger>:
	...
   22970:	0001cfa1 0001cfd1                       ........

00022978 <_ZTV7Storage>:
	...
   22980:	0001cd81 0001cf95                       ........

00022988 <_ZTV4Node>:
	...
   22990:	0001d9f1 0001da3b 0001cde9 0001d105     ....;...........
   229a0:	0001cdcd 0001cdb1 0001d439 fffffffc     ........9.......
   229b0:	00000000 0001d9f5 0001da49 0001d209     ........I.......
   229c0:	0001cdd9 0001cdbd 0001d6c1 fffffff8     ................
   229d0:	00000000 0001da05 0001da59 0001cf85     ........Y.......

000229e0 <_ZTV14ScanningModule>:
	...
   229e8:	0001e4b9 0001ec05 0001e4d9 00020b6d     ............m...
   229f8:	000207ed 0001e5b5 0001e4cf 0001e4cd     ................
   22a08:	00020c19 0001ea21 0001ec31 0001cd4b     ....!...1...K...
   22a18:	0001e56d 0001ec21 fffffffc 00000000     m...!...........
   22a28:	0001e4bd 0001ec11                       ........

00022a30 <_ZTV20StatusReporterModule>:
	...
   22a38:	0001e4a1 00020ba3 0001e4d1 00020b6d     ............m...
   22a48:	000207ed 0001e9dd 0001e4cf 0001e4cd     ................
   22a58:	00020c19 0001e865 0001e925 0001e515     ....e...%.......
   22a68:	0001e68d 0001cd49 fffffffc 00000000     ....I...........
   22a78:	0001e4a5 00020bb5 2f637273 75646f6d     ........src/modu
   22a88:	2f73656c 74617453 65527375 74726f70     les/StatusReport
   22a98:	6f4d7265 656c7564 7070632e 32302500     erModule.cpp.%02
   22aa8:	73000058 752f6372 696c6974 532f7974     X..src/utility/S
   22ab8:	61726f74 632e6567 73007070 752f6372     torage.cpp.src/u
   22ac8:	696c6974 4e2f7974 74537765 6761726f     tility/NewStorag
   22ad8:	70632e65 30250070 003a5832 00000000     e.cpp.%02X:.....

00022ae8 <_ZTV16EnrollmentModule>:
	...
   22af0:	00020539 00020751 0002059f 00020b6d     9...Q.......m...
   22b00:	000207ed 0002054d 0001e4cf 0001e4cd     ....M...........
   22b10:	00020c19 00020565 00020c15 0001cd4b     ....e.......K...
   22b20:	00020a15 0001cd49 fffffffc 00000000     ....I...........
   22b30:	0002053d 0002075d                       =...]...

00022b38 <_ZTV6Module>:
	...
   22b40:	00020509 0002076d 0002058d 00020b6d     ....m.......m...
   22b50:	000207ed 000205a7 0001e4cf 0001e4cd     ................
   22b60:	00020c19 00020c17 00020c15 0001cd4b     ............K...
   22b70:	00020a01 0001cd49 fffffffc 00000000     ....I...........
   22b80:	0002050d 00020779 5f746573 666e6f63     ....y...set_conf
   22b90:	74206769 20736968 20766461 303a3130     ig this adv 01:0
   22ba0:	31303a31 3a30303a 303a3436 31303a30     1:01:00:64:00:01
   22bb0:	3a34303a 363a3530 32303a31 3a31303a     :04:05:61:02:01:
   22bc0:	303a3630 46463a38 3a44343a 303a3230     06:08:FF:4D:02:0
   22bd0:	30253a32 253a7832 3a783230 303a3030     2:%02x:%02x:00:0
   22be0:	30303a30 3a30303a 303a3030 30303a30     0:00:00:00:00:00
   22bf0:	3a30303a 303a3030 30303a30 3a30303a     :00:00:00:00:00:
   22c00:	303a3030 30303a30 3a30303a 303a3030     00:00:00:00:00:0
   22c10:	30303a30 3a30303a 30203030 444f4d00     0:00:00:00 0.MOD
   22c20:	00454c55 00000000                       ULE.....

00022c28 <_ZTV17AdvertisingModule>:
	...
   22c30:	0002051d 00020735 000205a9 00020b6d     ....5.......m...
   22c40:	000207ed 000205cf 0001e4cf 0001e4cd     ................
   22c50:	00020c19 000207a5 00020c15 0001cd4b     ............K...
   22c60:	00020a01 00020789 fffffffc 00000000     ................
   22c70:	00020521 00020741 04030201 08070605     !...A...........
   22c80:	02010009 06050403 ffffffff 42ffffff     ...............B
   22c90:	47464443 4c4b4a48 51504e4d 56545352     CDFGHJKLMNPQRSTV
   22ca0:	5a595857 34333231 38373635 3a430039     WXYZ123456789.C:
   22cb0:	66726e2f 6b64732f 66726e2f 6b64735f     /nrf/sdk/nrf_sdk
   22cc0:	5f31315f 6f632f30 6e6f706d 73746e65     _11_0/components
   22cd0:	666f732f 76656474 2f656369 6d6d6f63     /softdevice/comm
   22ce0:	732f6e6f 6474666f 63697665 61685f65     on/softdevice_ha
   22cf0:	656c646e 6f732f72 65647466 65636976     ndler/softdevice
   22d00:	6e61685f 72656c64 5400632e 696d7265     _handler.c.Termi
   22d10:	006c616e 203a7325 6f705f5f 77282073     nal.%s: __pos (w
   22d20:	68636968 20736920 29757a25 74203e20     hich is %zu) > t
   22d30:	2d736968 7a69733e 20292865 69687728     his->size() (whi
   22d40:	69206863 7a252073 62002975 63697361     ch is %zu).basic
   22d50:	7274735f 3a676e69 3a74613a 6e5f5f20     _string::at: __n
   22d60:	68772820 20686369 25207369 2029757a      (which is %zu) 
   22d70:	74203d3e 2d736968 7a69733e 20292865     >= this->size() 
   22d80:	69687728 69206863 7a252073 62002975     (which is %zu).b
   22d90:	63697361 7274735f 3a676e69 706f633a     asic_string::cop
   22da0:	61620079 5f636973 69727473 3a3a676e     y.basic_string::
   22db0:	706d6f63 00657261 69736162 74735f63     compare.basic_st
   22dc0:	676e6972 535f3a3a 6572635f 00657461     ring::_S_create.
   22dd0:	69736162 74735f63 676e6972 72653a3a     basic_string::er
   22de0:	00657361 69736162 74735f63 676e6972     ase.basic_string
   22df0:	4d5f3a3a 7065725f 6563616c 7875615f     ::_M_replace_aux
   22e00:	73616200 735f6369 6e697274 693a3a67     .basic_string::i
   22e10:	7265736e 61620074 5f636973 69727473     nsert.basic_stri
   22e20:	3a3a676e 6c706572 00656361 69736162     ng::replace.basi
   22e30:	74735f63 676e6972 73613a3a 6e676973     c_string::assign
   22e40:	73616200 735f6369 6e697274 613a3a67     .basic_string::a
   22e50:	6e657070 61620064 5f636973 69727473     ppend.basic_stri
   22e60:	3a3a676e 69736572 6200657a 63697361     ng::resize.basic
   22e70:	7274735f 3a676e69 5f535f3a 736e6f63     _string::_S_cons
   22e80:	63757274 756e2074 6e206c6c 7620746f     truct null not v
   22e90:	64696c61 73616200 735f6369 6e697274     alid.basic_strin
   22ea0:	623a3a67 63697361 7274735f 00676e69     g::basic_string.
   22eb0:	69736162 74735f63 676e6972 75733a3a     basic_string::su
   22ec0:	72747362 00004300                       bstr.C..

00022ec8 <_global_impure_ptr>:
   22ec8:	20002e94                                ... 

00022ecc <__sf_fake_stdin>:
	...

00022eec <__sf_fake_stdout>:
	...

00022f0c <__sf_fake_stderr>:
	...
   22f2c:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
   22f3c:	32313000 36353433 41393837 45444342     .0123456789ABCDE
   22f4c:	31300046 35343332 39383736 64636261     F.0123456789abcd
   22f5c:	00006665                                         ef.
